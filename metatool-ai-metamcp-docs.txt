Directory structure:
└── metatool-ai-metamcp/
    └── docs/
        ├── README.md
        ├── docs.json
        ├── cn/
        │   ├── index.mdx
        │   ├── quickstart.mdx
        │   ├── concepts/
        │   │   ├── endpoints.mdx
        │   │   ├── inspector.mdx
        │   │   ├── mcp-servers.mdx
        │   │   ├── middleware-future.mdx
        │   │   ├── middleware.mdx
        │   │   └── namespaces.mdx
        │   ├── deployment/
        │   │   └── custom-deployment.mdx
        │   ├── development/
        │   │   ├── architecture.mdx
        │   │   ├── contributing.mdx
        │   │   └── i18n.mdx
        │   ├── integrations/
        │   │   ├── claude-desktop.mdx
        │   │   ├── cursor.mdx
        │   │   ├── general-stdio-with-api-key.mdx
        │   │   ├── open-web-ui.mdx
        │   │   └── troubleshooting-future.mdx
        │   └── troubleshooting/
        │       └── oauth-troubleshooting.mdx
        ├── en/
        │   ├── index.mdx
        │   ├── quickstart.mdx
        │   ├── concepts/
        │   │   ├── endpoints.mdx
        │   │   ├── inspector.mdx
        │   │   ├── mcp-servers.mdx
        │   │   ├── middleware-future.mdx
        │   │   ├── middleware.mdx
        │   │   └── namespaces.mdx
        │   ├── deployment/
        │   │   └── custom-deployment.mdx
        │   ├── development/
        │   │   ├── architecture.mdx
        │   │   ├── contributing.mdx
        │   │   └── i18n.mdx
        │   ├── integrations/
        │   │   ├── claude-desktop.mdx
        │   │   ├── cursor.mdx
        │   │   ├── general-stdio-with-api-key.mdx
        │   │   ├── general-stdio-with-oauth.mdx
        │   │   ├── open-web-ui.mdx
        │   │   └── troubleshooting-future.mdx
        │   └── troubleshooting/
        │       └── oauth-troubleshooting.mdx
        ├── essentials/
        │   ├── code.mdx
        │   ├── images.mdx
        │   ├── markdown.mdx
        │   ├── navigation.mdx
        │   ├── reusable-snippets.mdx
        │   └── settings.mdx
        └── snippets/
            └── snippet-intro.mdx

================================================
FILE: docs/README.md
================================================
# Mintlify Starter Kit

Use the starter kit to get your docs deployed and ready to customize.

Click the green **Use this template** button at the top of this repo to copy the Mintlify starter kit. The starter kit contains examples with

- Guide pages
- Navigation
- Customizations
- API reference pages
- Use of popular components

**[Follow the full quickstart guide](https://starter.mintlify.com/quickstart)**

## Development

Install the [Mintlify CLI](https://www.npmjs.com/package/mint) to preview your documentation changes locally. To install, use the following command:

```
npm i -g mint
```

Run the following command at the root of your documentation, where your `docs.json` is located:

```
mint dev
```

View your local preview at `http://localhost:3000`.

## Publishing changes

Install our GitHub app from your [dashboard](https://dashboard.mintlify.com/settings/organization/github-app) to propagate changes from your repo to your deployment. Changes are deployed to production automatically after pushing to the default branch.

## Need help?

### Troubleshooting

- If your dev environment isn't running: Run `mint update` to ensure you have the most recent version of the CLI.
- If a page loads as a 404: Make sure you are running in a folder with a valid `docs.json`.

### Resources
- [Mintlify documentation](https://mintlify.com/docs)
- [Mintlify community](https://mintlify.com/community)



================================================
FILE: docs/docs.json
================================================
{
  "$schema": "https://mintlify.com/docs.json",
  "theme": "mint",
  "name": "MetaMCP",
  "logo": {
    "light": "/favicon.png",
    "dark": "/favicon.png"
  },
  "favicon": {
    "light": "/favicon.png",
    "dark": "/favicon.png"
  },
  "icons":{
    "library": "lucide"
  },
  "colors": {
    "primary": "#3b82f6",
    "light": "#3b82f6",
    "dark": "#3b82f6"
  },
  "navbar": {
    "links": [
      {
        "label": "GitHub",
        "href": "https://github.com/metatool-ai/metamcp",
        "icon": "github"
      },
      {
        "label": "Discord",
        "href": "https://discord.gg/mNsyat7mFX",
        "icon": "discord"
      }
    ]
  },
  "navigation": {
    "languages": [
      {
        "language": "en",
        "groups": [
          {
            "group": "Getting Started",
            "pages": [
              "en/index",
              "en/quickstart"
            ]
          },
          {
            "group": "Core Concepts",
            "pages": [
              "en/concepts/mcp-servers",
              "en/concepts/namespaces",
              "en/concepts/endpoints",
              "en/concepts/middleware",
              "en/concepts/inspector"
            ]
          },
          {
            "group": "Deployment",
            "pages": [
              "en/deployment/custom-deployment"
            ]
          },
          {
            "group": "Integrations",
            "pages": [
              "en/integrations/cursor",
              "en/integrations/claude-desktop",
              "en/integrations/open-web-ui",
              "en/integrations/general-stdio-with-api-key",
              "en/integrations/general-stdio-with-oauth"
            ]
          },
          {
            "group": "Development",
            "pages": [
              "en/development/contributing",
              "en/development/i18n",
              "en/development/architecture"
            ]
          },
          {
            "group": "Troubleshooting",
            "pages": [
              "en/troubleshooting/oauth-troubleshooting"
            ]
          }
        ]
      },
      {
        "language": "cn",
        "groups": [
          {
            "group": "快速开始",
            "pages": [
              "cn/index",
              "cn/quickstart"
            ]
          },
          {
            "group": "核心概念",
            "pages": [
              "cn/concepts/mcp-servers",
              "cn/concepts/namespaces",
              "cn/concepts/endpoints",
              "cn/concepts/middleware",
              "cn/concepts/inspector"
            ]
          },
          {
            "group": "部署",
            "pages": [
              "cn/deployment/custom-deployment"
            ]
          },
          {
            "group": "集成",
            "pages": [
              "cn/integrations/cursor",
              "cn/integrations/claude-desktop",
              "cn/integrations/open-web-ui",
              "cn/integrations/general-stdio-with-api-key",
              "cn/integrations/general-stdio-with-oauth"
            ]
          },
          {
            "group": "开发",
            "pages": [
              "cn/development/contributing",
              "cn/development/i18n",
              "cn/development/architecture"
            ]
          },
          {
            "group": "故障排除",
            "pages": [
              "cn/troubleshooting/oauth-troubleshooting"
            ]
          }
        ]
      }
    ]
  },
  "footer": {
    "socials": {
      "github": "https://github.com/metatool-ai/metamcp",
      "discord": "https://discord.gg/mNsyat7mFX"
    }
  }
}


================================================
FILE: docs/cn/index.mdx
================================================
[Binary file]


================================================
FILE: docs/cn/quickstart.mdx
================================================
---
title: "快速开始"
description: "在几分钟内启动 MetaMCP 并配置您的第一个 MCP 服务器"
---

在几分钟内启动 MetaMCP 并配置您的第一个 MCP 服务器聚合。

## 前置要求

在开始之前，请确保您拥有：
- 已安装 Docker 和 Docker Compose
- Git 用于克隆仓库
- 对 MCP（模型上下文协议）的基本理解

## 步骤 1：安装

<AccordionGroup>
  <Accordion icon="github" title="克隆仓库">
    从 GitHub 克隆 MetaMCP 并导航到项目目录：
    
    ```bash
    git clone https://github.com/metatool-ai/metamcp.git
    cd metamcp
    ```
  </Accordion>

  <Accordion icon="settings" title="配置环境">
    复制示例环境文件并根据需要进行自定义：
    
    ```bash
    cp example.env .env
    ```
    
    <Note>
      如果您在 `.env` 文件中修改了 `APP_URL`，请确保仅从该 URL 访问 MetaMCP，因为 CORS 策略强制执行。
    </Note>
    <Warning>在生产环境中，请确保修改 POSTGRES_PASSWORD 和 BETTER_AUTH_SECRET。同时使用 HTTPS。生成密钥的典型方法是 `openssl rand -hex 32 | base64`</Warning>
  </Accordion>

  <Accordion icon="docker" title="使用 Docker Compose 启动">
    使用 Docker Compose 启动 MetaMCP：
    
    ```bash
    docker compose up -d
    ```
    
    这将启动：
    - MetaMCP 全栈 Docker 镜像
    - PostgreSQL 数据库
    
    <Tip>
      首次启动可能需要几分钟，因为需要拉取和下载 Docker 镜像。
    </Tip>
  </Accordion>
</AccordionGroup>

## 步骤 2：访问 MetaMCP

容器运行后：

1. **打开浏览器**并访问 `http://localhost:12008`（或您配置的 `APP_URL`）
2. **创建账户**或登录
3. **探索仪表板** - 您将看到 MCP 服务器、命名空间和端点的部分
4. **（可选）禁用注册** 您可能只允许您和您的团队访问 MetaMCP，因此一旦设置账户，您可以在设置页面禁用新用户注册。

## 步骤 3：配置您的第一个 MCP 服务器

<AccordionGroup>
  <Accordion icon="server" title="步骤 3.1：添加 MCP 服务器">
    1. 导航到侧边栏中的 **MCP 服务器**（或您可以从**探索和搜索**页面快速添加一个）
    2. 点击 **"添加服务器"** 按钮（右上角）
    3. 在打开的对话框中，填写服务器配置：
    
    **基本信息：**
    - **名称**：`hackernews-server`（必须是 URL 兼容的：仅限字母、数字、下划线、连字符）
    - **描述**：`用于获取故事和评论的 HackerNews MCP 服务器`
    - **类型**：从下拉菜单中选择 `STDIO`
    
    **服务器配置：**
    - **命令**：`uvx`
    - **参数**：`mcp-hn`（空格分隔的参数）
    - **环境变量**：留空（格式：`KEY=value`，每行一个）
    
    **所有权：**
    - 选择 **"仅限我自己（私有）"** 或 **"所有人（公共）"**
    - 私有服务器仅对您可访问
    - 公共服务器对所有用户可访问
    
    4. 点击 **"创建服务器"**
    5. 您应该看到成功消息："MCP 服务器已创建"
    
    <Note>
      创建服务器后，您可以点击它查看详细信息、测试连接并查看可用工具。
    </Note>
  </Accordion>

  <Accordion icon="package" title="步骤 3.2：创建命名空间">
    **为什么需要命名空间？** 命名空间将多个 MCP 服务器分组在一起，并为外部访问提供统一端点。
    
    1. 转到侧边栏中的 **命名空间**
    2. 点击 **"创建命名空间"** 按钮（右上角）
    3. 填写命名空间表单：
    
    **基本信息：**
    - **名称**：`news-information`（服务器组的描述性名称）
    - **描述**：`包含新闻和信息检索工具的命名空间`
    
    **所有权：**
    - 选择 **"仅限我自己（私有）"** 或 **"所有人（公共）"**
    
    **选择 MCP 服务器：**
    - 您将看到带有复选框的可用 MCP 服务器列表
    - 勾选您的 **"hackernews-server"** 旁边的复选框
    - 您可以为一个命名空间选择多个服务器
    - 每个服务器显示其类型（STDIO、SSE 等）和描述
    
    4. 点击 **"创建命名空间"**
    5. 成功消息："命名空间已创建"
    
    <Tip>
      您稍后可以通过编辑命名空间来添加或删除服务器。
    </Tip>
  </Accordion>


</AccordionGroup>

## 步骤 4：管理命名空间中的工具

<AccordionGroup>
  <Accordion icon="wrench" title="审查并禁用未使用的工具">
    **为什么要管理工具？** 每个 MCP 服务器可能暴露许多工具，但您可能只想通过端点提供某些工具。
    
    1. 转到侧边栏中的 **命名空间**
    2. 点击您的 **"news-information"** 命名空间查看详细信息
    3. 您将看到三个主要部分：
    
    **连接状态：**
    - 检查命名空间是否可以连接到其 MCP 服务器
    - 绿色状态表示所有服务器都可访问
    - 如果需要，点击 **"连接"** 建立连接
    
    **MCP 服务器：**
    - 查看分配给此命名空间的所有服务器
    - 查看服务器状态（活动/非活动/错误）
    - 监控服务器健康状态和配置
    
    **工具管理：**
    - 查看来自服务器的所有可用工具
    - 每个工具显示：
      - **工具名称**（例如，`get_top_stories`、`get_story`）
      - **源服务器**（哪个服务器提供此工具）
      - **描述**和输入模式
      - **状态**（启用/禁用）
    
    4. **禁用不需要的工具：**
    - 取消勾选您不想通过端点暴露的工具
    - 例如，您可能保留 `get_top_stories` 但禁用 `get_user_info`
    - 这有助于保持端点专注和安全
    
    5. 如果需要，**刷新工具**以从服务器获取最新工具
    
    <Note>
      只有启用的工具在外部应用程序使用您的端点时才可用。
    </Note>
  </Accordion>
</AccordionGroup>

## 步骤 5：创建端点

<AccordionGroup>
  <Accordion icon="link" title="创建您的公共端点">
    **什么是端点？** 端点通过其他应用程序可以使用的 HTTP API 为您的命名空间提供外部访问。
    
    1. 导航到侧边栏中的 **端点**
    2. 点击 **"创建端点"** 按钮（右上角）
    3. 配置您的端点：
    
    **基本信息：**
    - **名称**：`news-endpoint`（URL 兼容名称 - 这变成 `/metamcp/news-endpoint`）
    - **描述（可选）**：`新闻和信息工具的公共端点`
    
    **所有权：**
    - 选择 **"仅限我自己（私有）"** 或 **"所有人（公共）"**
    
    **命名空间选择：**
    - 点击 **"选择命名空间"** 下拉菜单
    - 选择您的 **"news-information"** 命名空间
    - 您将在下拉菜单中看到命名空间名称和描述
    
    **API 密钥身份验证：**
    - **启用 API 密钥身份验证**：切换开启（推荐）
      - 这需要 API 密钥进行端点访问
    - **使用查询参数身份验证**：切换开启/关闭
      - 开启时：允许 URL 中的 `?api_key=xxx`
      - 关闭时：仅在 `Authorization: Bearer xxx` 标头中接受 API 密钥
    
    **MCP 服务器创建：**
    - **"自动为此端点创建 MCP 服务器"**：勾选此框
    - 这会创建一个用于检查的可流式 HTTP MCP 服务器配置
    
    4. 点击 **"创建端点"**
    5. 成功消息："端点已创建"
    
    **您的端点将在以下位置可用：**
    - SSE：`http://localhost:12008/metamcp/news-endpoint/sse`
    - 可流式 HTTP：`http://localhost:12008/metamcp/news-endpoint/mcp`
    - OpenAPI：`http://localhost:12008/metamcp/news-endpoint/api`
    - 模式：`http://localhost:12008/metamcp/news-endpoint/api/openapi.json`
  </Accordion>
</AccordionGroup>

## 步骤 6：生成 API 密钥

<AccordionGroup>
  <Accordion icon="key" title="创建 API 密钥">
    1. 转到侧边栏中的 **API 密钥**
    2. 点击 **"生成密钥"** 按钮
    3. 填写 API 密钥表单：
    
    **密钥信息：**
    - **描述**：`我的第一个 MetaMCP API 密钥，用于新闻端点`
    - **作用域**：
      - **私有**：只有您可以使用此密钥
      - **公共**：所有用户都可以使用此密钥
    
    4. 点击 **"生成密钥"**
    5. **重要**：复制并安全保存密钥 - 它以 `sk_mt_` 开头
    6. 此密钥将用于对端点请求进行身份验证
    
    <Warning>
      API 密钥只显示一次。请确保立即复制它。
    </Warning>
  </Accordion>
</AccordionGroup>

## 步骤 7：管理您的配置

<AccordionGroup>
  <Accordion icon="settings" title="管理 MCP 服务器">
    **查看服务器详细信息：**
    - 点击 MCP 服务器列表中的任何服务器
    - 查看连接状态、可用工具和配置
    - 测试服务器连接并检查工具
    
    **编辑服务器：**
    - 使用每个服务器旁边的操作菜单（⋯）
    - 修改配置、添加环境变量
    - 更新命令和参数
    
    **服务器状态：**
    - **活动**：服务器正在运行且可用
    - **非活动**：服务器已配置但未运行
    - **错误**：服务器有连接问题
  </Accordion>

  <Accordion icon="layers" title="管理命名空间">
    **查看命名空间详细信息：**
    - 点击任何命名空间查看其服务器和工具
    - 监控命名空间中哪些服务器处于活动状态
    - 查看来自所有服务器的聚合工具
    
    **编辑命名空间：**
    - 从现有命名空间添加或删除服务器
    - 更新名称和描述
    - 更改所有权设置
    
    **工具管理：**
    - 查看命名空间中所有服务器可用的工具
    - 启用/禁用特定工具
    - 查看工具模式和文档
  </Accordion>

  <Accordion icon="link" title="管理端点">
    **端点 URL：**
    每个端点提供多种访问方法：
    - **SSE**：用于实时通信的服务器发送事件
    - **可流式 HTTP**：基于 HTTP 的 MCP 通信
    - **OpenAPI**：带有 OpenAPI 文档的 REST API
    - **模式**：用于集成的 OpenAPI JSON 模式
    
    **复制 URL：**
    - 使用操作菜单（⋯）复制特定 URL
    - 复制带有或不带有嵌入 API 密钥的 URL
    - 为不同集成使用不同格式
    
    **编辑端点：**
    - 更改端点映射到的命名空间
    - 更新身份验证设置
    - 修改访问权限
  </Accordion>
</AccordionGroup>

## 下一步

<CardGroup cols={2}>
  <Card title="添加更多服务器" icon="plus" href="/cn/concepts/mcp-servers">
    了解如何配置不同类型的 MCP 服务器（STDIO、HTTP 等）
  </Card>
  
  <Card title="配置中间件" icon="filter" href="/cn/concepts/middleware">
    应用中间件来过滤工具和转换请求/响应
  </Card>
  
  <Card title="连接到 Cursor" icon="mouse-pointer-2" href="/cn/integrations/cursor">
    配置 Cursor IDE 使用您的 MetaMCP 端点
  </Card>
  
  <Card title="连接到 Claude Desktop" icon="monitor-dot" href="/cn/integrations/claude-desktop">
    使用 mcp-proxy 设置 Claude Desktop 与 MetaMCP
  </Card>
</CardGroup>

## 故障排除

<AccordionGroup>
  <Accordion icon="warning" title="常见问题">
    **CORS 错误**：确保您从 `APP_URL` 中指定的 URL 访问 MetaMCP。
    
    **数据库连接**：使用 `docker ps` 检查 PostgreSQL 容器是否正在运行。
    
    **内存问题**：MetaMCP 需要至少 2GB RAM 以获得最佳性能。
    
    **服务器连接失败**：在服务器详细信息页面检查 MCP 服务器日志。
    
    **身份验证问题**：验证 API 密钥是否处于活动状态且格式正确。
  </Accordion>

  <Accordion icon="question" title="需要帮助？">
    - 浏览 [GitHub Issues](https://github.com/metatool-ai/metamcp/issues)
    - 加入我们的 [Discord 社区](https://discord.gg/mNsyat7mFX)
  </Accordion>
</AccordionGroup>



================================================
FILE: docs/cn/concepts/endpoints.mdx
================================================
---
title: "端点"
description: "创建公共端点，将命名空间暴露为可访问的 MCP 服务器"
---

**MetaMCP 端点**是一个公共接口，将命名空间暴露为可访问的 MCP 服务器。端点处理身份验证并提供 MCP 客户端可以连接的 URL。

## 什么是端点？

端点作为内部命名空间和外部 MCP 客户端之间的桥梁：

- **将命名空间暴露**为公共 MCP 服务器
- **通过 API 密钥处理身份验证**
- **支持多种传输**（SSE、可流式 HTTP、OpenAPI）

<Card title="端点 URL 示例" icon="link">
```
https://your-metamcp.com/metamcp/my-endpoint/sse
https://your-metamcp.com/metamcp/my-endpoint/mcp
https://your-metamcp.com/metamcp/my-endpoint/api
https://your-metamcp.com/metamcp/my-endpoint/api/openapi.json
```
</Card>

## 端点管理

### 可用操作

从端点仪表板，您可以：

- **编辑**端点设置
- **复制不同传输类型的 URL**
- **查看**关联的命名空间
- **删除**端点

### URL 格式

每个端点提供多种 URL 格式：

- **SSE**：`/metamcp/{name}/sse`
- **可流式 HTTP**：`/metamcp/{name}/mcp`
- **OpenAPI**：`/metamcp/{name}/api`
- **OpenAPI 模式**：`/metamcp/{name}/api/openapi.json`

## 下一步

<CardGroup cols={2}>
  <Card title="API 密钥" icon="key" href="/cn/api-keys">
    生成 API 密钥以安全访问端点
  </Card>
  
  <Card title="命名空间" icon="package" href="/cn/namespaces">
    了解如何将 MCP 服务器组织到命名空间中
  </Card>
  
  <Card title="集成指南" icon="plug" href="/cn/integrations/cursor">
    将您的端点连接到 MCP 客户端
  </Card>
  
  <Card title="MCP 服务器" icon="server" href="/cn/mcp-servers">
    管理命名空间内的 MCP 服务器
  </Card>
</CardGroup> 


================================================
FILE: docs/cn/concepts/inspector.mdx
================================================
---
title: "检查器"
description: "使用内置检查器调试和检查 MCP 服务器和 MetaMCP 端点"
---

**MetaMCP 检查器**是一个内置工具，允许您轻松测试和调试您管理的 MCP 服务器和 MetaMCP 端点。它提供与官方 MCP 检查器类似的功能，提供了一种验证连接和服务器行为的便捷方式。

<div align="center">
  <img src="/images/metamcp_screenshot.png" alt="MetaMCP 截图" style={{ width: "100%", maxWidth: "800px", margin: "2rem 0", borderRadius: "8px", boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)" }} />
</div>

## 下一步

<CardGroup cols={2}>
  <Card title="MCP 服务器" icon="server" href="/cn/concepts/mcp-servers">
    了解如何配置和调试 MCP 服务器
  </Card>
  
  <Card title="故障排除指南" icon="wrench" href="/cn/integrations/troubleshooting">
    MetaMCP 的常见问题和解决方案
  </Card>
  
  <Card title="集成测试" icon="plug" href="/cn/integrations/cursor">
    使用实际的 MCP 客户端测试您的配置
  </Card>
  
  <Card title="性能监控" icon="chart-line" href="/cn/configuration/monitoring">
    设置生产监控和告警
  </Card>
</CardGroup> 


================================================
FILE: docs/cn/concepts/mcp-servers.mdx
================================================
---
title: "MCP 服务器"
description: "了解如何在 MetaMCP 中配置和管理 MCP 服务器实例"
---

**MCP 服务器**是一个配置，告诉 MetaMCP 如何启动和管理模型上下文协议服务器。这些服务器提供工具、资源和提示，可以通过 MetaMCP 端点聚合和暴露。

## 什么是 MCP 服务器？

MCP 服务器是 MetaMCP 的构建块。每个服务器配置定义：

- **如何启动服务器**（命令、参数、环境）
- **服务器类型**（STDIO、SSE、可流式 HTTP）
- **身份验证要求**（如果有）
- **资源依赖**（Python 包、Node 模块等）

<Card title="配置示例" icon="code">
```json
{
  "name": "HackerNews",
  "type": "STDIO", 
  "command": "uvx",
  "args": ["mcp-hn"],
  "description": "访问 HackerNews 故事和评论"
}
```
</Card>

## 服务器类型

MetaMCP 支持三种类型的 MCP 服务器：

<AccordionGroup>
  <Accordion icon="terminal" title="STDIO 服务器">
    **最常见类型** - 通过标准输入/输出流通信
    
    ```json
    {
      "type": "STDIO",
      "command": "uvx", 
      "args": ["mcp-server-package"],
      "env": {
        "API_KEY": "your-api-key"
      }
    }
    ```
    
    **使用场景：**
    - 通过 `uvx` 安装的 Python 包
    - 通过 `npx` 的 Node.js 包
    - 自定义可执行脚本
  </Accordion>

  <Accordion icon="globe" title="SSE 服务器">
    **服务器发送事件** - 通过 SSE（服务器发送事件）通信
    
    ```json
    {
      "type": "SSE",
      "url": "https://api.example.com/sse",
      "bearerToken": "your-bearer-token"
    }
    ```

    <Info>如果服务器使用 OAuth，您可以将 bearerToken 留空。</Info>
  </Accordion>

  <Accordion icon="globe" title="可流式 HTTP 服务器">
    **基于 HTTP 的流式传输** - 可流式 HTTP 现在是远程 MCP 的标准
    
    ```json
    {
      "type": "STREAMABLE_HTTP",
      "url": "https://api.example.com/mcp",
      "bearerToken": "your-bearer-token"
    }
    ```

    <Info>如果服务器使用 OAuth，您可以将 bearerToken 留空。</Info>
  </Accordion>
</AccordionGroup>

## 配置选项

### 基本配置

<CodeGroup>
```json 必填字段
{
  "name": "unique-server-name",
  "type": "STDIO|SSE|STREAMABLE_HTTP",
  "command": "command-to-run", // 仅 STDIO
  "args": ["arg1", "arg2"],     // 仅 STDIO
  "url": "https://...",         // 仅 SSE/STREAMABLE_HTTP
}
```

```json 可选字段
{
  "description": "人类可读的描述",
  "env": {
    "KEY": "value"
  },
  "bearerToken": "auth-token"   // 仅 SSE/STREAMABLE_HTTP
}
```
</CodeGroup>

### 环境变量

向 STDIO 服务器传递环境变量：

```json
{
  "name": "TimeServer",
  "type": "STDIO",
  "command": "uvx",
  "args": ["mcp-server-time", "--local-timezone=America/New_York"],
  "env": {
    "TZ": "America/New_York"
  }
}
```

#### 环境变量插值

使用 `${ENV_VAR}` 语法在运行时引用环境变量：

```json
{
  "name": "ExampleServer",
  "type": "STDIO",
  "command": "uvx",
  "args": ["mcp-example"],
  "env": {
    "API_KEY": "${API_KEY}",
    "DEBUG": "true"
  }
}
```

**优势：**
- **安全**：API 密钥和密钥不会硬编码在配置中
- **灵活**：值从容器环境中解析
- **向后兼容**：原始值仍然像以前一样工作

**工作原理：**
- `${VAR_NAME}` 在运行时被 `process.env.VAR_NAME` 替换
- 缺失的变量会记录警告但不会使服务器崩溃
- 密钥在日志中自动被隐藏

### 身份验证

对于需要身份验证的服务器：

<CodeGroup>
```json 带有 API 密钥的 STDIO
{
  "env": {
    "API_KEY": "your-secret-key"
  }
}
```

```json 带有 Bearer Token 的远程服务器
{
  "bearerToken": "your-bearer-token"
}
```
</CodeGroup>

## 管理 MCP 服务器

### 添加服务器

1. **导航**到 MetaMCP 仪表板中的 MCP 服务器
2. **点击**"添加服务器"
3. **配置**服务器详细信息
4. **测试**配置
5. **保存**使其可用于命名空间

### 批量导入/导出

MetaMCP 支持批量导入和导出 MCP 服务器配置，便于迁移和备份。

#### 导出服务器

将所有配置的 MCP 服务器导出到 JSON 文件：

1. **导航**到仪表板中的 MCP 服务器
2. **点击**"导出 JSON"按钮
3. **选择**下载文件或复制到剪贴板

<Card title="导出格式" icon="code">
```json
{
  "mcpServers": {
    "HackerNews": {
      "type": "stdio",
      "command": "uvx",
      "args": ["mcp-hn"],
      "description": "访问 HackerNews 故事和评论"
    },
    "TimeServer": {
      "type": "stdio", 
      "command": "uvx",
      "args": ["mcp-server-time"],
      "env": {
        "TZ": "America/New_York"
      },
      "description": "时间和时区实用工具"
    },
    "RemoteAPI": {
      "type": "streamable_http",
      "url": "https://api.example.com/mcp",
      "bearerToken": "your-bearer-token",
      "description": "通过 HTTP 的远程 MCP 服务器"
    }
  }
}
```
</Card>

#### 导入服务器

从 JSON 配置导入多个 MCP 服务器：

1. **导航**到仪表板中的 MCP 服务器
2. **点击**"导入 JSON"按钮
3. **粘贴**或输入您的 JSON 配置
4. **点击**"导入"添加服务器

<CodeGroup>
```json STDIO 服务器格式
{
  "mcpServers": {
    "ServerName": {
      "type": "stdio",
      "command": "uvx",
      "args": ["package-name"],
      "env": {
        "API_KEY": "your-key"
      },
      "description": "可选描述"
    }
  }
}
```

```json SSE 服务器格式
{
  "mcpServers": {
    "ServerName": {
      "type": "sse",
      "url": "https://api.example.com/sse",
      "bearerToken": "your-token",
      "description": "可选描述"
    }
  }
}
```

```json 可流式 HTTP 格式
{
  "mcpServers": {
    "ServerName": {
      "type": "streamable_http", 
      "url": "https://api.example.com/mcp",
      "bearerToken": "your-token",
      "description": "可选描述"
    }
  }
}
```
</CodeGroup>

<Note>
**类型值（不区分大小写）：**
- `"stdio"`, `"STDIO"`, `"std"` → STDIO
- `"sse"`, `"SSE"` → SSE  
- `"streamable_http"`, `"STREAMABLE_HTTP"`, `"streamablehttp"`, `"http"` → STREAMABLE_HTTP
</Note>

<Note>
**导入行为：**
- 具有现有名称的服务器将使用新配置**更新**
- 新服务器将被**创建**
- 无效配置将被**跳过**并显示错误消息
- 导入过程显示成功/失败计数
</Note>

<Tip>
使用批量导入/导出用于：
- **环境迁移**（开发 → 测试 → 生产）
- **团队协作**（共享服务器配置）
- **备份和恢复**（配置备份）
- **快速设置**（一次部署多个服务器）
</Tip>

### 空闲会话管理

MetaMCP 预分配空闲会话以获得更好的性能：

<Card title="冷启动优化" icon="zap">
- **默认**：每个服务器 1 个空闲会话
- **可配置**：根据使用模式调整
- **自动扩展**：按需创建会话
- **清理**：超时后回收空闲会话
</Card>

## 依赖项的自定义 Dockerfile

如果您的 MCP 服务器需要 `uvx` 或 `npx` 之外的额外依赖项，您可以自定义 MetaMCP Dockerfile：

```dockerfile
FROM metamcp:latest

# 安装 Python 依赖项
RUN pip install requests beautifulsoup4

# 安装系统包
RUN apt-get update && apt-get install -y \
    curl \
    git \
    && rm -rf /var/lib/apt/lists/*

# 全局安装 Node.js 包
RUN npm install -g some-mcp-package
```

<Warning>
自定义依赖项会增加 Docker 镜像大小和启动时间。尽可能考虑使用轻量级替代方案。
</Warning>

## 故障排除

<AccordionGroup>
  <Accordion icon="triangle-alert" title="服务器无法启动">
    **常见原因：**
    - 缺少依赖项（通过自定义 Dockerfile 安装）
    - 命令或参数不正确
    - 环境变量未设置
    - 网络连接问题（对于 SSE/可流式 HTTP）
    
    **调试步骤：**
    1. 在 MetaMCP 仪表板中检查服务器日志
    2. 在终端中手动测试命令
    3. 验证环境变量
    4. 检查网络连接
  </Accordion>

  <Accordion icon="clock" title="性能缓慢">
    **优化策略：**
    - 为频繁使用的服务器增加空闲会话计数
    - 尽可能使用本地服务器而不是远程服务器
    - 在自定义 Docker 镜像中预安装依赖项
    - 配置适当的超时值
  </Accordion>

  <Accordion icon="shield" title="身份验证问题">
    **常见问题：**
    - API 密钥或 bearer token 过期
    - 环境变量名称不正确
    - 缺少必需的标头
    - 外部 API 的速率限制
    
    **解决方案：**
    1. 刷新 API 密钥/token
    2. 检查服务器文档了解必需的身份验证
    3. 实现适当的错误处理
    4. 添加带有退避的重试逻辑
  </Accordion>
</AccordionGroup>

## 下一步

<CardGroup cols={2}>
  <Card title="创建命名空间" icon="package" href="/cn/concepts/namespaces">
    将您的 MCP 服务器分组到有组织的命名空间中
  </Card>
  
  <Card title="设置端点" icon="link" href="/cn/concepts/endpoints">
    创建公共端点以访问您的服务器
  </Card>
  
  <Card title="添加中间件" icon="filter" href="/cn/concepts/middleware">
    转换和过滤 MCP 请求和响应
  </Card>
  
  <Card title="集成指南" icon="plug" href="/cn/integrations/cursor">
    将您配置的服务器连接到 MCP 客户端
  </Card>
</CardGroup> 


================================================
FILE: docs/cn/concepts/middleware-future.mdx
================================================
[Binary file]


================================================
FILE: docs/cn/concepts/middleware.mdx
================================================
---
title: "中间件"
description: "使用可插拔中间件转换 MCP 请求和响应"
---

MetaMCP 中的**中间件**允许您在命名空间级别拦截和转换 MCP 请求和响应。这个强大的功能使您能够添加过滤、日志记录、验证和安全等功能，而无需修改各个 MCP 服务器。

## （中间件仍在积极开发中）


================================================
FILE: docs/cn/concepts/namespaces.mdx
================================================
---
title: "命名空间"
description: "分组 MCP 服务器并通过统一端点管理工具"
---

MetaMCP 中的**命名空间**是 MCP 服务器的逻辑分组，允许您将多个服务器组织到单个统一的 MCP 端点中。

## 什么是命名空间？

命名空间允许您：

- **将多个 MCP 服务器分组**到统一集合中
- **创建单个 MCP 端点**，聚合来自所有服务器的工具
- **启用/禁用命名空间内**的各个服务器
- **通过启用/禁用特定工具**来控制工具可见性
- **支持私有和公共**命名空间访问

## 命名空间如何工作

当您创建命名空间时：

1. **选择 MCP 服务器**包含在命名空间中
2. **自动发现工具**来自所有活动服务器
3. **工具带有前缀**服务器名称（例如，`ServerName__toolName`）
4. **创建公共端点**以外部暴露命名空间

## 创建命名空间

1. **导航**到 MetaMCP 仪表板中的命名空间
2. **点击**"创建命名空间"
3. **配置**基本详细信息：
   - **名称**：命名空间的唯一标识符
   - **描述**：命名空间用途的可选描述
   - **所有权**：私有（您使用）或公共（组织范围）
4. **选择 MCP 服务器**包含在命名空间中
5. **保存**命名空间

### 所有权类型

- **私有命名空间**：仅创建者可访问
- **公共命名空间**：整个组织可访问

**注意**：公共命名空间只能包含公共 MCP 服务器。

## 管理服务器和工具

### 服务器管理

- **查看服务器状态**在命名空间服务器表中
- **启用/禁用服务器**使用状态切换单独控制
- **添加或删除服务器**通过编辑命名空间
- **监控服务器健康状态**和连接性

### 工具管理

- **自动发现**：从所有活动服务器发现工具
- **工具前缀**：工具带有服务器名称前缀以避免冲突
- **状态控制**：按命名空间启用/禁用各个工具
- **工具过滤**：非活动工具自动从列表中过滤

### 工具命名约定

工具遵循模式：`{ServerName}__{originalToolName}`

示例：来自 "WebSearch" 服务器的 `search` 工具变成 `WebSearch__search`

## 公共访问

要外部暴露命名空间：

1. **创建端点**指向您的命名空间
2. **配置身份验证**（推荐 API 密钥）
3. **与外部用户共享端点 URL**

端点提供：
- **MCP 访问**：标准 MCP 协议支持
- **REST API**：每个工具的 HTTP 端点
- **OpenAPI 文档**：自动生成的 API 文档

## 示例

包含文件系统和 git 服务器的开发命名空间：

```json
{
  "name": "development-tools",
  "description": "Essential development tools",
  "servers": [
    {
      "name": "filesystem",
      "status": "ACTIVE",
      "tools": ["read_file", "write_file", "list_directory"]
    },
    {
      "name": "git-helper", 
      "status": "ACTIVE",
      "tools": ["git_status", "git_commit", "git_diff"]
    }
  ]
}
```

通过命名空间可用的工具：
- `filesystem__read_file`
- `filesystem__write_file` 
- `filesystem__list_directory`
- `git-helper__git_status`
- `git-helper__git_commit`
- `git-helper__git_diff`

## 下一步

<CardGroup cols={2}>
  <Card title="创建端点" icon="link" href="/cn/concepts/endpoints">
    通过公共端点暴露您的命名空间
  </Card>
  
  <Card title="MCP 服务器" icon="server" href="/cn/concepts/mcp-servers">
    了解配置 MCP 服务器
  </Card>
  
  <Card title="集成设置" icon="plug" href="/cn/integrations/cursor">
    将您的命名空间连接到 MCP 客户端
  </Card>
  
  <Card title="检查器" icon="search-code" href="/cn/concepts/inspector">
    测试和调试您的命名空间工具
  </Card>
</CardGroup> 


================================================
FILE: docs/cn/deployment/custom-deployment.mdx
================================================
[Binary file]


================================================
FILE: docs/cn/development/architecture.mdx
================================================
---
title: "架构概述（进行中）"
---

### 主要流程
```mermaid
sequenceDiagram
    participant MCPClient as MCP 客户端（例如，Claude Desktop）
    participant MetaMCP as MetaMCP 服务器
    participant MCPServers as 已安装的 MCP 服务器

    MCPClient ->> MetaMCP: 请求列出工具

    loop 对于每个列出的 MCP 服务器
        MetaMCP ->> MCPServers: 请求 list_tools
        MCPServers ->> MetaMCP: 返回工具列表
    end

    MetaMCP ->> MetaMCP: 聚合工具列表并应用中间件
    MetaMCP ->> MCPClient: 返回聚合的工具列表

    MCPClient ->> MetaMCP: 调用工具
    MetaMCP ->> MCPServers: 向目标 MCP 服务器调用 call_tool
    MCPServers ->> MetaMCP: 返回工具响应
    MetaMCP ->> MCPClient: 返回工具响应
```

### 空闲会话失效

```mermaid
sequenceDiagram
    participant User as 用户
    participant Frontend as 前端
    participant Backend as 后端
    participant McpServerPool as McpServerPool
    participant MetaMcpServerPool as MetaMcpServerPool
    participant McpServer as McpServer

    User->>Frontend: 更新 MCP 服务器命令/参数
    Frontend->>Backend: PATCH /mcp-servers/{uuid}
    Backend->>Backend: 在数据库中更新服务器
    
    Note over Backend: 新的失效流程
    Backend->>McpServerPool: invalidateIdleSession(serverUuid, newParams)
    McpServerPool->>McpServerPool: 清理现有空闲会话
    McpServerPool->>McpServer: 终止旧连接
    McpServerPool->>McpServer: 使用更新的参数创建新连接
    McpServerPool->>McpServerPool: 存储新的空闲会话
    
    Backend->>Backend: 查找受影响的命名空间
    Backend->>MetaMcpServerPool: invalidateIdleServers(namespaceUuids)
    MetaMcpServerPool->>MetaMcpServerPool: 清理命名空间服务器
    MetaMcpServerPool->>MetaMcpServerPool: 创建新的命名空间服务器
    
    Backend->>Frontend: 成功响应
    Frontend->>User: "服务器更新成功"
    
    Note over User,McpServer: 下次连接将使用更新的参数
```


================================================
FILE: docs/cn/development/contributing.mdx
================================================
---
title: "参与 MetaMCP 贡献"
description: "了解如何参与 MetaMCP 的开发并帮助改进项目"
---

我们欢迎对 MetaMCP 的贡献！这份综合指南将帮助您开始为项目做出贡献，无论是修复错误、添加功能还是改进文档。

## 开始使用

### 前置要求

在贡献之前，请确保您具备：

- **Node.js 18+** 和 **pnpm** 已安装
- **Docker** 用于运行 PostgreSQL 和测试
- **Git** 用于版本控制
- 对 TypeScript、React 和 MCP 协议的**基本了解**

### 开发环境设置

<AccordionGroup>
  <Accordion icon="github" title="Fork 和克隆">
    1. 在 GitHub 上**Fork 仓库**
    2. **克隆您的 fork**到本地：
       ```bash
       git clone https://github.com/YOUR_USERNAME/metamcp.git
       cd metamcp
       ```
    3. **添加上游远程仓库**：
       ```bash
       git remote add upstream https://github.com/metatool-ai/metamcp.git
       ```
  </Accordion>

  <Accordion icon="package" title="安装依赖">
    使用 pnpm 安装项目依赖：
    
    ```bash
    pnpm install
    ```
    
    这将安装 monorepo 中所有工作区的依赖。
  </Accordion>

  <Accordion icon="cog" title="环境设置">
    设置您的开发环境：
    
    ```bash
    cp example.env .env
    ```
    
    根据需要修改 `.env` 文件以适配您的开发设置。
  </Accordion>

  <Accordion icon="database" title="数据库设置">
    使用 Docker 启动 PostgreSQL：
    
    ```bash
    docker compose up -d postgres
    # 或启动完整堆栈
    docker compose up -d
    ```

    首次迁移（先编辑 `.env.local`）
    ```bash
    cd apps/backend

    pnpm db:migrate:dev
    ```
  </Accordion>
</AccordionGroup>

## 开发工作流程

### 创建功能分支（命名不是必需的）

<CodeGroup>

```bash 功能分支
git checkout -b feature/your-feature-name
```

```bash 错误修复分支  
git checkout -b fix/issue-description
```

```bash 文档分支
git checkout -b docs/documentation-update
```

</CodeGroup>

### 进行更改

在进行更改时请遵循以下指南：

<Card title="代码质量标准" icon="code">
- **遵循 TypeScript 最佳实践**
- **使用 ESLint 和 Prettier** 保持一致的格式
- **编写描述性的提交信息**
- **为复杂函数添加 JSDoc 注释**
- **确保整个代码库的类型安全**
- **手动测试您的更改**
</Card>

### 测试您的更改

<AccordionGroup>
  <Accordion icon="flask-conical" title="本地测试">
    运行开发服务器并测试您的更改：
    
    ```bash
    pnpm dev
    ```
    
    这将以开发模式启动前端和后端。
  </Accordion>

  <Accordion icon="check" title="代码检查和格式化">
    确保代码质量：
    
    ```bash
    # 运行代码检查
    pnpm lint
    
    # 修复代码检查问题
    pnpm lint:fix
    ```
  </Accordion>

  <Accordion icon="docker" title="Docker 测试">
    使用 Docker 测试以确保生产环境兼容性：
    
    ```bash
    docker compose build
    docker compose up
    ```
  </Accordion>
</AccordionGroup>

## 贡献类型

### 错误修复

<AccordionGroup>
  <Accordion icon="bug" title="报告错误">
    **在报告错误之前：**
    
    1. 检查现有问题以避免重复
    2. 尝试一致地重现问题
    3. 收集相关信息（操作系统、浏览器、MetaMCP 版本）
    4. 包含重现问题的步骤
    
    **错误报告模板：**
    ```markdown
    ## 错误描述
    问题的简要描述
    
    ## 重现步骤
    1. 第一步
    2. 第二步
    3. 预期行为与实际行为
    
    ## 环境
    - 操作系统：[例如，macOS 14.0]
    - 浏览器：[例如，Chrome 120]
    - MetaMCP 版本：[例如，1.0.0]
    
    ## 其他上下文
    截图、日志或其他相关信息
    ```
  </Accordion>

  <Accordion icon="wrench" title="修复错误">
    **修复错误时：**
    
    1. 创建分支：`fix/issue-number-description`
    2. 实现修复
    3. 手动测试以确保修复有效
    4. 如有必要，更新文档
  </Accordion>
</AccordionGroup>

### 功能开发

<AccordionGroup>
  <Accordion icon="lightbulb" title="提出功能">
    **在实现新功能之前：**
    
    1. **开启一个 issue** 来讨论该功能
    2. **提供用例**和理由
    3. **考虑对现有功能的影响**
    4. **从维护者那里获得反馈**
    5. **规划实现**方法
  </Accordion>

  <Accordion icon="code" title="实现功能">
    **功能开发过程：**
    
    1. **从 main 创建功能分支**
    2. **逐步实现**并定期提交
    3. **更新文档**
    4. **使用真实的 MCP 服务器测试**
    5. **考虑 UI 更改的 i18n 影响**
  </Accordion>
</AccordionGroup>

### 文档

<AccordionGroup>
  <Accordion icon="book" title="文档指南">
    **更新文档时：**
    
    - 使用清晰、简洁的语言
    - 在有用时包含代码示例
    - 为 UI 更改添加截图
    - 更新 README 和文档网站
    - 测试所有代码示例
    - 考虑多个受众（初学者、高级用户）
  </Accordion>

  <Accordion icon="book-type" title="翻译贡献">
    **添加新语言支持：**
    
    1. 创建新的语言目录：`public/locales/[locale]/`
    2. 复制英语文件作为模板
    3. 翻译内容并保持键结构
    4. 更新 i18n 配置
    5. 彻底测试新语言
    6. 提交包含翻译文件的 PR
  </Accordion>
</AccordionGroup>

## Pull Request 流程

### 提交之前

<Card title="提交前检查清单" icon="checklist">
- ✅ **代码遵循项目标准**
- ✅ **尽可能修复代码检查问题（在快速开发时相对宽容）** (`pnpm lint`)
- ✅ **没有 TypeScript 错误**
- ✅ **如需要，文档已更新**
- ✅ **手动测试了更改**
- ✅ **如需要，包含数据库迁移**
- ✅ **提交中没有敏感信息**
</Card>

## 专业贡献

### OIDC 提供商设置

MetaMCP 支持 OpenID Connect 用于企业 SSO。在处理 OIDC 功能时：

<AccordionGroup>
  <Accordion icon="shield" title="OIDC 配置">
    **必需的环境变量：**
    
    ```bash
    # 必需
    OIDC_CLIENT_ID=your-oidc-client-id
    OIDC_CLIENT_SECRET=your-oidc-client-secret
    OIDC_DISCOVERY_URL=https://your-provider.com/.well-known/openid-configuration
    OIDC_AUTHORIZATION_URL=https://your-provider.com/auth/authorize
    
    # 可选
    OIDC_PROVIDER_ID=oidc
    OIDC_SCOPES=openid email profile
    OIDC_PKCE=true
    ```
  </Accordion>

  <Accordion icon="flask-conical" title="测试 OIDC">
    **OIDC 开发：**
    
    1. 使用测试提供商（Auth0、Keycloak）
    2. 配置重定向 URI：`${APP_URL}/api/auth/oauth2/callback/oidc`
    3. 测试身份验证流程
    4. 验证数据库中的用户创建
    5. 启用调试日志进行故障排除
  </Accordion>
</AccordionGroup>

### 数据库更改

在进行数据库架构更改时：

<AccordionGroup>
  <Accordion icon="database" title="架构迁移">
    **创建迁移：**
    
    ```bash
    # 架构更改后生成迁移
    cd apps/backend
    pnpm db:generate
    
    # 应用迁移
    pnpm db:migrate:dev # 使用 env.local 中的 PG 相关环境变量
    
    # 重置数据库（仅开发环境）
    pnpm db:reset
    ```
  </Accordion>

  <Accordion icon="table" title="添加新表">
    **数据库开发工作流程：**
    
    1. 在 `apps/backend/src/db/schema.ts` 中更新架构
    2. 在 `apps/backend/src/db/repositories/` 中创建存储库
    3. 在 `apps/backend/src/db/serializers/` 中创建序列化器
    4. 在 `apps/backend/src/trpc/` 中添加 tRPC 过程
    5. 在 `packages/zod-types/` 中更新前端类型
    6. 生成并应用迁移
  </Accordion>
</AccordionGroup>

### 前端开发

<AccordionGroup>
  <Accordion icon="component" title="UI 组件">
    **使用 shadcn/ui 组件：**
    
    ```bash
    # 添加新组件
    cd apps/frontend
    npx shadcn-ui@latest add [component-name]
    ```
    
    **组件指南：**
    - 遵循现有设计模式
    - 确保无障碍合规性
    - 添加适当的 TypeScript 类型
    - 包含加载和错误状态
  </Accordion>

  <Accordion icon="globe" title="国际化">
    **对于 UI 更改：**
    
    1. 首先添加英语翻译
    2. 更新其他语言或标记为待翻译
    3. 使用 `useTranslations()` 钩子
    4. 使用不同语言测试
    5. 确保文本扩展不会破坏布局
  </Accordion>
</AccordionGroup>

## 社区准则

### 行为准则

我们致力于提供一个欢迎和包容的环境：

<Card title="社区标准" icon="heart">
- **在所有互动中保持尊重和包容**
- **提供建设性反馈**并乐于接受反馈
- **专注于协作**并帮助彼此成功
- **尊重不同的观点**和经验水平
- **遵循项目指南**并保持代码质量
</Card>

### 沟通

<AccordionGroup>
  <Accordion icon="discord" title="Discord 社区">
    加入我们的 Discord 服务器：
    
    - 开发讨论
    - 获得贡献帮助
    - 分享想法和反馈
    - 社区公告
    
    [加入 MetaMCP Discord](https://discord.gg/mNsyat7mFX)
  </Accordion>

  <Accordion icon="github" title="GitHub 讨论">
    使用 GitHub Issues 和 Discussions 进行：
    
    - 错误报告和功能请求
    - 技术讨论
    - 文档反馈
    - 项目路线图讨论
  </Accordion>
</AccordionGroup>

## 获得帮助

### 资源

<CardGroup cols={2}>
  <Card title="Discord 社区" icon="discord" href="https://discord.gg/mNsyat7mFX">
    从社区获得帮助
  </Card>
  
  <Card title="GitHub Issues" icon="github" href="https://github.com/metatool-ai/metamcp/issues">
    浏览现有问题和讨论
  </Card>
</CardGroup>

## 认可

我们感谢对 MetaMCP 的所有贡献！贡献者通过以下方式获得认可：

- 仓库上的**GitHub 贡献者列表**
- **发布说明**中提及重要贡献

感谢您帮助让 MetaMCP 对每个人都更好！🚀

## 下一步

<CardGroup cols={1}>
  <Card title="开始贡献" icon="rocket" href="https://github.com/metatool-ai/metamcp/issues">
    浏览开放问题并开始贡献
  </Card>
</CardGroup> 



================================================
FILE: docs/cn/development/i18n.mdx
================================================
---
title: "国际化 (i18n)"
description: "使用 Next.js 区域路由和客户端翻译为 MetaMCP 添加多语言支持"
---

MetaMCP 使用 **Next.js 基于区域的路由** 和 **客户端翻译** 来支持多种语言。本指南解释了 i18n 系统以及如何添加新语言。

## 当前语言支持

MetaMCP 目前支持：

- **英语 (en)** - 默认语言
- **简体中文 (zh)** - 完整翻译可用

作者维护两种语言以确保翻译准确性，但欢迎为其他语言做出贡献。

## 项目结构

国际化系统按以下方式组织：

```bash
apps/frontend/
├── app/
│   └── [locale]/                  # 基于区域的路由
│       ├── layout.tsx            # 区域布局
│       ├── (sidebar)/            # 侧边栏布局组
│       └── ...
├── public/locales/
│   ├── en/                       # 英语翻译
│   │   ├── common.json
│   │   ├── auth.json
│   │   ├── navigation.json
│   │   ├── mcp-servers.json
│   │   ├── namespaces.json
│   │   ├── endpoints.json
│   │   ├── api-keys.json
│   │   ├── settings.json
│   │   ├── search.json
│   │   ├── inspector.json
│   │   ├── logs.json
│   │   └── validation.json
│   └── zh/                       # 中文翻译
│       └── (相同结构)
├── lib/
│   └── i18n.ts                  # 客户端 i18n 工具
├── hooks/
│   ├── useLocale.ts             # 获取当前区域的 Hook
│   └── useTranslations.ts       # 客户端翻译的 Hook
├── components/
│   └── language-switcher.tsx    # 语言切换组件
└── middleware.ts                # 区域检测和路由
```

## 工作原理

### URL 结构

MetaMCP 使用基于区域的路由：

- **英语 (默认)**: `/mcp-servers`, `/settings`, `/namespaces`
- **中文**: `/zh/mcp-servers`, `/zh/settings`, `/zh/namespaces`

### 中间件

`middleware.ts` 文件处理：

- **区域检测** 从 URL、cookie 和 Accept-Language 头部
- **自动重定向** 到适当的区域
- **身份验证检查**

<CodeGroup>
```typescript middleware.ts
import { NextRequest } from 'next/server';
import { getLocale, getLocalizedPath } from '@/lib/i18n';

export function middleware(request: NextRequest) {
  // 从 URL、cookie 或头部检测区域
  const locale = getLocale(request);
  
  // 如果需要则重定向
  if (!request.nextUrl.pathname.startsWith(`/${locale}`)) {
    const localizedPath = getLocalizedPath(request.nextUrl.pathname, locale);
    return Response.redirect(new URL(localizedPath, request.url));
  }
}
```

```typescript lib/i18n.ts
export function getLocalizedPath(path: string, locale: string): string {
  if (locale === 'en') {
    return path; // 默认区域不需要前缀
  }
  return `/${locale}${path}`;
}

export function detectLocale(request: NextRequest): string {
  // 首先检查 URL，然后检查 cookie，然后检查 Accept-Language
  // 返回检测到的区域或回退到 'en'
}
```
</CodeGroup>

## 使用翻译

### 客户端组件

对于客户端组件，使用 `useTranslations` Hook：

<CodeGroup>
```tsx 基本用法
"use client";

import { useTranslations } from "@/hooks/useTranslations";

function ClientComponent() {
  const { t, isLoading, locale } = useTranslations();
  
  if (isLoading) return <div>加载中...</div>;
  
  return (
    <div>
      <h1>{t('common:title')}</h1>
      <button>{t('auth:signIn')}</button>
    </div>
  );
}
```

```tsx 带参数
// 在翻译文件中: "welcome": "欢迎，{{name}}！"
<span>{t('common:welcome', { name: 'John' })}</span>

// 带计数: "itemCount": "找到 {{count}} 个项目"
<span>{t('search:itemCount', { count: 42 })}</span>
```

```tsx 条件翻译
const { t, locale } = useTranslations();

return (
  <div>
    <p>{t('common:currentLanguage')}: {locale}</p>
    {locale === 'zh' && (
      <p>{t('common:chineseSpecificMessage')}</p>
    )}
  </div>
);
```
</CodeGroup>

### 翻译键格式

使用冒号分隔的命名空间进行组织：

```json
{
  "server": {
    "create": "创建服务器",
    "edit": "编辑服务器",
    "delete": "删除服务器",
    "status": {
      "online": "在线",
      "offline": "离线",
      "error": "错误"
    },
    "validation": {
      "nameRequired": "服务器名称是必需的",
      "commandRequired": "命令是必需的"
    }
  }
}
```

**用法**: `t('mcp-servers:server.create')`, `t('mcp-servers:server.status.online')`

## 翻译文件组织

### 命名空间结构

每个翻译命名空间都有特定用途：

<AccordionGroup>
  <Accordion icon="globe" title="common.json">
    **共享 UI 元素和通用术语**
    
    ```json
    {
      "actions": {
        "save": "保存",
        "cancel": "取消",
        "delete": "删除",
        "edit": "编辑",
        "create": "创建",
        "search": "搜索"
      },
      "status": {
        "loading": "加载中...",
        "error": "错误",
        "success": "成功"
      },
      "form": {
        "required": "此字段是必需的",
        "invalid": "无效输入"
      }
    }
    ```
  </Accordion>

  <Accordion icon="lock" title="auth.json">
    **身份验证相关文本**
    
    ```json
    {
      "signIn": "登录",
      "signOut": "登出",
      "signUp": "注册",
      "email": "邮箱",
      "password": "密码",
      "forgotPassword": "忘记密码？",
      "createAccount": "创建账户",
      "loginWithOIDC": "使用 OIDC 登录"
    }
    ```
  </Accordion>

  <Accordion icon="navigation" title="navigation.json">
    **菜单项和导航文本**
    
    ```json
    {
      "dashboard": "仪表板",
      "mcpServers": "MCP 服务器",
      "namespaces": "命名空间",
      "endpoints": "端点",
      "apiKeys": "API 密钥",
      "settings": "设置",
      "inspector": "MCP 检查器",
      "logs": "实时日志"
    }
    ```
  </Accordion>

  <Accordion icon="server" title="mcp-servers.json">
    **MCP 服务器特定翻译**
    
    ```json
    {
      "server": {
        "create": "创建服务器",
        "edit": "编辑服务器",
        "name": "服务器名称",
        "type": "服务器类型",
        "command": "命令",
        "args": "参数",
        "env": "环境变量"
      },
      "types": {
        "stdio": "STDIO",
        "http": "HTTP",
        "websocket": "WebSocket"
      }
    }
    ```
  </Accordion>
</AccordionGroup>

### 翻译键最佳实践

<Card title="翻译键指南" icon="key">
- **使用描述性、层次化的键**: `server.validation.nameRequired`
- **使用 camelCase 保持一致性**: `signIn`, `mcpServers`
- **分组相关翻译**: 所有服务器相关术语放在 `server` 下
- **保持上下文清晰**: 如果不同，使用 `auth:signIn` vs `form:signIn`
- **使用插值处理动态内容**: `"welcome": "欢迎，{{name}}！"`
</Card>

## 添加新语言

### 步骤 1: 创建翻译文件

1. **在 `public/locales/` 中创建语言目录**:
   ```bash
   mkdir -p public/locales/es  # 西班牙语
   ```

2. **复制英语文件作为模板**:
   ```bash
   cp -r public/locales/en/* public/locales/es/
   ```

3. **翻译每个 JSON 文件中的内容**:
   ```json
   // public/locales/es/common.json
   {
     "actions": {
       "save": "Guardar",
       "cancel": "Cancelar",
       "delete": "Eliminar",
       "edit": "Editar",
       "create": "Crear"
     }
   }
   ```

### 步骤 2: 更新配置

将新区域添加到 i18n 配置中：

<CodeGroup>
```typescript lib/i18n.ts
export const SUPPORTED_LOCALES = ['en', 'zh', 'es'] as const;
export type Locale = typeof SUPPORTED_LOCALES[number];

export const LOCALE_NAMES: Record<Locale, string> = {
  en: 'English',
  zh: '中文',
  es: 'Español'
};
```

```typescript middleware.ts
import { SUPPORTED_LOCALES } from '@/lib/i18n';

export function middleware(request: NextRequest) {
  // 更新区域检测以包含新语言
  const supportedLocales = SUPPORTED_LOCALES;
  // ... 其余中间件逻辑
}
```
</CodeGroup>

### 步骤 3: 更新语言切换器

语言切换器将自动包含新语言：

```tsx
// components/language-switcher.tsx
import { LOCALE_NAMES, SUPPORTED_LOCALES } from '@/lib/i18n';

export function LanguageSwitcher() {
  return (
    <select>
      {SUPPORTED_LOCALES.map(locale => (
        <option key={locale} value={locale}>
          {LOCALE_NAMES[locale]}
        </option>
      ))}
    </select>
  );
}
```

### 步骤 4: 测试实现

1. **在新语言中添加测试内容**
2. **导航到** `/{locale}/` URL（例如，`/es/mcp-servers`）
3. **验证翻译** 正确显示
4. **测试语言切换** 功能
5. **检查回退** 对缺失翻译的处理

## 翻译工作流程

### 新功能

在向 MetaMCP 添加新功能时：

1. **首先添加英语翻译** 到适当的命名空间
2. **使用描述性键** 在上下文中有意义
3. **用英语测试** 确保键工作正确
4. **添加其他语言**（或标记为待翻译）
5. **在部署前测试所有语言**

### 贡献者

<AccordionGroup>
  <Accordion icon="translate" title="翻译贡献者">
    **贡献翻译：**
    
    1. Fork 仓库
    2. 创建新的语言文件或更新现有文件
    3. 遵循现有的键结构
    4. 在本地测试你的翻译
    5. 提交包含你更改的 Pull Request
    
    **提示：**
    - 保持翻译简洁但清晰
    - 保持术语一致性
    - 考虑文化背景，不仅仅是字面翻译
    - 测试较长文本以确保 UI 仍然工作
  </Accordion>

  <Accordion icon="robot" title="AI 辅助翻译">
    **使用 Cursor/Claude 等 AI 工具：**
    
    ```prompt
    将此英语 JSON 文件翻译为西班牙语，保持相同的结构和键：
    
    {
      "server": {
        "create": "Create Server",
        "edit": "Edit Server"
      }
    }
    
    保持 "MCP" 和 "API" 等技术术语不变。
    ```
  </Accordion>
</AccordionGroup>

## 故障排除

### 常见问题

<AccordionGroup>
  <Accordion icon="warning" title="缺失翻译">
    **当翻译不显示时：**
    
    1. 检查翻译键是否存在于 JSON 文件中
    2. 验证命名空间是否正确（`common:save` vs `auth:save`）
    3. 确保区域文件存在且是有效的 JSON
    4. 检查浏览器控制台是否有缺失键警告
    5. 验证组件是否正确使用 `useTranslations`
  </Accordion>

  <Accordion icon="bug" title="水合错误">
    **服务器/客户端翻译不匹配：**
    
    1. 确保服务器和客户端之间的区域检测一致
    2. 使用 `useTranslations` 的 `isLoading` 状态
    3. 如果区域可能改变，避免在 SSR 期间渲染翻译
    4. 禁用 JavaScript 测试以检查 SSR 行为
  </Accordion>

  <Accordion icon="globe" title="区域路由问题">
    **URL 路由问题：**
    
    1. 检查新区域的中间件配置
    2. 验证 `getLocalizedPath` 函数处理新语言
    3. 测试直接导航到本地化 URL
    4. 确保回退行为正确工作
  </Accordion>
</AccordionGroup>

### 调试工具

<CodeGroup>
```bash 开发调试
# 检查缺失的翻译键
grep -r "t('" apps/frontend/app --include="*.tsx" | \
  grep -v "useTranslations"

# 验证 JSON 文件
for file in public/locales/*/*.json; do
  echo "检查 $file"
  cat "$file" | jq . > /dev/null
done
```

```typescript 调试组件
"use client";

import { useTranslations } from "@/hooks/useTranslations";

export function TranslationDebugger() {
  const { t, locale, isLoading } = useTranslations();
  
  return (
    <div className="debug-panel">
      <p>当前区域: {locale}</p>
      <p>正在加载: {isLoading.toString()}</p>
      <p>测试翻译: {t('common:save')}</p>
    </div>
  );
}
```
</CodeGroup>

## 未来增强

### 计划功能

- **RTL 语言支持** 用于阿拉伯语、希伯来语
- **日期/时间本地化** 具有适当的格式
- **基于区域的数字格式**
- **货币格式** 用于定价功能
- **复数规则** 用于复杂的语言要求

### 贡献指南

<Card title="i18n 贡献指南" icon="checklist">
- 📝 **首先添加英语**: 始终从英语翻译开始
- 🔍 **彻底测试**: 验证所有区域工作正确
- 📊 **使用一致术语**: 维护技术术语词汇表
- 🌍 **考虑上下文**: 适应文化差异，不仅仅是语言
- 📱 **测试 UI 影响**: 确保较长翻译不会破坏布局
- 🤝 **协作**: 尽可能与母语者合作
</Card>

## 下一步

<CardGroup cols={2}>
  <Card title="贡献指南" icon="handshake" href="/cn/development/contributing">
    了解如何为 MetaMCP 开发做出贡献
  </Card>
  
  <Card title="前端开发" icon="code" href="/cn/development">
    了解前端架构和开发设置
  </Card>
  
  <Card title="组件开发" icon="component" href="/cn/development#frontend-development">
    了解使用 i18n 的 UI 组件开发
  </Card>
  
  <Card title="测试指南" icon="test" href="/cn/development#testing">
    测试你的国际化更改
  </Card>
</CardGroup> 


================================================
FILE: docs/cn/integrations/claude-desktop.mdx
================================================
---
title: "Claude Desktop 集成"
description: "使用 mcp-proxy 配置 Claude Desktop 连接到 MetaMCP 端点"
---

**Claude Desktop** 集成允许您直接通过 Claude 的界面访问 MetaMCP 工具。由于 Claude Desktop 只支持 stdio 服务器，您需要一个本地代理来连接到 MetaMCP 的远程端点。

## 前置要求

在开始之前，请确保您拥有：

- **Claude Desktop** 已安装并运行
- **MetaMCP** 本地运行或已部署
- **活动端点**在 MetaMCP 中配置
- **API 密钥**已生成（如果启用了身份验证）

## 基本配置

### 使用 mcp-proxy（推荐）

由于 MetaMCP 端点仅是远程的（SSE、可流式 HTTP），Claude Desktop 需要一个本地代理来连接。根据测试，`mcp-proxy` 是 API 密钥身份验证的推荐解决方案。

<CodeGroup>
```json 可流式 HTTP（推荐）
{
  "mcpServers": {
    "MetaMCP": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "--transport",
        "streamablehttp",
        "http://localhost:12008/metamcp/your-endpoint-name/mcp"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_your_api_key_here"
      }
    }
  }
}
```

```json SSE（替代）
{
  "mcpServers": {
    "MetaMCP": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "http://localhost:12008/metamcp/your-endpoint-name/sse"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_your_api_key_here"
      }
    }
  }
}
```

```json 多个端点
{
  "mcpServers": {
    "MetaMCP-Dev": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "--transport",
        "streamablehttp",
        "http://localhost:12008/metamcp/dev-tools/mcp"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_dev_key"
      }
    },
    "MetaMCP-Research": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "http://localhost:12008/metamcp/research-tools/sse"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_research_key"
      }
    }
  }
}
```
</CodeGroup>

## 配置文件位置

编辑 Claude Desktop 的配置文件：

- **macOS**：`~/Library/Application Support/Claude/claude_desktop_config.json`
- **Windows**：`%APPDATA%\Claude\claude_desktop_config.json`
- **Linux**：`~/.config/claude/claude_desktop_config.json`

## 身份验证方法

<AccordionGroup>
  <Accordion icon="key" title="API 密钥身份验证">
    **最常见方法**使用环境变量：
    
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "command": "uvx",
          "args": [
            "mcp-proxy",
            "--transport",
            "streamablehttp",
            "http://localhost:12008/metamcp/your-endpoint-name/mcp"
          ],
          "env": {
            "API_ACCESS_TOKEN": "sk_mt_your_key_here"
          }
        }
      }
    }
    ```
  </Accordion>

  <Accordion icon="shield-minus" title="无身份验证">
    **对于没有身份验证的公共端点**：
    
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "command": "uvx",
          "args": [
            "mcp-proxy",
            "http://localhost:12008/metamcp/public-tools/sse"
          ]
        }
      }
    }
    ```
  </Accordion>
</AccordionGroup>

## 远程/生产设置

对于远程 MetaMCP 实例，只需替换 localhost URL：

```json
{
  "mcpServers": {
    "MetaMCP-Production": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "--transport",
        "streamablehttp",
        "https://your-metamcp-domain.com/metamcp/your-endpoint-name/mcp"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_production_key"
      }
    }
  }
}
```

## 重要说明

- **替换** `your-endpoint-name` 为您的实际端点名称
- **替换** `sk_mt_your_api_key_here` 为您的 MetaMCP API 密钥
- **mcp-proxy** 处理 stdio 和 HTTP/SSE 之间的协议转换
- **环境变量**是传递 API 密钥的安全方式
- 有关详细故障排除，请参阅 [issue #76](https://github.com/metatool-ai/metamcp/issues/76) 


================================================
FILE: docs/cn/integrations/cursor.mdx
================================================
---
title: "Cursor 集成"
description: "通过 mcp.json 配置 Cursor IDE 使用 MetaMCP 端点"
---

**Cursor** 是一个流行的 AI 驱动代码编辑器，支持 MCP（模型上下文协议）集成。本指南向您展示如何将 Cursor 连接到您的 MetaMCP 端点以获得增强的编码功能。

另请参阅 Cursor 关于 MCP 的文档 https://docs.cursor.com/context/mcp

## 前置要求

在开始之前，请确保您拥有：

- **Cursor IDE** 已安装并运行
- **MetaMCP** 本地运行或已部署
- **活动端点**在 MetaMCP 中配置
- **API 密钥**已生成（如果启用了身份验证）

## 基本配置

### 简单的 mcp.json 设置

在 Cursor 的配置目录中创建或编辑您的 `mcp.json` 文件：

<CodeGroup>
```json 基本配置
{
  "mcpServers": {
    "MetaMCP": {
      "url": "http://localhost:12008/metamcp/your-endpoint-name/mcp"
    }
  }
}
```

```json 带身份验证
{
  "mcpServers": {
    "MetaMCP": {
      "url": "http://localhost:12008/metamcp/your-endpoint-name/mcp",
      "headers": {
        "Authorization": "Bearer sk_mt_your_api_key_here"
      }
    }
  }
}
```

```json 多个端点
{
  "mcpServers": {
    "MetaMCP-Dev": {
      "url": "http://localhost:12008/metamcp/dev-tools/mcp",
      "headers": {
        "Authorization": "Bearer sk_mt_dev_key"
      }
    },
    "MetaMCP-Research": {
      "url": "http://localhost:12008/metamcp/research-tools/mcp",
      "headers": {
        "Authorization": "Bearer sk_mt_research_key"
      }
    }
  }
}
```
</CodeGroup>

## 配置选项

### 传输类型

MetaMCP 支持不同的传输协议。**推荐使用可流式 HTTP**用于 Cursor：

<AccordionGroup>
  <Accordion title="可流式 HTTP（推荐）">
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "url": "http://localhost:12008/metamcp/your-endpoint-name/mcp"
        }
      }
    }
    ```
  </Accordion>

  <Accordion title="SSE（替代）">
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "url": "http://localhost:12008/metamcp/your-endpoint-name/sse"
        }
      }
    }
    ```
  </Accordion>
</AccordionGroup>

### 身份验证方法

<AccordionGroup>
  <Accordion icon="key" title="API 密钥身份验证">
    **最常见方法**使用 Authorization 标头：
    
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "url": "http://localhost:12008/metamcp/your-endpoint-name/mcp",
          "headers": {
            "Authorization": "Bearer sk_mt_your_key_here"
          }
        }
      }
    }
    ```
  </Accordion>

  <Accordion icon="shield-minus" title="无身份验证">
    **对于没有身份验证的公共端点**：
    
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "url": "http://localhost:12008/metamcp/public-tools/sse"
        }
      }
    }
    ```
  </Accordion>
</AccordionGroup>



================================================
FILE: docs/cn/integrations/general-stdio-with-api-key.mdx
================================================
---
title: "通用 Stdio 集成使用 `mcp-proxy` 和 API 密钥"
description: "配置任何基于 stdio 的 MCP 客户端使用 mcp-proxy 连接到 MetaMCP 端点"
---

**通用 Stdio 集成**允许任何支持 stdio 服务器的 MCP 客户端连接到 MetaMCP 的远程端点。由于 MetaMCP 端点是纯远程的（SSE、可流式 HTTP），您需要一个本地代理来桥接连接。

## 前置要求

在开始之前，请确保您拥有：

- **MCP 客户端**支持 stdio 服务器（Claude Desktop、Cursor 等）
- **MetaMCP**本地运行或已部署
- **活动端点**在 MetaMCP 中配置
- **API 密钥**已生成（如果启用了身份验证）
- **mcp-proxy**已安装（`uvx mcp-proxy`）

## 基本配置

### 使用 mcp-proxy（必需）

由于 MetaMCP 端点是纯远程的，您需要 `mcp-proxy` 来在 stdio 和 HTTP/SSE 协议之间进行转换。

<CodeGroup>
```json 可流式 HTTP（推荐）
{
  "mcpServers": {
    "MetaMCP": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "--transport",
        "streamablehttp",
        "http://localhost:12008/metamcp/your-endpoint-name/mcp"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_your_api_key_here"
      }
    }
  }
}
```

```json SSE（替代）
{
  "mcpServers": {
    "MetaMCP": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "http://localhost:12008/metamcp/your-endpoint-name/sse"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_your_api_key_here"
      }
    }
  }
}
```

```json 多个端点
{
  "mcpServers": {
    "MetaMCP-Dev": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "--transport",
        "streamablehttp",
        "http://localhost:12008/metamcp/dev-tools/mcp"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_dev_key"
      }
    },
    "MetaMCP-Research": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "http://localhost:12008/metamcp/research-tools/sse"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_research_key"
      }
    }
  }
}
```
</CodeGroup>

## 身份验证方法

<AccordionGroup>
  <Accordion icon="key" title="API 密钥身份验证">
    **最常见方法**使用环境变量：
    
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "command": "uvx",
          "args": [
            "mcp-proxy",
            "--transport",
            "streamablehttp",
            "http://localhost:12008/metamcp/your-endpoint-name/mcp"
          ],
          "env": {
            "API_ACCESS_TOKEN": "sk_mt_your_key_here"
          }
        }
      }
    }
    ```
  </Accordion>

  <Accordion icon="shield-minus" title="无身份验证">
    **对于没有身份验证的公共端点**：
    
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "command": "uvx",
          "args": [
            "mcp-proxy",
            "http://localhost:12008/metamcp/your-endpoint-name/sse"
          ]
        }
      }
    }
    ```
  </Accordion>
</AccordionGroup>

## 故障排除

### 常见问题

1. **连接被拒绝**：确保 MetaMCP 正在运行且可访问
2. **身份验证失败**：验证 API 密钥是否正确且具有适当权限
3. **找不到 mcp-proxy**：使用 `pip install mcp-proxy` 或 `uvx mcp-proxy` 安装

### 调试模式

为 mcp-proxy 启用调试日志：

```json
{
  "mcpServers": {
    "MetaMCP": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "--transport",
        "streamablehttp",
        "--debug",
        "http://localhost:12008/metamcp/your-endpoint-name/mcp"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_your_api_key_here"
      }
    }
  }
}
```

## 重要说明

- **替换** `your-endpoint-name` 为您的实际端点名称
- **替换** `sk_mt_your_api_key_here` 为您的 MetaMCP API 密钥
- **mcp-proxy** 处理 stdio 和可流式 HTTP/SSE 之间的协议转换
- **环境变量**是传递 API 密钥的安全方式 


================================================
FILE: docs/cn/integrations/open-web-ui.mdx
================================================
---
title: "Open WebUI 集成"
description: "使用 MetaMCP 来管理 Open WebUI 的工具"
---

## 前置要求

在开始之前，请确保您具备以下条件：
- 已安装 Docker 和 Docker Compose
- Open WebUI 正在运行（本地或已部署）
- MetaMCP 已部署并正确配置了 `APP_URL`（默认为 `http://localhost:12008`）

## 步骤 1：部署 MetaMCP 并进行正确配置

<AccordionGroup>
  <Accordion icon="github" title="克隆和设置 MetaMCP">
    如果还没有，请克隆 MetaMCP 并进行设置：
    
    ```bash
    git clone https://github.com/metatool-ai/metamcp.git
    cd metamcp
    cp example.env .env
    ```
  </Accordion>

  <Accordion icon="settings" title="为 Open WebUI 访问配置 APP_URL">
    **重要**：在 `.env` 文件中正确配置您的 `APP_URL` 以支持 Open WebUI 集成：
    
    ```bash
    # 本地 Open WebUI 访问本地 MetaMCP
    APP_URL=http://localhost:12008
    
    # 已部署的 Open WebUI 访问已部署的 MetaMCP
    APP_URL=https://your-metamcp-domain.com
    
    # 本地 Open WebUI 访问已部署的 MetaMCP
    APP_URL=https://your-metamcp-domain.com
    ```
    
    <Warning>
      Open WebUI 必须能够通过配置的 `APP_URL` 访问您的 MetaMCP 实例。确保防火墙规则和网络配置允许此访问。
    </Warning>
    
    同时配置其他生产设置：
    ```bash
    POSTGRES_PASSWORD=your_secure_password
    BETTER_AUTH_SECRET=your_auth_secret  # 使用以下命令生成：openssl rand -hex 32 | base64
    ```
  </Accordion>

  <Accordion icon="docker" title="启动 MetaMCP">
    使用 Docker Compose 启动 MetaMCP：
    
    ```bash
    docker compose up -d
    ```
    
    通过访问您配置的 `APP_URL` 来验证它是否正在运行。
  </Accordion>
</AccordionGroup>

## 步骤 2：为 Open WebUI 配置 MetaMCP

<AccordionGroup>
  <Accordion icon="user" title="创建 MetaMCP 账户">
    1. 打开浏览器并访问您的 `APP_URL`（例如，`http://localhost:12008`）
    2. **创建账户**或登录
    3. **（推荐）**在**设置**中禁用新用户注册以确保安全
  </Accordion>

  <Accordion icon="server" title="添加 MCP 服务器">
    添加您想要暴露给 Open WebUI 的 MCP 服务器：
    
    1. 在侧边栏中导航到 **MCP 服务器**
    2. 点击 **"添加服务器"** 按钮
    3. 配置您的服务器（以文件系统服务器为例）：
    
    **基本信息：**
    - **名称**：`hacker-news-server`
    - **描述**：`用于获取故事和评论的 Hacker News 集成`
    - **类型**：`STDIO`
    
    **服务器配置：**
    - **命令**：`uvx`
    - **参数**：`mcp-hn`
    - **环境变量**：（如果需要）
    
    **所有权：**
    - 选择 **"所有人（公开）"** 以允许 Open WebUI 访问
    
    4. 点击 **"创建服务器"**
    
    <Tip>
      对您想要提供给 Open WebUI 的所有 MCP 服务器重复此过程。
    </Tip>
  </Accordion>

  <Accordion icon="package" title="创建命名空间">
    将您的 MCP 服务器分组到命名空间中供 Open WebUI 使用：
    
    1. 在侧边栏中转到 **命名空间**
    2. 点击 **"创建命名空间"**
    3. 配置命名空间：
    
    **基本信息：**
    - **名称**：`openwebui-tools`
    - **描述**：`Open WebUI 集成的聚合工具`
    
    **所有权：**
    - 选择 **"所有人（公开）"**
    
    **选择 MCP 服务器：**
    - 勾选您想要包含的所有服务器
    - 这些将聚合到一个端点中
    
    4. 点击 **"创建命名空间"**
  </Accordion>

  <Accordion icon="wrench" title="管理工具（可选）">
    微调可用的工具：
    
    1. 点击您的 **"openwebui-tools"** 命名空间
    2. 查看 **工具管理** 部分
    3. 禁用您不希望 Open WebUI 访问的任何工具
    4. 这有助于保持工具集的专注性和安全性
  </Accordion>
</AccordionGroup>

## 步骤 3：创建 OpenAPI 端点

<AccordionGroup>
  <Accordion icon="link" title="创建公共端点">
    创建一个 Open WebUI 可以使用的端点：
    
    1. 在侧边栏中导航到 **端点**
    2. 点击 **"创建端点"**
    3. 配置端点：
    
    **基本信息：**
    - **名称**：`openwebui-api`
    - **描述**：`Open WebUI 集成的 OpenAPI 端点`
    
    **所有权：**
    - 选择 **"所有人（公开）"**
    
    **命名空间选择：**
    - 选择您的 **"openwebui-tools"** 命名空间
    
    **API 密钥认证：**
    - **启用 API 密钥认证**：切换为开启
    - **使用查询参数认证**：切换为关闭（Open WebUI 支持 Bearer 令牌）
    
    **MCP 服务器创建：**
    - 勾选 **"自动为此端点创建 MCP 服务器"**
    
    4. 点击 **"创建端点"**
    
    **您的 OpenAPI 端点将在以下位置可用：**
    - OpenAPI UI：`{APP_URL}/metamcp/openwebui-api/api`
    - OpenAPI 架构：`{APP_URL}/metamcp/openwebui-api/api/openapi.json`
  </Accordion>
</AccordionGroup>

## 步骤 4：生成 API 密钥

<Tip>在上一步中，如果您选择 **"自动为此端点创建 MCP 服务器"** 选项，那么至少会为您自动生成一个 API 密钥。您可以随意使用它，而不必创建新的。</Tip>
<AccordionGroup>
  <Accordion icon="key" title="为 Open WebUI 创建 API 密钥">
    1. 在侧边栏中转到 **API 密钥**
    2. 点击 **"生成密钥"**
    3. 配置 API 密钥：
    
    **密钥信息：**
    - **描述**：`Open WebUI 集成密钥`
    - **范围**：**公开**（以便 Open WebUI 可以使用）
    
    4. 点击 **"生成密钥"**
    5. **重要**：复制生成的密钥（以 `sk_mt_` 开头）
    
    <Warning>
      安全保存此密钥 - 它只显示一次，将需要用于 Open WebUI 配置。
    </Warning>
  </Accordion>
</AccordionGroup>

## 步骤 5：配置 Open WebUI

<AccordionGroup>
  <Accordion title="步骤 5.1：打开 Web UI">
    打开您的 Open Web UI 页面。找到设置。
    <img src="/images/open-web-ui/1.png" alt="OpenWebUI 截图 1" style={{ width: "100%", maxWidth: "800px", margin: "2rem 0", borderRadius: "8px", boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)" }} />
  </Accordion>
  <Accordion title="步骤 5.2：设置 > 工具">
    在设置弹出窗口中。转到"工具"。
    <img src="/images/open-web-ui/2.png" alt="OpenWebUI 截图 2" style={{ width: "100%", maxWidth: "800px", margin: "2rem 0", borderRadius: "8px", boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)" }} />
  </Accordion>
  <Accordion title="步骤 5.3：设置 > 工具 > 添加连接">
    在右上角的 **"管理工具服务器"** 下点击 **"+"** 按钮添加连接。
    <br /> 
    对于 **URL > 基础 URL** 输入 `{APP_URL}/metamcp/openwebui-api/api`。例如，如果 `APP_URL` 是 `http://localhost:12008`，则输入 `http://localhost:12008/metamcp/openwebui-api/api`。
    <br /> 
    对于 **URL > openapi.json 路径** 输入 `{APP_URL}/metamcp/openwebui-api/api/openapi.json`。例如，如果 `APP_URL` 是 `http://localhost:12008`，则输入 `http://localhost:12008/metamcp/openwebui-api/api/openapi.json`。
    <br /> 
    将前面步骤生成的 **"API 密钥"** 放入 **"Auth Bearer"** 字段。
    <br /> 
    使用"刷新"按钮测试连接。
    <img src="/images/open-web-ui/3.png" alt="OpenWebUI 截图 3" style={{ width: "100%", maxWidth: "800px", margin: "2rem 0", borderRadius: "8px", boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)" }} />
  </Accordion>
  <Accordion title="步骤 5.4：返回聊天并验证列出的工具">
    关闭任何弹出窗口。在主页点击新聊天。然后检查可用工具。
    <img src="/images/open-web-ui/4.png" alt="OpenWebUI 截图 4" style={{ width: "100%", maxWidth: "800px", margin: "2rem 0", borderRadius: "8px", boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)" }} />
    <img src="/images/open-web-ui/5.png" alt="OpenWebUI 截图 5" style={{ width: "100%", maxWidth: "800px", margin: "2rem 0", borderRadius: "8px", boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)" }} />
  </Accordion>
  <Accordion title="步骤 5.5：使用工具调用的聊天">
    在新聊天中，"显示热门黑客新闻"的查询将如下所示：
    <img src="/images/open-web-ui/6.png" alt="OpenWebUI 截图 6" style={{ width: "100%", maxWidth: "800px", margin: "2rem 0", borderRadius: "8px", boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)" }} />
  </Accordion>
</AccordionGroup>

<Tip>然后在新聊天中，使用支持工具调用的模型，如果需要，应该自动尝试调用工具。</Tip>
## 故障排除

<AccordionGroup>
  <Accordion icon="warning" title="常见问题">
    **连接错误：**
    - 验证 `APP_URL` 可以从 Open WebUI 访问
    - 检查防火墙和网络配置
    - 确保 API 密钥配置正确。首先关闭认证以测试是否有效。
    - 关闭认证后，您可以手动访问例如 `http://localhost:12008/metamcp/openwebui-api/api/openapi.json` 来验证 `openapi.json`。
    
    **认证问题：**
    - 验证 API 密钥格式（应以 `sk_mt_` 开头）
    - 确保在 Open WebUI 中正确配置了 Bearer 令牌认证
    - 验证授权头格式：`Bearer {your_api_key}`
    
    **工具执行失败：**
    - 在 MetaMCP 仪表板中检查 MCP 服务器状态
    - 查看命名空间设置中的工具权限
    - 监控日志以获取特定错误消息
    
    **CORS 错误：**
    - 确保允许 Open WebUI 域名
    - 检查 MetaMCP CORS 配置
    - 验证 APP_URL 与访问 URL 匹配
  </Accordion>

  <Accordion icon="question" title="需要帮助？">
    - 查看 [MetaMCP GitHub Issues](https://github.com/metatool-ai/metamcp/issues)
    - 加入我们的 [Discord 社区](https://discord.gg/mNsyat7mFX)
    - 如有必要，查看 Open WebUI 文档
  </Accordion>
</AccordionGroup>


================================================
FILE: docs/cn/integrations/troubleshooting-future.mdx
================================================
# Integration Troubleshooting

Common issues and solutions when integrating MetaMCP with various tools and platforms.

## General Troubleshooting

### Connection Issues

#### "Connection Refused" or "Cannot Connect"

**Symptoms**: Client cannot connect to MetaMCP server

**Solutions**:

1. **Check server status**:
```bash
# Test basic connectivity
curl -I https://your-domain.com/api/health

# Check if server is running locally
curl -I http://localhost:8000/api/health
```

2. **Verify network configuration**:
```bash
# Check if port is open
telnet your-domain.com 443
nc -zv your-domain.com 443

# For local development
telnet localhost 8000
```

3. **Check firewall settings**:
```bash
# Linux (ufw)
sudo ufw status
sudo ufw allow 8000

# macOS
sudo pfctl -sr | grep 8000

# Windows
netsh advfirewall firewall show rule name=all | findstr 8000
```

#### SSL/TLS Certificate Issues

**Symptoms**: "Certificate verification failed" or "SSL handshake error"

**Solutions**:

1. **Check certificate validity**:
```bash
# Check certificate
openssl s_client -connect your-domain.com:443 -servername your-domain.com

# Check certificate expiry
curl -vI https://your-domain.com 2>&1 | grep -E "(expire|valid)"
```

2. **For self-signed certificates**:
```bash
# Skip certificate verification (development only)
curl -k https://your-domain.com/api/health

# Add certificate to trust store
# macOS
sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain cert.pem

# Linux
sudo cp cert.pem /usr/local/share/ca-certificates/metamcp.crt
sudo update-ca-certificates
```

### Authentication Issues

#### "Unauthorized" (401) Errors

**Symptoms**: API returns 401 status code

**Solutions**:

1. **Verify API key format**:
```bash
# Check if API key starts with correct prefix
echo "mcp_1234567890abcdef" | grep "^mcp_"

# Test API key
curl -H "Authorization: Bearer mcp_1234567890abcdef" \
  https://your-domain.com/api/health
```

2. **Check API key expiration**:
```bash
# Get API key details
curl -H "Authorization: Bearer your-session-token" \
  https://your-domain.com/api/api-keys/key-uuid
```

3. **Verify header format**:
```bash
# Correct formats
curl -H "Authorization: Bearer mcp_key" https://domain.com/api
curl -H "X-API-Key: mcp_key" https://domain.com/api

# Common mistakes
curl -H "Authorization: mcp_key" https://domain.com/api  # Missing "Bearer"
curl -H "API-Key: mcp_key" https://domain.com/api       # Wrong header name
```

#### "Forbidden" (403) Errors

**Symptoms**: Authentication succeeds but access is denied

**Solutions**:

1. **Check permissions**:
```bash
# List API key permissions
curl -H "Authorization: Bearer mcp_key" \
  https://your-domain.com/api/api-keys/permissions

# Test specific permission
curl -H "Authorization: Bearer mcp_key" \
  https://your-domain.com/api/mcp-servers  # Requires mcp-servers:read
```

2. **Verify IP restrictions**:
```bash
# Check your external IP
curl ifconfig.me

# Test from allowed IP
curl --interface allowed-ip -H "Authorization: Bearer mcp_key" \
  https://your-domain.com/api/health
```

3. **Check resource scoping**:
```bash
# Access scoped namespace
curl -H "Authorization: Bearer mcp_key" \
  https://your-domain.com/api/namespaces/allowed-namespace-uuid

# This might fail if not in scope
curl -H "Authorization: Bearer mcp_key" \
  https://your-domain.com/api/namespaces/restricted-namespace-uuid
```

## Platform-Specific Issues

### Claude Desktop

#### Tools Not Appearing

**Symptoms**: MetaMCP tools don't show up in Claude Desktop

**Solutions**:

1. **Check configuration file location**:
```bash
# macOS
ls -la "~/Library/Application Support/Claude/claude_desktop_config.json"

# Windows
dir "%APPDATA%\Claude\claude_desktop_config.json"

# Linux
ls -la ~/.config/claude/claude_desktop_config.json
```

2. **Validate JSON syntax**:
```bash
# Use jq to validate JSON
cat claude_desktop_config.json | jq .

# Or use online validator
python -m json.tool claude_desktop_config.json
```

3. **Check MCP server status**:
```bash
# Test the exact endpoint used in config
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/mcp-proxy/tools
```

4. **Enable debug logging**:
```json
{
  "mcpServers": {
    "metamcp": {
      "command": "npx",
      "args": [
        "@modelcontextprotocol/server-metamcp",
        "--endpoint", "https://your-domain.com/api/mcp-proxy",
        "--api-key", "your-api-key",
        "--debug"
      ]
    }
  }
}
```

#### Tool Execution Errors

**Symptoms**: Tools appear but fail when executed

**Solutions**:

1. **Check tool permissions**:
```bash
# List available tools
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/tools

# Test tool execution directly
curl -X POST \
  -H "Authorization: Bearer your-api-key" \
  -H "Content-Type: application/json" \
  -d '{"name": "tool_name", "arguments": {}}' \
  https://your-domain.com/api/namespaces/uuid/tools/execute
```

2. **Verify tool arguments**:
```bash
# Get tool schema
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/tools/tool_name

# Check required parameters
jq '.inputSchema.required' tool_schema.json
```

3. **Check namespace status**:
```bash
# Verify namespace is active
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/namespaces/uuid

# Check MCP servers in namespace
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/namespaces/uuid/mcp-servers
```

### Cursor Integration

#### Extension Not Loading

**Symptoms**: MetaMCP extension fails to load in Cursor

**Solutions**:

1. **Check extension installation**:
```bash
# List installed extensions
code --list-extensions | grep metamcp

# Install if missing
code --install-extension metamcp-extension
```

2. **Verify configuration**:
```json
// .vscode/settings.json
{
  "metamcp.endpoint": "https://your-domain.com",
  "metamcp.apiKey": "your-api-key",
  "metamcp.namespace": "your-namespace-uuid"
}
```

3. **Check extension logs**:
   - Open Cursor Developer Tools (Cmd+Shift+I / Ctrl+Shift+I)
   - Go to Console tab
   - Look for MetaMCP-related errors

#### Tool Suggestions Not Working

**Symptoms**: Code completion doesn't include MetaMCP tools

**Solutions**:

1. **Refresh tool cache**:
   - Command Palette → "MetaMCP: Refresh Tools"
   - Or restart Cursor

2. **Check tool visibility**:
```bash
# Verify tools are accessible
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/namespaces/uuid/tools
```

3. **Update extension settings**:
```json
{
  "metamcp.enableAutoCompletion": true,
  "metamcp.suggestionDelay": 300,
  "metamcp.maxSuggestions": 10
}
```

### API Integration

#### Rate Limiting Issues

**Symptoms**: "Too Many Requests" (429) errors

**Solutions**:

1. **Check current rate limits**:
```bash
# Get rate limit info from headers
curl -I -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/tools

# Look for headers:
# X-RateLimit-Limit: 1000
# X-RateLimit-Remaining: 999
# X-RateLimit-Reset: 1640995200
```

2. **Implement exponential backoff**:
```python
import time
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

def create_session_with_retries():
    session = requests.Session()
    retry_strategy = Retry(
        total=3,
        backoff_factor=1,
        status_forcelist=[429, 500, 502, 503, 504],
    )
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    return session

# Usage
session = create_session_with_retries()
response = session.get(
    "https://your-domain.com/api/tools",
    headers={"Authorization": "Bearer your-api-key"}
)
```

3. **Request higher limits**:
```bash
# Contact support for higher limits
curl -X POST https://your-domain.com/api/support/rate-limit-increase \
  -H "Authorization: Bearer your-api-key" \
  -H "Content-Type: application/json" \
  -d '{
    "reason": "High-volume integration",
    "current_limit": 1000,
    "requested_limit": 10000
  }'
```

#### Webhook Failures

**Symptoms**: Webhooks not being delivered

**Solutions**:

1. **Check webhook endpoint**:
```bash
# Test if your endpoint is reachable
curl -X POST https://your-webhook-endpoint.com/webhook \
  -H "Content-Type: application/json" \
  -d '{"test": true}'
```

2. **Verify webhook configuration**:
```bash
# List configured webhooks
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/webhooks

# Test webhook delivery
curl -X POST \
  -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/webhooks/webhook-id/test
```

3. **Check webhook logs**:
```bash
# Get delivery attempts
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/webhooks/webhook-id/deliveries

# Get specific delivery details
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/webhooks/deliveries/delivery-id
```

## Network and Infrastructure

### Proxy Configuration

#### Corporate Proxy Issues

**Symptoms**: Connections fail behind corporate firewall

**Solutions**:

1. **Configure proxy settings**:
```bash
# Environment variables
export HTTP_PROXY=http://proxy.company.com:8080
export HTTPS_PROXY=http://proxy.company.com:8080
export NO_PROXY=localhost,127.0.0.1,.company.com

# Test connectivity through proxy
curl --proxy http://proxy.company.com:8080 \
  https://your-domain.com/api/health
```

2. **Proxy authentication**:
```bash
# With credentials
export HTTP_PROXY=http://username:password@proxy.company.com:8080

# Or use .netrc file
echo "machine proxy.company.com login username password" >> ~/.netrc
chmod 600 ~/.netrc
```

3. **Certificate issues with proxy**:
```bash
# Use corporate certificate bundle
export REQUESTS_CA_BUNDLE=/path/to/corporate-ca-bundle.crt
export SSL_CERT_FILE=/path/to/corporate-ca-bundle.crt
```

### DNS Issues

#### "Name Resolution Failed"

**Symptoms**: Cannot resolve MetaMCP domain

**Solutions**:

1. **Check DNS resolution**:
```bash
# Test DNS lookup
nslookup your-domain.com
dig your-domain.com

# Try different DNS servers
nslookup your-domain.com 8.8.8.8
dig @1.1.1.1 your-domain.com
```

2. **Use IP address temporarily**:
```bash
# Find IP address
host your-domain.com

# Use IP directly (not recommended for production)
curl -H "Host: your-domain.com" https://192.168.1.100/api/health
```

3. **Update hosts file**:
```bash
# Add entry to hosts file
echo "192.168.1.100 your-domain.com" | sudo tee -a /etc/hosts

# Windows
echo 192.168.1.100 your-domain.com >> C:\Windows\System32\drivers\etc\hosts
```

## Performance Issues

### Slow Response Times

**Symptoms**: API calls take longer than expected

**Solutions**:

1. **Check server health**:
```bash
# Get detailed health info
curl https://your-domain.com/api/health/detailed

# Check response time
time curl https://your-domain.com/api/health
```

2. **Optimize queries**:
```bash
# Use pagination
curl "https://your-domain.com/api/tools?limit=50&offset=0"

# Filter results
curl "https://your-domain.com/api/tools?name=filesystem*"

# Request only needed fields
curl "https://your-domain.com/api/tools?fields=name,description"
```

3. **Enable compression**:
```bash
# Request compressed responses
curl -H "Accept-Encoding: gzip" \
  https://your-domain.com/api/tools
```

### Memory Issues

#### "Out of Memory" Errors

**Symptoms**: Applications crash with memory errors

**Solutions**:

1. **Monitor memory usage**:
```bash
# Check system memory
free -h
top
htop

# Monitor specific process
ps aux | grep metamcp
```

2. **Optimize client configuration**:
```json
{
  "metamcp": {
    "maxConcurrentRequests": 5,
    "cacheSize": "100MB",
    "requestTimeout": 30000
  }
}
```

3. **Use streaming for large responses**:
```bash
# Stream large datasets
curl -N -H "Accept: application/x-ndjson" \
  https://your-domain.com/api/logs/stream
```

## Debugging Tools

### Enable Debug Logging

```bash
# Environment variables
export DEBUG=metamcp:*
export LOG_LEVEL=debug

# Application-specific
export METAMCP_DEBUG=true
export METAMCP_LOG_LEVEL=trace
```

### Network Analysis

```bash
# Capture network traffic
sudo tcpdump -i any -w metamcp.pcap host your-domain.com

# Analyze with Wireshark
wireshark metamcp.pcap

# HTTP-specific analysis
mitmproxy --mode reverse:https://your-domain.com
```

### Health Check Script

Create a comprehensive health check:

```bash
#!/bin/bash
# health-check.sh

DOMAIN="your-domain.com"
API_KEY="your-api-key"

echo "=== MetaMCP Health Check ==="

# Basic connectivity
echo "1. Testing basic connectivity..."
if curl -s -f "https://$DOMAIN/api/health" > /dev/null; then
    echo "✓ Server is reachable"
else
    echo "✗ Server is not reachable"
    exit 1
fi

# Authentication
echo "2. Testing authentication..."
if curl -s -f -H "Authorization: Bearer $API_KEY" \
   "https://$DOMAIN/api/api-keys/permissions" > /dev/null; then
    echo "✓ Authentication successful"
else
    echo "✗ Authentication failed"
    exit 1
fi

# API endpoints
echo "3. Testing API endpoints..."
endpoints=("namespaces" "mcp-servers" "tools")
for endpoint in "${endpoints[@]}"; do
    if curl -s -f -H "Authorization: Bearer $API_KEY" \
       "https://$DOMAIN/api/$endpoint" > /dev/null; then
        echo "✓ $endpoint endpoint working"
    else
        echo "✗ $endpoint endpoint failed"
    fi
done

echo "=== Health check complete ==="
```

### Log Analysis

Common log patterns to look for:

```bash
# Error patterns
grep -E "(ERROR|FATAL|Exception)" metamcp.log

# Authentication issues
grep -E "(401|403|Unauthorized|Forbidden)" metamcp.log

# Performance issues
grep -E "(timeout|slow|performance)" metamcp.log

# Rate limiting
grep -E "(429|rate.limit|throttle)" metamcp.log
```

## Getting Help

### Information to Collect

When reporting issues, include:

1. **Environment details**:
   - Operating system and version
   - Client application and version
   - MetaMCP server version
   - Network configuration

2. **Configuration**:
   - Sanitized configuration files
   - Environment variables (no secrets)
   - API key permissions

3. **Error details**:
   - Complete error messages
   - HTTP status codes
   - Timestamps
   - Steps to reproduce

4. **Logs**:
   - Client-side logs
   - Server-side logs (if accessible)
   - Network traces

### Support Channels

- **GitHub Issues**: https://github.com/metatool-ai/metamcp/issues
- **Discord**: https://discord.gg/mNsyat7mFX
- **Email**: support@metamcp.com
- **Documentation**: https://docs.metamcp.com 


================================================
FILE: docs/cn/troubleshooting/oauth-troubleshooting.mdx
================================================
[Binary file]


================================================
FILE: docs/en/index.mdx
================================================
---
title: "MetaMCP Documentation"
description: "MCP Aggregator, Orchestrator, Middleware, Gateway in one docker"
---

<div align="center">

<img src="/images/metamcp.svg" alt="MetaMCP Diagram" style={{ width: "100%", maxWidth: "600px", margin: "2rem 0" }} />

**MetaMCP** is a MCP proxy that lets you dynamically aggregate MCP servers into a unified MCP server, and apply middlewares. MetaMCP itself is a MCP server so it can be easily plugged into **ANY** MCP clients.

</div>

## 🎯 Use Cases

<CardGroup cols={2}>
  <Card title="Group & Host MCP Servers" icon="folder-open">
    Group MCP servers into namespaces, host them as meta-MCPs, and assign public endpoints (SSE or Streamable HTTP) with authentication.
  </Card>
  <Card title="Cherry-pick Tools" icon="pointer">
    Pick only the tools you need when remixing MCP servers. Apply pluggable middleware for observability and security.
  </Card>
  <Card title="Enhanced Inspector" icon="search-code">
    Use as enhanced MCP inspector with saved server configs, and inspect your MetaMCP endpoints.
  </Card>
  <Card title="Context Engineering Engine for MCP" icon="search">
    Use as Elasticsearch for MCP tool selection (coming soon).
  </Card>
</CardGroup>

Generally developers can use MetaMCP as **infrastructure** to host dynamically composed MCP servers through a unified endpoint, and build agents on top of it.

<div align="center">
  <img src="/images/metamcp_screenshot.png" alt="MetaMCP Screenshot" style={{ width: "100%", maxWidth: "800px", margin: "2rem 0", borderRadius: "8px", boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)" }} />
</div>

## Quick Start

Get MetaMCP running in minutes with Docker Compose:

<CodeGroup>
```bash Clone & Setup
git clone https://github.com/metatool-ai/metamcp.git
cd metamcp
cp example.env .env
```

```bash Start with Docker
docker compose up -d
```
</CodeGroup>

<Card title="Continue with Quickstart Guide" icon="rocket" href="/en/quickstart">
  Follow our complete setup guide to configure your first MCP servers and namespaces.
</Card>

## Core Concepts

Understanding these key concepts will help you get the most out of MetaMCP:

<CardGroup cols={2}>
  <Card title="MCP Servers" icon="server" href="/en/concepts/mcp-servers">
    Learn how to configure and manage MCP server instances.
  </Card>
  <Card title="Namespaces" icon="package" href="/en/concepts/namespaces">
    Group MCP servers and apply middleware at the namespace level.
  </Card>
  <Card title="Endpoints" icon="globe" href="/en/concepts/endpoints">
    Create public endpoints for your namespaces with different transport options.
  </Card>
  <Card title="Middleware" icon="filter" href="/en/concepts/middleware">
    Transform MCP requests and responses with pluggable middleware.
  </Card>
</CardGroup>

## Integrations

Connect MetaMCP to your favorite tools and platforms:

<CardGroup cols={2}>
  <Card title="Cursor" icon="mouse-pointer-2" href="/en/integrations/cursor">
    Configure Cursor to use MetaMCP endpoints via mcp.json
  </Card>
  <Card title="Claude Desktop" icon="monitor-dot" href="/en/integrations/claude-desktop">
    Connect Claude Desktop using mcp-proxy for STDIO compatibility
  </Card>
</CardGroup>

## Features

<AccordionGroup>
  <Accordion icon="shield" title="Enterprise Authentication">
    - Better Auth for frontend & backend
    - Session cookies for secure connections
    - API key authentication for external access
    - OpenID Connect (OIDC) support for enterprise SSO
    - Multi-tenancy with public/private scopes
  </Accordion>

  <Accordion icon="network" title="Multiple Transport Options">
    - **SSE (Server-Sent Events)** for MCP backward compatibility and real-time connections
    - **Streamable HTTP** for Streamable HTTP-based MCP communication (now standard remote MCP connection)
    - **OpenAPI endpoints** compatible with clients like Open WebUI
    - **STDIO compatibility** via proxy for local
  </Accordion>

  <Accordion icon="globe" title="Internationalization">
    - Built-in support for English and Chinese
    - Easy to add additional languages
    - Locale-based routing and content
  </Accordion>

  <Accordion icon="chart-line" title="Performance & Scalability">
    - Pre-allocated idle sessions for reduced cold start time
    - Configurable session management
    - Designed for at least 2GB-4GB memory instances
    - Docker-based deployment with nginx support
    - Cluster scaling and separation of MCP manager and worker will release in the future.
  </Accordion>
</AccordionGroup>

## Getting Help

<CardGroup cols={2}>
  <Card title="Contributing to MetaMCP" icon="code" href="/en/development/contributing">
    Set up a local development environment and contribute to MetaMCP.
  </Card>
   <Card title="API Reference" icon="book" href="/en/api-reference/introduction">
    Explore the complete API documentation for MetaMCP endpoints.
  </Card>
  <Card title="GitHub Issues" icon="github" href="https://github.com/metatool-ai/metamcp/issues">
    Report bugs, request features, or browse existing issues.
  </Card>
  <Card title="Discord Community" icon="discord" href="https://discord.gg/mNsyat7mFX">
    Join our Discord server for support and community discussions.
  </Card>
</CardGroup>



================================================
FILE: docs/en/quickstart.mdx
================================================
---
title: "Quick Start"
description: "Get MetaMCP running in minutes and configure your first MCP servers"
---

Get MetaMCP up and running in just a few minutes and configure your first MCP server aggregation.

## Prerequisites

Before starting, ensure you have:
- Docker and Docker Compose installed
- Git for cloning the repository
- Basic understanding of MCP (Model Context Protocol)

## Step 1: Installation

<AccordionGroup>
  <Accordion icon="github" title="Clone the Repository">
    Clone MetaMCP from GitHub and navigate to the project directory:
    
    ```bash
    git clone https://github.com/metatool-ai/metamcp.git
    cd metamcp
    ```
  </Accordion>

  <Accordion icon="settings" title="Configure Environment">
    Copy the example environment file and customize as needed:
    
    ```bash
    cp example.env .env
    ```
    
    <Note>
      If you modify `APP_URL` in the `.env` file, make sure you only access MetaMCP from that URL due to CORS policy enforcement.
    </Note>
    <Warning>In production environment, make sure you modify POSTGRES_PASSWORD and BETTER_AUTH_SECRET. Also use HTTPS. A typical way to generate secrets is `openssl rand -hex 32 | base64`</Warning>
  </Accordion>

  <Accordion icon="docker" title="Start with Docker Compose">
    Launch MetaMCP using Docker Compose:
    
    ```bash
    docker compose up -d
    ```
    
    This will start:
    - MetaMCP fullstack docker image
    - PostgreSQL database
    
    <Tip>
      The first startup may take a few minutes as Docker images are pulled and downloaded.
    </Tip>
  </Accordion>
</AccordionGroup>

## Step 2: Access MetaMCP

Once the containers are running:

1. **Open your browser** and go to `http://localhost:12008` (or your configured `APP_URL`)
2. **Create an account** or log in
3. **Explore the dashboard** - you'll see sections for MCP Servers, Namespaces, and Endpoints
4. **(Optional) Disable signup** You may only allow you and your team access MetaMCP, so once you setup the accounts, you can disable new user registration in Settings page.

## Step 3: Configure Your First MCP Server

<AccordionGroup>
  <Accordion icon="server" title="Step 3.1: Add a MCP Server">
    1. Navigate to **MCP Servers** in the sidebar (or you can quickly add one from **Explore & Search** page)
    2. Click **"Add Server"** button (top right)
    3. In the dialog that opens, fill out the server configuration:
    
    **Basic Information:**
    - **Name**: `hackernews-server` (must be URL-compatible: letters, numbers, underscores, hyphens only)
    - **Description**: `HackerNews MCP server for fetching stories and comments`
    - **Type**: Select `STDIO` from dropdown
    
    **Server Configuration:**
    - **Command**: `uvx`
    - **Arguments**: `mcp-hn` (space-separated arguments)
    - **Environment Variables**: Leave empty (format: `KEY=value`, one per line)
    
    **Ownership:**
    - Choose **"For myself (Private)"** or **"Everyone (Public)"**
    - Private servers are only accessible to you
    - Public servers are accessible to all users
    
    4. Click **"Create Server"**
    5. You should see a success message: "MCP Server Created"
    
    <Note>
      After creating the server, you can click on it to view details, test the connection, and see available tools.
    </Note>
  </Accordion>

  <Accordion icon="package" title="Step 3.2: Create a Namespace">
    **Why Namespaces?** Namespaces group multiple MCP servers together and provide a unified endpoint for external access.
    
    1. Go to **Namespaces** in the sidebar
    2. Click **"Create Namespace"** button (top right)
    3. Fill out the namespace form:
    
    **Basic Information:**
    - **Name**: `news-information` (descriptive name for your server group)
    - **Description**: `Namespace containing news and information retrieval tools`
    
    **Ownership:**
    - Choose **"For myself (Private)"** or **"Everyone (Public)"**
    
    **Select MCP Servers:**
    - You'll see a list of available MCP servers with checkboxes
    - Check the box next to your **"hackernews-server"**
    - You can select multiple servers for one namespace
    - Each server shows its type (STDIO, SSE, etc.) and description
    
    4. Click **"Create Namespace"**
    5. Success message: "Namespace Created"
    
    <Tip>
      You can add or remove servers from a namespace later by editing it.
    </Tip>
  </Accordion>


</AccordionGroup>

## Step 4: Manage Tools in Your Namespace

<AccordionGroup>
  <Accordion icon="wrench" title="Review and Disable Unused Tools">
    **Why Manage Tools?** Each MCP server may expose many tools, but you might only want to make certain tools available through your endpoint.
    
    1. Go to **Namespaces** in the sidebar
    2. Click on your **"news-information"** namespace to view details
    3. You'll see three main sections:
    
    **Connection Status:**
    - Check if the namespace can connect to its MCP servers
    - Green status means all servers are reachable
    - Click **"Connect"** if needed to establish connection
    
    **MCP Servers:**
    - View all servers assigned to this namespace
    - See server status (Active/Inactive/Error)
    - Monitor server health and configuration
    
    **Tools Management:**
    - See all tools available from your servers
    - Each tool shows:
      - **Tool name** (e.g., `get_top_stories`, `get_story`)
      - **Source server** (which server provides this tool)
      - **Description** and input schema
      - **Status** (enabled/disabled)
    
    4. **Disable unwanted tools:**
    - Uncheck tools you don't want to expose via the endpoint
    - For example, you might keep `get_top_stories` but disable `get_user_info`
    - This helps keep your endpoint focused and secure
    
    5. **Refresh Tools** if needed to get latest tools from servers
    
    <Note>
      Only enabled tools will be available when external applications use your endpoint.
    </Note>
  </Accordion>
</AccordionGroup>

## Step 5: Create an Endpoint

<AccordionGroup>
  <Accordion icon="link" title="Create Your Public Endpoint">
    **What are Endpoints?** Endpoints provide external access to your namespaces via HTTP APIs that other applications can consume.
    
    1. Navigate to **Endpoints** in the sidebar
    2. Click **"Create Endpoint"** button (top right)
    3. Configure your endpoint:
    
    **Basic Information:**
    - **Name**: `news-endpoint` (URL-compatible name - this becomes `/metamcp/news-endpoint`)
    - **Description (Optional)**: `Public endpoint for news and information tools`
    
    **Ownership:**
    - Choose **"For myself (Private)"** or **"Everyone (Public)"**
    
    **Namespace Selection:**
    - Click the **"Select a namespace"** dropdown
    - Choose your **"news-information"** namespace
    - You'll see the namespace name and description in the dropdown
    
    **API Key Authentication:**
    - **Enable API Key Authentication**: Toggle ON (recommended)
      - This requires API keys for endpoint access
    - **Use Query Parameter Authentication**: Toggle ON/OFF
      - When ON: Allows `?api_key=xxx` in URLs
      - When OFF: Only accepts API keys in `Authorization: Bearer xxx` headers
    
    **MCP Server Creation:**
    - **"Automatically create an MCP server for this endpoint"**: Check this box
    - This creates a Streamable HTTP MCP server configuration for inspection
    
    4. Click **"Create Endpoint"**
    5. Success message: "Endpoint Created"
    
    **Your endpoint will be available at:**
    - SSE: `http://localhost:12008/metamcp/news-endpoint/sse`
    - Streamable HTTP: `http://localhost:12008/metamcp/news-endpoint/mcp`
    - OpenAPI: `http://localhost:12008/metamcp/news-endpoint/api`
    - Schema: `http://localhost:12008/metamcp/news-endpoint/api/openapi.json`
  </Accordion>
</AccordionGroup>

## Step 6: Generate API Key

<AccordionGroup>
  <Accordion icon="key" title="Create API Key">
    1. Go to **API Keys** in the sidebar
    2. Click **"Generate Key"** button
    3. Fill out the API key form:
    
    **Key Information:**
    - **Description**: `My first MetaMCP API key for news endpoint`
    - **Scope**: 
      - **Private**: Only you can use this key
      - **Public**: All users can use this key
    
    4. Click **"Generate Key"**
    5. **Important**: Copy and save the key securely - it starts with `sk_mt_`
    6. This key will be used to authenticate requests to your endpoints
    
    <Warning>
      The API key is only shown once. Make sure to copy it immediately.
    </Warning>
  </Accordion>
</AccordionGroup>

## Step 7: Managing Your Configuration

<AccordionGroup>
  <Accordion icon="settings" title="Managing MCP Servers">
    **View Server Details:**
    - Click on any server in the MCP Servers list
    - See connection status, available tools, and configuration
    - Test server connection and inspect tools
    
    **Edit Servers:**
    - Use the actions menu (⋯) next to each server
    - Modify configuration, add environment variables
    - Update commands and arguments
    
    **Server States:**
    - **Active**: Server is running and available
    - **Inactive**: Server is configured but not running
    - **Error**: Server has connection issues
  </Accordion>

  <Accordion icon="layers" title="Managing Namespaces">
    **View Namespace Details:**
    - Click on any namespace to see its servers and tools
    - Monitor which servers are active in the namespace
    - View aggregated tools from all servers
    
    **Edit Namespaces:**
    - Add or remove servers from existing namespaces
    - Update name and description
    - Change ownership settings
    
    **Tool Management:**
    - See all tools available across servers in the namespace
    - Enable/disable specific tools
    - View tool schemas and documentation
  </Accordion>

  <Accordion icon="link" title="Managing Endpoints">
    **Endpoint URLs:**
    Each endpoint provides multiple access methods:
    - **SSE**: Server-Sent Events for real-time communication
    - **Streamable HTTP**: HTTP-based MCP communication
    - **OpenAPI**: REST API with OpenAPI documentation
    - **Schema**: OpenAPI JSON schema for integration
    
    **Copy URLs:**
    - Use the actions menu (⋯) to copy specific URLs
    - Copy URLs with or without embedded API keys
    - Use different formats for different integrations
    
    **Edit Endpoints:**
    - Change which namespace an endpoint maps to
    - Update authentication settings
    - Modify access permissions
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Add More Servers" icon="plus" href="/en/concepts/mcp-servers">
    Learn how to configure different types of MCP servers (STDIO, HTTP, etc.)
  </Card>
  
  <Card title="Configure Middleware" icon="filter" href="/en/concepts/middleware">
    Apply middleware to filter tools and transform requests/responses
  </Card>
  
  <Card title="Connect to Cursor" icon="mouse-pointer-2" href="/en/integrations/cursor">
    Configure Cursor IDE to use your MetaMCP endpoints
  </Card>
  
  <Card title="Connect to Claude Desktop" icon="monitor-dot" href="/en/integrations/claude-desktop">
    Set up Claude Desktop with MetaMCP using mcp-proxy
  </Card>
</CardGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion icon="warning" title="Common Issues">
    **CORS errors**: Ensure you're accessing MetaMCP from the URL specified in `APP_URL`.
    
    **Database connection**: Check that PostgreSQL container is running with `docker ps`.
    
    **Memory issues**: MetaMCP requires at least 2GB RAM for optimal performance.
    
    **Server connection failures**: Check MCP server logs in the server detail pages.
    
    **Authentication issues**: Verify API keys are active and correctly formatted.
  </Accordion>

  <Accordion icon="question" title="Need Help?">
    - Browse [GitHub Issues](https://github.com/metatool-ai/metamcp/issues)
    - Join our [Discord community](https://discord.gg/mNsyat7mFX)
  </Accordion>
</AccordionGroup>



================================================
FILE: docs/en/concepts/endpoints.mdx
================================================
---
title: "Endpoints"
description: "Create public endpoints that expose namespaces as accessible MCP servers"
---

A **MetaMCP Endpoint** is a public interface that exposes a namespace as an accessible MCP server. Endpoints handle authentication and provide URLs that MCP clients can connect to.

## What are Endpoints?

Endpoints serve as the bridge between your internal namespaces and external MCP clients:

- **Expose namespaces** as public MCP servers
- **Handle authentication** via API keys
- **Support multiple transports** (SSE, Streamable HTTP, OpenAPI)

<Card title="Example Endpoint URLs" icon="link">
```
https://your-metamcp.com/metamcp/my-endpoint/sse
https://your-metamcp.com/metamcp/my-endpoint/mcp
https://your-metamcp.com/metamcp/my-endpoint/api
https://your-metamcp.com/metamcp/my-endpoint/api/openapi.json
```
</Card>

## Endpoint Management

### Available Actions

From the endpoints dashboard, you can:

- **Edit** endpoint settings
- **Copy URLs** for different transport types
- **View** the associated namespace
- **Delete** endpoints

### URL Formats

Each endpoint provides multiple URL formats:

- **SSE**: `/metamcp/{name}/sse`
- **Streamable HTTP**: `/metamcp/{name}/mcp`
- **OpenAPI**: `/metamcp/{name}/api`
- **OpenAPI Schema**: `/metamcp/{name}/api/openapi.json`

## Next Steps

<CardGroup cols={2}>
  <Card title="API Keys" icon="key" href="/en/api-keys">
    Generate API keys for secure endpoint access
  </Card>
  
  <Card title="Namespaces" icon="package" href="/en/namespaces">
    Learn about organizing MCP servers into namespaces
  </Card>
  
  <Card title="Integration Guides" icon="plug" href="/en/integrations/cursor">
    Connect your endpoints to MCP clients
  </Card>
  
  <Card title="MCP Servers" icon="server" href="/en/mcp-servers">
    Manage the MCP servers within your namespaces
  </Card>
</CardGroup> 


================================================
FILE: docs/en/concepts/inspector.mdx
================================================
---
title: "Inspector"
description: "Debug and inspect MCP servers and MetaMCP endpoints with the built-in inspector"
---

The **MetaMCP Inspector** is a built-in tool that allows you to easily test and debug your managed MCP servers and MetaMCP endpoints. It offers functionality similar to the official MCP Inspector, providing a convenient way to validate your connections and server behavior.

<div align="center">
  <img src="/images/metamcp_screenshot.png" alt="MetaMCP Screenshot" style={{ width: "100%", maxWidth: "800px", margin: "2rem 0", borderRadius: "8px", boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)" }} />
</div>

## Next Steps

<CardGroup cols={2}>
  <Card title="MCP Servers" icon="server" href="/en/concepts/mcp-servers">
    Learn how to configure and debug MCP servers
  </Card>
  
  <Card title="Troubleshooting Guide" icon="wrench" href="/en/integrations/troubleshooting">
    Common issues and solutions for MetaMCP
  </Card>
  
  <Card title="Integration Testing" icon="plug" href="/en/integrations/cursor">
    Test your configurations with actual MCP clients
  </Card>
  
  <Card title="Performance Monitoring" icon="chart-line" href="/en/configuration/monitoring">
    Set up production monitoring and alerting
  </Card>
</CardGroup> 


================================================
FILE: docs/en/concepts/mcp-servers.mdx
================================================
---
title: "MCP Servers"
description: "Learn how to configure and manage MCP server instances in MetaMCP"
---

A **MCP Server** is a configuration that tells MetaMCP how to start and manage a Model Context Protocol server. These servers provide tools, resources, and prompts that can be aggregated and exposed through MetaMCP endpoints.

## What is a MCP Server?

MCP Servers are the building blocks of MetaMCP. Each server configuration defines:

- **How to start the server** (command, arguments, environment)
- **What type of server it is** (STDIO, SSE, Streamable HTTP)
- **Authentication requirements** (if any)
- **Resource dependencies** (Python packages, Node modules, etc.)

<Card title="Example Configuration" icon="code">
```json
{
  "name": "HackerNews",
  "type": "STDIO", 
  "command": "uvx",
  "args": ["mcp-hn"],
  "description": "Access HackerNews stories and comments"
}
```
</Card>

## Server Types

MetaMCP supports three types of MCP servers:

<AccordionGroup>
  <Accordion icon="terminal" title="STDIO Servers">
    **Most common type** - Communicates via standard input/output streams
    
    ```json
    {
      "type": "STDIO",
      "command": "uvx", 
      "args": ["mcp-server-package"],
      "env": {
        "API_KEY": "your-api-key"
      }
    }
    ```
    
    **Use cases:**
    - Python packages installed via `uvx`
    - Node.js packages via `npx`
    - Custom executable scripts
  </Accordion>

  <Accordion icon="globe" title="SSE Servers">
    **Server-Sent Events** - Communicates via SSE (Server-Sent Events)
    
    ```json
    {
      "type": "SSE",
      "url": "https://api.example.com/sse",
      "bearerToken": "your-bearer-token"
    }
    ```

    <Info>You can leave bearerToken as blank if the server uses OAuth.</Info>
  </Accordion>

  <Accordion icon="globe" title="Streamable HTTP Servers">
    **HTTP-based streaming** - Streamable HTTP is now the standard for remote MCP
    
    ```json
    {
      "type": "STREAMABLE_HTTP",
      "url": "https://api.example.com/mcp",
      "bearerToken": "your-bearer-token"
    }
    ```

    <Info>You can leave bearerToken as blank if the server uses OAuth.</Info>
  </Accordion>
</AccordionGroup>

## Configuration Options

### Basic Configuration

<CodeGroup>
```json Required Fields
{
  "name": "unique-server-name",
  "type": "STDIO|SSE|STREAMABLE_HTTP",
  "command": "command-to-run", // STDIO only
  "args": ["arg1", "arg2"],     // STDIO only
  "url": "https://...",         // SSE/STREAMABLE_HTTP only
}
```

```json Optional Fields
{
  "description": "Human-readable description",
  "env": {
    "KEY": "value"
  },
  "bearerToken": "auth-token"   // SSE/STREAMABLE_HTTP only
}
```
</CodeGroup>

### Environment Variables

Pass environment variables to STDIO servers:

```json
{
  "name": "TimeServer",
  "type": "STDIO",
  "command": "uvx",
  "args": ["mcp-server-time", "--local-timezone=America/New_York"],
  "env": {
    "TZ": "America/New_York"
  }
}
```

#### Environment Variable Interpolation

Use `${ENV_VAR}` syntax to reference environment variables at runtime:

```json
{
  "name": "ExampleServer",
  "type": "STDIO",
  "command": "uvx",
  "args": ["mcp-example"],
  "env": {
    "API_KEY": "${API_KEY}",
    "DEBUG": "true"
  }
}
```

**Benefits:**
- **Secure**: API keys and secrets aren't hardcoded in configs
- **Flexible**: Values resolved from container environment
- **Backward compatible**: Raw values still work as before

**How it works:**
- `${VAR_NAME}` gets replaced with `process.env.VAR_NAME` at runtime
- Missing variables log a warning but don't crash the server
- Secrets are automatically redacted in logs

### Authentication

For servers requiring authentication:

<CodeGroup>
```json STDIO with API Keys
{
  "env": {
    "API_KEY": "your-secret-key"
  }
}
```

```json Remote with Bearer Token
{
  "bearerToken": "your-bearer-token"
}
```
</CodeGroup>

## Managing MCP Servers

### Adding Servers

1. **Navigate** to MCP Servers in the MetaMCP dashboard
2. **Click** "Add Server" 
3. **Configure** the server details
4. **Test** the configuration
5. **Save** to make it available for namespaces

### Bulk Import/Export

MetaMCP supports bulk import and export of MCP server configurations for easy migration and backup.

#### Exporting Servers

Export all your configured MCP servers to a JSON file:

1. **Navigate** to MCP Servers in the dashboard
2. **Click** "Export JSON" button
3. **Choose** to either download the file or copy to clipboard

<Card title="Export Format" icon="code">
```json
{
  "mcpServers": {
    "HackerNews": {
      "type": "stdio",
      "command": "uvx",
      "args": ["mcp-hn"],
      "description": "Access HackerNews stories and comments"
    },
    "TimeServer": {
      "type": "stdio", 
      "command": "uvx",
      "args": ["mcp-server-time"],
      "env": {
        "TZ": "America/New_York"
      },
      "description": "Time and timezone utilities"
    },
    "RemoteAPI": {
      "type": "streamable_http",
      "url": "https://api.example.com/mcp",
      "bearerToken": "your-bearer-token",
      "description": "Remote MCP server via HTTP"
    }
  }
}
```
</Card>

#### Importing Servers

Import multiple MCP servers from a JSON configuration:

1. **Navigate** to MCP Servers in the dashboard
2. **Click** "Import JSON" button
3. **Paste** or type your JSON configuration
4. **Click** "Import" to add the servers

<CodeGroup>
```json STDIO Server Format
{
  "mcpServers": {
    "ServerName": {
      "type": "stdio",
      "command": "uvx",
      "args": ["package-name"],
      "env": {
        "API_KEY": "your-key"
      },
      "description": "Optional description"
    }
  }
}
```

```json SSE Server Format  
{
  "mcpServers": {
    "ServerName": {
      "type": "sse",
      "url": "https://api.example.com/sse",
      "bearerToken": "your-token",
      "description": "Optional description"
    }
  }
}
```

```json Streamable HTTP Format
{
  "mcpServers": {
    "ServerName": {
      "type": "streamable_http", 
      "url": "https://api.example.com/mcp",
      "bearerToken": "your-token",
      "description": "Optional description"
    }
  }
}
```
</CodeGroup>

<Note>
**Type Values (Case-Insensitive):**
- `"stdio"`, `"STDIO"`, `"std"` → STDIO
- `"sse"`, `"SSE"` → SSE  
- `"streamable_http"`, `"STREAMABLE_HTTP"`, `"streamablehttp"`, `"http"` → STREAMABLE_HTTP
</Note>

<Note>
**Import Behavior:**
- Servers with existing names will be **updated** with new configuration
- New servers will be **created**
- Invalid configurations will be **skipped** with error messages
- The import process shows success/failure counts
</Note>

<Tip>
Use bulk import/export for:
- **Environment migration** (dev → staging → production)
- **Team collaboration** (sharing server configurations)
- **Backup and restore** (configuration backups)
- **Quick setup** (deploying multiple servers at once)
</Tip>

### Idle Session Management

MetaMCP pre-allocates idle sessions for better performance:

<Card title="Cold Start Optimization" icon="zap">
- **Default**: 1 idle session per server
- **Configurable**: Adjust based on usage patterns
- **Auto-scaling**: Sessions created on demand
- **Cleanup**: Idle sessions recycled after timeout
</Card>

## Custom Dockerfile for Dependencies

If your MCP servers require additional dependencies beyond `uvx` or `npx`, you can customize the MetaMCP Dockerfile:

```dockerfile
FROM metamcp:latest

# Install Python dependencies
RUN pip install requests beautifulsoup4

# Install system packages
RUN apt-get update && apt-get install -y \
    curl \
    git \
    && rm -rf /var/lib/apt/lists/*

# Install Node.js packages globally
RUN npm install -g some-mcp-package
```

<Warning>
Custom dependencies increase the Docker image size and startup time. Consider using lightweight alternatives when possible.
</Warning>

## Troubleshooting

<AccordionGroup>
  <Accordion icon="triangle-alert" title="Server Won't Start">
    **Common causes:**
    - Missing dependencies (install via custom Dockerfile)
    - Incorrect command or arguments
    - Environment variables not set
    - Network connectivity issues (for SSE/Streamable HTTP)
    
    **Debug steps:**
    1. Check server logs in MetaMCP dashboard
    2. Test command manually in terminal
    3. Verify environment variables
    4. Check network connectivity
  </Accordion>

  <Accordion icon="clock" title="Slow Performance">
    **Optimization strategies:**
    - Increase idle session count for frequently used servers
    - Use local servers instead of remote when possible
    - Pre-install dependencies in custom Docker image
    - Configure appropriate timeout values
  </Accordion>

  <Accordion icon="shield" title="Authentication Issues">
    **Common problems:**
    - Expired API keys or bearer tokens
    - Incorrect environment variable names
    - Missing required headers
    - Rate limiting from external APIs
    
    **Solutions:**
    1. Refresh API keys/tokens
    2. Check server documentation for required auth
    3. Implement proper error handling
    4. Add retry logic with backoff
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Create Namespaces" icon="package" href="/en/concepts/namespaces">
    Group your MCP servers into organized namespaces
  </Card>
  
  <Card title="Set Up Endpoints" icon="link" href="/en/concepts/endpoints">
    Create public endpoints to access your servers
  </Card>
  
  <Card title="Add Middleware" icon="filter" href="/en/concepts/middleware">
    Transform and filter MCP requests and responses
  </Card>
  
  <Card title="Integration Guide" icon="plug" href="/en/integrations/cursor">
    Connect your configured servers to MCP clients
  </Card>
</CardGroup> 


================================================
FILE: docs/en/concepts/middleware-future.mdx
================================================
---
title: "Middleware"
description: "Transform MCP requests and responses with pluggable middleware"
---

**Middleware** in MetaMCP allows you to intercept and transform MCP requests and responses at the namespace level. This powerful feature enables you to add functionality like filtering, logging, validation, and security without modifying individual MCP servers.

## What is Middleware?

Middleware functions are executed in sequence for each MCP request, allowing you to:

- **Filter tools** to reduce context size and improve LLM performance
- **Log requests** for debugging and analytics
- **Validate inputs** to ensure data quality and security
- **Transform responses** to normalize data formats
- **Implement security** measures like rate limiting
- **Add observability** with metrics and tracing

<Card title="Middleware Flow" icon="flow">
```
MCP Client → Namespace → Middleware 1 → Middleware 2 → MCP Server
                     ←              ←              ←
```

Each middleware can modify the request before it reaches the server and the response before it returns to the client.
</Card>

## Built-in Middleware

MetaMCP provides several built-in middleware options:

<AccordionGroup>
  <Accordion icon="filter" title="Filter Inactive Tools">
    **Purpose**: Remove tools that aren't currently available or useful
    
    ```json
    {
      "type": "filter-inactive-tools",
      "config": {
        "checkHealth": true,
        "removeUnavailable": true,
        "maxToolsPerServer": 50,
        "excludePatterns": ["debug_*", "test_*"],
        "includePatterns": ["core_*"]
      }
    }
    ```
    
    **Configuration Options:**
    - `checkHealth`: Test tool availability before including
    - `removeUnavailable`: Filter out non-responsive tools
    - `maxToolsPerServer`: Limit tools per server to prevent context overflow
    - `excludePatterns`: Regex patterns for tools to exclude
    - `includePatterns`: Regex patterns for tools to include (takes precedence)
    
    **Benefits:**
    - Reduces LLM context size
    - Improves tool selection accuracy
    - Prevents errors from broken tools
    - Better performance for large tool sets
  </Accordion>

  <Accordion icon="chart-line" title="Request Logging">
    **Purpose**: Log all MCP requests and responses for debugging and analytics
    
    ```json
    {
      "type": "request-logging",
      "config": {
        "logLevel": "info",
        "includeHeaders": false,
        "includeBody": true,
        "sanitizeSecrets": true,
        "maxBodySize": 1024,
        "destination": "console"
      }
    }
    ```
    
    **Configuration Options:**
    - `logLevel`: `debug`, `info`, `warn`, `error`
    - `includeHeaders`: Log request/response headers
    - `includeBody`: Log request/response bodies
    - `sanitizeSecrets`: Remove sensitive data from logs
    - `maxBodySize`: Maximum body size to log (bytes)
    - `destination`: `console`, `file`, `database`
  </Accordion>

  <Accordion icon="shield" title="Rate Limiting">
    **Purpose**: Prevent abuse and manage resource usage
    
    ```json
    {
      "type": "rate-limiting",
      "config": {
        "requestsPerMinute": 60,
        "burstLimit": 10,
        "keyStrategy": "api-key",
        "skipPaths": ["/health", "/status"],
        "errorMessage": "Rate limit exceeded"
      }
    }
    ```
    
    **Configuration Options:**
    - `requestsPerMinute`: Sustained rate limit
    - `burstLimit`: Short-term burst allowance
    - `keyStrategy`: `api-key`, `ip-address`, `user-id`
    - `skipPaths`: Paths to exclude from rate limiting
    - `errorMessage`: Custom error message
  </Accordion>

  <Accordion icon="lock" title="Input Validation">
    **Purpose**: Validate and sanitize incoming requests
    
    ```json
    {
      "type": "input-validation",
      "config": {
        "maxInputLength": 10000,
        "allowedTools": ["specific_tool_1", "specific_tool_2"],
        "blockedPatterns": ["system\\(", "eval\\("],
        "sanitizeHtml": true,
        "requireAuth": true
      }
    }
    ```
    
    **Configuration Options:**
    - `maxInputLength`: Maximum input size in characters
    - `allowedTools`: Whitelist of allowed tools (optional)
    - `blockedPatterns`: Regex patterns to block
    - `sanitizeHtml`: Remove HTML tags from inputs
    - `requireAuth`: Enforce authentication for requests
  </Accordion>

  <Accordion icon="cache" title="Response Caching">
    **Purpose**: Cache responses to improve performance
    
    ```json
    {
      "type": "response-caching",
      "config": {
        "ttl": 300,
        "keyPattern": "{tool}:{hash}",
        "cacheableTools": ["search_*", "lookup_*"],
        "excludeErrors": true,
        "maxCacheSize": "100MB"
      }
    }
    ```
    
    **Configuration Options:**
    - `ttl`: Time to live in seconds
    - `keyPattern`: Cache key template
    - `cacheableTools`: Tools to cache (patterns supported)
    - `excludeErrors`: Don't cache error responses
    - `maxCacheSize`: Maximum cache size
  </Accordion>
</AccordionGroup>

## Custom Middleware

You can create custom middleware for specific use cases:

### Middleware Interface

```typescript
interface MiddlewareContext {
  request: MCPRequest;
  response?: MCPResponse;
  namespace: Namespace;
  server: MCPServer;
  metadata: Record<string, any>;
}

type Middleware = (
  context: MiddlewareContext,
  next: () => Promise<MCPResponse>
) => Promise<MCPResponse>;
```

### Example: Content Filter Middleware

```javascript
{
  "type": "custom",
  "name": "content-filter",
  "config": {
    "removeAds": true,
    "extractMainContent": true,
    "blockDomains": ["spam.com", "malware.site"],
    "maxContentLength": 50000
  }
}
```

### Example: Translation Middleware

```javascript
{
  "type": "custom", 
  "name": "auto-translate",
  "config": {
    "targetLanguage": "en",
    "translateResponses": true,
    "apiKey": "translation-api-key",
    "skipTools": ["code_*", "math_*"]
  }
}
```

## Middleware Configuration

### Basic Setup

Add middleware to a namespace configuration:

```json
{
  "namespace": "development-tools",
  "middleware": [
    {
      "type": "request-logging",
      "enabled": true,
      "config": {
        "logLevel": "info"
      }
    },
    {
      "type": "filter-inactive-tools", 
      "enabled": true,
      "config": {
        "maxToolsPerServer": 30
      }
    }
  ]
}
```

### Middleware Order

Middleware executes in the order specified:

```json
{
  "middleware": [
    {
      "type": "input-validation",
      "order": 1
    },
    {
      "type": "rate-limiting", 
      "order": 2
    },
    {
      "type": "request-logging",
      "order": 3
    },
    {
      "type": "response-caching",
      "order": 4
    }
  ]
}
```

### Conditional Middleware

Apply middleware based on conditions:

```json
{
  "type": "filter-inactive-tools",
  "conditions": {
    "tools": ["web_*", "search_*"],
    "servers": ["web-server"],
    "userRoles": ["developer", "admin"]
  },
  "config": {
    "maxToolsPerServer": 20
  }
}
```

## Middleware Examples

### Development Environment

Perfect for debugging and development:

```json
{
  "middleware": [
    {
      "type": "request-logging",
      "config": {
        "logLevel": "debug",
        "includeHeaders": true,
        "includeBody": true
      }
    },
    {
      "type": "input-validation",
      "config": {
        "maxInputLength": 50000,
        "sanitizeHtml": true
      }
    },
    {
      "type": "filter-inactive-tools",
      "config": {
        "checkHealth": true,
        "maxToolsPerServer": 100
      }
    }
  ]
}
```

### Production Environment

Optimized for performance and security:

```json
{
  "middleware": [
    {
      "type": "rate-limiting",
      "config": {
        "requestsPerMinute": 120,
        "burstLimit": 20
      }
    },
    {
      "type": "input-validation",
      "config": {
        "maxInputLength": 10000,
        "blockedPatterns": ["system\\(", "eval\\(", "__"],
        "requireAuth": true
      }
    },
    {
      "type": "response-caching",
      "config": {
        "ttl": 300,
        "cacheableTools": ["search_*", "lookup_*"]
      }
    },
    {
      "type": "filter-inactive-tools",
      "config": {
        "maxToolsPerServer": 50,
        "removeUnavailable": true
      }
    },
    {
      "type": "request-logging",
      "config": {
        "logLevel": "warn",
        "sanitizeSecrets": true
      }
    }
  ]
}
```

### Content Creation Workflow

Specialized for content and media processing:

```json
{
  "middleware": [
    {
      "type": "custom",
      "name": "content-filter",
      "config": {
        "removeAds": true,
        "extractMainContent": true,
        "maxContentLength": 100000
      }
    },
    {
      "type": "response-caching",
      "config": {
        "ttl": 1800,
        "cacheableTools": ["web_scraper", "image_search"]
      }
    },
    {
      "type": "filter-inactive-tools",
      "config": {
        "includePatterns": ["content_*", "image_*", "text_*"]
      }
    }
  ]
}
```

## Performance Considerations

### Middleware Impact

<Card title="Performance Tips" icon="zap">
- **Order matters**: Put fast middleware first
- **Cache aggressively**: Use caching for expensive operations
- **Filter early**: Remove unnecessary tools to reduce processing
- **Monitor performance**: Track middleware execution times
- **Async processing**: Use non-blocking operations when possible
</Card>

### Optimization Strategies

```json
{
  "middleware": [
    {
      "type": "filter-inactive-tools",
      "config": {
        "maxToolsPerServer": 25,
        "checkHealth": false
      }
    },
    {
      "type": "response-caching",
      "config": {
        "ttl": 600,
        "maxCacheSize": "50MB"
      }
    },
    {
      "type": "request-logging",
      "config": {
        "logLevel": "error",
        "includeBody": false
      }
    }
  ]
}
```

## Monitoring Middleware

### Performance Metrics

Track middleware performance:

- **Execution time** per middleware
- **Cache hit rates** for caching middleware
- **Filter effectiveness** for tool filtering
- **Error rates** by middleware type
- **Resource usage** and memory consumption

### Debug Information

```bash
# Enable middleware debugging
DEBUG=metamcp:middleware pnpm dev

# View middleware execution logs
GET /api/admin/middleware/logs?namespace=development-tools
```

## Troubleshooting

<AccordionGroup>
  <Accordion icon="warning" title="Middleware Errors">
    **Common causes:**
    - Invalid configuration parameters
    - Missing required dependencies
    - Conflicting middleware interactions
    - Resource limitations
    
    **Debug steps:**
    1. Check middleware configuration syntax
    2. Review error logs for specific issues
    3. Test with minimal middleware setup
    4. Verify resource availability
    5. Check middleware order and dependencies
  </Accordion>

  <Accordion icon="slow" title="Performance Issues">
    **Optimization strategies:**
    - Reduce middleware chain length
    - Optimize configuration parameters
    - Use caching middleware effectively
    - Monitor and profile middleware execution
    - Consider async processing for heavy operations
  </Accordion>

  <Accordion icon="bug" title="Unexpected Behavior">
    **Common problems:**
    - Middleware order affecting results
    - Configuration conflicts between middleware
    - Inconsistent error handling
    - Memory leaks in custom middleware
    
    **Solutions:**
    1. Review middleware execution order
    2. Check for configuration conflicts
    3. Implement proper error handling
    4. Monitor memory usage patterns
    5. Test middleware in isolation
  </Accordion>
</AccordionGroup>

## Best Practices

<Card title="Middleware Best Practices" icon="checklist">
- ✅ **Start simple**: Begin with basic middleware and add complexity gradually
- ✅ **Test thoroughly**: Validate middleware behavior with various inputs
- ✅ **Monitor performance**: Track execution times and resource usage
- ✅ **Handle errors gracefully**: Implement proper error handling and fallbacks
- ✅ **Document configuration**: Maintain clear documentation for custom middleware
- ✅ **Version middleware**: Use versioning for custom middleware changes
- ✅ **Security first**: Validate and sanitize all inputs in custom middleware
</Card>

## Next Steps

<CardGroup cols={2}>
  <Card title="Inspector" icon="magnifying-glass" href="/en/concepts/inspector">
    Learn about the MetaMCP inspector for debugging middleware
  </Card>
  
  <Card title="Namespace Configuration" icon="folder" href="/en/concepts/namespaces">
    Understand how to configure namespaces with middleware
  </Card>
  
  <Card title="Custom Development" icon="code" href="/en/development/contributing">
    Learn how to develop custom middleware
  </Card>
  
  <Card title="Performance Monitoring" icon="chart-line" href="/en/configuration/monitoring">
    Set up monitoring for your middleware stack
  </Card>
</CardGroup> 


================================================
FILE: docs/en/concepts/middleware.mdx
================================================
---
title: "Middleware"
description: "Transform MCP requests and responses with pluggable middleware"
---

**Middleware** in MetaMCP allows you to intercept and transform MCP requests and responses at the namespace level. This powerful feature enables you to add functionality like filtering, logging, validation, and security without modifying individual MCP servers.

## (Middleware is still under active development)


================================================
FILE: docs/en/concepts/namespaces.mdx
================================================
---
title: "Namespaces"
description: "Group MCP servers and manage tools with unified endpoints"
---

A **Namespace** in MetaMCP is a logical grouping of MCP servers that allows you to organize multiple servers into a single unified MCP endpoint.

## What are Namespaces?

Namespaces allow you to:

- **Group multiple MCP servers** into a unified collection
- **Create a single MCP endpoint** that aggregates tools from all servers
- **Enable/disable individual servers** within the namespace
- **Control tool visibility** by enabling/disabling specific tools
- **Support both private and public** namespace access

## How Namespaces Work

When you create a namespace:

1. **Select MCP servers** to include in the namespace
2. **Tools are automatically discovered** from all active servers
3. **Tools are prefixed** with server names (e.g., `ServerName__toolName`)
4. **Create public endpoints** to expose the namespace externally

## Creating a Namespace

1. **Navigate** to Namespaces in the MetaMCP dashboard
2. **Click** "Create Namespace"
3. **Configure** basic details:
   - **Name**: Unique identifier for your namespace
   - **Description**: Optional description of the namespace purpose
   - **Ownership**: Private (your use) or Public (organization-wide)
4. **Select MCP servers** to include in the namespace
5. **Save** the namespace

### Ownership Types

- **Private Namespace**: Only accessible by the creator
- **Public Namespace**: Accessible by entire organization

**Note**: Public namespaces can only contain public MCP servers.

## Managing Servers and Tools

### Server Management

- **View server status** in the namespace servers table
- **Enable/disable servers** individually using the status toggle
- **Add or remove servers** by editing the namespace
- **Monitor server health** and connectivity

### Tool Management

- **Automatic discovery**: Tools are discovered from all active servers
- **Tool prefixing**: Tools are prefixed with server names to avoid conflicts
- **Status control**: Enable/disable individual tools per namespace
- **Tool filtering**: Inactive tools are automatically filtered from listings

### Tool Naming Convention

Tools follow the pattern: `{ServerName}__{originalToolName}`

Example: A `search` tool from "WebSearch" server becomes `WebSearch__search`

## Public Access

To expose a namespace externally:

1. **Create an endpoint** that points to your namespace
2. **Configure authentication** (API key recommended)
3. **Share the endpoint URL** with external users

The endpoint provides:
- **MCP access**: Standard MCP protocol support
- **REST API**: HTTP endpoints for each tool
- **OpenAPI documentation**: Auto-generated API documentation

## Example

A development namespace containing filesystem and git servers:

```json
{
  "name": "development-tools",
  "description": "Essential development tools",
  "servers": [
    {
      "name": "filesystem",
      "status": "ACTIVE",
      "tools": ["read_file", "write_file", "list_directory"]
    },
    {
      "name": "git-helper", 
      "status": "ACTIVE",
      "tools": ["git_status", "git_commit", "git_diff"]
    }
  ]
}
```

Available tools through the namespace:
- `filesystem__read_file`
- `filesystem__write_file` 
- `filesystem__list_directory`
- `git-helper__git_status`
- `git-helper__git_commit`
- `git-helper__git_diff`

## Next Steps

<CardGroup cols={2}>
  <Card title="Create Endpoints" icon="link" href="/en/concepts/endpoints">
    Expose your namespace through public endpoints
  </Card>
  
  <Card title="MCP Servers" icon="server" href="/en/concepts/mcp-servers">
    Learn about configuring MCP servers
  </Card>
  
  <Card title="Integration Setup" icon="plug" href="/en/integrations/cursor">
    Connect your namespace to MCP clients
  </Card>
  
  <Card title="Inspector" icon="search-code" href="/en/concepts/inspector">
    Test and debug your namespace tools
  </Card>
</CardGroup> 


================================================
FILE: docs/en/deployment/custom-deployment.mdx
================================================
This guide walks you through deploying MetaMCP on a DigitalOcean VPS running Ubuntu from scratch, as an example.

## Prerequisites

- A DigitalOcean account
- A domain name pointing to your VPS
- Basic knowledge of Linux command line

## System Requirements

MetaMCP requires at least **2GB-4GB of memory** for optimal performance. The larger the instance, the better the performance due to MCP server pre-allocation and Docker operations.

**Recommended DigitalOcean Droplet:**
- **Basic/Regular**: 2GB RAM, 1 vCPU, 50GB SSD ($12/month)
- **Better Performance**: 4GB RAM, 2 vCPU, 80GB SSD ($24/month)

## Step 1: Create and Configure Your VPS

### 1.1 Create a Droplet

1. Log into your DigitalOcean account
2. Click "Create" → "Droplets"
3. Choose **Ubuntu 22.04 LTS** as the OS
4. Select a plan with at least 2GB RAM
5. Choose a datacenter region close to your users
6. Add your SSH key for secure access
7. Create the droplet

### 1.2 Initial Server Setup

Connect to your server via SSH:

```bash
ssh root@your_server_ip
```

Update the system:

```bash
apt update && apt upgrade -y
```

Install essential packages:

```bash
apt install -y curl wget git ufw nginx certbot python3-certbot-nginx
```

Configure firewall:

```bash
ufw allow OpenSSH
ufw allow 'Nginx Full'
ufw enable
```

Create a non-root user (optional but recommended):

```bash
adduser metamcp
usermod -aG sudo metamcp
# Switch to the new user
su - metamcp
```

## Step 2: Install Docker and Docker Compose

### 2.1 Install Docker

First, update your package index and install prerequisites:

```bash
sudo apt update
sudo apt install -y apt-transport-https ca-certificates curl gnupg lsb-release
```

Add Docker's official GPG key and repository:

```bash
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
```

Install Docker CE:

```bash
sudo apt update
sudo apt install -y docker-ce
```

Verify Docker is running:

```bash
sudo systemctl status docker
```

### 2.2 Install Docker Compose

Download and install Docker Compose:

```bash
sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
```

### 2.3 Configure Docker User (Optional)

To run Docker commands without `sudo`:

```bash
sudo usermod -aG docker $USER
```

Log out and back in for group changes to take effect, or run:

```bash
newgrp docker
```

## Step 3: Deploy MetaMCP

### 3.1 Clone the Repository

```bash
cd /opt
sudo git clone https://github.com/metatool-ai/metamcp.git
sudo chown -R $USER:$USER metamcp
cd metamcp
```

### 3.2 Configure Environment

```bash
cp example.env .env
```

Edit the `.env` file with your domain and settings:

```bash
nano .env
```

**⚠️ IMPORTANT SECURITY NOTE**: Because this is a production environment, make sure you modify `POSTGRES_PASSWORD` and `BETTER_AUTH_SECRET` from their default values. Also ensure you use HTTPS. A typical way to generate secure secrets is:

```bash
openssl rand -hex 32 | base64
```

Key configurations to update:

```env
# Your domain URL (MUST use HTTPS for production)
APP_URL=https://yourdomain.com

# Database - CHANGE THE PASSWORD from default!
DATABASE_URL=postgresql://postgres:YOUR_SECURE_PASSWORD@db:5432/metamcp
POSTGRES_PASSWORD=YOUR_SECURE_PASSWORD

# Generate secure secrets - DO NOT use the example values!
BETTER_AUTH_SECRET=your-super-secret-key-here
ENCRYPTION_KEY=your-32-character-encryption-key

# Optional: Configure OIDC if needed
# OIDC_CLIENT_ID=your-oidc-client-id
# OIDC_CLIENT_SECRET=your-oidc-client-secret
# OIDC_DISCOVERY_URL=https://your-provider.com/.well-known/openid-configuration
```

### 3.3 Update Docker Compose for Production

Edit `docker-compose.yml` to ensure proper volume naming:

```bash
nano docker-compose.yml
```

Update the volumes section to avoid conflicts:

```yaml
volumes:
  metamcp_postgres_data:
    driver: local
```

### 3.4 Start MetaMCP

```bash
# Pull images and start services
docker-compose up -d

# Check if services are running
docker-compose ps

# View logs if needed
docker-compose logs -f
```

## Step 4: Configure Nginx Reverse Proxy

### 4.1 Create Nginx Configuration

Create a new site configuration:

```bash
sudo nano /etc/nginx/sites-available/metamcp
```

Add the following configuration (replace `yourdomain.com` with your actual domain):

```nginx
server {
    listen 80;
    server_name yourdomain.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name yourdomain.com;

    # SSL configuration (will be managed by Certbot)
    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;

    location / {
        proxy_pass http://localhost:12008;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # SSE-specific optimizations for MCP connections
        proxy_buffering off;
        proxy_cache off;
        proxy_read_timeout 86400s;  # 24 hours for long-lived SSE connections
        proxy_send_timeout 86400s;
        
        # HTTP/1.1 with proper connection handling for SSE
        proxy_set_header Connection '';
        proxy_http_version 1.1;
        
        # Additional headers for better SSE support
        proxy_set_header Cache-Control 'no-cache';
        proxy_set_header X-Accel-Buffering 'no';
    }

    # Optional: Increase client max body size for file uploads
    client_max_body_size 100M;
}
```

### 4.2 Enable the Site

```bash
# Enable the site
sudo ln -s /etc/nginx/sites-available/metamcp /etc/nginx/sites-enabled/

# Remove default site
sudo rm /etc/nginx/sites-enabled/default

# Test nginx configuration
sudo nginx -t

# Start nginx
sudo systemctl enable nginx
sudo systemctl start nginx
```

## Step 5: SSL Certificate with Let's Encrypt

### 5.1 Obtain SSL Certificate

First, temporarily use HTTP only configuration for initial certificate:

```bash
# Create temporary HTTP-only config
sudo nano /etc/nginx/sites-available/metamcp-temp
```

Add this temporary configuration:

```nginx
server {
    listen 80;
    server_name yourdomain.com;

    location / {
        proxy_pass http://localhost:12008;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

Enable temporary config:

```bash
sudo ln -sf /etc/nginx/sites-available/metamcp-temp /etc/nginx/sites-enabled/metamcp
sudo nginx -t && sudo systemctl reload nginx
```

Obtain the certificate:

```bash
sudo certbot --nginx -d yourdomain.com
```

### 5.2 Restore Full Configuration

After obtaining the certificate, restore the full configuration:

```bash
sudo ln -sf /etc/nginx/sites-available/metamcp /etc/nginx/sites-enabled/metamcp
sudo nginx -t && sudo systemctl reload nginx
```

### 5.3 Set Up Auto-Renewal

```bash
# Test auto-renewal
sudo certbot renew --dry-run

# Add to crontab for automatic renewal
sudo crontab -e
```

Add this line to check for renewal twice daily:

```
0 12 * * * /usr/bin/certbot renew --quiet
```


================================================
FILE: docs/en/development/architecture.mdx
================================================
## Architecture Overview (WIP)

### Main
```mermaid
sequenceDiagram
    participant MCPClient as MCP Client (e.g., Claude Desktop)
    participant MetaMCP as MetaMCP Server
    participant MCPServers as Installed MCP Servers

    MCPClient ->> MetaMCP: Request list tools

    loop For each listed MCP Server
        MetaMCP ->> MCPServers: Request list_tools
        MCPServers ->> MetaMCP: Return list of tools
    end

    MetaMCP ->> MetaMCP: Aggregate tool lists & apply middleware
    MetaMCP ->> MCPClient: Return aggregated list of tools

    MCPClient ->> MetaMCP: Call tool
    MetaMCP ->> MCPServers: call_tool to target MCP Server
    MCPServers ->> MetaMCP: Return tool response
    MetaMCP ->> MCPClient: Return tool response
```

### Idle Session invalidation

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Backend
    participant McpServerPool
    participant MetaMcpServerPool
    participant McpServer

    User->>Frontend: Updates MCP server command/args
    Frontend->>Backend: PATCH /mcp-servers/{uuid}
    Backend->>Backend: Update server in database
    
    Note over Backend: New invalidation flow
    Backend->>McpServerPool: invalidateIdleSession(serverUuid, newParams)
    McpServerPool->>McpServerPool: Cleanup existing idle session
    McpServerPool->>McpServer: Terminate old connection
    McpServerPool->>McpServer: Create new connection with updated params
    McpServerPool->>McpServerPool: Store new idle session
    
    Backend->>Backend: Find affected namespaces
    Backend->>MetaMcpServerPool: invalidateIdleServers(namespaceUuids)
    MetaMcpServerPool->>MetaMcpServerPool: Cleanup namespace servers
    MetaMcpServerPool->>MetaMcpServerPool: Create new namespace servers
    
    Backend->>Frontend: Success response
    Frontend->>User: "Server updated successfully"
    
    Note over User,McpServer: Next connection will use updated parameters
```


================================================
FILE: docs/en/development/contributing.mdx
================================================
---
title: "Contributing to MetaMCP"
description: "Learn how to contribute to MetaMCP development and help improve the project"
---

We welcome contributions to MetaMCP! This comprehensive guide will help you get started with contributing to the project, whether you're fixing bugs, adding features, or improving documentation.

## Getting Started

### Prerequisites

Before contributing, ensure you have:

- **Node.js 18+** and **pnpm** installed
- **Docker** for running PostgreSQL and testing
- **Git** for version control
- **Basic understanding** of TypeScript, React, and MCP protocol

### Development Setup

<AccordionGroup>
  <Accordion icon="github" title="Fork and Clone">
    1. **Fork the repository** on GitHub
    2. **Clone your fork** locally:
       ```bash
       git clone https://github.com/YOUR_USERNAME/metamcp.git
       cd metamcp
       ```
    3. **Add upstream remote**:
       ```bash
       git remote add upstream https://github.com/metatool-ai/metamcp.git
       ```
  </Accordion>

  <Accordion icon="package" title="Install Dependencies">
    Install project dependencies using pnpm:
    
    ```bash
    pnpm install
    ```
    
    This will install dependencies for all workspaces in the monorepo.
  </Accordion>

  <Accordion icon="cog" title="Environment Setup">
    Set up your development environment:
    
    ```bash
    cp example.env .env
    ```
    
    Modify the `.env` file as needed for your development setup.
  </Accordion>

  <Accordion icon="database" title="Database Setup">
    Start PostgreSQL using Docker:
    
    ```bash
    docker compose up -d postgres
    # or start full stack
    docker compose up -d
    ```

    First time migration (edit `.env.local` first)
    ```bash
    cd apps/backend

    pnpm db:migrate:dev
    ```
  </Accordion>
</AccordionGroup>

## Development Workflow

### Creating a Feature Branch (naming not required)

<CodeGroup>
```bash Feature Branch
git checkout -b feature/your-feature-name
```

```bash Bug Fix Branch  
git checkout -b fix/issue-description
```

```bash Documentation Branch
git checkout -b docs/documentation-update
```
</CodeGroup>

### Making Changes

Follow these guidelines when making changes:

<Card title="Code Quality Standards" icon="code">
- **Follow TypeScript best practices**
- **Use ESLint and Prettier** for consistent formatting
- **Write descriptive commit messages**
- **Add JSDoc comments** for complex functions
- **Ensure type safety** throughout the codebase
- **Test your changes** manually
</Card>

### Testing Your Changes

<AccordionGroup>
  <Accordion icon="flask-conical" title="Local Testing">
    Run the development server and test your changes:
    
    ```bash
    pnpm dev
    ```
    
    This starts both frontend and backend in development mode.
  </Accordion>

  <Accordion icon="check" title="Linting and Formatting">
    Ensure code quality:
    
    ```bash
    # Run linting
    pnpm lint
    
    # Fix linting issues
    pnpm lint:fix
    ```
  </Accordion>

  <Accordion icon="docker" title="Docker Testing">
    Test with Docker to ensure production compatibility:
    
    ```bash
    docker compose build
    docker compose up
    ```
  </Accordion>
</AccordionGroup>

## Types of Contributions

### Bug Fixes

<AccordionGroup>
  <Accordion icon="bug" title="Reporting Bugs">
    **Before reporting a bug:**
    
    1. Check existing issues to avoid duplicates
    2. Try to reproduce the issue consistently
    3. Gather relevant information (OS, browser, MetaMCP version)
    4. Include steps to reproduce the problem
    
    **Bug report template:**
    ```markdown
    ## Bug Description
    Brief description of the issue
    
    ## Steps to Reproduce
    1. Step one
    2. Step two
    3. Expected vs actual behavior
    
    ## Environment
    - OS: [e.g., macOS 14.0]
    - Browser: [e.g., Chrome 120]
    - MetaMCP Version: [e.g., 1.0.0]
    
    ## Additional Context
    Screenshots, logs, or other relevant information
    ```
  </Accordion>

  <Accordion icon="wrench" title="Fixing Bugs">
    **When fixing bugs:**
    
    1. Create a branch: `fix/issue-number-description`
    2. Implement the fix
    3. Test manually to ensure the fix works
    4. Update documentation if necessary
  </Accordion>
</AccordionGroup>

### Feature Development

<AccordionGroup>
  <Accordion icon="lightbulb" title="Proposing Features">
    **Before implementing a new feature:**
    
    1. **Open an issue** to discuss the feature
    2. **Provide use cases** and justification
    3. **Consider impact** on existing functionality
    4. **Get feedback** from maintainers
    5. **Plan the implementation** approach
  </Accordion>

  <Accordion icon="code" title="Implementing Features">
    **Feature development process:**
    
    1. **Create feature branch** from main
    2. **Implement incrementally** with regular commits
    3. **Update documentation**
    4. **Test with real MCP servers**
    5. **Consider i18n impact** for UI changes
  </Accordion>
</AccordionGroup>

### Documentation

<AccordionGroup>
  <Accordion icon="book" title="Documentation Guidelines">
    **When updating documentation:**
    
    - Use clear, concise language
    - Include code examples where helpful
    - Add screenshots for UI changes
    - Update both README and docs site
    - Test all code examples
    - Consider multiple audiences (beginners, advanced users)
  </Accordion>

  <Accordion icon="book-type" title="Translation Contributions">
    **Adding new language support:**
    
    1. Create new locale directory: `public/locales/[locale]/`
    2. Copy English files as templates
    3. Translate content maintaining key structure
    4. Update i18n configuration
    5. Test the new locale thoroughly
    6. Submit PR with translation files
  </Accordion>
</AccordionGroup>

## Pull Request Process

### Before Submitting

<Card title="Pre-submission Checklist" icon="checklist">
- ✅ **Code follows project standards**
- ✅ **Fix liniting as much as possible (somewhat tolerant as we dev rapidly)** (`pnpm lint`)
- ✅ **No TypeScript errors**
- ✅ **Documentation updated** if needed
- ✅ **Changes tested manually**
- ✅ **Database migrations** included if needed
- ✅ **No sensitive information** in commits
</Card>

## Specialized Contributions

### OIDC Provider Setup

MetaMCP supports OpenID Connect for enterprise SSO. When working on OIDC features:

<AccordionGroup>
  <Accordion icon="shield" title="OIDC Configuration">
    **Required environment variables:**
    
    ```bash
    # Required
    OIDC_CLIENT_ID=your-oidc-client-id
    OIDC_CLIENT_SECRET=your-oidc-client-secret
    OIDC_DISCOVERY_URL=https://your-provider.com/.well-known/openid-configuration
    OIDC_AUTHORIZATION_URL=https://your-provider.com/auth/authorize
    
    # Optional
    OIDC_PROVIDER_ID=oidc
    OIDC_SCOPES=openid email profile
    OIDC_PKCE=true
    ```
  </Accordion>

  <Accordion icon="flask-conical" title="Testing OIDC">
    **For OIDC development:**
    
    1. Use a test provider (Auth0, Keycloak)
    2. Configure redirect URI: `${APP_URL}/api/auth/oauth2/callback/oidc`
    3. Test the authentication flow
    4. Verify user creation in database
    5. Enable debug logging for troubleshooting
  </Accordion>
</AccordionGroup>

### Database Changes

When making database schema changes:

<AccordionGroup>
  <Accordion icon="database" title="Schema Migrations">
    **Creating migrations:**
    
    ```bash
    # Generate migration after schema changes
    cd apps/backend
    pnpm db:generate
    
    # Apply migrations
    pnpm db:migrate:dev # which uses env.local for PG related env vars
    
    # Reset database (development only)
    pnpm db:reset
    ```
  </Accordion>

  <Accordion icon="table" title="Adding New Tables">
    **Database development workflow:**
    
    1. Update schema in `apps/backend/src/db/schema.ts`
    2. Create repository in `apps/backend/src/db/repositories/`
    3. Create serializer in `apps/backend/src/db/serializers/`
    4. Add tRPC procedures in `apps/backend/src/trpc/`
    5. Update frontend types in `packages/zod-types/`
    6. Generate and apply migrations
  </Accordion>
</AccordionGroup>

### Frontend Development

<AccordionGroup>
  <Accordion icon="component" title="UI Components">
    **Using shadcn/ui components:**
    
    ```bash
    # Add new components
    cd apps/frontend
    npx shadcn-ui@latest add [component-name]
    ```
    
    **Component guidelines:**
    - Follow existing design patterns
    - Ensure accessibility compliance
    - Add proper TypeScript types
    - Include loading and error states
  </Accordion>

  <Accordion icon="globe" title="Internationalization">
    **For UI changes:**
    
    1. Add English translations first
    2. Update other locales or mark for translation
    3. Use the `useTranslations()` hook
    4. Test with different languages
    5. Ensure text expansion doesn't break layout
  </Accordion>
</AccordionGroup>

## Community Guidelines

### Code of Conduct

We're committed to providing a welcoming and inclusive environment:

<Card title="Community Standards" icon="heart">
- **Be respectful** and inclusive in all interactions
- **Provide constructive feedback** and be open to receiving it
- **Focus on collaboration** and helping each other succeed
- **Respect different perspectives** and experience levels
- **Follow project guidelines** and maintain code quality
</Card>

### Communication

<AccordionGroup>
  <Accordion icon="discord" title="Discord Community">
    Join our Discord server for:
    
    - Development discussions
    - Getting help with contributions
    - Sharing ideas and feedback
    - Community announcements
    
    [Join MetaMCP Discord](https://discord.gg/mNsyat7mFX)
  </Accordion>

  <Accordion icon="github" title="GitHub Discussions">
    Use GitHub Issues and Discussions for:
    
    - Bug reports and feature requests
    - Technical discussions
    - Documentation feedback
    - Project roadmap discussions
  </Accordion>
</AccordionGroup>

## Getting Help

### Resources

<CardGroup cols={2}>
  <Card title="Discord Community" icon="discord" href="https://discord.gg/mNsyat7mFX">
    Get help from the community
  </Card>
  
  <Card title="GitHub Issues" icon="github" href="https://github.com/metatool-ai/metamcp/issues">
    Browse existing issues and discussions
  </Card>
</CardGroup>

## Recognition

We appreciate all contributions to MetaMCP! Contributors are recognized through:

- **GitHub contributors list** on the repository
- **Release notes** mentioning significant contributions

Thank you for helping make MetaMCP better for everyone! 🚀

## Next Steps

<CardGroup cols={1}>
  <Card title="Start Contributing" icon="rocket" href="https://github.com/metatool-ai/metamcp/issues">
    Browse open issues and start contributing
  </Card>
</CardGroup> 


================================================
FILE: docs/en/development/i18n.mdx
================================================
---
title: "Internationalization (i18n)"
description: "Add multi-language support to MetaMCP with Next.js locale routing and client-side translations"
---

MetaMCP uses **Next.js locale-based routing** and **client-side translations** to support multiple languages. This guide explains the i18n system and how to add new languages.

## Current Language Support

MetaMCP currently supports:

- **English (en)** - Default language
- **Chinese Simplified (zh)** - Full translation available

The author maintains both languages for translation accuracy, but contributions for additional languages are welcome.

## Project Structure

The internationalization system is organized as follows:

```bash
apps/frontend/
├── app/
│   └── [locale]/                  # Locale-based routing
│       ├── layout.tsx            # Locale layout
│       ├── (sidebar)/            # Sidebar layout group
│       └── ...
├── public/locales/
│   ├── en/                       # English translations
│   │   ├── common.json
│   │   ├── auth.json
│   │   ├── navigation.json
│   │   ├── mcp-servers.json
│   │   ├── namespaces.json
│   │   ├── endpoints.json
│   │   ├── api-keys.json
│   │   ├── settings.json
│   │   ├── search.json
│   │   ├── inspector.json
│   │   ├── logs.json
│   │   └── validation.json
│   └── zh/                       # Chinese translations
│       └── (same structure)
├── lib/
│   └── i18n.ts                  # Client-side i18n utilities
├── hooks/
│   ├── useLocale.ts             # Hook to get current locale
│   └── useTranslations.ts       # Hook for client-side translations
├── components/
│   └── language-switcher.tsx    # Language switching component
└── middleware.ts                # Locale detection and routing
```

## How It Works

### URL Structure

MetaMCP uses locale-based routing:

- **English (default)**: `/mcp-servers`, `/settings`, `/namespaces`
- **Chinese**: `/zh/mcp-servers`, `/zh/settings`, `/zh/namespaces`

### Middleware

The `middleware.ts` file handles:

- **Locale detection** from URL, cookies, and Accept-Language header
- **Automatic redirects** to appropriate locale
- **Authentication checks**

<CodeGroup>
```typescript middleware.ts
import { NextRequest } from 'next/server';
import { getLocale, getLocalizedPath } from '@/lib/i18n';

export function middleware(request: NextRequest) {
  // Detect locale from URL, cookie, or headers
  const locale = getLocale(request);
  
  // Redirect if needed
  if (!request.nextUrl.pathname.startsWith(`/${locale}`)) {
    const localizedPath = getLocalizedPath(request.nextUrl.pathname, locale);
    return Response.redirect(new URL(localizedPath, request.url));
  }
}
```

```typescript lib/i18n.ts
export function getLocalizedPath(path: string, locale: string): string {
  if (locale === 'en') {
    return path; // Default locale doesn't need prefix
  }
  return `/${locale}${path}`;
}

export function detectLocale(request: NextRequest): string {
  // Check URL first, then cookies, then Accept-Language
  // Return detected locale or fallback to 'en'
}
```
</CodeGroup>

## Using Translations

### Client Components

For client-side components, use the `useTranslations` hook:

<CodeGroup>
```tsx Basic Usage
"use client";

import { useTranslations } from "@/hooks/useTranslations";

function ClientComponent() {
  const { t, isLoading, locale } = useTranslations();
  
  if (isLoading) return <div>Loading...</div>;
  
  return (
    <div>
      <h1>{t('common:title')}</h1>
      <button>{t('auth:signIn')}</button>
    </div>
  );
}
```

```tsx With Parameters
// In translation file: "welcome": "Welcome, {{name}}!"
<span>{t('common:welcome', { name: 'John' })}</span>

// With count: "itemCount": "{{count}} items found"
<span>{t('search:itemCount', { count: 42 })}</span>
```

```tsx Conditional Translations
const { t, locale } = useTranslations();

return (
  <div>
    <p>{t('common:currentLanguage')}: {locale}</p>
    {locale === 'zh' && (
      <p>{t('common:chineseSpecificMessage')}</p>
    )}
  </div>
);
```
</CodeGroup>

### Translation Key Format

Use colon-separated namespaces for organization:

```json
{
  "server": {
    "create": "Create Server",
    "edit": "Edit Server",
    "delete": "Delete Server",
    "status": {
      "online": "Online",
      "offline": "Offline",
      "error": "Error"
    },
    "validation": {
      "nameRequired": "Server name is required",
      "commandRequired": "Command is required"
    }
  }
}
```

**Usage**: `t('mcp-servers:server.create')`, `t('mcp-servers:server.status.online')`

## Translation File Organization

### Namespace Structure

Each translation namespace serves a specific purpose:

<AccordionGroup>
  <Accordion icon="globe" title="common.json">
    **Shared UI elements and general terms**
    
    ```json
    {
      "actions": {
        "save": "Save",
        "cancel": "Cancel",
        "delete": "Delete",
        "edit": "Edit",
        "create": "Create",
        "search": "Search"
      },
      "status": {
        "loading": "Loading...",
        "error": "Error",
        "success": "Success"
      },
      "form": {
        "required": "This field is required",
        "invalid": "Invalid input"
      }
    }
    ```
  </Accordion>

  <Accordion icon="lock" title="auth.json">
    **Authentication-related text**
    
    ```json
    {
      "signIn": "Sign In",
      "signOut": "Sign Out",
      "signUp": "Sign Up",
      "email": "Email",
      "password": "Password",
      "forgotPassword": "Forgot Password?",
      "createAccount": "Create Account",
      "loginWithOIDC": "Login with OIDC"
    }
    ```
  </Accordion>

  <Accordion icon="navigation" title="navigation.json">
    **Menu items and navigation text**
    
    ```json
    {
      "dashboard": "Dashboard",
      "mcpServers": "MCP Servers",
      "namespaces": "Namespaces",
      "endpoints": "Endpoints",
      "apiKeys": "API Keys",
      "settings": "Settings",
      "inspector": "MCP Inspector",
      "logs": "Live Logs"
    }
    ```
  </Accordion>

  <Accordion icon="server" title="mcp-servers.json">
    **MCP server-specific translations**
    
    ```json
    {
      "server": {
        "create": "Create Server",
        "edit": "Edit Server",
        "name": "Server Name",
        "type": "Server Type",
        "command": "Command",
        "args": "Arguments",
        "env": "Environment Variables"
      },
      "types": {
        "stdio": "STDIO",
        "http": "HTTP",
        "websocket": "WebSocket"
      }
    }
    ```
  </Accordion>
</AccordionGroup>

### Best Practices for Translation Keys

<Card title="Translation Key Guidelines" icon="key">
- **Use descriptive, hierarchical keys**: `server.validation.nameRequired`
- **Use camelCase for consistency**: `signIn`, `mcpServers`
- **Group related translations**: All server-related terms under `server`
- **Keep context clear**: `auth:signIn` vs `form:signIn` if different
- **Use interpolation for dynamic content**: `"welcome": "Welcome, {{name}}!"`
</Card>

## Adding New Languages

### Step 1: Create Translation Files

1. **Create language directory** in `public/locales/`:
   ```bash
   mkdir -p public/locales/es  # For Spanish
   ```

2. **Copy English files** as templates:
   ```bash
   cp -r public/locales/en/* public/locales/es/
   ```

3. **Translate the content** in each JSON file:
   ```json
   // public/locales/es/common.json
   {
     "actions": {
       "save": "Guardar",
       "cancel": "Cancelar",
       "delete": "Eliminar",
       "edit": "Editar",
       "create": "Crear"
     }
   }
   ```

### Step 2: Update Configuration

Add the new locale to your i18n configuration:

<CodeGroup>
```typescript lib/i18n.ts
export const SUPPORTED_LOCALES = ['en', 'zh', 'es'] as const;
export type Locale = typeof SUPPORTED_LOCALES[number];

export const LOCALE_NAMES: Record<Locale, string> = {
  en: 'English',
  zh: '中文',
  es: 'Español'
};
```

```typescript middleware.ts
import { SUPPORTED_LOCALES } from '@/lib/i18n';

export function middleware(request: NextRequest) {
  // Update locale detection to include new language
  const supportedLocales = SUPPORTED_LOCALES;
  // ... rest of middleware logic
}
```
</CodeGroup>

### Step 3: Update Language Switcher

The language switcher will automatically include new languages:

```tsx
// components/language-switcher.tsx
import { LOCALE_NAMES, SUPPORTED_LOCALES } from '@/lib/i18n';

export function LanguageSwitcher() {
  return (
    <select>
      {SUPPORTED_LOCALES.map(locale => (
        <option key={locale} value={locale}>
          {LOCALE_NAMES[locale]}
        </option>
      ))}
    </select>
  );
}
```

### Step 4: Test the Implementation

1. **Add test content** in the new language
2. **Navigate to** `/{locale}/` URLs (e.g., `/es/mcp-servers`)
3. **Verify translations** appear correctly
4. **Test language switching** functionality
5. **Check fallbacks** work for missing translations

## Translation Workflow

### For New Features

When adding new features to MetaMCP:

1. **Add English translations first** in appropriate namespace
2. **Use descriptive keys** that make sense in context
3. **Test with English** to ensure keys work correctly
4. **Add other languages** (or mark for translation)
5. **Test all languages** before deployment

### For Contributors

<AccordionGroup>
  <Accordion icon="translate" title="Translation Contributors">
    **To contribute translations:**
    
    1. Fork the repository
    2. Create new language files or update existing ones
    3. Follow the existing key structure
    4. Test your translations locally
    5. Submit a Pull Request with your changes
    
    **Tips:**
    - Keep translations concise but clear
    - Maintain consistent terminology
    - Consider cultural context, not just literal translation
    - Test with longer text to ensure UI still works
  </Accordion>

  <Accordion icon="robot" title="AI-Assisted Translation">
    **Using AI tools like Cursor/Claude:**
    
    ```prompt
    Translate this English JSON file to Spanish, maintaining the same structure and keys:
    
    {
      "server": {
        "create": "Create Server",
        "edit": "Edit Server"
      }
    }
    
    Keep technical terms like "MCP" and "API" unchanged.
    ```
  </Accordion>
</AccordionGroup>

## Troubleshooting

### Common Issues

<AccordionGroup>
  <Accordion icon="warning" title="Missing Translations">
    **When translations don't appear:**
    
    1. Check the translation key exists in the JSON file
    2. Verify the namespace is correct (`common:save` vs `auth:save`)
    3. Ensure the locale file exists and is valid JSON
    4. Check browser console for missing key warnings
    5. Verify the component is using `useTranslations` correctly
  </Accordion>

  <Accordion icon="bug" title="Hydration Errors">
    **Server/client translation mismatches:**
    
    1. Ensure consistent locale detection between server and client
    2. Use the `isLoading` state from `useTranslations`
    3. Avoid rendering translations during SSR if locale might change
    4. Test with JavaScript disabled to check SSR behavior
  </Accordion>

  <Accordion icon="globe" title="Locale Routing Issues">
    **URL routing problems:**
    
    1. Check middleware configuration for new locales
    2. Verify `getLocalizedPath` function handles new languages
    3. Test direct navigation to localized URLs
    4. Ensure fallback behavior works correctly
  </Accordion>
</AccordionGroup>

### Debugging Tools

<CodeGroup>
```bash Development Debugging
# Check for missing translation keys
grep -r "t('" apps/frontend/app --include="*.tsx" | \
  grep -v "useTranslations"

# Validate JSON files
for file in public/locales/*/*.json; do
  echo "Checking $file"
  cat "$file" | jq . > /dev/null
done
```

```typescript Debug Component
"use client";

import { useTranslations } from "@/hooks/useTranslations";

export function TranslationDebugger() {
  const { t, locale, isLoading } = useTranslations();
  
  return (
    <div className="debug-panel">
      <p>Current locale: {locale}</p>
      <p>Is loading: {isLoading.toString()}</p>
      <p>Test translation: {t('common:save')}</p>
    </div>
  );
}
```
</CodeGroup>

## Future Enhancements

### Planned Features

- **RTL language support** for Arabic, Hebrew
- **Date/time localization** with proper formatting
- **Number formatting** based on locale
- **Currency formatting** for pricing features
- **Pluralization rules** for complex language requirements

### Contributing Guidelines

<Card title="i18n Contributing Guidelines" icon="checklist">
- 📝 **Add English first**: Always start with English translations
- 🔍 **Test thoroughly**: Verify all locales work correctly
- 📊 **Use consistent terminology**: Maintain glossary for technical terms
- 🌍 **Consider context**: Adapt to cultural differences, not just language
- 📱 **Test UI impact**: Ensure longer translations don't break layout
- 🤝 **Collaborate**: Work with native speakers when possible
</Card>

## Next Steps

<CardGroup cols={2}>
  <Card title="Contributing Guide" icon="handshake" href="/en/development/contributing">
    Learn how to contribute to MetaMCP development
  </Card>
  
  <Card title="Frontend Development" icon="code" href="/en/development">
    Understand the frontend architecture and development setup
  </Card>
  
  <Card title="Component Development" icon="component" href="/en/development#frontend-development">
    Learn about UI component development with i18n
  </Card>
  
  <Card title="Testing Guide" icon="test" href="/en/development#testing">
    Test your internationalization changes
  </Card>
</CardGroup> 


================================================
FILE: docs/en/integrations/claude-desktop.mdx
================================================
---
title: "Claude Desktop Integration"
description: "Configure Claude Desktop to connect to MetaMCP endpoints using mcp-proxy"
---

**Claude Desktop** integration allows you to access MetaMCP tools directly through Claude's interface. Since Claude Desktop only supports stdio servers, you'll need a local proxy to connect to MetaMCP's remote endpoints.

## Prerequisites

Before starting, ensure you have:

- **Claude Desktop** installed and running
- **MetaMCP** running locally or deployed
- **Active endpoint** configured in MetaMCP
- **API key** generated (if authentication is enabled)

## Basic Configuration

### Using mcp-proxy (Recommended)

Since MetaMCP endpoints are remote only (SSE, Streamable HTTP), Claude Desktop needs a local proxy to connect. Based on testing, `mcp-proxy` is the recommended solution for API key authentication.

<CodeGroup>
```json Streamable HTTP (Recommended)
{
  "mcpServers": {
    "MetaMCP": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "--transport",
        "streamablehttp",
        "http://localhost:12008/metamcp/your-endpoint-name/mcp"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_your_api_key_here"
      }
    }
  }
}
```

```json SSE (Alternative)
{
  "mcpServers": {
    "MetaMCP": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "http://localhost:12008/metamcp/your-endpoint-name/sse"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_your_api_key_here"
      }
    }
  }
}
```

```json Multiple Endpoints
{
  "mcpServers": {
    "MetaMCP-Dev": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "--transport",
        "streamablehttp",
        "http://localhost:12008/metamcp/dev-tools/mcp"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_dev_key"
      }
    },
    "MetaMCP-Research": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "http://localhost:12008/metamcp/research-tools/sse"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_research_key"
      }
    }
  }
}
```
</CodeGroup>

## Configuration File Location

Edit Claude Desktop's configuration file at:

- **macOS**: `~/Library/Application Support/Claude/claude_desktop_config.json`
- **Windows**: `%APPDATA%\Claude\claude_desktop_config.json`
- **Linux**: `~/.config/claude/claude_desktop_config.json`

## Authentication Methods

<AccordionGroup>
  <Accordion icon="key" title="API Key Authentication">
    **Most common method** using environment variable:
    
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "command": "uvx",
          "args": [
            "mcp-proxy",
            "--transport",
            "streamablehttp",
            "http://localhost:12008/metamcp/your-endpoint-name/mcp"
          ],
          "env": {
            "API_ACCESS_TOKEN": "sk_mt_your_key_here"
          }
        }
      }
    }
    ```
  </Accordion>

  <Accordion icon="shield-minus" title="No Authentication">
    **For public endpoints** without authentication:
    
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "command": "uvx",
          "args": [
            "mcp-proxy",
            "http://localhost:12008/metamcp/public-tools/sse"
          ]
        }
      }
    }
    ```
  </Accordion>
</AccordionGroup>

## Remote/Production Setup

For remote MetaMCP instances, simply replace the localhost URL:

```json
{
  "mcpServers": {
    "MetaMCP-Production": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "--transport",
        "streamablehttp",
        "https://your-metamcp-domain.com/metamcp/your-endpoint-name/mcp"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_production_key"
      }
    }
  }
}
```

## Important Notes

- **Replace** `your-endpoint-name` with your actual endpoint name
- **Replace** `sk_mt_your_api_key_here` with your MetaMCP API key
- **mcp-proxy** handles the protocol conversion between stdio and HTTP/SSE
- **Environment variables** are the secure way to pass API keys
- For detailed troubleshooting, see [issue #76](https://github.com/metatool-ai/metamcp/issues/76) 


================================================
FILE: docs/en/integrations/cursor.mdx
================================================
---
title: "Cursor Integration"
description: "Configure Cursor IDE to use MetaMCP endpoints via mcp.json"
---

**Cursor** is a popular AI-powered code editor that supports MCP (Model Context Protocol) integration. This guide shows you how to connect Cursor to your MetaMCP endpoints for enhanced coding capabilities.

Also refer to Cursor's doc on MCP https://docs.cursor.com/context/mcp

## Prerequisites

Before starting, ensure you have:

- **Cursor IDE** installed and running
- **MetaMCP** running locally or deployed
- **Active endpoint** configured in MetaMCP
- **API key** generated (if authentication is enabled)

## Basic Configuration

### Simple mcp.json Setup

Create or edit your `mcp.json` file in Cursor's configuration directory:

<CodeGroup>
```json Basic Configuration
{
  "mcpServers": {
    "MetaMCP": {
      "url": "http://localhost:12008/metamcp/your-endpoint-name/mcp"
    }
  }
}
```

```json With Authentication
{
  "mcpServers": {
    "MetaMCP": {
      "url": "http://localhost:12008/metamcp/your-endpoint-name/mcp",
      "headers": {
        "Authorization": "Bearer sk_mt_your_api_key_here"
      }
    }
  }
}
```

```json Multiple Endpoints
{
  "mcpServers": {
    "MetaMCP-Dev": {
      "url": "http://localhost:12008/metamcp/dev-tools/mcp",
      "headers": {
        "Authorization": "Bearer sk_mt_dev_key"
      }
    },
    "MetaMCP-Research": {
      "url": "http://localhost:12008/metamcp/research-tools/mcp",
      "headers": {
        "Authorization": "Bearer sk_mt_research_key"
      }
    }
  }
}
```
</CodeGroup>

## Configuration Options

### Transport Types

MetaMCP supports different transport protocols. **Streamable HTTP is recommended** for Cursor:

<AccordionGroup>
  <Accordion title="Streamable HTTP (Recommended)">
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "url": "http://localhost:12008/metamcp/your-endpoint-name/mcp"
        }
      }
    }
    ```
  </Accordion>

  <Accordion title="SSE (Alternative)">
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "url": "http://localhost:12008/metamcp/your-endpoint-name/sse"
        }
      }
    }
    ```
  </Accordion>
</AccordionGroup>

### Authentication Methods

<AccordionGroup>
  <Accordion icon="key" title="API Key Authentication">
    **Most common method** using Authorization header:
    
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "url": "http://localhost:12008/metamcp/your-endpoint-name/mcp",
          "headers": {
            "Authorization": "Bearer sk_mt_your_key_here"
          }
        }
      }
    }
    ```
  </Accordion>

  <Accordion icon="shield-minus" title="No Authentication">
    **For public endpoints** without authentication:
    
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "url": "http://localhost:12008/metamcp/public-tools/sse"
        }
      }
    }
    ```
  </Accordion>
</AccordionGroup>


================================================
FILE: docs/en/integrations/general-stdio-with-api-key.mdx
================================================
---
title: "General Stdio Integration using `mcp-proxy` with API Key"
description: "Configure any stdio-based MCP client to connect to MetaMCP endpoints using mcp-proxy"
---

**General Stdio Integration** allows any MCP client that supports stdio servers to connect to MetaMCP's remote endpoints. Since MetaMCP endpoints are remote-only (SSE, Streamable HTTP), you'll need a local proxy to bridge the connection.

## Prerequisites

Before starting, ensure you have:

- **MCP client** that supports stdio servers (Claude Desktop, Cursor, etc.)
- **MetaMCP** running locally or deployed
- **Active endpoint** configured in MetaMCP
- **API key** generated (if authentication is enabled)
- **mcp-proxy** installed (`uvx mcp-proxy`)

## Basic Configuration

### Using mcp-proxy (Required)

Since MetaMCP endpoints are remote only, you need `mcp-proxy` to convert between stdio and HTTP/SSE protocols.

<CodeGroup>
```json Streamable HTTP (Recommended)
{
  "mcpServers": {
    "MetaMCP": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "--transport",
        "streamablehttp",
        "http://localhost:12008/metamcp/your-endpoint-name/mcp"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_your_api_key_here"
      }
    }
  }
}
```

```json SSE (Alternative)
{
  "mcpServers": {
    "MetaMCP": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "http://localhost:12008/metamcp/your-endpoint-name/sse"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_your_api_key_here"
      }
    }
  }
}
```

```json Multiple Endpoints
{
  "mcpServers": {
    "MetaMCP-Dev": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "--transport",
        "streamablehttp",
        "http://localhost:12008/metamcp/dev-tools/mcp"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_dev_key"
      }
    },
    "MetaMCP-Research": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "http://localhost:12008/metamcp/research-tools/sse"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_research_key"
      }
    }
  }
}
```
</CodeGroup>

## Authentication Methods

<AccordionGroup>
  <Accordion icon="key" title="API Key Authentication">
    **Most common method** using environment variable:
    
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "command": "uvx",
          "args": [
            "mcp-proxy",
            "--transport",
            "streamablehttp",
            "http://localhost:12008/metamcp/your-endpoint-name/mcp"
          ],
          "env": {
            "API_ACCESS_TOKEN": "sk_mt_your_key_here"
          }
        }
      }
    }
    ```
  </Accordion>

  <Accordion icon="shield-minus" title="No Authentication">
    **For public endpoints** without authentication:
    
    ```json
    {
      "mcpServers": {
        "MetaMCP": {
          "command": "uvx",
          "args": [
            "mcp-proxy",
            "http://localhost:12008/metamcp/your-endpoint-name/sse"
          ]
        }
      }
    }
    ```
  </Accordion>
</AccordionGroup>

## Troubleshooting

### Common Issues

1. **Connection refused**: Ensure MetaMCP is running and accessible
2. **Authentication failed**: Verify API key is correct and has proper permissions
3. **mcp-proxy not found**: Install with `pip install mcp-proxy` or `uvx mcp-proxy`

### Debug Mode

Enable debug logging for mcp-proxy:

```json
{
  "mcpServers": {
    "MetaMCP": {
      "command": "uvx",
      "args": [
        "mcp-proxy",
        "--transport",
        "streamablehttp",
        "--debug",
        "http://localhost:12008/metamcp/your-endpoint-name/mcp"
      ],
      "env": {
        "API_ACCESS_TOKEN": "sk_mt_your_api_key_here"
      }
    }
  }
}
```

## Important Notes

- **Replace** `your-endpoint-name` with your actual endpoint name
- **Replace** `sk_mt_your_api_key_here` with your MetaMCP API key
- **mcp-proxy** handles the protocol conversion between stdio and Streamable HTTP/SSE
- **Environment variables** are the secure way to pass API keys

<CardGroup cols={2}>
  <Card title="General Stdio Integration using `mcp-remote` with OAuth` with API Key" icon="globe" href="/en/integrations/general-stdio-with-oauth">
    Configure any stdio-based MCP client to connect to MetaMCP endpoints using mcp-remote with OAuth
  </Card>

  <Card title="MCP OAuth Troubleshooting" icon="lock" href="/en/troubleshooting/oauth-troubleshooting">
    Troubleshoot common OAuth-related issues
  </Card>
  
  <Card title="Connect to Cursor" icon="mouse-pointer-2" href="/en/integrations/cursor">
    Configure Cursor IDE to use your MetaMCP endpoints
  </Card>
  
  <Card title="Connect to Claude Desktop" icon="monitor-dot" href="/en/integrations/claude-desktop">
    Set up Claude Desktop with MetaMCP using mcp-proxy
  </Card>
</CardGroup>


================================================
FILE: docs/en/integrations/general-stdio-with-oauth.mdx
================================================
---
title: "General Stdio Integration using `mcp-remote` with OAuth"
description: "Configure any stdio-based MCP client to connect to MetaMCP endpoints using mcp-remote with OAuth authentication"
---

**General Stdio Integration with OAuth** allows any MCP client that supports stdio servers to connect to MetaMCP's remote endpoints using OAuth authentication. Since MetaMCP endpoints are remote-only (SSE, Streamable HTTP), you'll need a local proxy to bridge the connection.

## Prerequisites

Before starting, ensure you have:

- **MCP client** that supports stdio servers (Claude Desktop, Cursor, etc.)
- **MetaMCP** running locally or deployed with OAuth enabled
- **Active endpoint** configured in MetaMCP
- **OAuth application** registered in MetaMCP
- **mcp-remote** available via npx (`npx -y mcp-remote`)

## Basic Configuration

### Using mcp-remote (Required)

Since MetaMCP endpoints are remote only, you need `mcp-remote` to convert between stdio and HTTP/SSE protocols with OAuth authentication.

<CodeGroup>
```json Basic OAuth Configuration
{
  "mcpServers": {
    "MetaMCP": {
      "command": "npx",
      "args": [
        "-y",
        "mcp-remote",
        "http://localhost:12008/metamcp/your-endpoint-name/mcp"
      ]
    }
  }
}
```

```json Multiple Endpoints
{
  "mcpServers": {
    "MetaMCP-Dev": {
      "command": "npx",
      "args": [
        "-y",
        "mcp-remote",
        "http://localhost:12008/metamcp/dev-tools/mcp"
      ]
    },
    "MetaMCP-Research": {
      "command": "npx",
      "args": [
        "-y",
        "mcp-remote",
        "http://localhost:12008/metamcp/research-tools/mcp"
      ]
    }
  }
}
```
</CodeGroup>

## OAuth Flow

When you first connect, `mcp-remote` will:

1. **Open your browser** to the OAuth authorization URL
2. **Prompt you to authorize** the application
3. **Redirect back** to the local callback server
4. **Store the tokens** locally for future use
5. **Establish the MCP connection** with authenticated access

### Token Management

- **Tokens are stored locally** by mcp-remote
- **Refresh tokens** are automatically used when access tokens expire
- **Clear tokens** by deleting the mcp-remote cache directory if needed

## Important Notes

- **Use** `http://localhost:12008/metamcp/your-endpoint-name/mcp` for OAuth authentication
- **Replace** `your-endpoint-name` with your actual endpoint name for public endpoints
- **mcp-remote** handles the protocol conversion between stdio and HTTP/SSE
- **OAuth flow** requires browser interaction on first connection
- **No manual OAuth setup** required - MetaMCP handles it automatically

<CardGroup cols={2}>
  <Card title="MCP OAuth Troubleshooting" icon="lock" href="/en/troubleshooting/oauth-troubleshooting">
    Troubleshoot common OAuth-related issues
  </Card>
  
  <Card title="General Stdio Integration using `mcp-proxy` with API Key" icon="globe" href="/en/integrations/general-stdio-with-api-key">
    Configure any stdio-based MCP client to connect to MetaMCP endpoints using mcp-proxy
  </Card>
  
  <Card title="Connect to Cursor" icon="mouse-pointer-2" href="/en/integrations/cursor">
    Configure Cursor IDE to use your MetaMCP endpoints
  </Card>
  
  <Card title="Connect to Claude Desktop" icon="monitor-dot" href="/en/integrations/claude-desktop">
    Set up Claude Desktop with MetaMCP using mcp-proxy
  </Card>
</CardGroup>


================================================
FILE: docs/en/integrations/open-web-ui.mdx
================================================
---
title: "Open WebUI Integration"
description: "Use MetaMCP to manage tools for Open WebUI"
---

## Prerequisites

Before starting, ensure you have:
- Docker and Docker Compose installed
- Open WebUI running (locally or deployed)
- MetaMCP deployed with a properly configured `APP_URL` (default to `http://localhost:12008`)

## Step 1: Deploy MetaMCP with Proper Configuration

<AccordionGroup>
  <Accordion icon="github" title="Clone and Setup MetaMCP">
    If you haven't already, clone MetaMCP and set it up:
    
    ```bash
    git clone https://github.com/metatool-ai/metamcp.git
    cd metamcp
    cp example.env .env
    ```
  </Accordion>

  <Accordion icon="settings" title="Configure APP_URL for Open WebUI Access">
    **Critical**: Configure your `APP_URL` properly in the `.env` file for Open WebUI integration:
    
    ```bash
    # For local Open WebUI accessing local MetaMCP
    APP_URL=http://localhost:12008
    
    # For deployed Open WebUI accessing deployed MetaMCP
    APP_URL=https://your-metamcp-domain.com
    
    # For local Open WebUI accessing deployed MetaMCP
    APP_URL=https://your-metamcp-domain.com
    ```
    
    <Warning>
      Open WebUI must be able to reach your MetaMCP instance at the configured `APP_URL`. Ensure firewall rules and network configuration allow this access.
    </Warning>
    
    Also configure other production settings:
    ```bash
    POSTGRES_PASSWORD=your_secure_password
    BETTER_AUTH_SECRET=your_auth_secret  # Generate with: openssl rand -hex 32 | base64
    ```
  </Accordion>

  <Accordion icon="docker" title="Start MetaMCP">
    Launch MetaMCP using Docker Compose:
    
    ```bash
    docker compose up -d
    ```
    
    Verify it's running by visiting your configured `APP_URL`.
  </Accordion>
</AccordionGroup>

## Step 2: Configure MetaMCP for Open WebUI

<AccordionGroup>
  <Accordion icon="user" title="Create MetaMCP Account">
    1. Open your browser and go to your `APP_URL` (e.g., `http://localhost:12008`)
    2. **Create an account** or log in
    3. **(Recommended)** Disable new user registration in **Settings** for security
  </Accordion>

  <Accordion icon="server" title="Add MCP Servers">
    Add the MCP servers you want to expose to Open WebUI:
    
    1. Navigate to **MCP Servers** in the sidebar
    2. Click **"Add Server"** button
    3. Configure your server (example with filesystem server):
    
    **Basic Information:**
    - **Name**: `hacker-news-server`
    - **Description**: `Hacker News integration for fetching stories and comments`
    - **Type**: `STDIO`
    
    **Server Configuration:**
    - **Command**: `uvx`
    - **Arguments**: `mcp-hn`
    - **Environment Variables**: (if needed)
    
    **Ownership:**
    - Choose **"Everyone (Public)"** for Open WebUI access
    
    4. Click **"Create Server"**
    
    <Tip>
      Repeat this process for all MCP servers you want to make available to Open WebUI.
    </Tip>
  </Accordion>

  <Accordion icon="package" title="Create a Namespace">
    Group your MCP servers into a namespace for Open WebUI:
    
    1. Go to **Namespaces** in the sidebar
    2. Click **"Create Namespace"**
    3. Configure the namespace:
    
    **Basic Information:**
    - **Name**: `openwebui-tools`
    - **Description**: `Aggregated tools for Open WebUI integration`
    
    **Ownership:**
    - Choose **"Everyone (Public)"**
    
    **Select MCP Servers:**
    - Check all servers you want to include
    - These will be aggregated into one endpoint
    
    4. Click **"Create Namespace"**
  </Accordion>

  <Accordion icon="wrench" title="Manage Tools (Optional)">
    Fine-tune which tools are available:
    
    1. Click on your **"openwebui-tools"** namespace
    2. Review the **Tools Management** section
    3. Disable any tools you don't want Open WebUI to access
    4. This helps keep the tool set focused and secure
  </Accordion>
</AccordionGroup>

## Step 3: Create OpenAPI Endpoint

<AccordionGroup>
  <Accordion icon="link" title="Create Public Endpoint">
    Create an endpoint that Open WebUI can consume:
    
    1. Navigate to **Endpoints** in the sidebar
    2. Click **"Create Endpoint"**
    3. Configure the endpoint:
    
    **Basic Information:**
    - **Name**: `openwebui-api`
    - **Description**: `OpenAPI endpoint for Open WebUI integration`
    
    **Ownership:**
    - Choose **"Everyone (Public)"**
    
    **Namespace Selection:**
    - Select your **"openwebui-tools"** namespace
    
    **API Key Authentication:**
    - **Enable API Key Authentication**: Toggle ON
    - **Use Query Parameter Authentication**: Toggle OFF (Open WebUI supports Bearer tokens)
    
    **MCP Server Creation:**
    - Check **"Automatically create an MCP server for this endpoint"**
    
    4. Click **"Create Endpoint"**
    
    **Your OpenAPI endpoint will be available at:**
    - OpenAPI UI: `{APP_URL}/metamcp/openwebui-api/api`
    - OpenAPI Schema: `{APP_URL}/metamcp/openwebui-api/api/openapi.json`
  </Accordion>
</AccordionGroup>

## Step 4: Generate API Key

<Tip>In the last step, if you select **"Automatically create an MCP server for this endpoint"** option, then at least one API key will be automatically generated for you. Feel free to use it instead of creating a new one.</Tip>
<AccordionGroup>
  <Accordion icon="key" title="Create API Key for Open WebUI">
    1. Go to **API Keys** in the sidebar
    2. Click **"Generate Key"**
    3. Configure the API key:
    
    **Key Information:**
    - **Description**: `Open WebUI Integration Key`
    - **Scope**: **Public** (so Open WebUI can use it)
    
    4. Click **"Generate Key"**
    5. **Important**: Copy the generated key (starts with `sk_mt_`)
    
    <Warning>
      Save this key securely - it's only shown once and will be needed for Open WebUI configuration.
    </Warning>
  </Accordion>
</AccordionGroup>

## Step 5: Configure Open WebUI

<AccordionGroup>
  <Accordion title="Step 5.1: Open Web UI">
    Open your Open Web UI page. Find settings.
    <img src="/images/open-web-ui/1.png" alt="OpenWebUI Screenshot 1" style={{ width: "100%", maxWidth: "800px", margin: "2rem 0", borderRadius: "8px", boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)" }} />
  </Accordion>
  <Accordion title="Step 5.2: Settings > Tools">
    In Settings pop up. Go to "Tools".
    <img src="/images/open-web-ui/2.png" alt="OpenWebUI Screenshot 2" style={{ width: "100%", maxWidth: "800px", margin: "2rem 0", borderRadius: "8px", boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)" }} />
  </Accordion>
  <Accordion title="Step 5.3: Settings > Tools > Add connection ">
    Under **"Manage Tool Servers"** on top right corner click on the **"+"** button to add a connection.
    <br /> 
    For **URL > Base URL** enter `{APP_URL}/metamcp/openwebui-api/api`. For example if `APP_URL` is `http://localhost:12008` then enter `http://localhost:12008/metamcp/openwebui-api/api`.
    <br /> 
    For **URL > openapi.json Path** enter `{APP_URL}/metamcp/openwebui-api/api/openapi.json`. For example if `APP_URL` is `http://localhost:12008` then enter `http://localhost:12008/metamcp/openwebui-api/api/openapi.json`.
    <br /> 
    Put the **"API Key"** generated in previous steps to **"Auth Bearer"** field.
    <br /> 
    Use the "refresh" button to test connection.
    <img src="/images/open-web-ui/3.png" alt="OpenWebUI Screenshot 3" style={{ width: "100%", maxWidth: "800px", margin: "2rem 0", borderRadius: "8px", boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)" }} />
  </Accordion>
  <Accordion title="Step 5.4: Back to chat and verify the listed tools">
    Close any pop ups. In home page click new chat. Then inspect the available tools.
    <img src="/images/open-web-ui/4.png" alt="OpenWebUI Screenshot 4" style={{ width: "100%", maxWidth: "800px", margin: "2rem 0", borderRadius: "8px", boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)" }} />
    <img src="/images/open-web-ui/5.png" alt="OpenWebUI Screenshot 5" style={{ width: "100%", maxWidth: "800px", margin: "2rem 0", borderRadius: "8px", boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)" }} />
  </Accordion>
  <Accordion title="Step 5.5: Chat with tool calling">
    In new chat, a query of "show top hacker news" would look like:
    <img src="/images/open-web-ui/6.png" alt="OpenWebUI Screenshot 5" style={{ width: "100%", maxWidth: "800px", margin: "2rem 0", borderRadius: "8px", boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)" }} />
  </Accordion>
</AccordionGroup>

<Tip>Then in new chats, with a model that supports tool calling, should automatically try to call tools if necessary.</Tip>
## Troubleshooting

<AccordionGroup>
  <Accordion icon="warning" title="Common Issues">
    **Connection Errors:**
    - Verify `APP_URL` is accessible from Open WebUI
    - Check firewall and network configuration
    - Ensure API key is correctly configured. Turn off Auth to test if it works first.
    - With Auth off, you can manually visit e.g., `http://localhost:12008/metamcp/openwebui-api/api/openapi.json` to verify the `openapi.json`.
    
    **Authentication Issues:**
    - Verify API key format (should start with `sk_mt_`)
    - Ensure Bearer token authentication is properly configured in Open WebUI
    - Verify Authorization header format: `Bearer {your_api_key}`
    
    **Tool Execution Failures:**
    - Check MCP server status in MetaMCP dashboard
    - Review tool permissions in namespace settings
    - Monitor logs for specific error messages
    
    **CORS Errors:**
    - Ensure Open WebUI domain is allowed
    - Check MetaMCP CORS configuration
    - Verify APP_URL matches access URL
  </Accordion>

  <Accordion icon="question" title="Need Help?">
    - Check [MetaMCP GitHub Issues](https://github.com/metatool-ai/metamcp/issues)
    - Join our [Discord community](https://discord.gg/mNsyat7mFX)
    - Review Open WebUI documentation if necessary
  </Accordion>
</AccordionGroup>


================================================
FILE: docs/en/integrations/troubleshooting-future.mdx
================================================
# Integration Troubleshooting

Common issues and solutions when integrating MetaMCP with various tools and platforms.

## General Troubleshooting

### Connection Issues

#### "Connection Refused" or "Cannot Connect"

**Symptoms**: Client cannot connect to MetaMCP server

**Solutions**:

1. **Check server status**:
```bash
# Test basic connectivity
curl -I https://your-domain.com/api/health

# Check if server is running locally
curl -I http://localhost:8000/api/health
```

2. **Verify network configuration**:
```bash
# Check if port is open
telnet your-domain.com 443
nc -zv your-domain.com 443

# For local development
telnet localhost 8000
```

3. **Check firewall settings**:
```bash
# Linux (ufw)
sudo ufw status
sudo ufw allow 8000

# macOS
sudo pfctl -sr | grep 8000

# Windows
netsh advfirewall firewall show rule name=all | findstr 8000
```

#### SSL/TLS Certificate Issues

**Symptoms**: "Certificate verification failed" or "SSL handshake error"

**Solutions**:

1. **Check certificate validity**:
```bash
# Check certificate
openssl s_client -connect your-domain.com:443 -servername your-domain.com

# Check certificate expiry
curl -vI https://your-domain.com 2>&1 | grep -E "(expire|valid)"
```

2. **For self-signed certificates**:
```bash
# Skip certificate verification (development only)
curl -k https://your-domain.com/api/health

# Add certificate to trust store
# macOS
sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain cert.pem

# Linux
sudo cp cert.pem /usr/local/share/ca-certificates/metamcp.crt
sudo update-ca-certificates
```

### Authentication Issues

#### "Unauthorized" (401) Errors

**Symptoms**: API returns 401 status code

**Solutions**:

1. **Verify API key format**:
```bash
# Check if API key starts with correct prefix
echo "mcp_1234567890abcdef" | grep "^mcp_"

# Test API key
curl -H "Authorization: Bearer mcp_1234567890abcdef" \
  https://your-domain.com/api/health
```

2. **Check API key expiration**:
```bash
# Get API key details
curl -H "Authorization: Bearer your-session-token" \
  https://your-domain.com/api/api-keys/key-uuid
```

3. **Verify header format**:
```bash
# Correct formats
curl -H "Authorization: Bearer mcp_key" https://domain.com/api
curl -H "X-API-Key: mcp_key" https://domain.com/api

# Common mistakes
curl -H "Authorization: mcp_key" https://domain.com/api  # Missing "Bearer"
curl -H "API-Key: mcp_key" https://domain.com/api       # Wrong header name
```

#### "Forbidden" (403) Errors

**Symptoms**: Authentication succeeds but access is denied

**Solutions**:

1. **Check permissions**:
```bash
# List API key permissions
curl -H "Authorization: Bearer mcp_key" \
  https://your-domain.com/api/api-keys/permissions

# Test specific permission
curl -H "Authorization: Bearer mcp_key" \
  https://your-domain.com/api/mcp-servers  # Requires mcp-servers:read
```

2. **Verify IP restrictions**:
```bash
# Check your external IP
curl ifconfig.me

# Test from allowed IP
curl --interface allowed-ip -H "Authorization: Bearer mcp_key" \
  https://your-domain.com/api/health
```

3. **Check resource scoping**:
```bash
# Access scoped namespace
curl -H "Authorization: Bearer mcp_key" \
  https://your-domain.com/api/namespaces/allowed-namespace-uuid

# This might fail if not in scope
curl -H "Authorization: Bearer mcp_key" \
  https://your-domain.com/api/namespaces/restricted-namespace-uuid
```

## Platform-Specific Issues

### Claude Desktop

#### Tools Not Appearing

**Symptoms**: MetaMCP tools don't show up in Claude Desktop

**Solutions**:

1. **Check configuration file location**:
```bash
# macOS
ls -la "~/Library/Application Support/Claude/claude_desktop_config.json"

# Windows
dir "%APPDATA%\Claude\claude_desktop_config.json"

# Linux
ls -la ~/.config/claude/claude_desktop_config.json
```

2. **Validate JSON syntax**:
```bash
# Use jq to validate JSON
cat claude_desktop_config.json | jq .

# Or use online validator
python -m json.tool claude_desktop_config.json
```

3. **Check MCP server status**:
```bash
# Test the exact endpoint used in config
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/mcp-proxy/tools
```

4. **Enable debug logging**:
```json
{
  "mcpServers": {
    "metamcp": {
      "command": "npx",
      "args": [
        "@modelcontextprotocol/server-metamcp",
        "--endpoint", "https://your-domain.com/api/mcp-proxy",
        "--api-key", "your-api-key",
        "--debug"
      ]
    }
  }
}
```

#### Tool Execution Errors

**Symptoms**: Tools appear but fail when executed

**Solutions**:

1. **Check tool permissions**:
```bash
# List available tools
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/tools

# Test tool execution directly
curl -X POST \
  -H "Authorization: Bearer your-api-key" \
  -H "Content-Type: application/json" \
  -d '{"name": "tool_name", "arguments": {}}' \
  https://your-domain.com/api/namespaces/uuid/tools/execute
```

2. **Verify tool arguments**:
```bash
# Get tool schema
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/tools/tool_name

# Check required parameters
jq '.inputSchema.required' tool_schema.json
```

3. **Check namespace status**:
```bash
# Verify namespace is active
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/namespaces/uuid

# Check MCP servers in namespace
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/namespaces/uuid/mcp-servers
```

### Cursor Integration

#### Extension Not Loading

**Symptoms**: MetaMCP extension fails to load in Cursor

**Solutions**:

1. **Check extension installation**:
```bash
# List installed extensions
code --list-extensions | grep metamcp

# Install if missing
code --install-extension metamcp-extension
```

2. **Verify configuration**:
```json
// .vscode/settings.json
{
  "metamcp.endpoint": "https://your-domain.com",
  "metamcp.apiKey": "your-api-key",
  "metamcp.namespace": "your-namespace-uuid"
}
```

3. **Check extension logs**:
   - Open Cursor Developer Tools (Cmd+Shift+I / Ctrl+Shift+I)
   - Go to Console tab
   - Look for MetaMCP-related errors

#### Tool Suggestions Not Working

**Symptoms**: Code completion doesn't include MetaMCP tools

**Solutions**:

1. **Refresh tool cache**:
   - Command Palette → "MetaMCP: Refresh Tools"
   - Or restart Cursor

2. **Check tool visibility**:
```bash
# Verify tools are accessible
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/namespaces/uuid/tools
```

3. **Update extension settings**:
```json
{
  "metamcp.enableAutoCompletion": true,
  "metamcp.suggestionDelay": 300,
  "metamcp.maxSuggestions": 10
}
```

### API Integration

#### Rate Limiting Issues

**Symptoms**: "Too Many Requests" (429) errors

**Solutions**:

1. **Check current rate limits**:
```bash
# Get rate limit info from headers
curl -I -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/tools

# Look for headers:
# X-RateLimit-Limit: 1000
# X-RateLimit-Remaining: 999
# X-RateLimit-Reset: 1640995200
```

2. **Implement exponential backoff**:
```python
import time
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

def create_session_with_retries():
    session = requests.Session()
    retry_strategy = Retry(
        total=3,
        backoff_factor=1,
        status_forcelist=[429, 500, 502, 503, 504],
    )
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    return session

# Usage
session = create_session_with_retries()
response = session.get(
    "https://your-domain.com/api/tools",
    headers={"Authorization": "Bearer your-api-key"}
)
```

3. **Request higher limits**:
```bash
# Contact support for higher limits
curl -X POST https://your-domain.com/api/support/rate-limit-increase \
  -H "Authorization: Bearer your-api-key" \
  -H "Content-Type: application/json" \
  -d '{
    "reason": "High-volume integration",
    "current_limit": 1000,
    "requested_limit": 10000
  }'
```

#### Webhook Failures

**Symptoms**: Webhooks not being delivered

**Solutions**:

1. **Check webhook endpoint**:
```bash
# Test if your endpoint is reachable
curl -X POST https://your-webhook-endpoint.com/webhook \
  -H "Content-Type: application/json" \
  -d '{"test": true}'
```

2. **Verify webhook configuration**:
```bash
# List configured webhooks
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/webhooks

# Test webhook delivery
curl -X POST \
  -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/webhooks/webhook-id/test
```

3. **Check webhook logs**:
```bash
# Get delivery attempts
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/webhooks/webhook-id/deliveries

# Get specific delivery details
curl -H "Authorization: Bearer your-api-key" \
  https://your-domain.com/api/webhooks/deliveries/delivery-id
```

## Network and Infrastructure

### Proxy Configuration

#### Corporate Proxy Issues

**Symptoms**: Connections fail behind corporate firewall

**Solutions**:

1. **Configure proxy settings**:
```bash
# Environment variables
export HTTP_PROXY=http://proxy.company.com:8080
export HTTPS_PROXY=http://proxy.company.com:8080
export NO_PROXY=localhost,127.0.0.1,.company.com

# Test connectivity through proxy
curl --proxy http://proxy.company.com:8080 \
  https://your-domain.com/api/health
```

2. **Proxy authentication**:
```bash
# With credentials
export HTTP_PROXY=http://username:password@proxy.company.com:8080

# Or use .netrc file
echo "machine proxy.company.com login username password" >> ~/.netrc
chmod 600 ~/.netrc
```

3. **Certificate issues with proxy**:
```bash
# Use corporate certificate bundle
export REQUESTS_CA_BUNDLE=/path/to/corporate-ca-bundle.crt
export SSL_CERT_FILE=/path/to/corporate-ca-bundle.crt
```

### DNS Issues

#### "Name Resolution Failed"

**Symptoms**: Cannot resolve MetaMCP domain

**Solutions**:

1. **Check DNS resolution**:
```bash
# Test DNS lookup
nslookup your-domain.com
dig your-domain.com

# Try different DNS servers
nslookup your-domain.com 8.8.8.8
dig @1.1.1.1 your-domain.com
```

2. **Use IP address temporarily**:
```bash
# Find IP address
host your-domain.com

# Use IP directly (not recommended for production)
curl -H "Host: your-domain.com" https://192.168.1.100/api/health
```

3. **Update hosts file**:
```bash
# Add entry to hosts file
echo "192.168.1.100 your-domain.com" | sudo tee -a /etc/hosts

# Windows
echo 192.168.1.100 your-domain.com >> C:\Windows\System32\drivers\etc\hosts
```

## Performance Issues

### Slow Response Times

**Symptoms**: API calls take longer than expected

**Solutions**:

1. **Check server health**:
```bash
# Get detailed health info
curl https://your-domain.com/api/health/detailed

# Check response time
time curl https://your-domain.com/api/health
```

2. **Optimize queries**:
```bash
# Use pagination
curl "https://your-domain.com/api/tools?limit=50&offset=0"

# Filter results
curl "https://your-domain.com/api/tools?name=filesystem*"

# Request only needed fields
curl "https://your-domain.com/api/tools?fields=name,description"
```

3. **Enable compression**:
```bash
# Request compressed responses
curl -H "Accept-Encoding: gzip" \
  https://your-domain.com/api/tools
```

### Memory Issues

#### "Out of Memory" Errors

**Symptoms**: Applications crash with memory errors

**Solutions**:

1. **Monitor memory usage**:
```bash
# Check system memory
free -h
top
htop

# Monitor specific process
ps aux | grep metamcp
```

2. **Optimize client configuration**:
```json
{
  "metamcp": {
    "maxConcurrentRequests": 5,
    "cacheSize": "100MB",
    "requestTimeout": 30000
  }
}
```

3. **Use streaming for large responses**:
```bash
# Stream large datasets
curl -N -H "Accept: application/x-ndjson" \
  https://your-domain.com/api/logs/stream
```

## Debugging Tools

### Enable Debug Logging

```bash
# Environment variables
export DEBUG=metamcp:*
export LOG_LEVEL=debug

# Application-specific
export METAMCP_DEBUG=true
export METAMCP_LOG_LEVEL=trace
```

### Network Analysis

```bash
# Capture network traffic
sudo tcpdump -i any -w metamcp.pcap host your-domain.com

# Analyze with Wireshark
wireshark metamcp.pcap

# HTTP-specific analysis
mitmproxy --mode reverse:https://your-domain.com
```

### Health Check Script

Create a comprehensive health check:

```bash
#!/bin/bash
# health-check.sh

DOMAIN="your-domain.com"
API_KEY="your-api-key"

echo "=== MetaMCP Health Check ==="

# Basic connectivity
echo "1. Testing basic connectivity..."
if curl -s -f "https://$DOMAIN/api/health" > /dev/null; then
    echo "✓ Server is reachable"
else
    echo "✗ Server is not reachable"
    exit 1
fi

# Authentication
echo "2. Testing authentication..."
if curl -s -f -H "Authorization: Bearer $API_KEY" \
   "https://$DOMAIN/api/api-keys/permissions" > /dev/null; then
    echo "✓ Authentication successful"
else
    echo "✗ Authentication failed"
    exit 1
fi

# API endpoints
echo "3. Testing API endpoints..."
endpoints=("namespaces" "mcp-servers" "tools")
for endpoint in "${endpoints[@]}"; do
    if curl -s -f -H "Authorization: Bearer $API_KEY" \
       "https://$DOMAIN/api/$endpoint" > /dev/null; then
        echo "✓ $endpoint endpoint working"
    else
        echo "✗ $endpoint endpoint failed"
    fi
done

echo "=== Health check complete ==="
```

### Log Analysis

Common log patterns to look for:

```bash
# Error patterns
grep -E "(ERROR|FATAL|Exception)" metamcp.log

# Authentication issues
grep -E "(401|403|Unauthorized|Forbidden)" metamcp.log

# Performance issues
grep -E "(timeout|slow|performance)" metamcp.log

# Rate limiting
grep -E "(429|rate.limit|throttle)" metamcp.log
```

## Getting Help

### Information to Collect

When reporting issues, include:

1. **Environment details**:
   - Operating system and version
   - Client application and version
   - MetaMCP server version
   - Network configuration

2. **Configuration**:
   - Sanitized configuration files
   - Environment variables (no secrets)
   - API key permissions

3. **Error details**:
   - Complete error messages
   - HTTP status codes
   - Timestamps
   - Steps to reproduce

4. **Logs**:
   - Client-side logs
   - Server-side logs (if accessible)
   - Network traces

### Support Channels

- **GitHub Issues**: https://github.com/metatool-ai/metamcp/issues
- **Discord**: https://discord.gg/mNsyat7mFX
- **Email**: support@metamcp.com
- **Documentation**: https://docs.metamcp.com 


================================================
FILE: docs/en/troubleshooting/oauth-troubleshooting.mdx
================================================
---
title: "MCP OAuth Troubleshooting"
description: "This page explains the authentication logic in MetaMCP exposed MCP endpoints and helps troubleshoot common OAuth-related issues."
---

> **Implementation Reference**: The authentication logic described in this page is implemented in [`apps/backend/src/middleware/api-key-oauth.middleware.ts`](https://github.com/metatool-ai/metamcp/blob/main/apps/backend/src/middleware/api-key-oauth.middleware.ts).

## Authentication Scenarios

MetaMCP supports four different authentication configurations, each with specific behaviors:

### 1. Both API Key and OAuth Disabled

**Configuration**: `enable_api_key_auth: false`, `enable_oauth: false`

**Behavior**: 
- All requests pass through without authentication
- No authentication headers required
- Suitable for public endpoints that don't require authentication

**Example Response**:
```json
{
  "message": "Public endpoint - no authentication required"
}
```

### 2. API Key Only (OAuth Disabled)

**Configuration**: `enable_api_key_auth: true`, `enable_oauth: false`

**Behavior**:
- Requires valid API key via `X-API-Key` header or query parameter
- **Critical Issue**: If API key is missing or invalid, some MCP clients (like Inspector) may attempt OAuth flow
- This can cause infinite refresh loops and 429 rate limit errors

**Valid Request**:
```bash
curl -H "X-API-Key: mcp_1234567890abcdef" \
  https://your-domain.com/api/endpoint
```

**Invalid/Missing API Key Response**:
```json
{
  "error": "authentication_required",
  "error_description": "Authentication required via API key",
  "supported_methods": [
    "X-API-Key header",
    "query parameter (api_key or apikey)"
  ],
  "timestamp": "2024-01-01T00:00:00.000Z"
}
```

**⚠️ Common Issue**: MCP Inspector may still try OAuth flow even when only API keys are enabled, leading to:
- Infinite token refresh attempts
- 429 "Too Many Requests" errors
- Inspector becoming unusable

**Solution**: Ensure your MCP client is configured to use API keys only when OAuth is disabled. Make sure you are providing the correct API key or it may result in 429 rate limited errors.

### 3. Both API Key and OAuth Enabled

**Configuration**: `enable_api_key_auth: true`, `enable_oauth: true`

**Behavior**:
- Accepts both API keys and OAuth bearer tokens
- API key takes precedence if provided
- Falls back to OAuth if no API key is provided
- Most flexible configuration

**Authentication Flow**:

1. **No Token Provided**: Initiates OAuth flow
   ```json
   {
     "error": "authentication_required",
     "error_description": "Authentication required via OAuth bearer token or API key",
     "supported_methods": [
       "Authorization header (Bearer token)",
       "X-API-Key header",
       "query parameter (api_key or apikey)"
     ]
   }
   ```

2. **Valid API Key**: Passes through
   ```bash
   curl -H "X-API-Key: mcp_1234567890abcdef" \
     https://your-domain.com/api/endpoint
   ```

3. **Valid OAuth Token**: Passes through
   ```bash
   curl -H "Authorization: Bearer mcp_token_1234567890abcdef" \
     https://your-domain.com/api/endpoint
   ```

4. **Invalid Credentials**: Returns 401 with rate limiting
   ```json
   {
     "error": "invalid_credentials",
     "error_description": "Authentication failed. Invalid credentials provided.",
     "timestamp": "2024-01-01T00:00:00.000Z"
   }
   ```

### 4. OAuth Only (API Key Disabled)

**Configuration**: `enable_api_key_auth: false`, `enable_oauth: true`

**Behavior**:
- Requires OAuth bearer token
- No API key support
- Clean OAuth-only authentication

**Valid Request**:
```bash
curl -H "Authorization: Bearer mcp_token_1234567890abcdef" \
  https://your-domain.com/api/endpoint
```

**No Token Response**:
```json
{
  "error": "authentication_required",
  "error_description": "Authentication required via OAuth bearer token",
  "supported_methods": ["Authorization header (Bearer token)"],
  "WWW-Authenticate": "Bearer realm=\"MetaMCP\", scope=\"admin\""
}
```

**Invalid Token Response**:
```json
{
  "error": "invalid_token",
  "error_description": "The provided OAuth token is invalid or has expired.",
  "timestamp": "2024-01-01T00:00:00.000Z"
}
```

## Common Issues and Solutions

### Issue 1: Infinite OAuth Refresh Loop

**Symptoms**:
- MCP Inspector continuously refreshes tokens
- 429 "Too Many Requests" errors
- Inspector becomes unresponsive

**Root Cause**: MCP client attempting OAuth flow when only API keys are enabled

**Solutions**:

1. **Enable OAuth in endpoint configuration**:
   ```json
   {
     "enable_api_key_auth": true,
     "enable_oauth": true
   }
   ```

2. **Configure MCP client to use API keys only**:
   - Update client configuration to use `X-API-Key` header
   - Disable OAuth flow in client settings

3. **Use OAuth-only configuration**:
   ```json
   {
     "enable_api_key_auth": false,
     "enable_oauth": true
   }
   ```

### Issue 2: 429 Rate Limit Errors

**Symptoms**:
- "Too many failed authentication attempts" errors
- Temporary lockout from authentication attempts

**Solutions**:

1. **Wait for rate limit to reset** (1 minute)
2. If you have enabled Auth, make sure you never pass in a wrong API key.
   ```

### Issue 3: Access Denied (403) Errors

**Symptoms**:
- "Access denied" errors even with valid credentials
- "Public API keys cannot access private endpoints" messages

**Root Cause**: Access control based on endpoint ownership

**Solutions**:

1. **For Private Endpoints**: Use API key owned by endpoint creator
2. **For Public Endpoints**: Any valid API key or OAuth token works
3. **Check endpoint ownership**:
   ```bash
   # Get endpoint details
   curl -H "Authorization: Bearer your-token" \
     https://your-domain.com/api/endpoints/endpoint-uuid
   ```

### Issue 4: Wrong Authentication Method

**Symptoms**:
- "Authentication required via API key" when using OAuth
- "Authentication required via OAuth bearer token" when using API key

**Solutions**:

1. **Check endpoint configuration**:
   ```bash
   # Get endpoint configuration
   curl -H "Authorization: Bearer your-token" \
     https://your-domain.com/api/endpoints/endpoint-uuid
   ```

2. **Use correct authentication method**:
   - API key: `X-API-Key` header or `api_key` query parameter
   - OAuth: `Authorization: Bearer` header



================================================
FILE: docs/essentials/code.mdx
================================================
---
title: 'Code blocks'
description: 'Display inline code and code blocks'
icon: 'code'
---

## Inline code

To denote a `word` or `phrase` as code, enclose it in backticks (`).

```
To denote a `word` or `phrase` as code, enclose it in backticks (`).
```

## Code blocks

Use [fenced code blocks](https://www.markdownguide.org/extended-syntax/#fenced-code-blocks) by enclosing code in three backticks and follow the leading ticks with the programming language of your snippet to get syntax highlighting. Optionally, you can also write the name of your code after the programming language.

```java HelloWorld.java
class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

````md
```java HelloWorld.java
class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```
````



================================================
FILE: docs/essentials/images.mdx
================================================
---
title: 'Images and embeds'
description: 'Add image, video, and other HTML elements'
icon: 'image'
---

<img
  style={{ borderRadius: '0.5rem' }}
  src="https://mintlify-assets.b-cdn.net/bigbend.jpg"
/>

## Image

### Using Markdown

The [markdown syntax](https://www.markdownguide.org/basic-syntax/#images) lets you add images using the following code

```md
![title](/path/image.jpg)
```

Note that the image file size must be less than 5MB. Otherwise, we recommend hosting on a service like [Cloudinary](https://cloudinary.com/) or [S3](https://aws.amazon.com/s3/). You can then use that URL and embed.

### Using embeds

To get more customizability with images, you can also use [embeds](/writing-content/embed) to add images

```html
<img height="200" src="/path/image.jpg" />
```

## Embeds and HTML elements

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/4KzFe50RQkQ"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowFullScreen
  style={{ width: '100%', borderRadius: '0.5rem' }}
></iframe>

<br />

<Tip>

Mintlify supports [HTML tags in Markdown](https://www.markdownguide.org/basic-syntax/#html). This is helpful if you prefer HTML tags to Markdown syntax, and lets you create documentation with infinite flexibility.

</Tip>

### iFrames

Loads another HTML page within the document. Most commonly used for embedding videos.

```html
<iframe src="https://www.youtube.com/embed/4KzFe50RQkQ"> </iframe>
```



================================================
FILE: docs/essentials/markdown.mdx
================================================
---
title: 'Markdown syntax'
description: 'Text, title, and styling in standard markdown'
icon: 'text-size'
---

## Titles

Best used for section headers.

```md
## Titles
```

### Subtitles

Best used for subsection headers.

```md
### Subtitles
```

<Tip>

Each **title** and **subtitle** creates an anchor and also shows up on the table of contents on the right.

</Tip>

## Text formatting

We support most markdown formatting. Simply add `**`, `_`, or `~` around text to format it.

| Style         | How to write it   | Result          |
| ------------- | ----------------- | --------------- |
| Bold          | `**bold**`        | **bold**        |
| Italic        | `_italic_`        | _italic_        |
| Strikethrough | `~strikethrough~` | ~strikethrough~ |

You can combine these. For example, write `**_bold and italic_**` to get **_bold and italic_** text.

You need to use HTML to write superscript and subscript text. That is, add `<sup>` or `<sub>` around your text.

| Text Size   | How to write it          | Result                 |
| ----------- | ------------------------ | ---------------------- |
| Superscript | `<sup>superscript</sup>` | <sup>superscript</sup> |
| Subscript   | `<sub>subscript</sub>`   | <sub>subscript</sub>   |

## Linking to pages

You can add a link by wrapping text in `[]()`. You would write `[link to google](https://google.com)` to [link to google](https://google.com).

Links to pages in your docs need to be root-relative. Basically, you should include the entire folder path. For example, `[link to text](/writing-content/text)` links to the page "Text" in our components section.

Relative links like `[link to text](../text)` will open slower because we cannot optimize them as easily.

## Blockquotes

### Singleline

To create a blockquote, add a `>` in front of a paragraph.

> Dorothy followed her through many of the beautiful rooms in her castle.

```md
> Dorothy followed her through many of the beautiful rooms in her castle.
```

### Multiline

> Dorothy followed her through many of the beautiful rooms in her castle.
>
> The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.

```md
> Dorothy followed her through many of the beautiful rooms in her castle.
>
> The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.
```

### LaTeX

Mintlify supports [LaTeX](https://www.latex-project.org) through the Latex component.

<Latex>8 x (vk x H1 - H2) = (0,1)</Latex>

```md
<Latex>8 x (vk x H1 - H2) = (0,1)</Latex>
```



================================================
FILE: docs/essentials/navigation.mdx
================================================
---
title: 'Navigation'
description: 'The navigation field in docs.json defines the pages that go in the navigation menu'
icon: 'map'
---

The navigation menu is the list of links on every website.

You will likely update `docs.json` every time you add a new page. Pages do not show up automatically.

## Navigation syntax

Our navigation syntax is recursive which means you can make nested navigation groups. You don't need to include `.mdx` in page names.

<CodeGroup>

```json Regular Navigation
"navigation": {
  "tabs": [
    {
      "tab": "Docs",
      "groups": [
        {
          "group": "Getting Started",
          "pages": ["quickstart"]
        }
      ]
    }
  ]
}
```

```json Nested Navigation
"navigation": {
  "tabs": [
    {
      "tab": "Docs",
      "groups": [
        {
          "group": "Getting Started",
          "pages": [
            "quickstart",
            {
              "group": "Nested Reference Pages",
              "pages": ["nested-reference-page"]
            }
          ]
        }
      ]
    }
  ]
}
```

</CodeGroup>

## Folders

Simply put your MDX files in folders and update the paths in `docs.json`.

For example, to have a page at `https://yoursite.com/your-folder/your-page` you would make a folder called `your-folder` containing an MDX file called `your-page.mdx`.

<Warning>

You cannot use `api` for the name of a folder unless you nest it inside another folder. Mintlify uses Next.js which reserves the top-level `api` folder for internal server calls. A folder name such as `api-reference` would be accepted.

</Warning>

```json Navigation With Folder
"navigation": {
  "tabs": [
    {
      "tab": "Docs",
      "groups": [
        {
          "group": "Group Name",
          "pages": ["your-folder/your-page"]
        }
      ]
    }
  ]
}
```

## Hidden pages

MDX files not included in `docs.json` will not show up in the sidebar but are accessible through the search bar and by linking directly to them.



================================================
FILE: docs/essentials/reusable-snippets.mdx
================================================
---
title: "Reusable snippets"
description: "Reusable, custom snippets to keep content in sync"
icon: "recycle"
---

import SnippetIntro from '/snippets/snippet-intro.mdx';

<SnippetIntro />

## Creating a custom snippet

**Pre-condition**: You must create your snippet file in the `snippets` directory.

<Note>
  Any page in the `snippets` directory will be treated as a snippet and will not
  be rendered into a standalone page. If you want to create a standalone page
  from the snippet, import the snippet into another file and call it as a
  component.
</Note>

### Default export

1. Add content to your snippet file that you want to re-use across multiple
   locations. Optionally, you can add variables that can be filled in via props
   when you import the snippet.

```mdx snippets/my-snippet.mdx
Hello world! This is my content I want to reuse across pages. My keyword of the
day is {word}.
```

<Warning>
  The content that you want to reuse must be inside the `snippets` directory in
  order for the import to work.
</Warning>

2. Import the snippet into your destination file.

```mdx destination-file.mdx
---
title: My title
description: My Description
---

import MySnippet from '/snippets/path/to/my-snippet.mdx';

## Header

Lorem impsum dolor sit amet.

<MySnippet word="bananas" />
```

### Reusable variables

1. Export a variable from your snippet file:

```mdx snippets/path/to/custom-variables.mdx
export const myName = 'my name';

export const myObject = { fruit: 'strawberries' };
```

2. Import the snippet from your destination file and use the variable:

```mdx destination-file.mdx
---
title: My title
description: My Description
---

import { myName, myObject } from '/snippets/path/to/custom-variables.mdx';

Hello, my name is {myName} and I like {myObject.fruit}.
```

### Reusable components

1. Inside your snippet file, create a component that takes in props by exporting
   your component in the form of an arrow function.

```mdx snippets/custom-component.mdx
export const MyComponent = ({ title }) => (
  <div>
    <h1>{title}</h1>
    <p>... snippet content ...</p>
  </div>
);
```

<Warning>
  MDX does not compile inside the body of an arrow function. Stick to HTML
  syntax when you can or use a default export if you need to use MDX.
</Warning>

2. Import the snippet into your destination file and pass in the props

```mdx destination-file.mdx
---
title: My title
description: My Description
---

import { MyComponent } from '/snippets/custom-component.mdx';

Lorem ipsum dolor sit amet.

<MyComponent title={'Custom title'} />
```



================================================
FILE: docs/essentials/settings.mdx
================================================
---
title: 'Global Settings'
description: 'Mintlify gives you complete control over the look and feel of your documentation using the docs.json file'
icon: 'gear'
---

Every Mintlify site needs a `docs.json` file with the core configuration settings. Learn more about the [properties](#properties) below.

## Properties

<ResponseField name="name" type="string" required>
Name of your project. Used for the global title.

Example: `mintlify`

</ResponseField>

<ResponseField name="navigation" type="Navigation[]" required>
  An array of groups with all the pages within that group
  <Expandable title="Navigation">
    <ResponseField name="group" type="string">
    The name of the group.

    Example: `Settings`

    </ResponseField>
    <ResponseField name="pages" type="string[]">
    The relative paths to the markdown files that will serve as pages.

    Example: `["customization", "page"]`

    </ResponseField>

  </Expandable>
</ResponseField>

<ResponseField name="logo" type="string or object">
  Path to logo image or object with path to "light" and "dark" mode logo images
  <Expandable title="Logo">
    <ResponseField name="light" type="string">
      Path to the logo in light mode
    </ResponseField>
    <ResponseField name="dark" type="string">
      Path to the logo in dark mode
    </ResponseField>
    <ResponseField name="href" type="string" default="/">
      Where clicking on the logo links you to
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="favicon" type="string">
  Path to the favicon image
</ResponseField>

<ResponseField name="colors" type="Colors">
  Hex color codes for your global theme
  <Expandable title="Colors">
    <ResponseField name="primary" type="string" required>
      The primary color. Used for most often for highlighted content, section
      headers, accents, in light mode
    </ResponseField>
    <ResponseField name="light" type="string">
      The primary color for dark mode. Used for most often for highlighted
      content, section headers, accents, in dark mode
    </ResponseField>
    <ResponseField name="dark" type="string">
      The primary color for important buttons
    </ResponseField>
    <ResponseField name="background" type="object">
      The color of the background in both light and dark mode
      <Expandable title="Object">
        <ResponseField name="light" type="string" required>
          The hex color code of the background in light mode
        </ResponseField>
        <ResponseField name="dark" type="string" required>
          The hex color code of the background in dark mode
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="topbarLinks" type="TopbarLink[]">
  Array of `name`s and `url`s of links you want to include in the topbar
  <Expandable title="TopbarLink">
    <ResponseField name="name" type="string">
    The name of the button.

    Example: `Contact us`
    </ResponseField>
    <ResponseField name="url" type="string">
    The url once you click on the button. Example: `https://mintlify.com/docs`
    </ResponseField>

  </Expandable>
</ResponseField>

<ResponseField name="topbarCtaButton" type="Call to Action">
  <Expandable title="Topbar Call to Action">
    <ResponseField name="type" type={'"link" or "github"'} default="link">
    Link shows a button. GitHub shows the repo information at the url provided including the number of GitHub stars.
    </ResponseField>
    <ResponseField name="url" type="string">
    If `link`: What the button links to.
    
    If `github`: Link to the repository to load GitHub information from.
    </ResponseField>
    <ResponseField name="name" type="string">
    Text inside the button. Only required if `type` is a `link`.
    </ResponseField>

  </Expandable>
</ResponseField>

<ResponseField name="versions" type="string[]">
  Array of version names. Only use this if you want to show different versions
  of docs with a dropdown in the navigation bar.
</ResponseField>

<ResponseField name="anchors" type="Anchor[]">
  An array of the anchors, includes the `icon`, `color`, and `url`.
  <Expandable title="Anchor">
    <ResponseField name="icon" type="string">
    The [Font Awesome](https://fontawesome.com/search?q=heart) icon used to feature the anchor.

    Example: `comments`
    </ResponseField>
    <ResponseField name="name" type="string">
    The name of the anchor label.

    Example: `Community`
    </ResponseField>
    <ResponseField name="url" type="string">
      The start of the URL that marks what pages go in the anchor. Generally, this is the name of the folder you put your pages in.
    </ResponseField>
    <ResponseField name="color" type="string">
      The hex color of the anchor icon background. Can also be a gradient if you pass an object with the properties `from` and `to` that are each a hex color.
    </ResponseField>
    <ResponseField name="version" type="string">
      Used if you want to hide an anchor until the correct docs version is selected.
    </ResponseField>
    <ResponseField name="isDefaultHidden" type="boolean" default="false">
      Pass `true` if you want to hide the anchor until you directly link someone to docs inside it.
    </ResponseField>
    <ResponseField name="iconType" default="duotone" type="string">
      One of: "brands", "duotone", "light", "sharp-solid", "solid", or "thin"
    </ResponseField>

  </Expandable>
</ResponseField>

<ResponseField name="topAnchor" type="Object">
  Override the default configurations for the top-most anchor.
  <Expandable title="Object">
    <ResponseField name="name" default="Documentation" type="string">
      The name of the top-most anchor
    </ResponseField>
    <ResponseField name="icon" default="book-open" type="string">
      Font Awesome icon.
    </ResponseField>
    <ResponseField name="iconType" default="duotone" type="string">
      One of: "brands", "duotone", "light", "sharp-solid", "solid", or "thin"
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="tabs" type="Tabs[]">
  An array of navigational tabs.
  <Expandable title="Tabs">
    <ResponseField name="name" type="string">
      The name of the tab label.
    </ResponseField>
    <ResponseField name="url" type="string">
      The start of the URL that marks what pages go in the tab. Generally, this
      is the name of the folder you put your pages in.
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="api" type="API">
  Configuration for API settings. Learn more about API pages at [API Components](/api-playground/demo).
  <Expandable title="API">
    <ResponseField name="baseUrl" type="string">
      The base url for all API endpoints. If `baseUrl` is an array, it will enable for multiple base url
      options that the user can toggle.
    </ResponseField>

    <ResponseField name="auth" type="Auth">
      <Expandable title="Auth">
        <ResponseField name="method" type='"bearer" | "basic" | "key"'>
          The authentication strategy used for all API endpoints.
        </ResponseField>
        <ResponseField name="name" type="string">
        The name of the authentication parameter used in the API playground.

        If method is `basic`, the format should be `[usernameName]:[passwordName]`
        </ResponseField>
        <ResponseField name="inputPrefix" type="string">
        The default value that's designed to be a prefix for the authentication input field.

        E.g. If an `inputPrefix` of `AuthKey` would inherit the default input result of the authentication field as `AuthKey`.
        </ResponseField>
      </Expandable>
    </ResponseField>

    <ResponseField name="playground" type="Playground">
      Configurations for the API playground

      <Expandable title="Playground">
        <ResponseField name="mode" default="show" type='"show" | "simple" | "hide"'>
          Whether the playground is showing, hidden, or only displaying the endpoint with no added user interactivity `simple`

          Learn more at the [playground guides](/api-playground/demo)
        </ResponseField>
      </Expandable>
    </ResponseField>

    <ResponseField name="maintainOrder" type="boolean">
      Enabling this flag ensures that key ordering in OpenAPI pages matches the key ordering defined in the OpenAPI file.

      <Warning>This behavior will soon be enabled by default, at which point this field will be deprecated.</Warning>
    </ResponseField>

  </Expandable>
</ResponseField>

<ResponseField name="openapi" type="string | string[]">
  A string or an array of strings of URL(s) or relative path(s) pointing to your
  OpenAPI file.
  
  Examples:
  <CodeGroup>
    ```json Absolute
    "openapi": "https://example.com/openapi.json"
    ```
    ```json Relative
    "openapi": "/openapi.json"
    ```
    ```json Multiple
    "openapi": ["https://example.com/openapi1.json", "/openapi2.json", "/openapi3.json"]
    ```
  </CodeGroup>

</ResponseField>

<ResponseField name="footerSocials" type="FooterSocials">
  An object of social media accounts where the key:property pair represents the social media platform and the account url.
  
  Example: 
  ```json
  {
    "x": "https://x.com/mintlify",
    "website": "https://mintlify.com"
  }
  ```
  <Expandable title="FooterSocials">
    <ResponseField name="[key]" type="string">
    One of the following values `website`, `facebook`, `x`, `discord`, `slack`, `github`, `linkedin`, `instagram`, `hacker-news`
    
    Example: `x`
    </ResponseField>
    <ResponseField name="property" type="string">
    The URL to the social platform.
    
    Example: `https://x.com/mintlify`
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="feedback" type="Feedback">
  Configurations to enable feedback buttons

  <Expandable title="Feedback">
    <ResponseField name="suggestEdit" type="boolean" default="false">
    Enables a button to allow users to suggest edits via pull requests
    </ResponseField>
    <ResponseField name="raiseIssue" type="boolean" default="false">
    Enables a button to allow users to raise an issue about the documentation
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="modeToggle" type="ModeToggle">
  Customize the dark mode toggle.
  <Expandable title="ModeToggle">
    <ResponseField name="default" type={'"light" or "dark"'}>
      Set if you always want to show light or dark mode for new users. When not
      set, we default to the same mode as the user's operating system.
    </ResponseField>
    <ResponseField name="isHidden" type="boolean" default="false">
      Set to true to hide the dark/light mode toggle. You can combine `isHidden` with `default` to force your docs to only use light or dark mode. For example:
      
      <CodeGroup>
      ```json Only Dark Mode
      "modeToggle": {
        "default": "dark",
        "isHidden": true
      }
      ```

      ```json Only Light Mode
      "modeToggle": {
        "default": "light",
        "isHidden": true
      }
      ```
      </CodeGroup>

    </ResponseField>

  </Expandable>
</ResponseField>

<ResponseField name="backgroundImage" type="string">
  A background image to be displayed behind every page. See example with
  [Infisical](https://infisical.com/docs) and [FRPC](https://frpc.io).
</ResponseField>



================================================
FILE: docs/snippets/snippet-intro.mdx
================================================
One of the core principles of software development is DRY (Don't Repeat
Yourself). This is a principle that applies to documentation as
well. If you find yourself repeating the same content in multiple places, you
should consider creating a custom snippet to keep your content in sync.


