Directory structure:
└── surrealdb-docs.surrealdb.com/
    ├── README.md
    └── src/
        ├── components/
        │   └── Tabs/
        │       └── LICENSE.md
        └── content/
            ├── doc-cloud/
            │   ├── architecture.mdx
            │   ├── index.mdx
            │   ├── advanced-topics/
            │   │   ├── configure-an-instance.mdx
            │   │   ├── data-export-and-backup.mdx
            │   │   ├── index.mdx
            │   │   ├── manage-organisation-permissions.mdx
            │   │   ├── migrating-data.mdx
            │   │   ├── network-access.mdx
            │   │   ├── search-and-shortcuts.mdx
            │   │   ├── surrealql-editors.mdx
            │   │   └── monitoring/
            │   │       ├── index.mdx
            │   │       ├── logs.mdx
            │   │       └── metrics.mdx
            │   ├── billing-and-support/
            │   │   ├── billing.mdx
            │   │   ├── index.mdx
            │   │   └── support.mdx
            │   ├── connect/
            │   │   ├── cli.mdx
            │   │   ├── http.mdx
            │   │   ├── index.mdx
            │   │   ├── sdk.mdx
            │   │   └── surrealist.mdx
            │   ├── faqs/
            │   │   └── index.mdx
            │   └── getting-started/
            │       ├── create-an-account.mdx
            │       ├── create-an-instance.mdx
            │       ├── create-an-organisation.mdx
            │       └── index.mdx
            ├── doc-integrations/
            │   ├── index.mdx
            │   ├── data-management/
            │   │   ├── airbyte.mdx
            │   │   ├── fivetran.mdx
            │   │   ├── index.mdx
            │   │   ├── n8n.mdx
            │   │   ├── unstructured.mdx
            │   │   └── surreal-sync/
            │   │       ├── index.mdx
            │   │       ├── install.mdx
            │   │       ├── json-lines.mdx
            │   │       ├── mongodb.mdx
            │   │       └── neo4j.mdx
            │   ├── Embeddings/
            │   │   ├── fastembed.mdx
            │   │   ├── index.mdx
            │   │   ├── mistral.mdx
            │   │   ├── openai.mdx
            │   │   ├── python.mdx
            │   │   └── rust.mdx
            │   └── Frameworks/
            │       ├── agno.mdx
            │       ├── camel.mdx
            │       ├── crewai.mdx
            │       ├── dagster.mdx
            │       ├── deepeval.mdx
            │       ├── dynamiq.mdx
            │       ├── feast.mdx
            │       ├── googleagent.mdx
            │       ├── index.mdx
            │       ├── langchain.mdx
            │       ├── llama-index.mdx
            │       └── smolagents.mdx
            ├── doc-sdk-dotnet/
            │   ├── data-types.mdx
            │   ├── index.mdx
            │   ├── installation.mdx
            │   ├── start.mdx
            │   ├── core/
            │   │   ├── authentication.mdx
            │   │   ├── connection-strings.mdx
            │   │   ├── create-a-new-connection.mdx
            │   │   ├── data-manipulation.mdx
            │   │   ├── dependency-injection.mdx
            │   │   ├── index.mdx
            │   │   ├── parameters.mdx
            │   │   ├── streaming.mdx
            │   │   └── writing-surrealql.mdx
            │   └── methods/
            │       ├── authenticate.mdx
            │       ├── connect.mdx
            │       ├── create.mdx
            │       ├── delete.mdx
            │       ├── export.mdx
            │       ├── health.mdx
            │       ├── import.mdx
            │       ├── index.mdx
            │       ├── info.mdx
            │       ├── insert-relation.mdx
            │       ├── insert.mdx
            │       ├── invalidate.mdx
            │       ├── kill.mdx
            │       ├── listen_live.mdx
            │       ├── live-query.mdx
            │       ├── live-raw-query.mdx
            │       ├── live-table.mdx
            │       ├── merge.mdx
            │       ├── patch.mdx
            │       ├── query.mdx
            │       ├── raw-query.mdx
            │       ├── relate.mdx
            │       ├── run.mdx
            │       ├── select.mdx
            │       ├── set.mdx
            │       ├── signin.mdx
            │       ├── signup.mdx
            │       ├── unset.mdx
            │       ├── update.mdx
            │       ├── upsert.mdx
            │       ├── use.mdx
            │       └── version.mdx
            ├── doc-sdk-golang/
            │   ├── connection-engines.mdx
            │   ├── data-types.mdx
            │   ├── index.mdx
            │   ├── installation.mdx
            │   ├── start.mdx
            │   ├── core/
            │   │   ├── handling-authentication.mdx
            │   │   └── index.mdx
            │   └── methods/
            │       ├── authenticate.mdx
            │       ├── create.mdx
            │       ├── delete.mdx
            │       ├── index.mdx
            │       ├── info.mdx
            │       ├── insert-relation.mdx
            │       ├── insert.mdx
            │       ├── invalidate.mdx
            │       ├── kill.mdx
            │       ├── let.mdx
            │       ├── live-notification.mdx
            │       ├── live.mdx
            │       ├── merge.mdx
            │       ├── new.mdx
            │       ├── patch.mdx
            │       ├── query.mdx
            │       ├── raw-query.mdx
            │       ├── relate.mdx
            │       ├── select.mdx
            │       ├── signin.mdx
            │       ├── signup.mdx
            │       ├── unset.mdx
            │       ├── update.mdx
            │       ├── upsert.mdx
            │       ├── use.mdx
            │       └── version.mdx
            ├── doc-sdk-java/
            │   ├── api-documentation.mdx
            │   ├── data-types.mdx
            │   ├── index.mdx
            │   ├── installation.mdx
            │   ├── start.mdx
            │   └── core/
            │       ├── create-a-new-connection.mdx
            │       ├── handling-authentication.mdx
            │       └── index.mdx
            ├── doc-sdk-javascript/
            │   ├── data-types.mdx
            │   ├── index.mdx
            │   ├── installation.mdx
            │   ├── properties.mdx
            │   ├── start.mdx
            │   ├── core/
            │   │   ├── create-a-new-connection.mdx
            │   │   ├── data-maniplulation.mdx
            │   │   ├── handling-authentication.mdx
            │   │   ├── index.mdx
            │   │   ├── parameters.mdx
            │   │   ├── streaming.mdx
            │   │   ├── utilities.mdx
            │   │   └── writing-surrealql.mdx
            │   ├── engines/
            │   │   ├── index.mdx
            │   │   ├── node.mdx
            │   │   └── wasm.mdx
            │   ├── frameworks/
            │   │   ├── index.mdx
            │   │   ├── react.mdx
            │   │   └── solidjs.mdx
            │   └── methods/
            │       ├── authenticate.mdx
            │       ├── close.mdx
            │       ├── connect.mdx
            │       ├── create.mdx
            │       ├── delete.mdx
            │       ├── export.mdx
            │       ├── import.mdx
            │       ├── index.mdx
            │       ├── info.mdx
            │       ├── insert.mdx
            │       ├── insertrelation.mdx
            │       ├── invalidate.mdx
            │       ├── kill.mdx
            │       ├── let.mdx
            │       ├── live.mdx
            │       ├── merge.mdx
            │       ├── patch.mdx
            │       ├── query.mdx
            │       ├── select.mdx
            │       ├── signin.mdx
            │       ├── signup.mdx
            │       ├── subscribelive.mdx
            │       ├── unset.mdx
            │       ├── update.mdx
            │       ├── upsert.mdx
            │       └── use.mdx
            ├── doc-sdk-php/
            │   ├── data-types.mdx
            │   ├── index.mdx
            │   ├── setup.mdx
            │   ├── core/
            │   │   ├── authentication.mdx
            │   │   ├── data-querying.mdx
            │   │   ├── index.mdx
            │   │   └── initialization.mdx
            │   └── methods/
            │       ├── authenticate.mdx
            │       ├── close.mdx
            │       ├── connect.mdx
            │       ├── create.mdx
            │       ├── delete.mdx
            │       ├── export.mdx
            │       ├── health.mdx
            │       ├── import.mdx
            │       ├── index.mdx
            │       ├── info.mdx
            │       ├── insert.mdx
            │       ├── insertRelation.mdx
            │       ├── invalidate.mdx
            │       ├── let.mdx
            │       ├── merge.mdx
            │       ├── patch.mdx
            │       ├── query.mdx
            │       ├── queryRaw.mdx
            │       ├── run.mdx
            │       ├── select.mdx
            │       ├── signin.mdx
            │       ├── signup.mdx
            │       ├── status.mdx
            │       ├── unset.mdx
            │       ├── update.mdx
            │       ├── upsert.mdx
            │       ├── use.mdx
            │       └── version.mdx
            ├── doc-sdk-python/
            │   ├── data-types.mdx
            │   ├── index.mdx
            │   ├── installation.mdx
            │   ├── start.mdx
            │   ├── concepts/
            │   │   ├── create-a-new-connection.mdx
            │   │   ├── data-maniplulation.mdx
            │   │   ├── handling-authentication.mdx
            │   │   ├── index.mdx
            │   │   ├── parameters.mdx
            │   │   ├── streaming.mdx
            │   │   └── writing-surrealql.mdx
            │   └── methods/
            │       ├── authenticate.mdx
            │       ├── close.mdx
            │       ├── connect.mdx
            │       ├── create.mdx
            │       ├── delete.mdx
            │       ├── index.mdx
            │       ├── info.mdx
            │       ├── insert-relation.mdx
            │       ├── insert.mdx
            │       ├── invalidate.mdx
            │       ├── kill.mdx
            │       ├── let.mdx
            │       ├── live.mdx
            │       ├── merge.mdx
            │       ├── patch.mdx
            │       ├── query.mdx
            │       ├── select.mdx
            │       ├── signin.mdx
            │       ├── signup.mdx
            │       ├── subscribelive.mdx
            │       ├── unset.mdx
            │       ├── update.mdx
            │       ├── upsert.mdx
            │       └── use.mdx
            ├── doc-sdk-rust/
            │   ├── index.mdx
            │   ├── setup.mdx
            │   ├── concepts/
            │   │   ├── authenticating-users.mdx
            │   │   ├── concurrency.mdx
            │   │   ├── fetch.mdx
            │   │   ├── flexible-typing.mdx
            │   │   ├── index.mdx
            │   │   ├── live.mdx
            │   │   ├── rust_after-3.0.mdx
            │   │   ├── transaction.mdx
            │   │   └── vector-embeddings.mdx
            │   ├── frameworks/
            │   │   ├── actix.mdx
            │   │   ├── axum.mdx
            │   │   ├── egui.mdx
            │   │   ├── index.mdx
            │   │   └── rocket.mdx
            │   └── methods/
            │       ├── authenticate.mdx
            │       ├── connect.mdx
            │       ├── create.mdx
            │       ├── delete.mdx
            │       ├── export.mdx
            │       ├── get.mdx
            │       ├── import.mdx
            │       ├── index.mdx
            │       ├── init.mdx
            │       ├── insert.mdx
            │       ├── invalidate.mdx
            │       ├── new.mdx
            │       ├── query.mdx
            │       ├── run.mdx
            │       ├── select-live.mdx
            │       ├── select.mdx
            │       ├── set.mdx
            │       ├── signin.mdx
            │       ├── signup.mdx
            │       ├── unset.mdx
            │       ├── update.mdx
            │       ├── upsert.mdx
            │       ├── use.mdx
            │       ├── version.mdx
            │       └── wait-for.mdx
            ├── doc-surrealdb/
            │   ├── index.mdx
            │   ├── cli/
            │   │   ├── env.mdx
            │   │   ├── export.mdx
            │   │   ├── fix.mdx
            │   │   ├── help.mdx
            │   │   ├── import.mdx
            │   │   ├── index.mdx
            │   │   ├── isready.mdx
            │   │   ├── sql.mdx
            │   │   ├── start.mdx
            │   │   ├── upgrade.mdx
            │   │   ├── validate.mdx
            │   │   ├── version.mdx
            │   │   └── ml/
            │   │       ├── export.mdx
            │   │       ├── import.mdx
            │   │       └── index.mdx
            │   ├── deployment/
            │   │   ├── amazon.mdx
            │   │   ├── azure.mdx
            │   │   ├── google.mdx
            │   │   ├── index.mdx
            │   │   ├── kubernetes.mdx
            │   │   └── surreal cloud.mdx
            │   ├── embedding/
            │   │   ├── dotnet.mdx
            │   │   ├── index.mdx
            │   │   ├── javascript.mdx
            │   │   ├── python.mdx
            │   │   └── rust.mdx
            │   ├── faqs/
            │   │   ├── index.mdx
            │   │   └── known-issues.mdx
            │   ├── installation/
            │   │   ├── index.mdx
            │   │   ├── linux.mdx
            │   │   ├── macos.mdx
            │   │   ├── nightly.mdx
            │   │   ├── windows.mdx
            │   │   ├── running/
            │   │   │   ├── docker.mdx
            │   │   │   ├── file.mdx
            │   │   │   ├── index.mdx
            │   │   │   ├── memory.mdx
            │   │   │   └── tikv.mdx
            │   │   └── upgrading/
            │   │       ├── index.mdx
            │   │       └── migrating-data-to-2.x.mdx
            │   ├── integration/
            │   │   ├── cbor.mdx
            │   │   ├── http.mdx
            │   │   ├── index.mdx
            │   │   ├── rpc.mdx
            │   │   └── sdks.mdx
            │   ├── introduction/
            │   │   ├── architecture.mdx
            │   │   ├── index.mdx
            │   │   ├── start.mdx
            │   │   └── concepts/
            │   │       ├── database.mdx
            │   │       ├── index.mdx
            │   │       └── namespace.mdx
            │   ├── migrating/
            │   │   ├── index.mdx
            │   │   ├── neo4j.mdx
            │   │   └── postgresql.mdx
            │   ├── models/
            │   │   ├── document.mdx
            │   │   ├── full-text-search.mdx
            │   │   ├── geospatial.mdx
            │   │   ├── graph.mdx
            │   │   ├── index.mdx
            │   │   ├── time-series.mdx
            │   │   └── vector.mdx
            │   ├── querying/
            │   │   ├── index.mdx
            │   │   ├── graphql/
            │   │   │   ├── http.mdx
            │   │   │   ├── index.mdx
            │   │   │   └── surrealist.mdx
            │   │   ├── sdks/
            │   │   │   └── index.mdx
            │   │   ├── surrealism/
            │   │   │   ├── examples.mdx
            │   │   │   ├── index.mdx
            │   │   │   └── tutorial.mdx
            │   │   └── surrealql/
            │   │       ├── cli.mdx
            │   │       ├── http.mdx
            │   │       ├── index.mdx
            │   │       └── surrealist.mdx
            │   ├── reference-guide/
            │   │   ├── full-text-search.mdx
            │   │   ├── index.mdx
            │   │   ├── observability.mdx
            │   │   ├── performance-best-practices.mdx
            │   │   ├── sample-industry-schemas.mdx
            │   │   ├── schema-creation-best-practices.mdx
            │   │   └── security-best-practices.mdx
            │   └── security/
            │       ├── authentication.mdx
            │       ├── capabilities.mdx
            │       ├── index.mdx
            │       ├── summary.mdx
            │       └── troubleshooting.mdx
            ├── doc-surrealist/
            │   ├── getting-started.mdx
            │   ├── index.mdx
            │   ├── installation.mdx
            │   ├── troubleshooting.mdx
            │   ├── advanced-topics/
            │   │   ├── connection-templates.mdx
            │   │   ├── embedding-surrealist.mdx
            │   │   ├── index.mdx
            │   │   ├── intents.mdx
            │   │   ├── search-and-shortcuts.mdx
            │   │   ├── settings-and-customisation.mdx
            │   │   └── surrealql-editors.mdx
            │   ├── concepts/
            │   │   ├── designing-the-database-schema.mdx
            │   │   ├── explore-database-records.mdx
            │   │   ├── index.mdx
            │   │   ├── local-database-serving.mdx
            │   │   ├── manage-database-access.mdx
            │   │   ├── sending-queries-with-graphql.mdx
            │   │   ├── sending-queries.mdx
            │   │   ├── specialized-api-docs.mdx
            │   │   ├── surreal-cloud.mdx
            │   │   └── writing-stored-procedures.mdx
            │   └── faqs/
            │       ├── index.mdx
            │       ├── info.mdx
            │       └── known-issues.mdx
            ├── doc-surrealkv/
            │   ├── index.mdx
            │   └── performance.mdx
            ├── doc-surrealml/
            │   ├── computation.mdx
            │   ├── index.mdx
            │   └── storage.mdx
            ├── doc-surrealql/
            │   ├── comments.mdx
            │   ├── demo.mdx
            │   ├── index.mdx
            │   ├── operators.mdx
            │   ├── parameters.mdx
            │   ├── transactions.mdx
            │   ├── clauses/
            │   │   ├── explain.mdx
            │   │   ├── fetch.mdx
            │   │   ├── from.mdx
            │   │   ├── group-by.mdx
            │   │   ├── index.mdx
            │   │   ├── limit.mdx
            │   │   ├── omit.mdx
            │   │   ├── order-by.mdx
            │   │   ├── split.mdx
            │   │   ├── where.mdx
            │   │   └── with.mdx
            │   ├── datamodel/
            │   │   ├── arrays.mdx
            │   │   ├── booleans.mdx
            │   │   ├── bytes.mdx
            │   │   ├── casting.mdx
            │   │   ├── closures.mdx
            │   │   ├── datetimes.mdx
            │   │   ├── files.mdx
            │   │   ├── formatters.mdx
            │   │   ├── futures.mdx
            │   │   ├── geometries.mdx
            │   │   ├── idioms.mdx
            │   │   ├── ids.mdx
            │   │   ├── index.mdx
            │   │   ├── literals.mdx
            │   │   ├── none-and-null.mdx
            │   │   ├── numbers.mdx
            │   │   ├── objects.mdx
            │   │   ├── ranges.mdx
            │   │   ├── records.mdx
            │   │   ├── references.mdx
            │   │   ├── regex.mdx
            │   │   ├── sets.mdx
            │   │   ├── strings.mdx
            │   │   ├── uuid.mdx
            │   │   └── values.mdx
            │   ├── functions/
            │   │   ├── index.mdx
            │   │   ├── database/
            │   │   │   ├── api.mdx
            │   │   │   ├── array.mdx
            │   │   │   ├── bytes.mdx
            │   │   │   ├── count.mdx
            │   │   │   ├── crypto.mdx
            │   │   │   ├── duration.mdx
            │   │   │   ├── encoding.mdx
            │   │   │   ├── file.mdx
            │   │   │   ├── geo.mdx
            │   │   │   ├── http.mdx
            │   │   │   ├── index.mdx
            │   │   │   ├── math.mdx
            │   │   │   ├── meta.mdx
            │   │   │   ├── not.mdx
            │   │   │   ├── object.mdx
            │   │   │   ├── parse.mdx
            │   │   │   ├── rand.mdx
            │   │   │   ├── record.mdx
            │   │   │   ├── search.mdx
            │   │   │   ├── sequence.mdx
            │   │   │   ├── session.mdx
            │   │   │   ├── sleep.mdx
            │   │   │   ├── string.mdx
            │   │   │   ├── time.mdx
            │   │   │   ├── type.mdx
            │   │   │   ├── value.mdx
            │   │   │   └── vector.mdx
            │   │   ├── ml/
            │   │   │   ├── functions.mdx
            │   │   │   └── index.mdx
            │   │   └── script/
            │   │       ├── arguments.mdx
            │   │       ├── built-in-functions.mdx
            │   │       ├── context.mdx
            │   │       ├── index.mdx
            │   │       ├── surrealql-functions.mdx
            │   │       └── type-conversion.mdx
            │   └── statements/
            │       ├── access.mdx
            │       ├── alter.mdx
            │       ├── begin.mdx
            │       ├── break.mdx
            │       ├── cancel.mdx
            │       ├── commit.mdx
            │       ├── continue.mdx
            │       ├── create.mdx
            │       ├── delete.mdx
            │       ├── for.mdx
            │       ├── ifelse.mdx
            │       ├── index.mdx
            │       ├── info.mdx
            │       ├── insert.mdx
            │       ├── kill.mdx
            │       ├── let.mdx
            │       ├── live.mdx
            │       ├── rebuild.mdx
            │       ├── relate.mdx
            │       ├── remove.mdx
            │       ├── return.mdx
            │       ├── select.mdx
            │       ├── show.mdx
            │       ├── sleep.mdx
            │       ├── throw.mdx
            │       ├── update.mdx
            │       ├── upsert.mdx
            │       ├── use.mdx
            │       └── define/
            │           ├── analyzer.mdx
            │           ├── api.mdx
            │           ├── bucket.mdx
            │           ├── config.mdx
            │           ├── database.mdx
            │           ├── event.mdx
            │           ├── field.mdx
            │           ├── function.mdx
            │           ├── index.mdx
            │           ├── indexes.mdx
            │           ├── module.mdx
            │           ├── namespace.mdx
            │           ├── param.mdx
            │           ├── scope.mdx
            │           ├── sequence.mdx
            │           ├── table.mdx
            │           ├── token.mdx
            │           ├── user.mdx
            │           └── access/
            │               ├── bearer.mdx
            │               ├── index.mdx
            │               ├── jwt.mdx
            │               └── record.mdx
            ├── doc-tutorials/
            │   ├── build-a-realtime-presence-web-application-using-surrealdb-live-queries.mdx
            │   ├── connect-to-surrealdb-via-ngrok-tunnel.mdx
            │   ├── define-a-schema.mdx
            │   ├── index.mdx
            │   ├── integrate-auth0-as-authentication-provider.mdx
            │   ├── integrate-aws-cognito-as-authentication-provider.mdx
            │   ├── using-github-actions.mdx
            │   └── working-with-surrealdb-over-http-via-postman.mdx
            └── labs-items/
                ├── aeons-surreal-renaissance-official-book-for-in-depth-learning-through-storytelling.md
                ├── allographer.md
                ├── aspire-community-package.md
                ├── aspnet-healthchecks-package.md
                ├── awaited-surrealdb.md
                ├── beyond-surreal-a-closer-look-at-newsql-relational-data-beyond-fireship.md
                ├── blink-instant-editing.md
                ├── build-a-realtime-presence-web-application-using-surrealdb-live-queries.md
                ├── build-an-ai-rag-agent.md
                ├── cli-phone-book-in-python-using-surrealdb-as-database.md
                ├── connect-to-surrealdb-via-ngrok-tunnel.md
                ├── define-a-schema-in-surrealdb.md
                ├── dokku-surrealdb.md
                ├── getting-started-with-surrealdb-future-of-cloud-databases-maybe.md
                ├── getting-started-with-surrealdb-using-python-and-docker.md
                ├── getting-started-with-surrealdb.md
                ├── gke-using-terraform.md
                ├── hosting-surreal-db-in-rust-in-less-than-3-minutes.md
                ├── how-to-use-surrealdb-with-the-fresh-framework-and-deno.md
                ├── improve-database-management-with-surrealdb.md
                ├── integrate-auth0-as-an-authentication-provider.md
                ├── integrate-aws-cognito-as-an-authentication-provider.md
                ├── iot-telemetry-example.md
                ├── kards-social-foss-social-media-app.md
                ├── kysely-surrealdb.md
                ├── langchain-integration.md
                ├── livestream-series-documenting-learning-surrealdb.md
                ├── make-a-genai-chatbot-using-graphrag-with-surrealdb-langchain.md
                ├── medical-graphrag-chatbot-rust-langchain.md
                ├── minimal-langchain-chatbot-example-with-vector-and-graph.md
                ├── nextjs-surrealdb-demo-basic-blog-that-serves-as-a-demo-template-for-your-nextjs-surrealdb-project.md
                ├── playrbase-event-player-management-system.md
                ├── pterodactyl-egg.md
                ├── pysurrealdb.md
                ├── ra-surrealdb.md
                ├── rust-powered-database-surrealdb-its-pretty-ambitious-code-to-the-moon.md
                ├── semantic-search-rust-using-mistralai.md
                ├── semantic-search-rust-using-openai.md
                ├── simple-api-with-gingonic-and-surrealdb-go.md
                ├── sirqle.md
                ├── smig.md
                ├── starter-kit-for-surrealdb-tauri-next-js.md
                ├── surreal-4o-fine-tuned-model-datasets-for-surrealql-queries-project-to-create-structured-datasets-for-openai.md
                ├── surreal-codegen.md
                ├── surreal-id.md
                ├── surreal-transfer.md
                ├── surreal-ts.md
                ├── surrealdb-1.md
                ├── surrealdb-admin.md
                ├── surrealdb-ai-assistant.md
                ├── surrealdb-ai-docs-retrieval-project-to-showcase-how-to-build-a-gpt-based-question-answering-system-on-top-of-surrealdb-docs.md
                ├── surrealdb-as-a-vector-store-for-langchain-a-jupyter-notebook-demonstrating-how-to-use-surrealdb-as-a-vector-store.md
                ├── surrealdb-c.md
                ├── surrealdb-client-generator.md
                ├── surrealdb-cloudflare.md
                ├── surrealdb-cr.md
                ├── surrealdb-erlang.md
                ├── surrealdb-explorer.md
                ├── surrealdb-extras.md
                ├── surrealdb-fastapi-nextjs-starter.md
                ├── surrealdb-flask-starter.md
                ├── surrealdb-flutter.md
                ├── surrealdb-fundamentals-course-official-course-to-efficiently-learn-surrealdb-in-3-hours.md
                ├── surrealdb-github-action.md
                ├── surrealdb-go-driver-starter.md
                ├── surrealdb-go.md
                ├── surrealdb-grafana-datasource.md
                ├── surrealdb-in-100-seconds.md
                ├── surrealdb-java.md
                ├── surrealdb-js.md
                ├── surrealdb-koa-starter-rest-api.md
                ├── surrealdb-mcp-server.md
                ├── surrealdb-migrations-action.md
                ├── surrealdb-migrations.md
                ├── surrealdb-net.md
                ├── surrealdb-node.md
                ├── surrealdb-nuxt-3-starter.md
                ├── surrealdb-odatav4-connector.md
                ├── surrealdb-php.md
                ├── surrealdb-presence-demo-demo-project-on-how-to-create-a-realtime-presence-web-application-using-surrealdb-live-queries.md
                ├── surrealdb-py.md
                ├── surrealdb-react-nodejs-starter.md
                ├── surrealdb-rocket.md
                ├── surrealdb-rust-embedded-database-quick-tutorial.md
                ├── surrealdb-sandbox-an-offline-browser-based-playground-for-experimenting-with-surrealdb.md
                ├── surrealdb-solidstart-starter.md
                ├── surrealdb-spring-client.md
                ├── surrealdb-springboot.md
                ├── surrealdb-streamlit-starter.md
                ├── surrealdb-surrealdb.md
                ├── surrealdb-sveltekit-auth-example.md
                ├── surrealdb-sveltekit-starter.md
                ├── surrealdb-sveltekit.md
                ├── surrealdb-the-kitchen-sink-document-store-that-might-dethrone-firebase.md
                ├── surrealdb-valibot.md
                ├── surrealdb-vector-store-for-langchain.md
                ├── surrealdb-vue-blog-starter.md
                ├── surrealdb-vue-starter.md
                ├── surrealdb-wasm.md
                ├── surrealdb-x-openai-example-of-rag-using-surrealdb-and-openai.md
                ├── surrealdb-zod.md
                ├── surrealdb.md
                ├── surrealdb_dsl.md
                ├── surrealdb_extra.md
                ├── surrealdb_migration_engine.md
                ├── surrealdb_query_builder.md
                ├── surrealised.md
                ├── surrealist-1.md
                ├── surrealist.md
                ├── surrealml-vs-pytorch-vs-onnx-benchmarking-the-performance-of-surrealml-against-pytorch-and-onnx-vladimir-rotariu.md
                ├── surrealreact.md
                ├── sveltekit-surreal-database-authentication.md
                ├── tour-of-surrealdb-course-to-learn-basics-in-30-minutes.md
                ├── type-surrealdb.md
                ├── unlocking-surrealdb-building-a-real-world-multi-tenant-rbac-system-made-easy-4-part-series.md
                ├── unreal-orm.md
                ├── use-surrealdb-in-github-actions.md
                ├── use-surrealdb-with-langchain.md
                ├── using-surrealdb-to-prove-football-statistics.md
                └── working-with-surrealdb-over-http-via-postman.md

================================================
FILE: README.md
================================================

<p align="center">
    <a href="https://surrealdb.com#gh-dark-mode-only" target="_blank">
        <img width="300" src="src/assets/img/logo/dark/logo.svg" alt="SurrealDB Logo">
    </a>
</p>

<h3 align="center">
    <a href="https://surrealdb.com#gh-dark-mode-only" target="_blank">
        <img src="src/assets/img/logo/dark/text.svg" height="15" alt="SurrealDB">
    </a>
    is the ultimate cloud <br> database for tomorrow's applications
</h3>

<h3 align="center">Develop easier. &nbsp; Build faster. &nbsp; Scale quicker.</h3>

<br>

<p align="center">The documentation for <a href="https://github.com/surrealdb/surrealdb" target="_blank">SurrealDB</a>, built using <a href="https://astro.build/" target="_blank">Astro</a>.</p>

<p align="center">If you want to contribute, then please read the <a href="https://github.com/surrealdb/docs.surrealdb.com/blob/main/CONTRIBUTING.md" target="_blank">contributing guidelines</a>.</p>

<br>

<p align="center">
    <a href="https://surrealdb.com/discord"><img src="https://img.shields.io/discord/902568124350599239?label=discord&style=flat-square&color=5a66f6"></a>
    &nbsp;
    <a href="https://twitter.com/surrealdb"><img src="https://img.shields.io/badge/twitter-follow_us-1d9bf0.svg?style=flat-square"></a>
    &nbsp;
    <a href="https://dev.to/surrealdb"><img src="https://img.shields.io/badge/dev-join_us-86f7b7.svg?style=flat-square"></a>
    &nbsp;
    <a href="https://www.linkedin.com/company/surrealdb/"><img src="https://img.shields.io/badge/linkedin-connect_with_us-0a66c2.svg?style=flat-square"></a>
    &nbsp;
    <a href="https://www.youtube.com/channel/UCjf2teVEuYVvvVC-gFZNq6w"><img src="https://img.shields.io/badge/youtube-subscribe-ff0000.svg?style=flat-square"></a>
</p>

<p align="center">
    <a href="https://surrealdb.com/blog"><img height="25" src="src/assets/img/logo/dark/blog.svg" alt="Blog"></a>
    &nbsp;
    <a href="https://github.com/surrealdb/surrealdb"><img height="25" src="src/assets/img/logo/dark/github.svg" alt="Github	"></a>
    &nbsp;
    <a href="https://www.linkedin.com/company/surrealdb/"><img height="25" src="src/assets/img/logo/dark/linkedin.svg" alt="LinkedIn"></a>
    &nbsp;
    <a href="https://twitter.com/surrealdb"><img height="25" src="src/assets/img/logo/dark/twitter.svg" alt="Twitter"></a>
    &nbsp;
    <a href="https://www.youtube.com/channel/UCjf2teVEuYVvvVC-gFZNq6w"><img height="25" src="src/assets/img/logo/dark/youtube.svg" alt="Youtube"></a>
    &nbsp;
    <a href="https://dev.to/surrealdb"><img height="25" src="src/assets/img/logo/dark/dev.svg" alt="Dev"></a>
    &nbsp;
    <a href="https://surrealdb.com/discord"><img height="25" src="src/assets/img/logo/dark/discrod.svg" alt="Discord"></a>
    &nbsp;
    <a href="https://stackoverflow.com/questions/tagged/surrealdb"><img height="25" src="src/assets/img/logo/dark/stack-overflow.svg" alt="StackOverflow"></a>
</p>

<br>

## Table of Contents

- [Getting Started with SurrealDB](#getting-started-with-surrealdb)
- [Learn SurrealDB](#learn-surrealdb)
- [Contributing to the Documentation](#contributing-to-the-documentation)
  - [Good First Issues](#good-first-issues)
- [Installation](#installation)
- [Contributing Lab Content](#contributing-lab-content-to-surrealdb-documentation)
  - [Overview](#overview)
  - [Prerequisites](#prerequisites)
  - [Creating a New Lab](#creating-a-new-lab)
    - [Using the Lab Creation Tool](#using-the-lab-creation-tool)
- [Categories](#categories)
- [Topics](#topics)
- [Best practices](#best-practices)
- [Submitting your contribution](#submitting-your-contribution)
- [Review process](#review-process)
- [Need help?](#need-help)
- [Development](#development)
- [Building](#building)
- [Adding a new doc](#adding-a-new-doc)
- [File structure](#file-structure)
- [Linting](#linting)


## Getting started with SurrealDB

Visit [surrealdb.com/docs](https://surrealdb.com/docs/surrealdb/) to get started with SurrealDB. 


## Learn SurrealDB

- SurrealDB University: https://surrealdb.com/learn/fundamentals
- Aeon's Surreal Renaissance (Interative book): https://surrealdb.com/learn/book
- Documentation: https://surrealdb.com/docs


## Contributing to the documentation

Please see our [contributing guidelines](/CONTRIBUTING.md).

### Good First Issues

We have a list of [good first issues](https://github.com/surrealdb/docs.surrealdb.com/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22) that contain bugs that have a relatively limited scope. This is a great place to get started, gain experience, and get familiar with our contribution process.

## Installation

To get started with contributing to the SurrealDB documentation, first install the required packages using the following command. 

> This project uses [Bun](https://bun.sh/) as our package manager. If you haven't installed Bun yet, then please see the [installation guide](https://bun.sh/docs/installation) for your operating system. It also requires Node.js v20.0.0 or higher.

```bash
bun i 
```

## Contributing Lab content to SurrealDB Documentation

## Overview
Labs are a collection of community and official content that helps users learn and work with SurrealDB. This guide will help you contribute your own lab content to the documentation.

## Prerequisites
- [Bun](https://bun.sh/) installed on your system
- A GitHub account
- Basic knowledge of Markdown

## Creating a new Lab

### Using the Lab creation tool
The easiest way to create a new lab is using the built-in tool:

1. Clone the repository and install dependencies:

```bash
git clone https://github.com/surrealdb/docs.surrealdb.com.git
cd docs.surrealdb.com
bun install
```

2. Run the lab creation tool:

```bash
bun run make:lab
```

3. Follow the interactive prompts to provide:
   - Lab name (required)
   - URL (optional) - Link to your project/repository
   - Category (required) - Choose from:
     - CI/CD
     - Demos
     - Deployment Tools
     - Development Tools
     - Docker Images
     - Integrations
     - Libraries
     - SDKs
     - Templates
     - Tutorials
     - Videos
   - Topics (optional) - Select one or more from:
     - AI
     - Data Management
     - Embedding
     - Security
     - Examples
     - Optimisation
     - Beginner
   - Author name (required)
   - Author role (required for community content)

### Manual creation

Alternatively, you can create a lab manually by creating a new Markdown file in [`src/content/labs-items/`](https://github.com/surrealdb/docs.surrealdb.com/tree/main/src/content/labs-items) with the following structure:

```markdown
---
title: "Your Lab Title"
url: "https://your-project-url.com"  # Optional
category: "Category Name"  # Must be one of the predefined categories
topics:  # Optional
  - Topic1
  - Topic2
author:
  name: "Your Name"
  role: "Your Role"
  avatar: "your-name-slug"  # Will be automatically generated
---

Your lab content here...
```

> For the author avater field, you will also need to upload an avatar to /src/assets/img/labs-authors with the same file name as the author property in the lab markdown

## Content guidelines

### Categories
Choose the most appropriate category for your lab:
- **CI/CD**: Continuous integration and deployment tools
- **Demos**: Example applications and demonstrations
- **Deployment Tools**: Tools for deploying SurrealDB
- **Development Tools**: Tools for development workflow
- **Docker Images**: Docker-related resources
- **Integrations**: Third-party integrations
- **Libraries**: Code libraries and packages
- **SDKs**: Software development kits
- **Templates**: Project templates and starters
- **Tutorials**: Step-by-step guides
- **Videos**: Video content and tutorials

### Topics
Select relevant topics to help users find your content:
- **AI**: Artificial Intelligence related content
- **Data Management**: Data handling and management
- **Embedding**: Embedding-related features
- **Security**: Security features and best practices
- **Examples**: Code examples and snippets
- **Optimisation**: Performance optimization
- **Beginner**: Content suitable for beginners

## Best practices

1. **Title**: Choose a clear, descriptive title that reflects the content. Keep it short and concise for better readability
2. **Content** (Only required when no URL is provided):
   - Start with a brief introduction
   - Include clear instructions
   - Add code examples where relevant
   - Include screenshots or diagrams if helpful
3. **URL**: If your lab has an associated project, include the URL
4. **Author Information**: 
   - Use your real name
   - Provide a clear role description
   - For official SurrealDB content, use "surrealdb" as the author name

## Submitting your contribution

1. Create a new branch for your lab
2. Add your lab content
3. Commit your changes
4. Push to your fork
5. Create a pull request

## Review process

Your lab will be reviewed for:
- Technical accuracy
- Content quality
- Adherence to guidelines
- Proper categorisation and topics

## Need help?

If you need assistance or have questions:
- [Open an issue in the repository](https://github.com/surrealdb/docs.surrealdb.com/issues)
- [Join the SurrealDB community channels](https://discord.com/invite/surrealdb)
- [Check existing labs for examples](/docs/labs)

Remember, your contribution helps the SurrealDB community grow and learn. Thank you for contributing!


## Development

The following command starts a local development server and opens up a browser window. Most changes are reflected live without having to restart the server.

```
bun dev
```

### Railroad diagrams (reusable)

This repo includes a reusable helper to generate SVG railroad diagrams using the JS library by Tab Atkins ([JS README](https://tabatkins.github.io/railroad-diagrams/README-js.html), [project page](https://tabatkins.github.io/railroad-diagrams/)).

- Utility: `src/util/railroad.ts`
- Component: `src/components/RailroadDiagram.astro`
- CSS: included from the `railroad-diagrams` package

Usage in MDX/Markdown (Astro Content):

```mdx
import RailroadDiagram from "../../components/RailroadDiagram.astro";

export const ast = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Start", startType: "simple", label: "statement" },
    {
      type: "Sequence",
      children: [
        { type: "NonTerminal", text: "ACCESS" },
        { type: "Choice", index: 1, children: [
          { type: "Terminal", text: "ON" },
          { type: "Terminal", text: "TO" }
        ]},
        { type: "NonTerminal", text: "resource" },
      ]
    },
    { type: "End" }
  ]
};

<RailroadDiagram ast={ast} className="my-6" />
```

You can also compose diagrams directly with the library and pass a prebuilt diagram to the helper functions in `src/util/railroad.ts` if needed.

## Building

The following command builds and generates static content into the `build` directory, and can then be served using any static contents hosting service.

```
bun run build
```

## Adding a new doc

**READ VERY CAREFULLY**

When adding a new doc, you MUST update redirect logic <br />
If this does not happen, you'll get endless redirects :D <br />
In: project://aws/viewer-request/index.js#4

## File structure

To contribute to the documentation, most of your changes will be made to the `src/content` directory. Each section of the documentation has its own subdirectory, and each page is an MDX file. 

```md
src/
    assets/
    components/
    content/
        doc-surrealdb/
        doc-surrealql/
        doc-surrealist/
        ...
    layouts/
    pages/
    styles/
    util/ 
```

## Linting

To ensure the documentation is consistent and follows our style guide, we use `make qc` to check for linting errors. You can also use `make qa` to automatically fix most of the errors. 

Here are the commands for some of the common commands you may need to use.

- `make install` - Install dependencies, first time or when they change
- `make dev` - Run a development server
- `make build` - Build the website
- `make preview` - Preview a build you made
- `make qc` - Check code quality (fmt + lint)
- `make qa` - Apply safe code quality suggestions
- `make qau` - Apply (un)safe code quality suggestions



================================================
FILE: src/components/Tabs/LICENSE.md
================================================
MIT License

Copyright (c) 2023 [Astro contributors](https://github.com/withastro/starlight/graphs/contributors)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
FILE: src/content/doc-cloud/architecture.mdx
================================================
---
sidebar_position: 2
sidebar_label: SurrealDB Cloud Architecture
title: SurrealDB Cloud Architecture | SurrealDB Cloud 
description: In this section, we will explore the SurrealDB Cloud architecture and how it is designed to provide a scalable, high-performance, and secure database solution.
no_page_headings: true
---

import Image from "@components/Image.astro";
import LightStartSingleNode from "@img/image/cloud/light/start-single-node-light.png";
import DarkStartSingleNode from "@img/image/cloud/start-single-node.png";
import LightStartMultiNode from "@img/image/cloud/light/enterprise-multi-node-light.png";
import DarkStartMultiNode from "@img/image/cloud/enterprise-multi-node.png";

# Cloud architecture

SurrealDB Cloud benefits from [SurrealDB’s layered architecture](/docs/surrealdb/introduction/architecture), which separates storage from compute, enabling improved scalability, durability and availability without the need to operate, manage, scale or shard your database.

## Start
For development, and staging applications with vertically-scalable requirements. SurrealDB Cloud Start provides users with dedicated storage and a single-node for compute which can scale vertically.

<Image
alt="SurrealDB Cloud architecture"
src={{
	light: LightStartSingleNode,
	dark: DarkStartSingleNode,
	}}  
/>

## Dedicated

For large-scale, mission-critical applications. Dedicated environment horizontal and vertical scalability, providing fault-tolerant and highly scalable deployments, without the need to shard your database.

<Image
alt="SurrealDB Cloud architecture"
src={{
	light: LightStartMultiNode,
	dark: DarkStartMultiNode,
	}}  
/>

> [!IMPORTANT]
> In the future, we plan to offer an option to launch multiple instances against a centralised storage layer together with autoscaling. These features will allow customers to, for example, have one production instance autoscaling running 24x7 for the main transactional part of the application and have different data & analytics teams querying the same centralised storage layer with their own individual compute needs (e.g. higher memory or GPU) meaning they can run only when needed for the specific query.

To learn more about the plans, please refer to the [Pricing](/pricing) page.



================================================
FILE: src/content/doc-cloud/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: What is SurrealDB Cloud ?
title: What is SurrealDB Cloud ? | Introduction
description: SurrealDB Cloud redefines the database experience, offering the power and flexibility of SurrealDB without the pain of managing infrastructure. Elevate your business to unparalleled levels of scale and resilience. Focus on building tomorrow's applications. Let us take care of the rest.
no_page_headings: true
---

import { Icon } from 'astro-icon/components';
import Image from "@components/Image.astro";

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

import CloudImageLight from '@img/image/cloud/light/cloud-light.png';
import CloudImageDark from '@img/image/cloud/cloud-dark.png';

import LightCloud from '@img/icon/light/cloud-light.png';
import DarkCloud from '@img/icon/dark/cloud.png';

import HighlyAvailable from '@img/image/cloud/light/highly-available-and-scalable-light.png';
import HighlyAvailableDark from '@img/image/cloud/highly-available-and-scalable-dark.png';

<div class="flag-title">
	<Image
		class="size-11 my-auto"
		width={300}
		alt="SurrealDB Cloud "
		src={{
			light: LightCloud,
			dark: DarkCloud,
		}}
	/>
	# What is SurrealDB Cloud ?
</div>

{/* <p>
	SurrealDB Cloud redefines the database experience, offering the power and flexibility of SurrealDB without the pain of managing infrastructure. Elevate your business to unparalleled levels of scale and resilience. Focus on building tomorrow's applications. Let us take care of the rest.
</p>

<p>
	Designed to be lightweight, the SurrealDB Cloud product leverages the Open-Source SurrealDB product as much as possible. Its features are intended to complement those of the open-source version and offer you a seamless deployment experience.
</p> */}

SurrealDB Cloud transforms the database experience, providing the power and versatility of SurrealDB without the complexity of managing infrastructure. Whether you’re building for passion projects or enterprise-scale applications, SurrealDB Cloud offers the scalability, resilience, and innovation you need to stay ahead.

Enjoy a fully managed solution that takes the hassle out of infrastructure operations. With SurrealDB’s ACID compliance, you can confidently run transactions at scale across multiple environments, ensuring data integrity and reliability.

Designed to support your growth, SurrealDB Cloud scales effortlessly [from prototypes to large-scale deployments](/docs/cloud/getting-started/create-an-instance). By leveraging centralized data, it enables departments or teams to work efficiently while maintaining consistent data integrity and reducing redundancy.

Our transparent and [predictable pricing](/pricing) ensures you only pay for what you need.

<a
	href="/docs/cloud/getting-started"
	class="gradient-button group mt-2"
>
	Get started with SurrealDB Cloud 
	<Icon name="fa6-solid:arrow-right" class="w-4 transition-transform group-hover:translate-x-1" />
</a>


<iframe
	width="100%"
	src="https://www.youtube.com/embed/S04qOKkVcmE?si=6tOcQyeXPTzcR8JS"
	title="Getting Started with SurrealDB Cloud "
	frameborder="0"
	allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
	referrerpolicy="strict-origin-when-cross-origin"
	style={{ aspectRatio: 1.7, paddingTop: '20px' }}
	class="mt-8"
	allowfullscreen
></iframe>

## What can you do? 

When using SurrealDB Cloud , you can connect to your SurrealDB instance with a few clicks. You can connect to any SurrealDB instance via Surrealist, the command-line interface, and any of the supported SDKs. 


<div className="flex flex-col items-start justify-between">
  <div className="w-full">
    <Tabs groupId="What can you do">
      <TabItem value="Create an instance" label="Create an instance" default>
        <div className="flex flex-col md:flex-row items-start justify-between">
          <div className="flex-1">
            SurrealDB Cloud allows you to connect to your SurrealDB instance with just a few clicks. You can create an instance, connect to it, and start building your application.

            <h4>1. Create Instance.</h4>

            When creating an instance, you will enter the instance name and organization to ensure that you can easily identify your instance. Finally, you can select the version of SurrealDB to use and the region to deploy your instance.

            <h4>2. Select a region.</h4>

            Once you have created your instance, you can select the region to deploy your instance. This will allow you to connect to your instance from anywhere in the world.

            <h4>3. Select an Instance preset.</h4>

            Once you have selected a region, you can select an instance preset. This will allow you to select the instance size and type to best suit your needs.

            <h4>4. Finalize and connect to your Instance.</h4>

            Once you have created your instance, you can connect to it from anywhere in the world. You can connect to your instance from anywhere in the world.
          </div>
          
        </div>
      </TabItem>
      <TabItem value="Connect to your instance" label="Connect to your instance">
        <div className="flex flex-col md:flex-row items-start justify-between">
          <div className="flex-1 text-left">
            You can connect to any SurrealDB Cloud Instance via [Surrealist](/docs/cloud/connect/surrealist), the [command-line interface (CLI)](/docs/cloud/connect/cli), and [any of the supported SDKs](/docs/cloud/connect/sdk).

            <h4>[Connect via Surrealist](/docs/cloud/connect/surrealist)</h4>

            Since SurrealDB Cloud is closely integrated with Surrealist, you can execute queries directly from the interface. This allows you to interact with your data in real time, without having to switch between different tools.

            <h4>[Connect via CLI](/docs/cloud/connect/cli)</h4>

            If you prefer to use a command-line interface, you can use the SurrealDB CLI to connect to your instance. This connection includes a token that is used to authenticate your connection.

            To do so, select the connect with the CLI option and copy the command.

            <h4>[Connect via SDK](/docs/cloud/connect/sdk)</h4>

            You can also connect to your instance using any of the supported SDKs. In your preferred SDK, use the connect method and pass in your instance endpoint.
          </div>
        </div>
      </TabItem>
    </Tabs>
  </div>
</div>





================================================
FILE: src/content/doc-cloud/advanced-topics/configure-an-instance.mdx
================================================
---
sidebar_position: 2
sidebar_label: Configure an Instance
title: Configure an Instance
description: SurrealDB Cloud is a hosted version of SurrealDB, providing a fully managed, scalable, and secure database solution. This guide will help you migrate your existing SurrealDB Instance to SurrealDB Cloud .
---

import Image from "@components/Image.astro";
import LightConfigure from "@img/image/cloud/configure-dark.png";
import DarkConfigure from "@img/image/cloud/configure-dark.png";
import InstanceType from "@img/image/cloud/change-instance-type-1.png";
import InstanceTypeModal from "@img/image/cloud/change-to-production.png";
import InstanceUsage from "@img/image/cloud/view-instance-usage.png";
import DeleteInstance from "@img/image/cloud/delete-instance.png";
import InstanceCapabilities from "@img/image/cloud/instance-capabilities.png";


# Configure an Instance

After you have created an Instance, you can configure it to your needs. This includes changing the Instance type, compute nodes, and capabilities. To do this, click on the **Configure Instance** button on the Instance card; this will open up a configuration drawer.

## Instance Configuration

In the Instance configuration drawer, you can change the following settings:

- **Capabilities**: the capabilities of the Instance, this controls the functionality available to users such as scripting, guest access, enabled endpoints for RPC and HTTP endpoints. You can also opt into beta features and restrict access to specific resources.
- **Version**: the version of SurrealDB that will be used for the Instance. If you a new version is available, you will be prompted to upgrade and also see the release notes.


### Instance capabilities

The capabilities you choose will determine the features available to your Instance. This includes scripting, guest access, enabled endpoints for RPC and HTTP and more. For RPC methods, HTTP endpoints and preview features, you can leave pick one of the following options:

- **Allow all by default**: All endpoints are allowed by default and you can then select which endpoints to deny.
- **Deny all by default**: All endpoints are denied by default and you can then select which endpoints to allow.

On the other hand network access and functions provide a more granular control over the endpoints. 

> [!IMPORTANT]
> Learn more about configuring [network access](/docs/cloud/advanced-topics/network-access) in the advanced topics section.

<Image
alt="Configure an Instance"
src={{
	light: LightConfigure,
	dark: DarkConfigure,
	}}  
/>

{/* <Image
alt="Configure an Instance"
src={{
	light: InstanceCapabilities,
	dark: InstanceCapabilities,
	}}  
/>


<Image
alt="Instance Usage"
src={{
	light: InstanceUsage,
	dark: InstanceUsage,
	}}  
/> */}


## Upgrade Instance

To upgrade an Instance, you can click the **Upgrade now** button on the Instance card. This will open a modal to select the tier you want to upgrade to as shown below. Depending on the tier you choose, and the resources you have allocated, you will be billed accordingly. When you click this button, you will have the following options:

- **Instance type**: the type of the Instance.
- **Storage capacity**: the size of the storage disk

### Instance type

While the Instance type you choose will determine the compute and memory available to your Instance. Before you hit the limit of your current plan, you can upgrade your plan to a higher tier using this option. 

First, select the **Instance type** option which will open a modal to select the tier you want to upgrade to as shown below. Depending on the tier you choose, and the resources you have allocated, you will be billed accordingly.

<Image
alt="Instance Type"
src={{
	light: InstanceType,
	dark: InstanceType,
	}}  
/>


### Storage capacity

The storage capacity is the amount of storage available to your Instance. This is used to store the database files and can be increased at any time. For paid plans, you can increase the storage capacity up to the maximum limit of your plan.

> [!IMPORTANT]
> Storage expansion is unavailable for free instances. Upgrade your instance to unlock the ability to increase your storage capacity.

<Image
alt="Instance Usage"
src={{
	light: InstanceUsage,
	dark: InstanceUsage,
	}}  
/> 

## Pause or Delete an Instance 

From the overview page, you can delete an Instance by clicking the option button on the Instance card and selecting **Delete**. This will bring up a confirmation modal. Once confirmed, the Instance will be deleted.

To pause an Instance, click the option button on the Instance card and select **Pause**. This will bring up a confirmation modal. Once confirmed, the Instance will be paused.


<Image
alt="Delete an Instance"
src={{
	light: DeleteInstance,
	dark: DeleteInstance,
	}}  
/>



================================================
FILE: src/content/doc-cloud/advanced-topics/data-export-and-backup.mdx
================================================
---
sidebar_position: 1
sidebar_label: Backup and restore
title: Data Export & Backup
description: Learn how to export and backup your SurrealDB Cloud instance data for external storage and disaster recovery.
---

import Image from "@components/Image.astro";
import BackupLight from "@img/image/cloud/backup.png";
import BackupDark from "@img/image/cloud/backup.png";
import RestoreLight from "@img/image/cloud/restore.png";
import RestoreDark from "@img/image/cloud/restore.png";

# Backup and restore

This section covers the backup and restore options for your SurrealDB Cloud Instance and the process of selecting a backup strategy. It also covers your responsibilities for backing up data stored in your SurrealDB Cloud instance and the available options for data export and recovery.

## Backup

SurrealDB Cloud provides a robust backup and restore solution for your SurrealDB Cloud instance. You can backup your data to a local file or to an external storage location. You can also restore your data from a backup file.

> [!IMPORTANT]
> Automated backups are not available for free Instances. To enable automated backups, you must upgrade to a [paid plan](/pricing). This gives you access to restore your data from a backup file.

### Restoring from a backup 

In the resources section of the Instance dashboard, you can access the list of all your available backups. To restore from a backup, click the **Create from selected** button on the backup you want to restore from. 

<Image
alt="Restoring from a backup"
src={{ 
	light: BackupLight,
	dark: BackupDark,
	}}  
/>


This will will take you to the [create a new Instance ](/docs/cloud/getting-started/create-an-instance#create-from-selected) page with the backup option already selected.

<Image
alt="Restoring from a backup"
src={{ 
	light: RestoreLight,
	dark: RestoreDark,
	}}  
/>

You can also view a list of all available backups from the backup select dropdown in the Instance creation page.

## Limitations of the backup and restore feature

- The source and restore instance must be in the same region
- It is not possible to restore a backup into an existing (or the same) Instance
- The storage of the restore Instance must be equal or greater than the source Instance

## Next Steps

- [Configure an Instance](/docs/cloud/advanced-topics/configure-an-instance)
- [Network Access](/docs/cloud/advanced-topics/network-access)
- [Migrating Data](/docs/cloud/advanced-topics/migrating-data)




================================================
FILE: src/content/doc-cloud/advanced-topics/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Advanced topics
title: Advanced topics | SurrealDB Cloud 
description: In this section you will explore the advanced topics for navigating SurrealDB Cloud in Surrealist.
---

# Advanced topics

In this section you will explore the following advanced topics for navigating SurrealDB Cloud in Surrealist :

- [Configure an Instance](/docs/cloud/advanced-topics/configure-an-instance)
- [Manage Organisation permissions](/docs/cloud/advanced-topics/manage-organisation-permissions)
- [Migrating data](/docs/cloud/advanced-topics/migrating-data)
- [Data Export & Backup](/docs/cloud/advanced-topics/data-export-and-backup)
- [Search and shortcuts](/docs/cloud/advanced-topics/search-and-shortcuts)
- [SurrealQL editor](/docs/cloud/advanced-topics/surrealql-editors)


## Next steps 

Explore the advanced topics for navigating SurrealDB Cloud in Surrealist in detail. 



================================================
FILE: src/content/doc-cloud/advanced-topics/manage-organisation-permissions.mdx
================================================
---
sidebar_position: 3
sidebar_label: Manage Organisation permissions
title: Manage Organisation permissions
description: Learn how to manage the permissions of your Organisation in SurrealDB Cloud . 
---

# Manage Organisation permissions

SurrealDB Cloud allows you to manage the permissions of your Organisation. This includes adding members to your Organisation, removing members, and changing their permissions (as an owner). In this section, we will go through the different roles and permissions that are available in SurrealDB Cloud .


## Role permissions

In an Organisation, by default the creator of the Organisation is the owner. The owner can invite new members to the Organisation and change their permissions. In inviting a new member they can be assigned a role of admin or member. The following chart shows the different permissions assigned to each role.



<table style={{ width: '100%' }}>
  <thead>
    <tr>
      <th>Role</th>
      <th>Description</th>
      <th>Permissions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong style={{ whiteSpace: 'nowrap' }}>Owner</strong></td>
      <td>The owner of the Organisation</td>
      <td>
        <ul>
          <li>Can manage the Organisation instances, team, usage and billing information</li>
          <li>Can access Instance capabilities</li>
          <li>Can invite and remove members from the Organisation</li>
          <li>Can change the permissions of other members</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong style={{ whiteSpace: 'nowrap' }}>Admin</strong></td>
      <td>An admin of the Organisation</td>
      <td>
        <ul>
          <li>Can do everything an owner can do except for managing the [billing information](/docs/cloud/billing-and-support/billing) or update other users permissions</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong style={{ whiteSpace: 'nowrap' }}>Member</strong></td>
      <td>A member of the Organisation</td>
      <td>
        <ul>
          <li>Can only view the existing Organisation instances, team. Within the team they can only remove themselves</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

> [!NOTE]
> In the future we will allow users to control permissions granularly for each user, create new roles and manage permissions for each role. 


================================================
FILE: src/content/doc-cloud/advanced-topics/migrating-data.mdx
================================================
---
sidebar_position: 4
sidebar_label: Migrating data
title: Migrating Data to SurrealDB Cloud 
description: SurrealDB Cloud is a hosted version of SurrealDB, providing a fully managed, scalable, and secure database solution. This guide will help you migrate your existing SurrealDB instance to SurrealDB Cloud .
---

# Migrating data from SurrealDB to SurrealDB Cloud 

SurrealDB Cloud is a hosted version of SurrealDB, providing a fully managed, scalable, and secure database solution. This guide will help you migrate your existing SurrealDB Instance to SurrealDB Cloud .


## Exporting and importing data

1. Export your current data as a `.surql` (SurrealQL) file. You can do this using the [`surreal export`](/docs/surrealdb/cli/export) command in the terminal:

```bash
# Example export command to export data to a file called `export.surql` in the downloads directory.
surreal export --conn <connection-url> --user root --pass secret --ns test --db test downloads/export.surql
``` 

2. This will create a file called `export.surql` in the current directory.

3. You can now import this file into your SurrealDB Cloud Instance.


```bash
surreal import --conn <connection-url> --user root --pass secret --ns test --db test downloads/export.surql
```



================================================
FILE: src/content/doc-cloud/advanced-topics/network-access.mdx
================================================
---
sidebar_position: 5
sidebar_label: Configure network access
title: Configure network access
description: SurrealDB Cloud provides a number of network capabilities to help you secure your database and data.
---

import Image from "@components/Image.astro";
import LightConfigure from "@img/image/cloud/network-access.png";
import DarkConfigure from "@img/image/cloud/network-access.png";

## Network access

Network access is a type of [Instance capability](/docs/cloud/advanced-topics/configure-an-instance#instance-capabilities) that allows you to control and manage how your SurrealDB Cloud Instance connects to external services and networks through [HTTP functions and requests](/docs/surrealql/functions/database/http). This capability enables you to make HTTP calls to external APIs and services directly from your database queries while maintaining control over which endpoints can be accessed.

With this feature, you can define precise rules that determine which network destinations your database can access. This helps protect your data, prevent unauthorized connections, and ensure compliance with your organization’s security policies.

In SurrealDB Cloud , network access lets you:

- Allow or deny outbound connections to specific domains, IP addresses, or ranges.
- Create custom policies that fit your infrastructure and security needs.

By leveraging network access, you gain full control over your database’s connectivity, reducing the risk of accidental data leaks or malicious activity.

> [!NOTE]
> Supported versions: `>=2.1.8, <2.2.0` or `>=2.2.6, <2.3.0` or `>=2.3.6`. If you are using a different version, you can still use network access, but you will need to manually upgrade to access the network access rules.


## Using network access in SurrealDB Cloud 

In your SurrealDB Cloud dashboard, you can easily configure and preview network access rules.

### Configure network access in SurrealDB Cloud 

To allow outgoing HTTP requests from your instance, you'll need to enable network access capability and configure allowed network patterns. Here's how to do it:

1.	Open the Network Access Section:In the SurrealDB Cloud dashboard, click on the **configure instance** button to open the instance configuration drawer. Here, you’ll find the **network access** option (set to Deny by default) to specify allowed and denied network patterns.

2.	Set Allowed and Denied Patterns:
    - Enter the domains, IP addresses, you wish to allow in the **Allowed by default** field.
    - Add any domains or IPs you want to block in the **Denied by default** field.

3. Click on **Apply capabilities** to save your changes. This will change your instance configuration. 

<Image
alt="Configure an Instance"
src={{
	light: LightConfigure,
	dark: DarkConfigure,
	}}  
/>

## Additional resources

Learn more about network access in the video tutorial below:

<iframe width="100%" src="https://www.youtube.com/embed/EUp5PxbzvV4?si=ezt6HhQuhhqHu9tU" title="
Network capabilities in SurrealDB Cloud " frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" style={{ aspectRatio: 1.7, paddingTop: '20px' }}
	class="mt-8" allowfullscreen></iframe>


================================================
FILE: src/content/doc-cloud/advanced-topics/search-and-shortcuts.mdx
================================================
---
sidebar_position: 6
sidebar_label: Search and shortcuts
title: SurrealDB Cloud | Search and shortcuts
description: In this section, you will learn about the search and shortcuts in Surrealist as it relates to the SurrealDB Cloud dashboard.
---

import Image from "@components/Image.astro";

import SearchAndShortcutsLight from "@img/image/surrealist/search-and-hot-key.png";
import SearchAndShortcutsDark from "@img/image/surrealist/search-and-hot-key.png";

# Search and shortcuts

Surrealist offers a range of shortcuts to help you navigate the interface more efficiently. You can find a list of all available shortcuts by pressing `Ctrl + K` or `Cmd + K` on your keyboard.

In the search modal, you can access all available shortcuts for open sessions, the views, all available tables in your connect database and the settings dialog.

<Image
alt="Search and Shortcuts"
src={{
    light: SearchAndShortcutsLight,
    dark: SearchAndShortcutsDark,
    }}
/>

<br/>

<br/>

<table>
    <thead>
        <tr>
            <th scope="col">Options</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Type">
                <code>Connections</code>
            </td>
            <td scope="row" data-label="Description">
                Open a list of all available connections and create a new connection type.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Views</code>
            </td>
            <td scope="row" data-label="Description">
                Open all available views in the current session. This can be the Cloud view, GraphQL view, Query view, Designer view or the Authentication view.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Tables</code>
            </td>
            <td scope="row" data-label="Description">
                Shows all available tables in the connected database. If you have no tables in the connection, load the Surreal Deal Store dataset, you can see the tables in the dataset.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Query</code>
            </td>
            <td scope="row" data-label="Description">
                See all saved queries, view the query history and create a new query. Comment out a line in the query editor using `Cmd + /` or `Ctrl + /`. 
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Explorer</code>
            </td>
            <td scope="row" data-label="Description">
                Import and export your database schema in a `.surql` file format.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Authentication</code>
            </td>
            <td scope="row" data-label="Description">
                Create user permissions and roles for your connected database.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>API Docs</code>
            </td>
            <td scope="row" data-label="Description">
                Access the SurrealDB API documentation and access snippets for your queries in different SDK languages.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Settings</code>
            </td>
            <td scope="row" data-label="Description">
                Access the Settings dialog to customise the appearance and behaviour of Surrealist.
                Increase the view size of your editor with `cmd + Option + +` or reduce with `cmd + Option + -`.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Navigator</code>
            </td>
            <td scope="row" data-label="Description">
                Reload the navigator to see all available shortcuts and open the search modal.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Developer</code>
            </td>
            <td scope="row" data-label="Description">
                Open a new connection and reset tour settings.
            </td>
        </tr>
    </tbody>
</table>





================================================
FILE: src/content/doc-cloud/advanced-topics/surrealql-editors.mdx
================================================
---
sidebar_position: 7
sidebar_label: SurrealQL editors
title: SurrealDB Cloud | SurrealQL Editors
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
---

# SurrealQL editors

Throughout Surrealist you will encounter various SurrealQL editors. These editors support intelligent SurrealQL highlighting and provide a range of features to help you write queries and edit records.

## Shortcuts

Editors support an array of useful shortcuts to help you navigate and edit more efficiently.

<table>
    <thead>
        <tr>
            <th scope="col">Shortcuts</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Shortcuts">
                <code>tab</code>
            </td>
            <td scope="row" data-label="Description">
                Indent the current line by 4 spaces.
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Shortcuts">
                <code>shift + tab</code>
            </td>
            <td scope="row" data-label="Description">
                Unindent the current line by 4 spaces.
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Shortcuts">
                <code>ctrl/cmd + f</code>
            </td>
            <td scope="row" data-label="Description">
                Open the search and replace panel
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Shortcuts">
                <code>ctrl/cmd + /</code>
            </td>
            <td scope="row" data-label="Description">
                Toggles comments on the selected or active line(s)
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Shortcuts">
                <code>ctrl/cmd + left click</code>
            </td>
            <td scope="row" data-label="Description">
                Place multiple cursors at the clicked locations
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Shortcuts">
                <code>ctrl/cmd + shift + L</code>
            </td>
            <td scope="row" data-label="Description">
                Selects all occurrences of the currently selected text
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Shortcuts">
                <code>ctrl/cmd + d</code>
            </td>
            <td scope="row" data-label="Description">
                Selects next occurrence of the currently selected text
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Shortcuts">
                <code>ctrl/cmd + enter</code>
            </td>
            <td scope="row" data-label="Description">
                Execute the query query (only applied to the query editor)
            </td>
        </tr>
	</tbody>
</table>

## Record inspection

Some editors support record inspection, which allows you to open a record in the Record inspector drawer by holding `ctrl/cmd` and left-clicking on a record id.

## JSON

Some editors, such as the record editor and query responses, support falling back to a JSON representation.
This can be configured in the Settings dialog under `Appearance > Value formatting mode`.


================================================
FILE: src/content/doc-cloud/advanced-topics/monitoring/index.mdx
================================================
---
sidebar_position: 4
sidebar_label: Monitoring
title: Monitoring | SurrealDB Cloud 
description: In this section you will learn how to monitor your SurrealDB Cloud Instance. 
---

# Monitoring

In this section you will learn how to monitor your SurrealDB Cloud Instance. You will learn how to view the metrics of your Instance and how to configure alerts. 

- [Metrics](/docs/cloud/advanced-topics/monitoring/metrics)
- [Logs](/docs/cloud/advanced-topics/monitoring/logs)




================================================
FILE: src/content/doc-cloud/advanced-topics/monitoring/logs.mdx
================================================
---
sidebar_position: 3
sidebar_label: Logs
title: Logs
description: Learn how to view the logs of your SurrealDB Cloud Instance. 
---

import Image from "@components/Image.astro";
import LightLogs from "@img/image/cloud/logs.png";
import DarkLogs from "@img/image/cloud/logs.png";

# Logs

In this section you will learn how to view the SurrealDB logs of your SurrealDB Cloud Instance. 

> [!NOTE]
> Currently, SurrealDB only supports activity logs for instance level events. Audit logs are not supported yet but will be in the future. 

## Viewing logs

To view the logs of your SurrealDB Cloud Instance, navigate to the **monitoring** tab in the sidebar. Under the **logs** option, you will see a list of logs for your SurrealDB Cloud Instance. 

<Image
alt="Configure an Instance"
src={{
	light: LightLogs,
	dark: DarkLogs,
	}}  
/>

## Filtering logs

While viewing the logs of your SurrealDB Cloud Instance, you can filter the logs by selecting the **filter** button. This will open a modal where you can select the logs you want to view. You can filter by the following:

- **Level**: this includes the level of the log.
- **Source**: this includes the source of the log.
- **Message**: this includes the message of the log.





================================================
FILE: src/content/doc-cloud/advanced-topics/monitoring/metrics.mdx
================================================
---
sidebar_position: 3
sidebar_label: Metrics
title: Metrics
description: Learn how to monitor the metrics of your SurrealDB Cloud Instance. 
---

import Image from "@components/Image.astro";
import LightMetrics from "@img/image/cloud/metrics.png";
import DarkMetrics from "@img/image/cloud/metrics.png";

# Metrics

In this section you will explore the different metrics that are available for your SurrealDB Cloud Instance. The following metrics are available for your SurrealDB Cloud Instance:

- **System**: this includes the compute and memory usage of your SurrealDB Cloud Instance. 
- **Connections**: this includes HTTP and RPC requests to your SurrealDB Cloud Instance. 
- **Network traffic**: this includes the network egress and ingress traffic to and from your SurrealDB Cloud Instance. 

To access the metrics of your SurrealDB Cloud Instance, navigate to the **monitoring** tab in the sidebar. Under the **metrics** option, you will see a list of metrics for your SurrealDB Cloud Instance. 

<Image
alt="Configure an Instance"
src={{
	light: LightMetrics,
	dark: DarkMetrics,
	}}  
/>

You will see a list of metrics for your SurrealDB Cloud Instance. 

### Filtering metrics

While viewing the metrics of your SurrealDB Cloud Instance, you can filter the metrics by selecting the **filter** button. This will open a modal where you can select the metrics you want to view. You can filter by the last hour, last 12 hours, last day, last week, and last month. 



================================================
FILE: src/content/doc-cloud/billing-and-support/billing.mdx
================================================
---
sidebar_position: 1
sidebar_label: Billing
title: Billing | SurrealDB Cloud 
description: Overview of SurrealDB Cloud and how to get started with it.
---

import Image from "@components/Image.astro";

import UpdateBillingLight from '@img/image/cloud/update-billing.png';
import UpdateBillingDark from '@img/image/cloud/update-billing.png';

# Billing

SurrealDB Cloud offers a flexible pricing model that allows you to pay only for the resources you use. The pricing is based on the amount of storage, compute power, and network bandwidth you consume, enabling you to scale your resources up or down based on your requirements.

You can manage your billing information and payment details in the Billing section of the SurrealDB Cloud dashboard.


## Update billing information

To update your billing information, you can click on the **Update** button on the top right corner of the billing information page.

<Image
alt="Update Billing"
src={{
	light: UpdateBillingLight,
	dark: UpdateBillingDark,
	}}
/>


## View payment details

To view your payment details, you can click on the **Billing** tab in the SurrealDB Cloud dashboard. This will display a comprehensive overview of your payment history, including past invoices, current charges, and upcoming payments. 

You can also see information about your payment method, billing cycle, and any active subscriptions or usage-based charges.


## Discount codes

If you have a discount code, you can enter it in the **Discount code** field on the billing page. This will apply the discount to your account and reduce the amount you owe.


## Referrals

The SurrealDB Cloud referral program allows you to benefit from every friend that signs up via a referral link.

1. Refer a friend by sharing your personalized referral link. You can find your personalized referral link [in the Billing dashboard](https://app.surrealdb.com/cloud/billing).
2. After your friend signs up, you will receive $10 of credit (up to a max of $50 or 5 referrals) and your friend will receive $25. In order to use your rewards you must enter your billing details.

## Invoices

You can view and download your payment invoices in the SurrealDB Cloud dashboard.

## Billing support

If you have any questions or need help with SurrealDB Cloud billing, please send an email to [support@surrealdb.com](mailto:support@surrealdb.com) outlining the nature of your query and we will help you.

> [!IMPORTANT]
> Please reach out using the email address associated with your SurrealDB Cloud account. You can find this by hovering over the Person icon in the top right hand corner within Surrealist.


================================================
FILE: src/content/doc-cloud/billing-and-support/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Billing and support
title: Billing and support | SurrealDB Cloud 
description: In this section you will explore the billing and support options for SurrealDB Cloud .
---

# Billing and support

In this section you will explore the following billing and support options for SurrealDB Cloud :

- [Billing](/docs/cloud/billing-and-support/billing)
- [Support](/docs/cloud/billing-and-support/support)



================================================
FILE: src/content/doc-cloud/billing-and-support/support.mdx
================================================
---
sidebar_position: 2
sidebar_label: Support
title: Support | SurrealDB Cloud 
description: Support offered by SurrealDB Cloud .
---
import Image from "@components/Image.astro";

import SurrealSidekickDark from '@img/image/cloud/sidekick.png';

# Support

SurrealDB Cloud offers a variety of tools, resources, and community channels to help you get started, enhance your skills, and resolve any issues you may encounter depending on your problem.

## Surreal Sidekick

Surreal Sidekick is an AI copilot that can help you get started with SurrealDB, convert queries to SurrealQL, and answer general questions. Surreal Sidekick is only trained with public facing resources, such as our [SurrealDB documentation](/docs/surrealdb), [SurrealDB University](/learn), and the [SurrealDB Book](/learn/book).

<Image
alt="Surreal Sidekick"
src={{
	light: SurrealSidekickDark,
	dark: SurrealSidekickDark,
	}}  
/>

### Getting started
To start using Surreal Sidekick, you'll need a [SurrealDB Cloud account](/docs/cloud/getting-started/create-an-account). Once logged in, navigate to Surreal Sidekick in the sidebar and start asking questions.

> [!WARNING]
>Surreal Sidekick, like any AI model, can occasionally provide incorrect information or hallucinate. We continuously improve our documentation and public resources to enhance Surreal Sidekick's accuracy. In accordance with our terms, please don’t submit any sensitive data.

## Account and billing support

For account or billing-related issues, you can raise a support ticket by emailing [support@surrealdb.com](mailto:support@surrealdb.com).

## Community support

Join our [Discord](https://discord.gg/surrealdb) community to connect with knowledgeable users and get help with your questions. Within the `#surreal-cloud` channel you can troubleshoot issues, ask for tips or chat with other SurrealDB Cloud users. 

Our team is active in the server too and can escalate more complex issues if needed.

## Additional support channels

If you need further assistance with your SurrealDB Cloud account, our community is here to help through our [Discord](https://discord.gg/surrealdb). 




================================================
FILE: src/content/doc-cloud/connect/cli.mdx
================================================
---
sidebar_position: 3
sidebar_label: Connect via CLI
title: Connect via CLI | SurrealDB Cloud 
description: Connect to your SurrealDB Cloud instance using the CLI and run queries.
---

import Image from "@components/Image.astro";

import OpenInCLI from '@img/image/cloud/open-in-cli.png';

# Connect via CLI

Once you have created a SurrealDB Cloud Instance, you can connect to it via CLI. The SurrealDB CLI lets you interact with your SurrealDB Cloud Instance from the command line.


## Prerequisites

Before connecting to your SurrealDB Cloud Instance using the CLI, you need to install the [SurrealDB CLI](/docs/surrealdb/installation).

## Connect to your SurrealDB Cloud Instance

Once it is installed, you can connect to your SurrealDB Cloud Instance using the [`surreal sql`](/docs/surrealdb/cli/sql) command. This command connects to your SurrealDB Cloud Instance using the specified endpoint and token. 

```bash
surreal sql --endpoint <endpoint> --ns <namespace> --db <database> --token <token>
```

<Image
alt="SurrealDB Cloud "
src={{
	light: OpenInCLI,
	dark: OpenInCLI,
	}}
/>

The `token` is a JSON Web Token (JWT) that is used to authenticate your connection to the SurrealDB Cloud Instance. You can find the token in the Instance details page in the SurrealDB Cloud console.

## Next steps

Learn more about the [SurrealDB CLI](/docs/surrealdb/cli) in the SurrealDB documentation.



================================================
FILE: src/content/doc-cloud/connect/http.mdx
================================================
---
sidebar_position: 5
sidebar_label: Connect via HTTP using cURL
title: Connect via HTTP using cURL | SurrealDB Cloud 
description: Connect to your SurrealDB Cloud instance using the HTTP API and run queries.
---

import Image from "@components/Image.astro";

import OpenInHTTPCurlLight from '@img/image/cloud/open-in-http.png';
import OpenInHTTPCurlDark from '@img/image/cloud/open-in-http.png';

# Connect via HTTP using cURL

SurrealDB Cloud supports connection via HTTP. This allows you to connect to your SurrealDB Cloud Instance using curl or any HTTP client. To get started, select the **Connect** button on your Instance. Then select **HTTP cURL**.  


<Image
alt="Open in HTTP cURL"
src={{
	light: OpenInHTTPCurlLight,
	dark: OpenInHTTPCurlDark,
	}}
/>


> [!NOTE]
> The URL provided can be used in any HTTP client, but by default it is set to use curl. Use the URL in your HTTP client to connect to your SurrealDB Cloud Instance from clients like Postman or any other HTTP client.

## Connect to your SurrealDB Cloud Instance

Once you have filled in the credentials, copy the URL and connect to your SurrealDB Cloud Instance. Below is an example of the connection URL in curl.

```bash
curl -X GET "https://cloud-demo-06am27fc5dtavfp0mml4bktj18.aws-use1.surreal.cloud/version" \
  -H "Surreal-NS: DEMO namespace" \
  -H "Surreal-DB: DEMO database"
```




================================================
FILE: src/content/doc-cloud/connect/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Connect to Instance
title: Connect to Instance | SurrealDB Cloud 
description: In this section you will explore the connection options for SurrealDB Cloud instances. You can connect to your Instance using the SurrealDB Cloud CLI or any of the supported SDKs.
---

# Connect to your SurrealDB Cloud Instance

You can connect to your SurrealDB Cloud instances in three main ways. In this section you will explore the following connection options:

 
- [querying in Surrealist](/docs/cloud/connect/surrealist) : Surrealist is a query builder and IDE for SurrealDB. It allows you to connect to your SurrealDB Cloud Instance and run queries in a graphical interface.
- [connect via CLI](/docs/cloud/connect/cli) : using the command-line interface for SurrealDB, you can connect to your SurrealDB Cloud Instance and run queries in a command-line interface.
- [connect via SDK](/docs/cloud/connect/sdk) : SurrealDB Cloud supports a variety of SDKs for connecting to your Instance. You can use the SDKs to connect to your Instance and run queries in your preferred programming language.
- [connect via HTTP](/docs/cloud/connect/http) : SurrealDB Cloud supports a REST API for connecting to your Instance. You can use the API to connect to your Instance and run queries using CURL or any HTTP client.

## Before you begin

To connect to an Instance, you must have the following:

- [a SurrealDB Cloud account](/docs/cloud/getting-started/create-an-account).
- [an Instance to connect to](/docs/cloud/getting-started/create-an-instance).


## Next steps 

Explore the connection options for SurrealDB Cloud instances in detail. 


================================================
FILE: src/content/doc-cloud/connect/sdk.mdx
================================================
---
sidebar_position: 4
sidebar_label: Connect via SDK
title: Connect via SDK | SurrealDB Cloud 
description: Connect to your SurrealDB Cloud Instance using any of the available SDKs.
---

import Image from "@components/Image.astro";

import OpenInSDK from '@img/image/cloud/open-in-sdk.png';

import CreateRootUser from '@img/image/cloud/create-root-user.png';

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Connect via SDK

Once you have created a SurrealDB Cloud Instance, you can connect to it using any of the [available SDKs](/docs/surrealdb/integration/sdks). This allows you to interact with your SurrealDB Cloud Instance programmatically.


<Image
alt="Open in SDK"
src={{
	light: OpenInSDK,
	dark: OpenInSDK,
	}}
/>
 
After you have selected your SDK, you will need to provide your connection details which will populate the code snippet to your SurrealDB Cloud Instance.


## Enter connection details

When using any of the SurrealDB SDKs, before you can start querying your SurrealDB Cloud Instance, you will need to provide your connection details. SurrealDB requires **namespace** & **database** details so that it knows where to run and store your data. On the top of the dashboard, you can find the prompt to create a namespace and database.

Learn more about [namespaces](/docs/surrealdb/introduction/concepts/namespace) and [databases](/docs/surrealdb/introduction/concepts/database) in the SurrealDB documentation.



### Create a root authentication

> [!NOTE]
> This step is only required if you are authenticating using the `signin` method on your initial connection. Learn more about [access methods](/docs/surrealql/statements/define/access) and [system Users](/docs/surrealql/statements/define/user) in the SurrealDB documentation.


First navigate to the Authentication panel of Surrealist. There, you can create a root user by clicking on the **+** button in the **Root Authentication** section. 

In the dialog that appears, select either:

- **new system user**: create a root user by entering a username, password, and selecting a role to define their access level to Instance resources and permissions
- **new access method**: create an access method by entering a name and selecting the type to define its access level to Instance resources and permissions

For both options, you can configure the Token duration and session duration.

<Image
alt="Open in SDK"
src={{
	light: CreateRootUser,
	dark: CreateRootUser,
	}}
/>

After creating your root authentication, you will be able to authenticate with your SurrealDB Cloud Instance using any of the available SDKs.

If you want to create a Namespace and Database authentication for record-level access, you will need to first create a Namespace and Database. Learn more about [namespaces](/docs/surrealdb/introduction/concepts/namespace) and [databases](/docs/surrealdb/introduction/concepts/database) in the SurrealDB documentation.


## Connect to your SurrealDB Cloud Instance

After you have created your root authentication for root-level access, you can use the credentials to sign in to your SurrealDB Cloud Instance. 

The `connect` method takes your SurrealDB Cloud connection string as an argument to connect to your SurrealDB Cloud Instance. You can then fill in the **namespace** and **database** details to select the specific namespace and database you want to use. 

If you are using a system user option of the root authentication, you can also fill in the **username** and **password** details to sign in to your SurrealDB Cloud Instance.

> [!NOTE]
>If you are using a non-root user, depending on the access method you have created, you will need to fill in the `access` details to sign in to your SurrealDB Cloud Instance. Please refer to the [documentation for your specific SDK](/docs/surrealdb/integration/sdks) for more information.


{/* SurrealDB Cloud provides a connection string that you can use to connect to your instance. This connection string includes the endpoint and token that you need to authenticate your connection. 

In your preferred SDK, using the `connect` method, which takes a connection string as an argument to connect to your SurrealDB Cloud Instance.  */}



Below are examples of how you can connect to your Instance using the SurrealDB SDK:


<Tabs groupId="SDKs">
  <TabItem value="Rust" label="Rust" default>

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::any;
use surrealdb::opt::auth::Root;
use tokio;
use chrono::{DateTime, Utc};

#[derive(Serialize, Deserialize)]
struct Project {
	name: String,
	description: String,
	status: String,
	priority: String,
	tags: Vec<String>,
	created_at: DateTime<Utc>,
}

// Open a connection
let db = any::connect("wss://<INSTANCE_ENDPOINT>").await?;

// Select namespace and database
db.use_ns("DEMO namespace").use_db("DEMO database").await?;

// Authenticate
db.signin(Root {
	username: "",
	password: "",
}).await?;

// Create a record
let project = Project {
	name: "SurrealDB Dashboard".to_string(),
	description: "A modern admin interface for SurrealDB".to_string(),
	status: "in_progress".to_string(),
	priority: "high".to_string(),
	tags: vec!["typescript".to_string(), "react".to_string(), "database".to_string()],
	created_at: Utc::now(),
};

db.create("project").content(project).await?;
```
  </TabItem>
<TabItem value="JavaScript" label="JavaScript">

```js
import { Surreal, Table } from "surrealdb";

const db = new Surreal();

// Open a connection and authenticate
await db.connect("wss://<INSTANCE_ENDPOINT", {
	namespace: "DEMO namespace",
	database: "DEMO database",
	auth: {
		username: "",
		password: "",
	}
});

// Create record
await db.create(new Table("project"), {
	name: "SurrealDB Dashboard",
	description: "A modern admin interface for SurrealDB",
	status: "in_progress",
	priority: "high",
	tags: ["typescript", "react", "database"],
	created_at: new Date(),
});

// Select all records in project table
console.log(await db.select(new Table("project")));

await db.close();
```
</TabItem>
  <TabItem value="Python" label="Python">

```py

from surrealdb import Surreal, RecordID
from datetime import datetime

# Open a connection
with Surreal(url="wss://<INSTANCE_ENDPOINT") as db:

	# Select namespace and database
	await db.use("DEMO namespace", "DEMO database")

	# Authenticate
	await db.sign_in(username="", password="")

	# Create a record
	db.create(RecordID("project", "1"), {
		"name": "SurrealDB Dashboard",
		"description": "A modern admin interface for SurrealDB",
		"status": "in_progress",
		"priority": "high",
		"tags": ["typescript", "react", "database"],
		"created_at": datetime.utcnow(),
	})

	# Select a specific record
	print(db.select(RecordID("project", "1")))
```
</TabItem>
<TabItem value=".NET" label=".NET">

```csharp

using SurrealDb.Net;
using SurrealDb.Net.Models;
using SurrealDb.Net.Models.Auth;
using System.Text.Json;

const string TABLE = "project";

using var db = new SurrealDbClient("wss://<INSTANCE_ENDPOINT/rpc");

// Select namespace and database
await db.Use("DEMO namespace", "DEMO database");

// Create record
var project = new Project
{
	Name = "SurrealDB Dashboard",
	Description = "A modern admin interface for SurrealDB",
	Status = "in_progress",
	Priority = "high",
	Tags = new[] { "typescript", "react", "database" },
	CreatedAt = DateTime.UtcNow,
};

await db.Create(TABLE, project);
// Run 
dotnet run
```
</TabItem>
<TabItem value="PHP" label="PHP">
```php
$db = new \Surreal\Surreal();

// Open a connection
$db->connect("wss://<INSTANCE_ENDPOINT", [
	"namespace" => "DEMO namespace",
	"database" => "DEMO database",
]);

// Authenticate
$db->signin([
	"username" => "",
	"password" => "",
]);

// Create a record
$db->create("project", [
	"name" => "SurrealDB Dashboard",
	"description" => "A modern admin interface for SurrealDB",
	"status" => "in_progress",
	"priority" => "high",
	"tags" => ["typescript", "react", "database"],
	"created_at" => new DateTime(),
]);
```
</TabItem>
</Tabs>

## Next steps

Learn more about the [SurrealDB SDKs](/docs/surrealdb/integration/sdks) in the SurrealDB documentation.
 



================================================
FILE: src/content/doc-cloud/connect/surrealist.mdx
================================================
---
sidebar_position: 2
sidebar_label: Querying in Surrealist
title: Querying in Surrealist | SurrealDB Cloud 
description: Query your SurrealDB Cloud instance using Surrealist.
---

import Image from "@components/Image.astro";

import OpenInSurrealistLight from '@img/image/cloud/open-in-surrealist.png';
import OpenInSurrealistDark from '@img/image/cloud/open-in-surrealist.png';

import NamespaceDatabaseLight from '@img/image/cloud/namespace-database.png';
import NamespaceDatabaseDark from '@img/image/cloud/namespace-database.png';

import QueryingInstanceLight from '@img/image/cloud/querying-instance.png';
import QueryingInstanceDark from '@img/image/cloud/querying-instance.png';

# Querying in Surrealist

Once you have created a SurrealDB Cloud Instance, you can start querying it in Surrealist in the [query view](/docs/surrealist/concepts/sending-queries).

In the query view, and before you can run queries in Surrealist, you need to select a [Namespace](/docs/surrealdb/introduction/concepts) and a [Database](/docs/surrealdb/introduction/concepts) to work in.

First click on the **Namespace** button and select the namespace you want to work in (if you have not created a namespace, you will see an option to create one). Then click on the **Database** button and select the database you want to work in (if you have not created a namespace, you will see an option to create one).

<Image
alt="Namespace and Database"
src={{
	light: NamespaceDatabaseLight,
	dark: NamespaceDatabaseDark,
	}}
/>

Once you have selected a namespace and database, you can start running queries in Surrealist. You can run queries to create, read, update, and delete data in your SurrealDB Cloud Instance.

<Image
alt="Querying Instance"
src={{
	light: QueryingInstanceLight,
	dark: QueryingInstanceDark,
	}}
/>

You can now see your queries and results in the Surrealist query view. You can also see the created records in the explore view.

## Next steps

Learn more about [Surrealist](/docs/surrealist) and SurrealQL in the [SurrealDB documentation](/docs/surrealql).



================================================
FILE: src/content/doc-cloud/faqs/index.mdx
================================================
---
sidebar_position: 7
sidebar_label: FAQs
title: FAQs | SurrealDB Cloud 
description: If you have questions about SurrealDB Cloud , you can find answers here. This document provides a comprehensive understanding of SurrealDB Cloud , whether you are a beginner getting started with SurrealDB Cloud or an experienced user looking for specific information.
---

# Frequently asked questions

If you have questions about SurrealDB Cloud , you can find answers on this page. This document provides a comprehensive understanding of SurrealDB Cloud , whether you are a beginner getting started with SurrealDB Cloud or an experienced user looking for specific information.

## General questions 

### What is SurrealDB Cloud ? 

SurrealDB Cloud offers the power and flexibility of SurrealDB without the pain of managing infrastructure. We take care of managing and operating the underlying infrastructure so that you can focus on what you do best-building great applications for your customers. 


### How do I get started with SurrealDB Cloud ?

Getting started is easy.  [Sign up for an account on Surrealist](https://app.surrealdb.com/cloud/). Once registered, you can access the dashboard, choose services, and start building with SurrealDB Cloud immediately.

### Are there self-help resources like documentation or tutorials available?
Yes. We have a [resource hub with all our latest documentation](/docs/).  We also recommend our [YouTube channel](https://www.youtube.com/channel/UCjf2teVEuYVvvVC-gFZNq6w) where you can find easy-to-follow tutorials, and content from our Community.


### What kind of support is available at the launch of SurrealDB Cloud ?

We are offering community support at launch.  You can get help via our [Discord channel](https://discord.gg/surrealdb) `#surreal-cloud` or any of our [community channels](/community). 

### Which cloud platform is SurrealDB available on?

At present, SurrealDB is available on AWS. In the future we plan to expand to other cloud platforms.

### My current application is on SurrealDB.  Can I move this to SurrealDB Cloud ?
Yes. You can move your current application built in SurrealDB to SurrealDB Cloud . You can find more information in the [migrate your existing data](/docs/cloud/advanced-topics/migrating-data) documentation.

### How do I migrate my existing on-premises instance to SurrealDB Cloud ?

We are working on a migration tool to help you move your existing on-premises instance to SurrealDB Cloud .  In the meantime, you can use the `import` and `export` commands to move data between your on-premises instance and SurrealDB Cloud . 

### When will SurrealDB Cloud leave beta?

SurrealDB Cloud is currently in beta as we continue to improve the platform and add new features. 

### What programming languages are supported?

SurrealDB Cloud supports the following programming languages:

- [JavaScript/TypeScript](/docs/sdk/javascript)
- [Python](/docs/sdk/python)
- [Go](/docs/sdk/golang)
- [Java](/docs/sdk/java)
- [Rust](/docs/sdk/rust)
- [PHP](/docs/sdk/php)
- [.NET](/docs/sdk/dotnet)

### Why am I getting an authentication error connecting via SDK? 

You need to create a User first. Head to the [connect via SDK](/docs/cloud/connect/sdk) documentation for more details.

### Does SurrealDB Cloud backup my data? 

For the [paid tiers](/pricing), SurrealDB Cloud automatically backs up your data daily with a 7 day retention period to ensure data durability and availability.

### How often can I increase the disk size of my instance?

You can increase the disk size of your instance once every 6 hours.

### Can I transfer an instance to another organisation?

No, you cannot transfer an instance to another organisation. However, you can create a new instance in the new organisation and then use the `import` and `export` commands to move data between the two instances.

### Can I delete an organisation?

For now no, you cannot delete an organisation. However, you can delete an instance from an organisation.

### What are the limits of the SurrealDB Cloud ?

It is not currently possible to configure [CLI](/docs/surrealdb/cli) arguments or environment variables in SurrealDB Cloud .

[GraphQL support](/docs/surrealdb/querying/graphql) is not yet enabled on SurrealDB Cloud instances.

> [!NOTE]
> Free Tier instances surpassing the 1GB free storage allowance will be limited to data retrieval only. Unless you upgrade to a paid tier, you will not be able to create new data.

## Security

### How secure is SurrealDB Cloud ?

SurrealDB Cloud is designed with security in mind and aims to provide robust protection for your data and applications. As detailed within our [Security Addendum](/legal/security-addendum), the platform leverages industry-standard security practices, including encryption at rest and in transit, network isolation, access controls and monitoring. For authentication, SurrealDB Cloud supports multi-factor authentication through the available identity providers that offer it to their users. We are certified with compliance standards like ISO 27001, SOC 2 (Type 1), and Cyber Essentials Plus. We are working towards achieving SOC 2 Type 2 compliance, with plans to expand to other industry-specific compliance programs in the future such as HIPAA or PCI DSS.

Additionally, SurrealDB Cloud is built on top of SurrealDB, which provides powerful and flexible [security features](/docs/surrealdb/security/summary#product) that are available to all SurrealDB Cloud customers. SurrealDB is developed and maintained following modern [security practices](/docs/surrealdb/security/summary#process) to ensure early detection of security vulnerabilities and other security issues.

We are happy to discuss the security of SurrealDB Cloud with customers assessing usage of the service for their workloads during the beta phase. Please [Contact Us.](/pricing/contact)

### How can I report a security issue in SurrealDB Cloud ?

If you believe you have found a security vulnerability in SurrealDB Cloud or SurrealDB, we encourage you to let us know right away. We will investigate all legitimate reports and do our best to quickly address the issue. Please report any security issue to [security@surrealdb.com](mailto:security@surrealdb.com). For security issues in SurrealDB, please submit a report via [Github Security Advisories](https://github.com/surrealdb/surrealdb/security/advisories) rather than posting a public issue in GitHub.

We ask that you...

- ... privately disclose the details of any potential vulnerability to SurrealDB.
- ... provide enough information to reproduce the vulnerability in your report.

We ask that you refrain from...

- ... disclosing the details of a vulnerability publicly or to third parties.
- ... exploiting a vulnerability beyond what is strictly necessary to verify its existence.
- ... running automated security tools against SurrealDB infrastructure without permission.

We commit to...

- ... acknowledging your report within three business days of the date of communication.
- ... verifying the issue and keeping you informed of the progress toward its resolution.
- ... handling your report and any data you share with us with strict confidentiality.
- ... abstaining from legal action against you for any report made following this policy.
- ... crediting you in any relevant public security advisory unless you desire otherwise.

### How do I configure user authentication?
SurrealDB Cloud allows users to authenticate directly into their instances from Surrealist using a pre-defined access method. Once connected to your Instance, you may [define users](/docs/surrealql/statements/define/user) or [access methods](/docs/surrealql/statements/define/access) that users can use to access your Instance or specific namespaces or databases using any of the available [interfaces](/docs/surrealdb/integration), the [SurrealDB CLI](/docs/surrealdb/cli) or [Surrealist](https://app.surrealdb.com/query).

### Can I use my own encryption keys?
Currently, any encryption keys used to encrypt data at rest are managed by SurrealDB Cloud . Since the architecture technically supports it, we may consider allowing customers to associate their own Customer-Managed Encryption Keys (CMEK) to be used to encrypt data at rest in the future. If you are interested in CMEK, please, contact us.

### Can I limit who can reach my instances over the internet?
All instances created in SurrealDB Cloud are publicly reachable over the internet and currently rely exclusively on the authentication and authorization mechanisms that are defined within the instance to prevent access to their data. We plan on providing the ability to restrict network access to instances as well as the ability to limit the [capabilities](/docs/surrealdb/security/capabilities) of each instance in the future. If your use case requires private network access to the instances, please, contact us.

## Pricing

### How much does SurrealDB Cloud cost?

SurrealDB Cloud offers a flexible pricing model that allows you to pay only for the resources you use, such as used compute and provisioned storage. For detailed pricing information, please refer to the [pricing](/pricing) page.

### Is there a free tier available for SurrealDB Cloud ?

Yes, SurrealDB Cloud offers a free tier that allows you to get started with the platform at no cost. The free tier provides limited resources for development and testing purposes, enabling you to explore the features and capabilities of SurrealDB Cloud without incurring any charges.


### I am on the free tier.  Can I add another cluster?

Anyone using the Individual (free) tier wishing to add another cluster will be alerted in their account that they must fill in their [billing information](/docs/cloud/billing-and-support/billing).


### Will SurrealDB provide itemised invoices with tax identified?
Yes. Customers with a VAT or tax identification number, should insert this in the billing section of their customer profile. 

### Who do I contact for billing queries or account issues?
Please send an email to support@surrealdb.com outlining the nature of your query and we will help you. 

### Are there any additional fees? 

No, we are transparent about our pricing. All costs are outlined on our [pricing page](/pricing), and there are no hidden fees or unexpected charges. Prices quoted on our website are exclusive of VAT or sales tax. Any relevant taxes will be displayed clearly on all customer invoices.

### How am I billed for usage? 

You are billed on a monthly basis for all services used during the previous month. The billing cycle starts on the first day of each month and ends on the last day. You will receive an invoice via email.

## Legal

### What terms and conditions govern my use of SurrealDB Cloud ?

Using SurrealDB Cloud means that the User agrees to the terms and conditions of our Master Services Agreement (MSA) available on our [legal page](/legal). Here we endeavour to be open and transparent with our legal, compliance, and privacy processes and our shared responsibilities and commitments to supporting your use of the Services.

### Are you located in a US-Embargoed country or in Russia?

SurrealDB Inc., complies with U.S. regulations related to embargoed countries and regions. As such, SurrealDB currently prohibits use of its products and services in Cuba, Iran, North Korea, Syria, and the currently Russian-controlled regions of Crimea, Luhansk People's Republic (LNR), and Donetsk People's Republic (DNR).  SurrealDB uses geoblocker software to prevent logins from these restricted regions; however, regional blocks may mean that an entire country is restricted from using our services. **This is beyond our direct control.**

Additionally, Surreal DB Ltd is subject to Article 5n(2b) of Council Regulation 833/2014 in which it is prohibited to sell, supply, transfer, export, or provide, directly or indirectly, software for the management of enterprises and software for design and manufacture, to the Government of Russia or to legal persons, entities or bodies established in Russia.

SurrealDB takes its compliance obligations very seriously and will update them as needed from time to time.

## Troubleshooting and Support

### What should I do if I cannot connect to SurrealDB Cloud ?

If you are unable to connect to SurrealDB Cloud , please check the following:

- Ensure that your network connection is stable and that you have internet access.
- Verify that your credentials are correct and that you have the necessary permissions to access SurrealDB Cloud .
- Check the status of the SurrealDB Cloud service to see if there are any ongoing issues or maintenance activities.
- If you are still unable to connect, please contact SurrealDB Cloud support for further assistance.

### Where can I find further documentation or tutorials?

You can find a variety of resources to help you learn more about SurrealDB via [our website]() including:

- [SurrealDB Docs](/docs/): Comprehensive guides and references for all features, including docs to accompany [Surrealist](/docs/cloud)
- [YouTube Channel](https://youtube.com/surrealdb): Stay up-to-date with the latest releases, learn new skills and discover what other developers are building with SurrealDB.
- [SurrealDB University](/learn): A self-paced video course with hands-on labs and interactive tutorials.
- [SurrealDB Book](/learn/book): An in-depth, story-driven guide to mastering SurrealDB.

### How do I report a bug or request a feature in SurrealDB Cloud ?

If you encounter a bug or have a feature request for SurrealDB Cloud , you can report it through the support portal or contact the SurrealDB Cloud team directly. Please provide detailed information about the issue or feature request, including steps to reproduce the problem, screenshots, and any other relevant details. The SurrealDB Cloud team will review your submission and work to address the issue or implement the feature in a future release.



================================================
FILE: src/content/doc-cloud/getting-started/create-an-account.mdx
================================================
---
sidebar_position: 2
sidebar_label: Create an Account
title: Create a SurrealDB Cloud Account 
description: To get started with SurrealDB Cloud , you need to create an account. You can use your email address, a passkey, Google, or GitHub to create an account.
---


# Create a SurrealDB Cloud account

To get started, in the Surrealist app, click on the **Explore SurrealDB Cloud** option on the start screen. This will open the Cloud dashboard on the sidebar. Click on the **continue** button to create a SurrealDB Cloud account. You will be redirected to the SurrealDB Cloud authentication page where you can create or sign in to your account.

This account is used to authenticate your access to SurrealDB Cloud and [manage your created Instances](/docs/cloud/getting-started/create-an-instance).



## Registration options

There are several ways to create a SurrealDB Cloud account. The options are Google, GitHub. Please use only one of the available options to avoid conflicts: 

- [Create an Account with Google](#create-an-account-with-google)
- [Create an Account with GitHub](#create-an-account-with-github)
- [Create an Account with Email](#create-an-account-with-email)

> [!IMPORTANT]
> When you sign in with Google or GitHub, you will be briefly redirected to their secure sign-in page through SurrealDB Cloud . This process uses OAuth2, a secure authentication protocol that allows you to use your existing account without sharing your password with us. We only request basic information (email address and name) from your account. After you authorize the connection, the provider sends a secure token back to SurrealDB Cloud , confirming your identity and granting you access to our services.

### Create an Account with Google

Using your Google account to sign up offers a quick and convenient way to create a SurrealDB Cloud account. It leverages Google's secure authentication system and eliminates the need for a separate password. 


To create an account with Google, follow these steps:

1. Select **Sign up with Google** option that says "Sign Up with Google" or displays the Google logo in the authentication page
2. Choose Google Account: a Google sign-in window will appear; select the Google account you wish to use or enter your Google email and password
3. Grant permissions: review the permissions requested by the platform and click "Allow" to grant access
4. **Account created and logged in**: your new account is now created using your Google credentials, and you are automatically logged in

### Create an Account with GitHub

Creating an account with your GitHub account is a quick and convenient way to create a SurrealDB Cloud account. It leverages GitHub's secure authentication system and eliminates the need for a separate password. 

To create an account with GitHub, follow these steps:

1. Select **Sign up with GitHub** option that says "Sign Up with GitHub" or displays the GitHub logo in the authentication page
2. Choose GitHub Account: a GitHub sign-in window will appear; select the GitHub account you wish to use or enter your GitHub email and password if prompted
3. Grant permissions: review the permissions requested by the platform and click "Allow" to grant access
4. **Account created and logged in**: your new account is now created using your GitHub credentials, and you are automatically logged in

### Create an Account with Email

Creating an account using your email address allows you to register without linking a third-party service. This option is ideal if you prefer to use a custom password or don't want to connect your Google or GitHub accounts.

To create an account with Email, follow these steps:

1. Select **Sign up with Email** on the authentication page.
2. Enter your email address 
3. You'll have the option to create a secure password or use a passkey.
4. Confirm your email address by clicking the verification link sent to your inbox.
5. Your new account is now created, and you can log in with your email and password.

> [!NOTE]
> If you forget your password, you can reset it by clicking on the **Forgot password?** link on the authentication page and follow the instructions sent to your email.

## Sign in to SurrealDB Cloud 

If you already have an account, you can sign in to SurrealDB Cloud . Sign in is required to access your SurrealDB Cloud instances. You can sign in using the same email address, Google, or GitHub account you used to create your account. 

### Sign in with Google

1. Navigate to the [SurrealDB Cloud ](https://app.surrealdb.com/cloud) dashboard in [Surrealist](https://app.surrealdb.com).
2. **Select "Continue with Google"**: click on the "Continue with Google" option.
3. **Choose Google account**: a Google sign-in window may appear; select your Google account or enter your Google email and password if prompted.
4. **Authenticate**: complete any additional security steps if required, such as two-factor authentication.
5. **Access granted**: you are now securely logged into your account using your Google credentials.

### Sign in with GitHub

1. Navigate to the [SurrealDB Cloud ](https://app.surrealdb.com/cloud) dashboard in [Surrealist](https://app.surrealdb.com).
2. **Select "Continue with GitHub"**: click on the "Continue with GitHub" option.
3. **Choose GitHub account**: a GitHub sign-in window may appear; select your GitHub account or enter your GitHub email and password if prompted.
4. **Authenticate**: complete any additional security steps if required, such as two-factor authentication.
5. **Access granted**: you are now securely logged into your account using your GitHub credentials.

### Sign in with Email

1. Navigate to the [SurrealDB Cloud ](https://app.surrealdb.com/cloud) dashboard in [Surrealist](https://app.surrealdb.com).
2. **Select "Sign In with Email"**: click on the "Sign In with Email" option.
3. **Enter your email and password**: enter your email address and password.
4. **Access granted**: you are now securely logged into your account using your email and password.

### Sign in with Passkey

1. Navigate to the [SurrealDB Cloud ](https://app.surrealdb.com/cloud) dashboard in [Surrealist](https://app.surrealdb.com).
2. **Select "Continue with Passkey"**: click on the "Continue with Passkey" option.
3. **Access granted**: you are now securely logged into your account using your passkey.

## Next steps

After creating an account, you can connect to a SurrealDB Cloud instance using Surrealist, a command-line interface, or any of the supported SDKs. For more information, see the [create a SurrealDB Cloud Instance](/docs/cloud/getting-started/create-an-instance) document.


================================================
FILE: src/content/doc-cloud/getting-started/create-an-instance.mdx
================================================
---
sidebar_position: 3
sidebar_label: Create an Instance
title: Create an Instance | SurrealDB Cloud 
description: In this section, you will learn how to create an Instance in SurrealDB Cloud .
---

import Image from "@components/Image.astro";

import CreateInstanceLight from '@img/image/cloud/create-instance.png';
import CreateInstanceDark from '@img/image/cloud/create-instance.png';
import RestoreLight from "@img/image/cloud/restore.png";
import RestoreDark from "@img/image/cloud/restore.png";

# Create an Instance

SurrealDB Cloud allows you to create a new Instance with a few clicks. You can create an Instance in your personal account or in an organization. 

You can create an Instance in these steps from the overview:

1. Click on the **Deploy Instance** button. This will take you to the plan page where you can choose the plan you want to use for your Instance.

2. After you have selected your plan, configure your Instance. You can choose between the following Instance types:

    - **General purpose**: for production environments, data at scale, or professional use cases.

    - **Burstable**: for testing, starter projects, or for low-traffic applications. Clusters under heavy load may experience CPU throttling.

    - **Free Tier**: experience SurrealDB with a free Instance.

3. Input your Instance details.
    - **Region**: the region you want to deploy your Instance in. 
        - AWS US East (N. Virginia)
        - AWS US West (Oregon)
        - AWS Europe (Ireland)
    - **SurrealDB version**: the version of SurrealDB you want to use. Selecting the latest version is recommended but if you select a lower version, you will be able to upgrade to the latest in your Instance settings.
    - **Instance name**: the name of the Instance.

4. You have the option to select Instance Data from the following options:
    - **Empty**: this will create a new SurrealDB Instance with no data.
    - **Demo dataset**: this option will populate your Instance with a demo dataset and some sample queries to get you started.
    - **Upload from file**: this will allow you to upload a CSV file to your Instance.
    - **Restore from backup**: this will allow you to restore a backup of an existing Instance.

<Image
alt="Restoring from a backup"
src={{
	light: RestoreLight,
	dark: RestoreDark,
	}}
/>
<br/>
5. In the **Storage** section, select storage capacity. This is the amount of storage you want to allocate to your Instance. Depending on the plan you have selected, you will have different options.

<Image
alt="Surreal Sidekick"
src={{
	light: CreateInstanceLight,
	dark: CreateInstanceLight,
	}}  
/>

<br/>

6. After customising your Instance, click the **Continue to checkout** button. You'll be taken to a checkout page where you can review your order. If you have selected a paid plan you will be prompted to enter your payment details.


## Next steps

Now that you have created an Instance, you can [connect to your SurrealDB Cloud Instance](/docs/cloud/connect). You can also [configure your Instance](/docs/cloud/advanced-topics/configure-an-instance) to change the Instance type, number of nodes, and capabilities.


================================================
FILE: src/content/doc-cloud/getting-started/create-an-organisation.mdx
================================================
---
sidebar_position: 4
sidebar_label: Create an Organisation
title: Create an Organisation | SurrealDB Cloud 
description: In this section, you will learn how to create an Organisation in SurrealDB Cloud .
---

import Image from "@components/Image.astro";

import CreateOrganisationLight from '@img/image/cloud/create-organisation.png';
import CreateOrganisationDark from '@img/image/cloud/create-organisation.png';
import InviteMemberLight from '@img/image/cloud/invite-member.png';
import InviteMemberDark from '@img/image/cloud/invite-member.png';

# Create an Organisation

SurrealDB Cloud allows you to create a new Organisation with a few clicks to seperately manage your different projects. 

You can create an Organisation in these steps from the overview:

1. On the overview page, click on the **Create organisation** button. This will take you to the create Organisation form.

2. Enter the name of the Organisation and click on the **Create organisation** button.

You will be redirected to the Organisation overview page where you can manage your Organisation instances, team, usage and billing information.


## Organisation Overview

After you create a new Organisation, you will be automatically added as [the owner of the Organisation](/docs/cloud/advanced-topics/manage-organisation-permissions). As an Organisation owner, you can manage your Organisation instances, team, usage and billing information from the overview page. 

To create a new Instance, click on the **Deploy Instance** button and follow the steps in the [create an instance](/docs/cloud/getting-started/create-an-instance) documentation.

<Image
alt="Surreal Sidekick"
src={{
	light: CreateOrganisationLight,
	dark: CreateOrganisationDark,
	}}  
/>

When you visit the Organisation overview page, you'll find everything you need to manage your Organisation in one place:

- The **Instances** tab shows all your database instances. Here you can create new instances, monitor how they're running, and make any needed changes.

- Under **Team**, you can handle everything related to your Organisation's members - invite new people, remove members who have left, and set what each person is allowed to do.

- The **Usage** tab helps you keep an eye on how much of your resources you're using, with easy-to-read metrics and trends.

- In **Billing**, you can manage all your payment details - update payment methods, view past invoices, and handle any billing-related tasks.


Depending on your permissions, the overview page will show different sections. More information about the different roles and permissions can be found in the [manage Organisation permissions](/docs/cloud/advanced-topics/manage-organisation-permissions) section.

## Invite members to your Organisation

To invite members to your Organisation, click on the **Team** tab and then the **Invite member** button. This will open a modal where you can invite a new member to your Organisation and the role of the member. Learn more about what each role does in the [manage Organisation permissions](/docs/cloud/advanced-topics/manage-organisation-permissions) section.

<Image
alt="Surreal Sidekick"
src={{
	light: InviteMemberLight,
	dark: InviteMemberDark,
	}}  
/>


## Related pages

- [Create an Instance](/docs/cloud/getting-started/create-an-instance)
- [Manage Organisation Permissions](/docs/cloud/advanced-topics/manage-organisation-permissions)




================================================
FILE: src/content/doc-cloud/getting-started/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Get Started
title: Get Started with SurrealDB Cloud 
description: SurrealDB Cloud is a cloud-based platform that provides a comprehensive suite of tools and services to help you build, manage, and deploy your database.
---

import { Icon } from 'astro-icon/components';

# Get started with SurrealDB Cloud 

SurrealDB Cloud provides services to help you build, manage, and deploy your database. Whether you are a beginner getting started with SurrealDB Cloud or an experienced user looking for specific information, this document provides a comprehensive understanding of SurrealDB Cloud .

To get started with SurrealDB Cloud , you need to sign up for an account and create an instance. Once you have created a project, you can start building your database, managing your data, and deploying your application.

SurrealDB Cloud offers several options for connecting to your created database instance, [including Surrealist](/docs/cloud/connect/surrealist), [a command-line interface](/docs/cloud/connect/cli), and [any of the supported SDKs](/docs/cloud/connect/sdk). 

<a
	href="https://app.surrealdb.com/cloud"
	class="gradient-button group mt-2 mb-6"
>
	Sign up for SurrealDB Cloud 
	<Icon name="fa6-solid:arrow-right" class="w-4 transition-transform group-hover:translate-x-1" />
</a>

## Next Steps

- [Create a SurrealDB Cloud account](/docs/cloud/getting-started/create-an-account)
- [Create a SurrealDB Cloud Instance](/docs/cloud/getting-started/create-an-instance)
- [Connect to your Instance](/docs/cloud/connect)
- [Getting Started with SurrealDB Cloud ](https://youtu.be/upm1lwaHmwU?si=8Xcmz-wFt6OMDc6R)



================================================
FILE: src/content/doc-integrations/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Overview
title: Integrations | Overview
description: SurrealDB is designed to be easily integrated with a wide range of different technologies and platforms.
---

import Boxes from "@components/boxes/Boxes.astro";
import IconBox from "@components/boxes/IconBox.astro";
import Version from '@components/Version.astro';
import Image from "@components/Image.astro";

import Logo from '@img/icon/light/integrations.png';

<div class="flag-title">
	<Image
		class="size-11 my-auto"
		width={300}
		alt="Integrations"
		src={{
			light: Logo,
			dark: Logo,
		}}
	/>
	# Integrations
</div>

SurrealDB is designed to be easily integrated with a wide range of different technologies and platforms. Our ecosystem of integrations spans across multiple categories, making it simple to incorporate SurrealDB into your existing tech stack.

## Data Management

Streamline your data operations with our data management integrations:

- **Unstructured**: Process and analyze unstructured data
- **Fivetran**: ETL and data pipeline automation
- **MixedBread**: Advanced vector embeddings and semantic search

## AI & ML Frameworks

SurrealDB seamlessly integrates with popular AI and ML frameworks, enabling you to build intelligent applications:

<table>
  <tbody>
    <tr>
      <td><a href="/docs/integrations/frameworks/langchain">LangChain</a></td>
      <td>Build LLM-powered applications with ease</td>
    </tr>
    <tr>
      <td><a href="/docs/integrations/frameworks/agno">Agno</a></td>
      <td>Build high performance Agents with memory, knowledge and reasoning</td>
    </tr>
    <tr>
      <td><a href="/docs/integrations/frameworks/crewai">CrewAI</a></td>
      <td>Create and manage AI agent teams</td>
    </tr>
    <tr>
      <td><a href="/docs/integrations/frameworks/deepeval">DeepEval</a></td>
      <td>Evaluate and improve your AI models</td>
    </tr>
    <tr>
      <td><a href="/docs/integrations/frameworks/dagster">DAGster</a></td>
      <td>Orchestrate your data pipelines</td>
    </tr>
    <tr>
      <td><a href="/docs/integrations/frameworks/camel">CAMEL</a></td>
      <td>Develop autonomous AI agents</td>
    </tr>
    <tr>
      <td><a href="/docs/integrations/frameworks/llama-index">Llama Index</a></td>
      <td>Build RAG pipelines with SurrealDB as vector store</td>
    </tr>
    <tr>
      <td><a href="/docs/integrations/frameworks/dynamiq">Dynamiq</a></td>
      <td>Build dynamic AI applications</td>
    </tr>
    <tr>
      <td><a href="/docs/integrations/frameworks/smolagents">SmolAgents</a></td>
      <td>Create lightweight AI agents</td>
    </tr>
  </tbody>
</table>


## Embeddings

Enhance your applications with powerful vector search capabilities:

### Quick start

<table>
  <tbody>
    <tr>
      <td><a href="/docs/integrations/embeddings/python">Python</a></td>
      <td>LangChain, Ollama, Mistral, and more</td>
    </tr>
    <tr>
      <td><a href="/docs/integrations/embeddings/rust">Rust</a></td>
      <td>Mistral, Ollama, and more</td>
    </tr>
  </tbody>
</table>

### Full examples

<table>
  <tbody>
    <tr>
      <td><a href="/docs/integrations/embeddings/mistral">Mistral</a></td>
      <td>Mistral AI's embedding model and SurrealDB vector search (Python and Rust)</td>
    </tr>
    <tr>
      <td><a href="/docs/integrations/embeddings/openai">OpenAI</a></td>
      <td>OpenAI's embedding service and SurrealDB vector search (Python and Rust)</td>
    </tr>
  </tbody>
</table>

## Getting Started

To get started with any integration, visit the specific integration's documentation page. Each integration includes:

- Installation instructions
- Configuration steps
- Usage examples
- Best practices
- Common use cases

{/* <Boxes>
    <IconBox
        title="AI & ML Frameworks"
        description="Build intelligent applications with popular AI frameworks"
        icon="robot"
        link="/docs/integrations/frameworks"
    />
    <IconBox
        title="Data Management"
        description="Streamline your data operations with powerful tools"
        icon="database"
        link="/docs/integrations/data-management"
    />
    <IconBox
        title="Embeddings"
        description="Enhance your applications with vector search"
        icon="search"
        link="/docs/integrations/embeddings"
    />
</Boxes> */}

## Contributing

We welcome contributions to expand our integration ecosystem. If you're interested in creating a new integration or improving an existing one, please visit our [GitHub repository](https://github.com/surrealdb/docs.surrealdb.com) to learn more about the contribution process.



================================================
FILE: src/content/doc-integrations/data-management/airbyte.mdx
================================================
---
sidebar_position: 2
sidebar_label: Airbyte
title: Airbyte | Data Management
description: The Airbyte connector allows you to sync data to SurrealDB from hundreds of sources.
---

# Airbyte

This guide helps you configure SurrealDB as a destination in [Airbyte](https://airbyte.com) using the [official connector](https://github.com/surrealdb/airbyte-connector).

## Prerequisites
To connect SurrealDB to Airbyte, you need the following:

- An Airbyte deployment with access to the SurrealDB destination connector.
- SurrealDB `v2.2.0` or later.
- A SurrealDB instance (self-hosted or [SurrealDB Cloud ](https://app.surrealdb.com/cloud)) reachable by Airbyte.
- Ensure your SurrealDB database can be accessed by Airbyte. If your database is within a VPC, you may need to allow access from the IP you're using to expose Airbyte.
- A token or user credentials with [`DEFINE TABLE`](/docs/surrealql/statements/define/table), [`DEFINE INDEX`](/docs/surrealql/statements/define/indexes), [`UPSERT`](/docs/surrealql/statements/upsert), [`SELECT`](/docs/surrealql/statements/select), and [`REMOVE`](/docs/surrealql/statements/remove) permissions.

## Setup instructions

Follow these steps to configure SurrealDB as a destination. You can use either a self-hosted instance or SurrealDB Cloud .

Before proceeding, ensure you have the endpoint URL and credentials for your SurrealDB instance and that Airbyte can reach it over the network.

#### Option 1: Self-hosted SurrealDB

1. Ensure your SurrealDB instance is reachable from Airbyte. This might involve opening network access or configuring an SSH tunnel.
2. Create a dedicated user or token in SurrealDB, for example:

```surql
DEFINE USER airbyte ON ROOT PASSWORD "YourPassword" ROLES OWNER;
```

Use the generated credentials when setting up the destination.

#### Option 2: SurrealDB Cloud 

1. Visit the [Instances page](https://app.surrealdb.com/cloud/instances) and select your instance.
2. Click **Connect with Surreal CLI** to obtain a connection command containing the `--endpoint` and authentication details.
3. Verify you can connect using `surreal sql` with those parameters.

## Finish Airbyte configuration

1. Open the Airbyte dashboard and add a new **Destination**.
2. Select **SurrealDB** from the list of destination types.
3. Provide the host, port, namespace, database, and either the username/password or token you created earlier.
4. Click **Set up destination** and run the connection test.

Upon a successful test, you can start syncing data from your sources into SurrealDB tables. Each stream will be output into its own table in SurrealDB. Each table will contain 3 columns:

- `_airbyte_raw_id`: a uuid assigned by Airbyte to each event that is processed. The column type in SurrealDB is string. The connector use this as the ID of each record in the destination SurrealDB table.
- `_airbyte_extracted_at`: a timestamp representing when the event was pulled from the data source. The column type in SurrealDB is datetime.
- `_airbyte_data`: a json blob representing with the event data. The column type in SurrealDB is object.

## Known Limitations
SurrealDB destination forces all identifier (table, schema and columns) names to be lowercase.

## Related links

- [Airbyte destination documentation](https://github.com/surrealdb/airbyte-connector)
- [Connect to airbyte via a dev container](https://github.com/surrealdb/airbyte-connector/blob/main/devcontainer.md)



================================================
FILE: src/content/doc-integrations/data-management/fivetran.mdx
================================================
---
sidebar_position: 2
sidebar_label: Fivetran
title: Fivetran | Data Management
description: The Fivetran integration for SurrealDB allows you to sync data from Fivetran to SurrealDB.
---

# Fivetran

This guide will help you connect SurrealDB to Fivetran. The Fivetran integration is available through their [partner-built program](https://fivetran.com/docs/partner-built-program). For support with self-hosted SurrealDB destinations, please contact [SurrealDB Support](/contact). For SurrealDB Cloud related questions, reach out to [SurrealDB Cloud Support](/docs/cloud/billing-and-support/support).

## Prerequisites
To connect SurrealDB to Fivetran, you need the following:

- A Fivetran role with the [Create Destinations or Manage Destinations](https://fivetran.com/docs/using-fivetran/fivetran-dashboard/account-settings/role-based-access-control#rbacpermissions) permissions.
- A SurrealDB token.
- A SurrealDB instance (self-hosted or Cloud) that is accessible by Fivetran.

## Setup instructions

Follow these steps to set up SurrealDB as a destination in Fivetran. You have two options: self-hosted SurrealDB or SurrealDB Cloud .

Before proceeding with either option, ensure you have:

- Access to your SurrealDB instance with appropriate permissions
- The necessary connection details (endpoint URL, credentials)
- Network connectivity between Fivetran and your SurrealDB instance

#### Option 1: Self-hosted SurrealDB

1. For self-hosted SurrealDB, ensure your SurrealDB instance is accessible by Fivetran according to your Fivetran deployment:
   - For [Fivetran SaaS Deployment](https://fivetran.com/docs/deployment-models/saas-deployment), ensure your SurrealDB is accessible via Internet.
   - For [Fivetran Hybrid Deployment](https://fivetran.com/docs/deployment-models/hybrid-deployment), ensure your SurrealDB is accessible by the Fivetran Hybrid Deployment Agent.
   - For [Fivetran Self-Hosted Deployment](https://fivetran.com/docs/deployment-models/self-hosted-deployment), ensure your SurrealDB is accessible by the Fivetran HVR Agent.
2. Set up the token and use it following [SurrealDB's Authentication documentation](/docs/surrealdb/security/authentication#token).

#### Option 2: SurrealDB Cloud 

1. Ensure your SurrealDB instance is up and running and accessible via Internet.
2. Browse the [Instances page](https://app.surrealdb.com/cloud/instances) and select your chosen instance.
3. Click **Connect with Surreal CLI** and locate the `surreal sql --endpoint wss://YOUR_INSTANCE_HOSTNAME --token YOUR_TOKEN` command.
4. Run the command, and set up your own [`ACCESS`](/docs/surrealql/statements/define/access) or [`USER`](/docs/surrealql/statements/define/user). The example below works for testing purposes:

    ```surql
    USE NS your_ns;
    USE DB your_db;
    DEFINE USER your_user ON DATABASE PASSWORD "YourPassword" ROLES OWNER;
    ```

5. Ensure the user/pass is working by running:

    ```surql
    surreal sql --endpoint wss://YOUR_INSTANCE_HOSTNAME --user your_user --pass YourPassword --ns your_ns --db your_db
    ```

6. Make a note of the `endpoint`, `user`, and `pass` parameters. You will need them to configure Fivetran.

7. (Optional) If you prefer using `token`, we recommend `DEFINE ACCESS ... TYPE JWT`. Refer to the [`DEFINE ACCESS > JWT` documentation](/docs/surrealql/statements/define/access/jwt) to set up JWT access.

    - Verify if the token is working before proceeding to the next section, by running:
    ```surql
    surreal sql --endpoint wss://YOUR_INSTANCE_HOSTNAME --token your_token --ns your_ns --db your_db
    ```

## Finish Fivetran configuration

1. Log in to your [Fivetran account](https://fivetran.com/login).
2. Go to the **Destinations** page and click **Add destination**.
3. Enter a **Destination name** of your choice.
4. Click **Add**.
5. Select **SurrealDB** as the destination type.
6. Enter the `url`, `user` and `pass` (or `token`) you verified in the previous step.

> [!NOTE]
> The `url` setting corresponds to the `endpoint` parameter you verified in the previous step.

7. Click **Save & Test**.

Fivetran [tests and validates](https://fivetran.com/docs/destinations/surrealdb#setup-tests) the SurrealDB connection. Upon successfully completing the setup tests, you can sync your data using Fivetran connectors to the SurrealDB destination.

In addition, Fivetran automatically configures a [Fivetran Platform Connector](https://fivetran.com/docs/logs/fivetran-platform) to transfer the connector logs and account metadata to a schema in this destination. The Fivetran Platform Connector enables you to monitor your connectors, track your usage, and audit changes. The connector sends all these details at the destination level.

> [!IMPORTANT]
> If you are an Account Administrator, you can manually add the Fivetran Platform Connector on an account level so that it syncs all the metadata and logs for all the destinations in your account to a single destination. If an account-level Fivetran Platform Connector is already configured in a destination in your Fivetran account, then we don't add destination-level Fivetran Platform Connectors to the new destinations you create.

## Setup tests

Fivetran performs the following SurrealDB connection tests:

- The Database Connection test checks if we can connect to your SurrealDB database using the provided URL and token.

The test should complete in a few seconds if your Fivetran deployment can access the target SurrealDB instance.

## Related articles

- [Destination Overview](https://fivetran.com/docs/destinations/surrealdb)

- [API Destination Configuration](https://fivetran.com/docs/rest-api/api-reference/destinations/create-destination?service=surrealdb_destination)

- [Documentation Home](/docs/surrealdb/introduction/start)


================================================
FILE: src/content/doc-integrations/data-management/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Data Management
title: Data Management | Overview
description: This section contains information about the different data management features of SurrealDB.
---

import Boxes from "@components/boxes/Boxes.astro";
import IconBox from "@components/boxes/IconBox.astro";
import Version from '@components/Version.astro';

# Data Management

SurrealDB offers comprehensive data management capabilities to help you efficiently store, organize, and transform your data. Through integrations with leading data platforms, you can build robust ETL pipelines, ingest data from diverse sources, and maintain data quality at scale. The integrations below enable seamless data workflows while leveraging SurrealDB's multi-model architecture.

<style>{`
  td:first-child a { white-space: nowrap; word-break: keep-all; }
`}</style>

<table>
    <thead>
        <tr>
            <th>Integration</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><a href="/docs/integrations/data-management/airbyte">Airbyte</a></td>
            <td>Data integration platform specialising in ELT pipelines.</td>
        </tr>
        <tr>
            <td><a href="/docs/integrations/data-management/fivetran">Fivetran</a></td>
            <td>Data integration platform to manage data transfer between different sources and destination systems.</td>
        </tr>
        <tr>
            <td><a href="/docs/integrations/data-management/unstructured">Unstructured</a></td>
            <td>Data ingestion platform to manage data transfer between different sources and destination systems.</td>
        </tr>
    </tbody>
</table>


================================================
FILE: src/content/doc-integrations/data-management/n8n.mdx
================================================
---
sidebar_position: 2
sidebar_label: n8n
title: n8n | Data Management
description: The official n8n node for SurrealDB. It provides both action and tool nodes to interact with a SurrealDB database, allowing you to create, read, update, and delete records, as well as execute custom SurrealQL queries.
---

# n8n

This guide shows how to integrate SurrealDB with [n8n](https://n8n.io/), a [fair-code licensed](https://docs.n8n.io/reference/license/) workflow automation platform.


The official n8n node for SurrealDB. It provides both action and tool nodes to interact with a SurrealDB database, allowing you to create, read, update, and delete records, as well as execute custom SurrealQL queries. It is available in the [n8n Community Nodes](https://docs.n8n.io/integrations/community-nodes/) repository.


> [!IMPORTANT]
> As with all community nodes, this node works only with self-hosted n8n instances, not with n8n Cloud. This node has been tested with SurrealDB `v2.x`


## Features

- **Dual Node Types**: Functions as both an action node and a tool node for AI workflows
- **Complete CRUD Operations**: Create, read, update, and delete SurrealDB records
- **Custom Queries**: Execute any SurrealQL query with full parameter support
- **Enhanced Query Builder**: Visual interface for building `SELECT` queries with `WHERE`, `ORDER BY`, `GROUP BY`, and other clauses
- **Table Operations**: List fields and explore table structure
- **Relationship Support**: Query and manage record relationships
- **Native Data Format**: Works with SurrealDB's native data formats
- **Connection Pooling**: Configurable connection pooling for improved performance and resource management
- **Enhanced Error Handling**: Comprehensive error classification, automatic retry logic, and connection recovery
    - **Intelligent Recovery**: Different error handling strategies for different operation types
    - **Detailed Error Reporting**: Rich error context with categorization and severity levels
- **Pool Monitoring**: Built-in pool statistics and performance monitoring

## Prerequisites

1. You need a self-hosted n8n instance (`v0.214.0` or later recommended).
2. You need access to a SurrealDB instance (`2.0.0` or later recommended).

## Installation Steps

1. Open your n8n instance
2. Go to **Settings** > **Community Nodes**
3. Click **Install**
4. Enter `n8n-nodes-surrealdb` and click **Install**
5. Restart your n8n instance if prompted

> [!NOTE]
> To use this node as a tool in AI workflows, you must set the environment variable `N8N_COMMUNITY_PACKAGES_ALLOW_TOOL_USAGE=true`. 

## Configuration

In order to use SurrealDB in n8n, you need to configure the SurrealDB node.

### Credentials

To use the SurrealDB node, you need to create credentials with the following properties:

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Connection String</strong></td>
      <td>The connection string to your SurrealDB instance (must start with <code>http://</code> or <code>https://</code>). WebSocket connections (<code>ws://</code> or <code>wss://</code>) are not supported.</td>
    </tr>
    <tr>
      <td><strong>Authentication</strong></td>
      <td>Choose the authentication scope:</td>
    </tr>
    <tr>
      <td><strong>Root</strong></td>
      <td>Full access to all namespaces and databases</td>
    </tr>
    <tr>
      <td><strong>Namespace</strong></td>
      <td>Access limited to a specific namespace</td>
    </tr>
    <tr>
      <td><strong>Database</strong></td>
      <td>Access limited to a specific database within a namespace</td>
    </tr>
    <tr>
      <td><strong>Username</strong></td>
      <td>Username for authentication</td>
    </tr>
    <tr>
      <td><strong>Password</strong></td>
      <td>Password for authentication</td>
    </tr>
    <tr>
      <td><strong>Namespace</strong></td>
      <td>Target namespace (required for Namespace and Database authentication)</td>
    </tr>
    <tr>
      <td><strong>Database</strong></td>
      <td>Target database (required for Database authentication)</td>
    </tr>
  </tbody>
</table>


The authentication type you choose affects how namespace and database information is handled. Depending on the authentication type, you will need to provide different information. See the table below for more details.

<table>
  <thead>
    <tr>
      <th>Authentication Type</th>
      <th>Access Scope</th>
      <th>Required Fields</th>
      <th>Optional Fields</th>
      <th>Override Capability</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Root Authentication</strong></td>
      <td>All namespaces and databases</td>
      <td>None</td>
      <td>Namespace, Database</td>
      <td>Can override namespace/database at node level</td>
    </tr>
    <tr>
      <td><strong>Namespace Authentication</strong></td>
      <td>All databases within a specific namespace</td>
      <td>Namespace</td>
      <td>Database</td>
      <td>Can override database at node level</td>
    </tr>
    <tr>
      <td><strong>Database Authentication</strong></td>
      <td>Specific database within a specific namespace</td>
      <td>Namespace, Database</td>
      <td>None</td>
      <td>Can override both at node level for specific operations</td>
    </tr>
  </tbody>
</table>

### Node-Level Namespace and Database Overrides

For most operations, you can override the namespace and database settings from your credentials:

1. In the node configuration, expand the **Options** section
2. Enter values in the **Namespace** and/or **Database** fields
3. These values will take precedence over the credential settings for that specific operation
4. You will be required to provide a namespace when using Namespace authentication
5. You will be required to provide both a namespace and database when using Database authentication

## Operations

The SurrealDB node provides a comprehensive set of operations organized by resource type. For anything not covered, you can use the **Execute Query** operation.

<table>
  <thead>
    <tr>
      <th>Category</th>
      <th>Operation</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="5"><strong>Record Operations</strong></td>
      <td><strong>Create Record</strong></td>
      <td>Create a single record in a table</td>
    </tr>
    <tr>
      <td><strong>Get Record</strong></td>
      <td>Retrieve a specific record by ID</td>
    </tr>
    <tr>
      <td><strong>Update Record</strong></td>
      <td>Update a specific record by ID</td>
    </tr>
    <tr>
      <td><strong>Upsert Record</strong></td>
      <td>Create or update a record (insert if not exists, update if exists)</td>
    </tr>
    <tr>
      <td><strong>Delete Record</strong></td>
      <td>Delete a specific record by ID</td>
    </tr>
    <tr>
      <td rowspan="9"><strong>Table Operations</strong></td>
      <td><strong>Get All Records</strong></td>
      <td>Retrieve all records from a table</td>
    </tr>
    <tr>
      <td><strong>Create Many</strong></td>
      <td>Create multiple records in a table</td>
    </tr>
    <tr>
      <td><strong>Get Many</strong></td>
      <td>Retrieve multiple records by IDs</td>
    </tr>
    <tr>
      <td><strong>Update All Records</strong></td>
      <td>Update all records in a table</td>
    </tr>
    <tr>
      <td><strong>Delete All Records</strong></td>
      <td>Delete all records from a table</td>
    </tr>
    <tr>
      <td><strong>Merge All Records</strong></td>
      <td>Merge the same data into all records in a table</td>
    </tr>
    <tr>
      <td><strong>Create Table</strong></td>
      <td>Define a new table with optional schema</td>
    </tr>
    <tr>
      <td><strong>Delete Table</strong></td>
      <td>Remove a table from the database</td>
    </tr>
    <tr>
      <td><strong>Get Table</strong></td>
      <td>Retrieve information about a table</td>
    </tr>
    <tr>
      <td rowspan="3"><strong>Field Operations</strong></td>
      <td><strong>List Fields</strong></td>
      <td>List all fields defined on a table</td>
    </tr>
    <tr>
      <td><strong>Create Field</strong></td>
      <td>Create a new field on a table</td>
    </tr>
    <tr>
      <td><strong>Delete Field</strong></td>
      <td>Delete a field from a table</td>
    </tr>
    <tr>
      <td rowspan="2"><strong>Index Operations</strong></td>
      <td><strong>Create Index</strong></td>
      <td>Create a new index on a table</td>
    </tr>
    <tr>
      <td><strong>Delete Index</strong></td>
      <td>Delete an index from a table</td>
    </tr>
    <tr>
      <td rowspan="3"><strong>Relationship Operations</strong></td>
      <td><strong>Create Relationship</strong></td>
      <td>Create a relationship between two records</td>
    </tr>
    <tr>
      <td><strong>Delete Relationship</strong></td>
      <td>Delete a relationship between records</td>
    </tr>
    <tr>
      <td><strong>Query Relationships</strong></td>
      <td>Query relationships between records</td>
    </tr>
    <tr>
      <td rowspan="2"><strong>Query Operations</strong></td>
      <td><strong>Execute Query</strong></td>
      <td>Execute a raw SurrealQL query with parameters</td>
    </tr>
    <tr>
      <td><strong>Build Select Query</strong></td>
      <td>Build SELECT queries using a visual interface with WHERE, ORDER BY, GROUP BY, and other clauses</td>
    </tr>
    <tr>
      <td rowspan="3"><strong>System Operations</strong></td>
      <td><strong>Health Check</strong></td>
      <td>Check if the database instance is responsive</td>
    </tr>
    <tr>
      <td><strong>Version</strong></td>
      <td>Get the version of the SurrealDB instance</td>
    </tr>
    <tr>
      <td><strong>Get Pool Statistics</strong></td>
      <td>Monitor connection pool performance and statistics</td>
    </tr>
  </tbody>
</table>

## Understanding SurrealDB and n8n Integration

### Connection Protocol

> [!IMPORTANT]
> Due to n8n's architecture, this node only supports HTTP/HTTPS connections to SurrealDB. WebSocket connections (WS/WSS) are not supported.

Your connection string must start with `http://` or `https://` (not `ws://` or `wss://`). This means that when configuring your SurrealDB instance, ensure it's accessible via `HTTP/HTTPS`. 

If you're using SurrealDB Cloud or another instance that only offers WebSocket connections, you'll need to set up a [self-hosted SurrealDB instance](/pricing) with HTTP enabled. This limitation is due to how n8n handles connections and executes node operations. You can read more about this in the [n8n documentation](https://docs.n8n.io/integrations/community-nodes/n8n-nodes-surrealdb/connection-protocol/).

This node uses the HTTP/HTTPS protocol exclusively, which means that each operation creates a new connection to SurrealDB, the connection is closed after the operation completes, and no persistent connection is maintained between operations.

### Connection Pooling

The SurrealDB node includes comprehensive connection pooling to improve performance and resource management. Connection pooling allows the node to reuse database connections across multiple operations, reducing connection overhead and improving response times.

#### Pool Configuration Options

You can configure the connection pool through the "Connection Pooling" options in any node operation:

- **Max Connections** (default: 10): Maximum number of connections in the pool
- **Min Connections** (default: 2): Minimum number of connections to keep in the pool
- **Acquire Timeout** (default: 30000ms): Maximum time to wait for a connection from the pool
- **Health Check Interval** (default: 60000ms): Interval between health checks for pool connections
- **Max Idle Time** (default: 300000ms): Maximum time a connection can remain idle before being closed
- **Retry Attempts** (default: 3): Number of retry attempts for failed connection acquisitions
- **Retry Delay** (default: 1000ms): Delay between retry attempts

#### Pool Monitoring

Use the **System > Get Pool Statistics** operation to monitor pool performance:

```json
{
  "poolStatistics": {
    "totalConnections": 5,
    "activeConnections": 2,
    "idleConnections": 3,
    "waitingRequests": 0,
    "totalRequests": 150,
    "failedRequests": 2,
    "averageResponseTime": 45,
    "successRate": 99
  },
  "performance": {
    "averageResponseTimeMs": 45,
    "requestsPerSecond": 2,
    "errorRate": 1
  },
  "poolHealth": {
    "utilizationRate": 40,
    "availableConnections": 3,
    "waitingRequests": 0
  }
}
```


### SurrealDB Result Handling

SurrealDB operations often return empty results rather than errors when no matching data is found. This behavior differs from many other databases and can be important to understand when building workflows:

- **Empty Results vs. Errors**: A query for a non-existent record returns an empty result, not an error
- **Always Output Data**: The "Always Output Data" option is particularly useful with SurrealDB to ensure your workflow continues even when no results are found

### Working with SurrealDB Data Types

SurrealDB supports rich data types that map well to n8n's JSON handling:

- **Records and IDs**: SurrealDB record IDs use the format `table:id`
- **Relationships**: Relationships are first-class citizens in SurrealDB
- **Arrays and Objects**: Nested data structures are fully supported

## Error Handling

The SurrealDB node includes a comprehensive error handling and recovery system that automatically manages common database issues:

### Automatic Error Classification

The system automatically categorizes errors into different types:
<table>
  <thead>
    <tr>
      <th>Error Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Connection Errors</strong></td>
      <td>Network issues, timeouts, connection refused</td>
    </tr>
    <tr>
      <td><strong>Authentication Errors</strong></td>
      <td>Invalid credentials, unauthorized access</td>
    </tr>
    <tr>
      <td><strong>Query Errors</strong></td>
      <td>Syntax errors, malformed queries</td>
    </tr>
    <tr>
      <td><strong>Validation Errors</strong></td>
      <td>Invalid data, missing required fields</td>
    </tr>
    <tr>
      <td><strong>System Errors</strong></td>
      <td>Database server issues, internal errors</td>
    </tr>
  </tbody>
</table>

### Intelligent Retry Logic

- **Exponential Backoff**: Automatic retry with increasing delays
- **Operation-Specific Retries**: Different retry strategies for read vs write operations
- **Configurable Limits**: Adjustable retry counts and delays
- **Smart Error Filtering**: Only retry on recoverable errors

### Connection Recovery

- **Automatic Reconnection**: Reconnects to SurrealDB on connection failures
- **Re-authentication**: Automatically re-authenticates after reconnection
- **Connection Validation**: Verifies connection health before retrying operations

### Enhanced Error Reporting

When `Continue on Fail` is enabled, errors include detailed information:
```json
{
  "error": {
    "message": "Connection timeout",
    "category": "TIMEOUT_ERROR",
    "severity": "MEDIUM",
    "retryable": true,
    "context": {
      "operation": "executeQuery",
      "itemIndex": 0,
      "timestamp": "2024-01-15T10:30:00Z",
      "recoveryStrategy": "CONNECTION_RECOVERY"
    }
  }
}
```

### Error Handling Strategies

Different operation types use different error handling strategies:

- **Read Operations**: Faster retries, continue on low/medium errors
- **Write Operations**: More retries, stop on medium+ errors
- **Critical Operations**: Minimal retries, stop on any error
- **Bulk Operations**: Moderate retries, handle rate limiting

For detailed information about the error handling system, see [Error Handling Documentation](https://github.com/surrealdb/n8n-nodes-surrealdb/blob/main/docs/ERROR_HANDLING.md).

## Resources

- [n8n Community Nodes Documentation](https://docs.n8n.io/integrations/community-nodes/)
- [SurrealDB Documentation](/docs)
- [SurrealQL Reference](/docs/surrealql)




================================================
FILE: src/content/doc-integrations/data-management/unstructured.mdx
================================================
---
sidebar_position: 2
sidebar_label: Unstructured
title: Unstructured | Data Management
description: This section contains information about the Unstructured data management feature of SurrealDB.
---

# Unstructured

Unstructured cleans raw files (PDF, HTML, Office docs …) and, if you wish, embeds each chunk. SurrealDB then keeps those embeddings together with any metadata or graph relations—so your whole retrieval pipeline lives in one database.


## Setup

```bash
pip install unstructured surrealdb              # ingestion + SurrealDB SDK
surreal start --log trace --auth root root      # local server (or connect to your cluster)
```

## One-shot CLI workflow

Below we extract **embedded chunks from a PDF annual report**, save them as JSONL, then bulk-insert the file into SurrealDB.

```bash
# Choose any embedding backend supported by Unstructured
EMBED_PROVIDER="openai"

unstructured-ingest \
  local \
  --input-path example-docs/annual-report-2024.pdf \
  --output-dir ./chunks_jsonl                      \
  --strategy hi_res                                \
  --chunk-elements                                 \
  --embedding-provider "$EMBED_PROVIDER"           \
  --verbose                                        \
  filesystem                                       # write JSONL locally
```

A tiny script can read each line of `chunks_jsonl/annual-report-2024.jsonl` and push it into SurrealDB (see “Importer” below).


## Fully programmatic pipeline

### Create a tiny SurrealDB writer

```python title="surreal_writer.py"
from typing import List, Dict, Any
from surrealdb import Surreal
from unstructured.ingest.runner.writers.base_writer import Writer
from unstructured.ingest.interfaces import BaseDoc

class SDBConfig:
    def __init__(self, url: str, table: str, dim: int):
        self.url, self.table, self.dim = url, table, dim

class SDBWriter(Writer):
    def __init__(self, cfg: SDBConfig, batch_size: int = 100):
        self.cfg, self.batch_size, self.db = cfg, batch_size, None

    async def _connect(self):
        if self.db is None:
            self.db = Surreal(self.cfg.url)
            await self.db.connect()
            await self.db.signin({"user": "root", "pass": "secret"})
            await self.db.use("reports", "corp")          # namespace / database
            await self.db.query(f"""
                DEFINE TABLE IF NOT EXISTS {self.cfg.table};
                DEFINE FIELD  text       ON {self.cfg.table} TYPE string;
                DEFINE FIELD  page       ON {self.cfg.table} TYPE int;
                DEFINE FIELD  embedding  ON {self.cfg.table} TYPE array;
                DEFINE INDEX  hnsw_idx   ON {self.cfg.table}
                             FIELDS embedding HNSW DIMENSION {self.cfg.dim};
            """)

    async def write(self, batch: List[BaseDoc], **_):
        await self._connect()
        rows: List[Dict[str, Any]] = []
        for doc in batch:
            rows.append({
                "id":        f"chunk:{doc.id}",
                "text":      doc.text,
                "page":      doc.metadata.get("page_number", -1),
                "embedding": doc.embedding,
            })
        await self.db.create(self.cfg.table, rows)
```

### Run the ingest runner

```python
# ingest_to_surreal.py (NEW example)
from unstructured.ingest.connector.local import SimpleLocalConfig
from unstructured.ingest.interfaces import (
    ChunkingConfig, EmbeddingConfig, PartitionConfig,
    ProcessorConfig, ReadConfig,
)
from unstructured.ingest.runner import LocalRunner
from surreal_writer import SDBWriter, SDBConfig

if __name__ == "__main__":
    EMBED_DIM = 1536                              # e.g. OpenAI `text-embedding-3-small`

    writer = SDBWriter(
        cfg=SDBConfig(
            url="ws://localhost:8000/rpc",
            table="AnnualChunks",
            dim=EMBED_DIM,
        ),
        batch_size=80,
    )

    runner = LocalRunner(
        processor_config=ProcessorConfig(
            verbose=True,
            output_dir="./tmp-output",
            num_processes=2,
        ),
        connector_config=SimpleLocalConfig(
            input_path="example-docs/annual-report-2024.pdf",
        ),
        read_config=ReadConfig(),
        partition_config=PartitionConfig(),
        chunking_config=ChunkingConfig(chunk_elements=True),
        embedding_config=EmbeddingConfig(provider="openai"),   # UNIQUE vs. prior
        writer=writer,
        writer_kwargs={},
    )
    runner.run()
```

Running `python ingest_to_surreal.py` will:

1. Split the *2024 Annual Report* into clean text chunks
2. Embed each chunk with the OpenAI provider
3. Insert `{text, page, embedding}` rows into the `AnnualChunks` table with an HNSW index.


## Querying SurrealDB

```surql
-- Retrieve the 6 chunks most similar to a query vector
LET $q = <your-query-vector>;
SELECT text, page,
       vector::distance::cosine(embedding, $q) AS score
FROM AnnualChunks
WHERE embedding <|6|> $q
ORDER BY score;
```

SurrealDB gives you the chunk text, the original page number, and a similarity score—all filterable and join-able with any other table.

### Resources

* [Unstructured docs](https://unstructured-io.github.io/unstructured/api.html)
* Sample PDF used above – replace `annual-report-2024.pdf` with your own corp docs.

By pairing Unstructured’s document intelligence with SurrealDB’s multi-model engine, you get a fully self-contained pipeline for RAG, semantic search and analytics—no extra vector stores, no ETL headaches.



================================================
FILE: src/content/doc-integrations/data-management/surreal-sync/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Surreal Sync
title: Surreal Sync
description: Use the surreal-sync tool to migrate your data from another database to SurrealDB.
---

# Surreal Sync

Migrating your data can be done through [Surreal Sync](https://github.com/surrealdb/surreal-sync), a command-line tool that allows you to directly migrate data from another source into a running SurrealDB database through a single command such as the following.

```
SOURCE_URL=mongodb://user:pass@localhost:27017 \
surreal-sync sync mongo-db \
  --source-database "mydb" \
  --to-namespace "production" \
  --to-database "migrated_data"
```

> [!WARNING]
> Surreal Sync is currently in [active development](https://github.com/surrealdb/surreal-sync/releases) and is not yet stable. We are looking forward to any and all feedback on the tool, either via raising an issue or PR on the Surreal Sync repo, or anywhere else in the [SurrealDB community](/community).

## Supported migration sources

This tool can currently be used to migrate data from the following sources:

- [JSON lines](/docs/integrations/data-management/surreal-sync/json-lines) (including [SurrealDB terminal output!](/blog/two-new-ways-to-keep-an-eye-on-your-surrealdb-database#saving-logging-output-as-a-file))
- [MongoDB](/docs/integrations/data-management/surreal-sync/mongodb)
- [Neo4J](/docs/integrations/data-management/surreal-sync/neo4j)

## How data is migrated

Most data types are fully supported, meaning that there is a SurrealQL format that matches the originating type.

For example, Neo4J's `Duration` and `Bytes` and `String` are converted to SurrealQL types of the same name: `duration`, `bytes`, and `string`, and MongoDB's `TimeStamp` and `Double` are converted to `datetime` and `float`.

Partially supported data types are types that do not have a direct SurrealQL equivalent that could be used without data loss. These types are brought in as an object with fields that preserve the original data.

For example, Neo4J's `Point3D` type is turned into a GeoJSON-like object that includes an array of three floats for a point's longitude, latitude, and elevation:

```json
{
  "type": "Point",
  "srid": 4979,
  "coordinates": [longitude, latitude, elevation]
}
```




================================================
FILE: src/content/doc-integrations/data-management/surreal-sync/install.mdx
================================================
---
sidebar_position: 2
sidebar_label: Installing the migration tool
title: Install | Data migration
description: The surreal-sync tool can be installed on a number of operating systems via a single command.

---

# Install

The Surreal Sync data migration tool can be installed using the following commands.

```bash
# Linux (x86_64)
curl -L https://github.com/surrealdb/surreal-sync/releases/latest/download/surreal-sync-x86_64-unknown-linux-gnu.tar.gz | tar xz
sudo mv surreal-sync /usr/local/bin/

# macOS (Apple Silicon)
curl -L https://github.com/surrealdb/surreal-sync/releases/latest/download/surreal-sync-aarch64-apple-darwin.tar.gz | tar xz
sudo mv surreal-sync /usr/local/bin/

# Linux (ARM64)
curl -L https://github.com/surrealdb/surreal-sync/releases/latest/download/surreal-sync-aarch64-unknown-linux-gnu.tar.gz | tar xz
sudo mv surreal-sync /usr/local/bin/
```

For more ways to install or build from source, see the project's [readme page](https://github.com/surrealdb/surreal-sync?tab=readme-ov-file#install-pre-built-binaries).


================================================
FILE: src/content/doc-integrations/data-management/surreal-sync/json-lines.mdx
================================================
---
sidebar_position: 3
sidebar_label: Migrate from JSON lines
title: JSON lines | Data migration
description: The surreal-sync tool can be used to migrate JSON lines data into a running SurrealDB instance.
---

# JSONL Source Usage Guide

This page is a slimmed down version of [its counterpart](https://github.com/surrealdb/surreal-sync/blob/main/docs/jsonl.md) at the README documentation for the surreal-sync tool.

## Overview

The JSONL source in surreal-sync allows you to import JSON Lines (JSONL) files into SurrealDB. Each JSONL file becomes a table in SurrealDB, and each line in the file becomes a document in that table.

JSONL source is particularly useful for:

- Importing data from APIs that export in JSON (`jq` can be used to convert JSON to JSONL)
- Migrating from document-based systems like Notion
- Bulk loading structured JSON data, like configuration files or logs (even SurrealDB terminal output [when set to JSON mode](/blog/two-new-ways-to-keep-an-eye-on-your-surrealdb-database#saving-logging-output-as-a-file))
- Converting references between documents into SurrealDB's record links (RecordIds)

## Basic Usage

```bash
surreal-sync sync jsonl \
  --source-uri /path/to/jsonl/directory \
  --to-namespace myns \
  --to-database mydb
```

## Prerequisites

Before using JSONL source, ensure you have:

1. SurrealDB running locally or accessible via network
2. surreal-sync built and available in your PATH

To start SurrealDB locally:

```bash
surreal start --user root --pass root
```

## Example: Importing Notion-like Data

Let's walk through an example using sample Notion-like data with pages, blocks, and databases.

### Sample JSONL Files

Create a directory with the following JSONL files.

Note: each one of these has an `id` field, which is required in SurrealDB. To set another field as the id field, pass in the flag `--id-field "field_name"`.

**databases.jsonl**:

```json
{"id": "db1", "name": "Documentation", "description": "Main documentation database", "created_at": "2023-12-01T10:00:00Z", "properties": {"status": "active", "version": 1.0}}
{"id": "db2", "name": "API Docs", "description": "API reference documentation", "created_at": "2023-12-15T10:00:00Z", "properties": {"status": "beta", "version": 0.5}}
```

**pages.jsonl**:

```json
{"id": "page1", "title": "Getting Started", "content": "Welcome to our documentation", "parent": {"type": "database_id", "database_id": "db1"}, "created_at": "2024-01-01T10:00:00Z"}
{"id": "page2", "title": "Advanced Topics", "content": "Deep dive into advanced features", "parent": {"type": "page_id", "page_id": "page1"}, "created_at": "2024-01-02T10:00:00Z"}
{"id": "page3", "title": "API Reference", "content": "Complete API documentation", "parent": {"type": "database_id", "database_id": "db2"}, "created_at": "2024-01-03T10:00:00Z"}
```

**blocks.jsonl**:

```json
{"id": "block1", "type": "paragraph", "text": "This is a paragraph block", "parent": {"type": "page_id", "page_id": "page1"}, "order": 1}
{"id": "block2", "type": "heading", "text": "Introduction", "level": 1, "parent": {"type": "page_id", "page_id": "page1"}, "order": 2}
{"id": "block3", "type": "code", "text": "console.log('Hello World');", "language": "javascript", "parent": {"type": "page_id", "page_id": "page2"}, "order": 1}
{"id": "block4", "type": "list", "items": ["Item 1", "Item 2", "Item 3"], "parent": {"type": "block_id", "block_id": "block2"}, "order": 3}
```

### Running the Import

Use the following command to import the data with conversion rules for parent references:

```bash
surreal-sync sync jsonl \
  --source-uri /workspace/tests/test_data/jsonl \
  --to-namespace notion \
  --to-database docs \
  --surreal-endpoint http://surrealdb:8000 \
  --surreal-username root \
  --surreal-password root \
  --rule 'type="database_id",database_id databases:database_id' \
  --rule 'type="page_id",page_id pages:page_id' \
  --rule 'type="block_id",block_id blocks:block_id'
```

> [!NOTE]
>Replace `http://surrealdb:8000` with `http://localhost:8000` if running SurrealDB locally on your machine.

If successful, the command will complete without output. You can verify the import worked by checking the database as shown in the next section.

### Understanding Conversion Rules

The `--rule` flag defines how to convert JSON objects into SurrealDB record links. The format is:

```
--rule 'type="TYPE_VALUE",ID_FIELD TARGET_TABLE:ID_FIELD'
```

For example:

- `type="page_id",page_id pages:page_id` means:
  - When a JSON object has `"type": "page_id"`
  - Take the value from the `page_id` field
  - Convert it to a record link like `pages:page1` if the `page_id` is `page1`.

## Custom ID Fields

By default, surreal-sync looks for an `id` field in each JSON object. You can specify a different field name:

```bash
surreal-sync sync jsonl \
  --source-uri /path/to/jsonl \
  --to-namespace myns \
  --to-database mydb \
  --id-field "item_id"
```

Example JSONL with custom ID field:
```json
{"item_id": "prod1", "name": "Widget", "price": 19.99}
{"item_id": "prod2", "name": "Gadget", "price": 29.99}
```

## Advanced Options

### Batch Size
Control how many records are processed at once:
```bash
--batch-size 500
```

### Dry Run
Test the import without actually writing data:
```bash
--dry-run
```

### Environment Variables
You can also use environment variables for configuration:
```bash
export SURREAL_ENDPOINT=http://localhost:8000
export SURREAL_USERNAME=root
export SURREAL_PASSWORD=root
export SOURCE_URI=/path/to/jsonl

surreal-sync sync jsonl \
  --to-namespace myns \
  --to-database mydb
```

## Tips and Best Practices

1. **File Naming**: Name your JSONL files exactly as you want your SurrealDB tables to be named.

2. **ID Values**: Ensure all documents have unique ID values within each file.

3. **Data Types**: JSONL source preserves JSON data types:
   - Numbers remain as integers or floats
   - Strings remain as strings
   - Arrays and objects are preserved
   - Booleans remain as booleans
   - Null values are preserved

4. **References**: Use conversion rules to maintain relationships between documents across different tables.

5. **Performance**: For large datasets, adjust the batch size based on your system's memory and SurrealDB's capacity.

## Troubleshooting

1. **Missing ID Field**: If you see "Missing ID field" errors, ensure your JSON objects have the ID field (default: "id") or specify the correct field with `--id-field`.

2. **Invalid Rule Format**: Conversion rules must follow the exact format. Check for proper quoting and spacing.

3. **File Not Found**: Ensure the source URI points to a directory containing `.jsonl` files, not individual files.

4. **Connection Issues**: Verify SurrealDB is running and accessible at the specified endpoint.


================================================
FILE: src/content/doc-integrations/data-management/surreal-sync/mongodb.mdx
================================================
---
sidebar_position: 4
sidebar_label: Migrate from MongoDB
title: MongoDB | Data migration
description: Use the surreal-sync tool to migrate your data from MongoDB to SurrealDB.
---

# MongoDB

## Supported data types

MongoDB data types are either fully supported via direct conversion, or partially supported via an object that maintains the information in the original type. For more on these data types, see [the project repository](https://github.com/surrealdb/surreal-sync/blob/main/docs/neo4j-data-types.md).

## Import example

Create file users.json containing data to be stored in MongoDB:

```json
[
  {
    "_id": { "$oid": "64a7a21fc25e3d2c7a3b55f1" },
    "name": "Alice Johnson",
    "email": "alice@example.com",
    "age": 29,
    "roles": ["admin", "editor"]
  },
  {
    "_id": { "$oid": "64a7a21fc25e3d2c7a3b55f2" },
    "name": "Bob Smith",
    "email": "bob@example.com",
    "age": 35,
    "roles": ["user"]
  }
]
```

Next, import the data to MongoDB via the following command.

```
mongoimport --db testdb --collection users --file users.json --jsonArray
```

With the data imported, start the server at the path of your current directory.

```
mongod --dbpath /your/current/directory
```

With the MongoDB server running, start a SurrealDB server with `surreal start --user root --pass root`.

The `surreal-sync` command can then be used to import the data from the running MongoDB instance.

```
surreal-sync sync mongo-db \
  --source-database "testdb" \
  --to-namespace "production" \
  --to-database "migrated_data" \
  --source-uri "mongodb://localhost:27017"
```

To confirm the data, log in to the SurrealDB database under namespace `production` and database `migrated_data`, and use the query `SELECT * FROM users` to see the data.

```surql title="Result"
[
	{
		age: 29,
		email: 'alice@example.com',
		id: users:64a7a21fc25e3d2c7a3b55f1,
		name: 'Alice Johnson',
		roles: [
			'admin',
			'editor'
		]
	},
	{
		age: 35,
		email: 'bob@example.com',
		id: users:64a7a21fc25e3d2c7a3b55f2,
		name: 'Bob Smith',
		roles: [
			'user'
		]
	}
]
```


================================================
FILE: src/content/doc-integrations/data-management/surreal-sync/neo4j.mdx
================================================
---
sidebar_position: 5
sidebar_label: Migrate from Neo4J
title: Neo4J | Data migration
description: Use the surreal-sync tool to migrate your data from Neo4J to SurrealDB, including edges.
---

# Neo4J

## Supported data types

Neo4J data types are either fully supported via direct conversion, or partially supported via an object that maintains the information in the original type. For more on these data types, see [the project repository](https://github.com/surrealdb/surreal-sync/blob/main/docs/neo4j-data-types.md).

## Import example

Log in to Neo4J, start server with user `neo4j` and password `password`, then run the following queries:

```surql title="Sample Neo4J data"
CREATE (a:Person {name: 'Alice', age: 29})
CREATE (b:Person {name: 'Bob', age: 35})
CREATE (c:Person {name: 'Charlie', age: 40})
CREATE (a)-[:FRIENDS_WITH]->(b)
CREATE (b)-[:FRIENDS_WITH]->(c)
```

Next, start a surrealdb server with the command `surreal start --user root --pass root`.

Then run the following command to import the data to SurrealDB:

```
surreal-sync sync
neo4j \
  --source-uri "bolt://localhost:7687" \
  --source-username "neo4j" \
  --source-password "password" \
  --to-namespace "test" \
  --to-database "test"
```

Log in to SurrealDB under namespace `test` and database `test`, use `SELECT *, friends_with->person AS friends FROM person` statement to see imported data:

```surql title="Result"
[
	{
		age: 29,
		friends: NONE,
		id: person:0,
		labels: [
			'Person'
		],
		name: 'Alice',
		neo4j_id: 0
	},
	{
		age: 35,
		friends: NONE,
		id: person:1,
		labels: [
			'Person'
		],
		name: 'Bob',
		neo4j_id: 1
	},
	{
		age: 40,
		friends: NONE,
		id: person:2,
		labels: [
			'Person'
		],
		name: 'Charlie',
		neo4j_id: 2
	}
]
```

## After migration

After a migration is done, you may want to add a schema. As SurrealDB is schemaless by default, tables will be declared with the `DEFINE TABLE <table_name> TYPE ANY SCHEMALESS PERMISSIONS NONE`. For example, if [this sample movie database](https://github.com/neo4j-graph-examples/movies/blob/main/scripts/movies.cypher) is imported, the Surrealist Designer view will simply show nine table names with no specified relation.

![Surrealist's designer view showing some schemaless tables with no clear connection between them.](loose_schema.png)

Note that the graph relations have already been set up; they just have not been strictly defined in the schema.

```surql
SELECT 
	name, 
	->wrote->movie.title AS wrote 
FROM person
ORDER BY name;

-- Output
[
	{
		name: 'Aaron Sorkin',
		wrote: [
			'A Few Good Men'
		]
	},
	{
		name: 'Al Pacino',
		wrote: []
	},
	{
		name: 'Alice',
		wrote: []
	},
	// and so on
]
```

To begin setting a schema, you can use this sort of query to see exactly which relations exist.

```surql
-- Get every type and destination of links from `person`, flatten into
-- a single array, remove duplicates
(SELECT VALUE ->?.{
    val: id.tb() + '->' + out.tb()
} FROM person).flatten().map(|$v| $v.val).distinct();
```

```surql
[
	'friends_with->person',
	'acted_in->movie',
	'directed->movie',
	'produced->movie',
	'wrote->movie',
	'follows->person',
	'reviewed->movie'
]
```

This information can now be used to overwrite the existing loose definitions into concrete `RELATION` tables with a specified `in` and `out`.

```surql
DEFINE TABLE OVERWRITE friends_with TYPE RELATION IN person OUT person;
DEFINE TABLE OVERWRITE follows TYPE RELATION IN person OUT person;

DEFINE TABLE OVERWRITE acted_in TYPE RELATION IN person OUT movie;
DEFINE TABLE OVERWRITE directed TYPE RELATION IN person OUT movie;
DEFINE TABLE OVERWRITE wrote TYPE RELATION IN person OUT movie;
DEFINE TABLE OVERWRITE follows TYPE RELATION IN person OUT person;
DEFINE TABLE OVERWRITE reviewed TYPE RELATION IN person OUT movie;
DEFINE TABLE OVERWRITE produced TYPE RELATION IN person OUT movie;
```

![Surrealist's designer view showing concretely defined tables and the relation between them.](concrete_schema.png)


================================================
FILE: src/content/doc-integrations/Embeddings/fastembed.mdx
================================================
---
sidebar_position: 5
sidebar_label: Fastembed
title: Fastembed | Embeddings
description: This section contains information about using Fastembed to retrieve embeddings to store in SurrealDB
---

# Fastembed

Fastembed is a library that allows you to generate vector embeddings locally, without needing an API key or calling into an external service.

Fastembed uses the included ONNX runtime to run its embedding models, downloading the model once every time it is used for the first time.

Fastembed libraries are available for the following languages:

* [Python](https://github.com/qdrant/fastembed)
* [Rust](https://crates.io/crates/fastembed)
* [Go](https://github.com/Anush008/fastembed-go)
* [JavaScript](https://github.com/Anush008/fastembed-js)

## Overview of available models

The following is an overview of most of the models available for Fastembed. General use cases are:

* Prototyping, development speed, cost savings: models with small vector embedding sizes tend to take up a relatively small amount of disk size as well (generally a few hundred MB) and can be quickly downloaded and run locally.
* Small or edge devices: devices with no internet access can still take advantage of vector embeddings.
* Particular use cases: some models are specialized for certain use cases such as images, certain languages, and contexts.

### MiniLM Series

Fast general-purpose embeddings. Choose L6 for speed, L12 for quality. Ideal for semantic search, clustering, and similarity tasks.

A "quantized" model means that it is optimised for faster inference and lower memory usage, often with minimal quality loss.

| Model name      | Embedding size | Description                                         |
| --------------- | -------------- | --------------------------------------------------- |
| AllMiniLML6V2   | 384            | Sentence Transformer model, MiniLM-L6-v2            |
| AllMiniLML6V2Q  | 384            | Quantized Sentence Transformer model, MiniLM-L6-v2  |
| AllMiniLML12V2  | 384            | Sentence Transformer model, MiniLM-L12-v2           |
| AllMiniLML12V2Q | 384            | Quantized Sentence Transformer model, MiniLM-L12-v2 |

### BGE Series 

Used for dense retrieval and semantic similarity. BGESmallENV15 is optimized for speed and tends to be the default choice for many applications.

| Model name     | Embedding size | Description                                                  |
| -------------- | -------------- | ------------------------------------------------------------ |
| BGEBaseENV15   | 768            | v1.5 release of the base English model                       |
| BGEBaseENV15Q  | 768            | Quantized v1.5 release of the base English model             |
| BGELargeENV15  | 1024           | v1.5 release of the large English model                      |
| BGELargeENV15Q | 1024           | Quantized v1.5 release of the large English model            |
| BGESmallENV15  | 384            | v1.5 release of the fast and default English model           |
| BGESmallENV15Q | 384            | Quantized v1.5 release of the fast and default English model |


### Nomic Embed Text

Used for large context window embeddings.

Optimized for long-context English text (8K tokens). v1.5 improves quality over v1.

| Model name         | Embedding size | Description                                                     |
| ------------------ | -------------- | --------------------------------------------------------------- |
| NomicEmbedTextV1   | 768            | 8192 context length english model                               |
| NomicEmbedTextV15  | 768            | v1.5 release of the 8192 context length english model           |
| NomicEmbedTextV15Q | 768            | Quantized v1.5 release of the 8192 context length english model |


### Paraphrase Models

Used for paraphrase detection and multilingual similarity. Ideal for sentence equivalence and semantic matching tasks.

| Model name               | Embedding size | Description                                                              |
| ------------------------ | -------------- | ------------------------------------------------------------------------ |
| ParaphraseMLMiniLML12V2  | 384            | Multi-lingual model                                                      |
| ParaphraseMLMiniLML12V2Q | 384            | Quantized Multi-lingual model                                            |
| ParaphraseMLMpnetBaseV2  | 768            | Sentence-transformers model for tasks like clustering or semantic search, based on the MPNet architecture. |


### Chinese BGE Models

| Model name    | Embedding size | Description                             |
| ------------- | -------------- | --------------------------------------- |
| BGESmallZHV15 | 512            | v1.5 release of the small Chinese model |
| BGELargeZHV15 | 1024           | v1.5 release of the large Chinese model |


### ModernBert and Multilingual E5

Used for context-rich multilingual embeddings. Great for cross-language retrieval and nuanced contextual understanding.

| Model name           | Embedding size | Description                                    |
| -------------------- | -------------- | ---------------------------------------------- |
| ModernBertEmbedLarge | 1024           | Large model of ModernBert Text Embeddings      |
| MultilingualE5Small  | 384            | Small model of multilingual E5 Text Embeddings |
| MultilingualE5Base   | 768            | Base model of multilingual E5 Text Embeddings  |
| MultilingualE5Large  | 1024           | Large model of multilingual E5 Text Embeddings |


### Mxbai and GTE

Used for high-quality English/multilingual embeddings.

| Model name         | Embedding size | Description                                                |
| ------------------ | -------------- | ---------------------------------------------------------- |
| MxbaiEmbedLargeV1  | 1024           | Large English embedding model from MixedBreed.ai           |
| MxbaiEmbedLargeV1Q | 1024           | Quantized Large English embedding model from MixedBreed.ai |
| GTEBaseENV15       | 768            | Base multilingual embedding model from Alibaba            |
| GTEBaseENV15Q      | 768            | Quantized base multilingual embedding model from Alibaba  |
| GTELargeENV15      | 1024           | Large multilingual embedding model from Alibaba            |
| GTELargeENV15Q     | 1024           | Quantized large multilingual embedding model from Alibaba  |


### CLIP and Code Models

Use CLIP for image-text matching, Jina for code search and retrieval. JinaEmbeddingsV2BaseCode is optimised for embedding code snippets.

| Model name               | Embedding size | Description                         |
| ------------------------ | -------------- | ----------------------------------- |
| ClipVitB32               | 512            | CLIP text encoder based on ViT-B/32 |
| JinaEmbeddingsV2BaseCode | 768            | Jina embeddings v2 base code        |

## Language-specific example

The following example in Rust demonstrates how SurrealDB can be used to store the embeddings from the default language model for a number of phrases, after which it can be prompted to return the three closest results to a certain prompt.

First add a few crates to Cargo.toml with the following command:

```bash
cargo add anyhow fastembed serde tokio surrealdb --features surrealdb/kv-mem
```

Then use the following code.

```rust
use anyhow::Error;
use fastembed::{EmbeddingModel, InitOptions, TextEmbedding};
use serde::Serialize;
use surrealdb::{
    Surreal, Value,
    engine::any::{Any, connect},
};

const SCHEMA: &str = "DEFINE TABLE document;
        DEFINE FIELD text ON document TYPE string;
        DEFINE FIELD embedding ON document TYPE array<float>;
        // Uncomment this to use HNSW index, ensure that number after DIMENSION matches size of embedding
        // DEFINE INDEX hnsw_embed ON document FIELDS embedding HNSW DIMENSION 384 DIST COSINE";

const INSERT_QUERY: &str = "INSERT INTO document $docs";

const VECTOR_QUERY: &str = "SELECT 
        text, 
        vector::distance::knn() AS distance 
        FROM document
        WHERE embedding <|3,COSINE|> $embeds
        ORDER BY distance";

#[derive(Serialize)]
struct DocumentInput {
    text: String,
    embedding: Vec<f32>,
}

async fn store_docs(
    input: Vec<&str>,
    db: &Surreal<Any>,
    model: &mut TextEmbedding,
) -> Result<(), Error> {
    let docs = model
        .embed(input.clone(), None)?
        .into_iter()
        .zip(input.into_iter())
        .map(|(embedding, text)| DocumentInput {
            text: text.to_string(),
            embedding,
        })
        .collect::<Vec<DocumentInput>>();

    db.query(INSERT_QUERY).bind(("docs", docs)).await?;
    Ok(())
}

async fn test_embed(
    input: &str,
    db: &Surreal<Any>,
    model: &mut TextEmbedding,
) -> Result<(), Error> {
    let Some(embeds) = model.embed(vec![input], None)?.into_iter().next() else {
        return Err(anyhow::anyhow!("Nothing found at index 0"));
    };

    let val = db
        .query(VECTOR_QUERY)
        .bind(("embeds", embeds.clone()))
        .await?
        .take::<Value>(0)?;
    println!("{val}\n");
    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    // Default model
    let mut model = TextEmbedding::try_new(InitOptions::new(EmbeddingModel::BGESmallENV15))?;

    let db = connect("memory").await?;

    db.use_ns("ns").use_db("db").await?;

    db.query(SCHEMA).await?;

    let input = vec![
        // Cities
        "Calgary is a city in the Canadian province of Alberta.",
        "Ljubljana is the capital and largest city of Slovenia.",
        // Historical / mythological figures
        "Xenophon of Athens was a Greek military leader, philosopher, and historian.",
        "King Arthur was a mythical king in the mythology of Great Britain.",
        // Planets
        "Venus is the second planet from the Sun.",
        "Ceres is a dwarf planet in the middle main asteroid belt between the orbits of Mars and Jupiter.",
        // Languages
        "Manx is a Gaelic language of the insular Celtic branch of the Celtic language family",
        "Interlingue, originally Occidental, is an international auxiliary language created in 1922.",
        // Sea animals
        "Octopuses have a complex nervous system and are among the most intelligent and behaviourally diverse invertebrates.",
        "Clams have no central nervous system at all and are near to plants in intelligence.",
    ];
    store_docs(input, &db, &mut model).await?;

    println!("Edmonton is closest to:");
    test_embed("Edmonton", &db, &mut model).await?;

    println!("Merlin is closest to:");
    test_embed("Merlin", &db, &mut model).await?;

    println!("Earth is closest to:");
    test_embed("Earth", &db, &mut model).await?;

    println!("Irish is closest to:");
    test_embed("Irish language", &db, &mut model).await?;

    println!("Squid are closest to:");
    test_embed("Squid", &db, &mut model).await?;

    Ok(())
}
```

Output of the example with the default model:

```
Edmonton is closest to:
[
    { distance: 0.2596421358215669f, text: 'Calgary is a city in the Canadian province of Alberta.' },
    { distance: 0.5010449624435647f, text: 'Ljubljana is the capital and largest city of Slovenia.' },
    { distance: 0.5242241576926254f, text: 'Interlingue, originally Occidental, is an international auxiliary language created in 1922.' }
]

Merlin is closest to:
[
    { distance: 0.3653307924860497f, text: 'King Arthur was a mythical king in the mythology of Great Britain.' },
    { distance: 0.4515194174120666f, text: 'Manx is a Gaelic language of the insular Celtic branch of the Celtic language family' },
    { distance: 0.5317039966149415f, text: 'Calgary is a city in the Canadian province of Alberta.' }
]

Earth is closest to:
[
    { distance: 0.3380429615054925f, text: 'Venus is the second planet from the Sun.' },
    { distance: 0.3764237673020161f, text: 'Ceres is a dwarf planet in the middle main asteroid belt between the orbits of Mars and Jupiter.' },
    { distance: 0.444087039462282f, text: 'Calgary is a city in the Canadian province of Alberta.' }
]

Irish is closest to:
[
    { distance: 0.27517683002655635f, text: 'Manx is a Gaelic language of the insular Celtic branch of the Celtic language family' },
    { distance: 0.34080671701374754f, text: 'Interlingue, originally Occidental, is an international auxiliary language created in 1922.' },
    { distance: 0.5113325799682362f, text: 'King Arthur was a mythical king in the mythology of Great Britain.' }
]

Squid are closest to:
[
    { distance: 0.3439891425642231f, text: 'Octopuses have a complex nervous system and are among the most intelligent and behaviourally diverse invertebrates.' },
    { distance: 0.4707156750207915f, text: 'Manx is a Gaelic language of the insular Celtic branch of the Celtic language family' },
    { distance: 0.517311424260043f, text: 'Clams have no central nervous system at all and are near to plants in intelligence.' }
]
```


================================================
FILE: src/content/doc-integrations/Embeddings/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Embeddings
title: Embeddings | Overview
description: This section contains information about different LLM models you can use with SurrealDB.
---

import Boxes from '@src/components/boxes/Boxes.astro';
import IconBox from '@components/boxes/IconBox.astro';

import LightPython from '@img/icon/light/python.png';
import LightRust from '@img/icon/light/rust.png';

import DarkPython from '@img/icon/dark/python.png';
import DarkRust from '@img/icon/dark/rust.png';

# Embeddings

SurrealDB offers comprehensive support for vector embeddings, enabling powerful semantic search and machine learning capabilities across your data. Through integrations with leading embedding providers, you can easily store, index and query high-dimensional vectors alongside your regular data.

<Boxes columns={2} wider class="pt-2">
	<IconBox
		title="Quick start with Python"
		description="LangChain, Ollama, Mistral, and more"
		href="/docs/integrations/embeddings/python"
		icon={{ light: LightPython, dark: DarkPython }}
	/>
	<IconBox
		title="Quick start with Rust"
		description="Mistral, Ollama, and more"
		href="/docs/integrations/embeddings/rust"
		icon={{ light: LightRust, dark: DarkRust }}
	/>
</Boxes>

## Full examples

<table>
  <tbody>
    <tr>
      <td><a href="/docs/integrations/embeddings/mistral">Mistral</a></td>
      <td>Mistral AI's embedding model and SurrealDB vector search (Python and Rust)</td>
    </tr>
    <tr>
      <td><a href="/docs/integrations/embeddings/openai">OpenAI</a></td>
      <td>OpenAI's embedding service and SurrealDB vector search (Python and Rust)</td>
    </tr>
  </tbody>
</table>



================================================
FILE: src/content/doc-integrations/Embeddings/mistral.mdx
================================================
---
sidebar_position: 4
sidebar_label: Mistral
title: Mistral
description: End-to-end guide for building a fast semantic-search stack with Mistral-Embed vectors stored in SurrealDB’s native HNSW index.
---

import Label from "@components/shared/Label.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Mistral

<Tabs>
<TabItem label="Python">

Modern open-source RAG pipelines need two things:

1. **High-quality embeddings** – *Mistral-Embed* (`mistral-embed`) returns 1 024-dimensional float vectors that rival OpenAI + Cohere.  
2. **Blazing-fast vector storage** – **SurrealDB** (≥ v1.5) ships an in-memory HNSW index, queried with the `<|K,EF|>` operator in SurrealQL.

Below you’ll wire them together, from install → ingestion → search → production-ready script.

## Prerequisites

```bash
pip install mistralai surrealdb
````

Set two environment variables (or hard-code them if you must):

```bash
export SDB_URL="http://localhost:8000/rpc"   # ← SurrealDB RPC endpoint
export MISTRAL_API_KEY="sk-…"                # ← your Mistral key
```

## Connect and create the schema

```python
from mistralai.client import MistralClient
from surrealdb import Surreal
import os, asyncio

# ----- 1.1 · Config -----------------------------------------------------------------
SDB_URL  = os.getenv("SDB_URL", "http://localhost:8000/rpc")
SDB_USER = os.getenv("SDB_USER", "root")
SDB_PASS = os.getenv("SDB_PASS", "secret")
NS, DB   = "demo", "demo"
TABLE    = "mistral_docs"
MODEL    = "mistral-embed"

# ----- 1.2 · Clients ----------------------------------------------------------------
sdb   = Surreal(SDB_URL)
mistr = MistralClient(api_key=os.environ["MISTRAL_API_KEY"])

async def init_db():
    await sdb.signin({"user": SDB_USER, "pass": SDB_PASS})
    await sdb.use(NS, DB)

    # one quick embedding → get true vector dimension
    dim = len(mistr.embeddings(model=MODEL, input=["ping"]).data[0].embedding)

    schema = """
    DEFINE TABLE $tb SCHEMALESS PERMISSIONS NONE;
    DEFINE FIELD text      ON $tb TYPE string;
    DEFINE FIELD embedding ON $tb TYPE array;

    DEFINE INDEX hnsw_idx ON $tb
      FIELDS embedding
      HNSW DIMENSION {dim}
      DIST   COSINE;
    """
    await sdb.query(schema, {"tb": TABLE})

asyncio.run(init_db())
```

### Why detect the dimension dynamically?

*Future-proofing:* if Mistral introduces a **small** or **large** Embed model with a different dimension, the code auto-adapts.

## Embed and bulk-insert documents

```python
DOCS = [
    "SurrealDB offers an in-memory HNSW vector index for low-latency search.",
    "Mistral-Embed produces 1 024-dimensional embeddings.",
    "You can build a completely open-source RAG stack with these two tools.",
]

async def insert_docs(docs, batch=64):
    rows = []
    for i in range(0, len(docs), batch):
        chunk = docs[i : i + batch]
        vecs  = mistr.embeddings(model=MODEL, input=chunk).data
        rows += [
            {
                "id":        f"{TABLE}:{i+j}",
                "text":      chunk[j],
                "embedding": vec.embedding,
            }
            for j, vec in enumerate(vecs)
        ]
    await sdb.query(f"INSERT INTO {TABLE} $data", {"data": rows})

asyncio.run(insert_docs(DOCS))
```

*Why bulk-insert?* One SurrealQL call → one network round-trip — **much faster** than inserting row-by-row.

## Search with a natural-language query

```python
async def search(query: str, k: int = 3, ef: int = 64):
    q_vec = mistr.embeddings(model=MODEL, input=[query]).data[0].embedding
    surql = """
    LET $q := $vec;
    SELECT id, text, vector::distance::knn() AS score
    FROM $tb
    WHERE embedding <|{k},{ef}|> $q
    ORDER BY score;
    """
    res = await sdb.query(surql, {"vec": q_vec, "tb": TABLE})
    return res[0].result

hits = asyncio.run(search("Which database supports native vector search?"))
for h in hits:
    print(f"⭐ {h['text']}  (score={h['score']:.4f})")
```

`<|K,EF|>` activates the HNSW **K-nearest-neighbour** operator (`K=3`, `efSearch=64`).
`vector::distance::knn()` exposes the cosine distance already computed inside the index—no post-processing needed.

## Full script (ready to run)

```python
# mistral_surreal_demo.py
from __future__ import annotations
import os, asyncio
from mistralai.client import MistralClient
from surrealdb import Surreal

SDB_URL  = os.getenv("SDB_URL", "http://localhost:8000/rpc")
SDB_USER = os.getenv("SDB_USER", "root")
SDB_PASS = os.getenv("SDB_PASS", "secret")
NS, DB, TABLE = "demo", "demo", "mistral_docs"
MODEL   = "mistral-embed"
KEY     = os.environ["MISTRAL_API_KEY"]  # export first!

sdb, mistr = Surreal(SDB_URL), MistralClient(api_key=KEY)

DOCS = [
    "SurrealDB's vector index is built on HNSW.",
    "Mistral-Embed vectors offer strong semantic quality.",
    "Together they form a fast, open-source search stack.",
]

async def main():
    await sdb.signin({"user": SDB_USER, "pass": SDB_PASS})
    await sdb.use(NS, DB)

    dim = len(mistr.embeddings(model=MODEL, input=["x"]).data[0].embedding)
    await sdb.query("""
        DEFINE TABLE $tb SCHEMALESS PERMISSIONS NONE;
        DEFINE FIELD text ON $tb TYPE string;
        DEFINE FIELD embedding ON $tb TYPE array;
        DEFINE INDEX hnsw_idx ON $tb FIELDS embedding
               HNSW DIMENSION {dim} DIST COSINE;
    """, {"tb": TABLE})

    # ingest if empty
    if (await sdb.query(f"SELECT count() FROM {TABLE};"))[0].result[0]["count"] == 0:
        rows = []
        vecs = mistr.embeddings(model=MODEL, input=DOCS).data
        rows = [
            {"id": f"{TABLE}:{i}", "text": DOCS[i], "embedding": v.embedding}
            for i, v in enumerate(vecs)
        ]
        await sdb.query(f"INSERT INTO {TABLE} $data", {"data": rows})

    # search
    q_vec = mistr.embeddings(model=MODEL,
                             input=["open-source vector database"] ).data[0].embedding
    res = await sdb.query("""
        LET $q := $vec;
        SELECT text, vector::distance::knn() AS score
        FROM {TABLE}
        WHERE embedding <|3,64|> $q
        ORDER BY score;
    """, {"vec": q_vec})
    print(res[0].result)

if __name__ == "__main__":
    asyncio.run(main())
```

## About quantisation

SurrealDB currently stores vectors as `float32` / `float64` arrays and does **not** ship built-in binary or int8 quantisation.
If memory is critical you can:

1. Quantise offline to int8 (e.g. with *faiss* or *sentence-transformers*).
2. Store the int8 arrays in **another field** (SurrealQL’s array type is agnostic).
3. Execute a **two-stage search**: coarse K-NN on the int8 field, then rescore on the full-precision field.


### You’re done 🚀

You now have a clean, fully-async SurrealDB setup that stores **Mistral-Embed** vectors, supports **fast HNSW search**, and can be dropped into any RAG or semantic-search workflow.
{/* 
```python
# ───────────────────────── 0 · Imports & config ──────────────────────────
from __future__ import annotations

import os, asyncio, math, typing as T
from mistralai.client import MistralClient
from surrealdb import Surreal

SDB_URL    = os.getenv("SDB_URL", "http://localhost:8000/rpc")
SDB_USER   = os.getenv("SDB_USER", "root")
SDB_PASS   = os.getenv("SDB_PASS", "secret")
NS         = "demo"
DB         = "demo"
TABLE      = "mistral_docs"

MISTRAL_KEY = os.getenv("MISTRAL_API_KEY")   # ▸ export MISTRAL_API_KEY=...
assert MISTRAL_KEY, "No Mistral key found!"

# ───────────────────────── 1 · Clients ───────────────────────────────────
sdb   = Surreal(SDB_URL)
mistr = MistralClient(api_key=MISTRAL_KEY)

# ───────────────────────── 2 · Example documents ─────────────────────────
DOCS = [
    "SurrealDB ships an in-memory HNSW index for high-speed ANN search.",
    "Mistral-Embed produces 1024-dimensional float vectors.",
    "You can pair them for a full open-source semantic-search stack.",
]

# ───────────────────────── 3 · Helper funcs ──────────────────────────────
async def	init_db() -> None:
    """Connect and (re)create the schema if needed."""
    await sdb.signin({"user": SDB_USER, "pass": SDB_PASS})
    await sdb.use(NS, DB)

    # embed *one* doc to get the true dimension
    dim = len(
        mistr.embeddings(model="mistral-embed", input=["ping"]).data[0].embedding
    )

    schema = `
    DEFINE TABLE $tb SCHEMALESS PERMISSIONS NONE;
    DEFINE FIELD text      ON $tb TYPE string;
    DEFINE FIELD embedding ON $tb TYPE array;

    DEFINE INDEX hnsw_idx ON $tb
      FIELDS embedding
      HNSW DIMENSION {dim}
      DIST   COSINE;
    """
    await sdb.query(schema, {"tb": TABLE})


async def	insert_docs(docs: list[str]) -> None:
    """Batch-embed & insert documents via one SurrealQL call."""
    batch_size = 64
    rows: list[dict[str, T.Any]] = []

    for i in range(0, len(docs), batch_size):
        chunk  = docs[i : i + batch_size]
        vecs   = mistr.embeddings(model="mistral-embed", input=chunk).data
        rows  += [
            {
                "id":        f"{TABLE}:{i + j}",
                "text":      chunk[j],
                "embedding": vec.embedding,
            }
            for j, vec in enumerate(vecs)
        ]

    await sdb.query(f"INSERT INTO {TABLE} $data", {"data": rows})


async def	search(query: str, k: int = 3, ef: int = 64):
    """Return the top-k docs for a query."""
    q_vec = mistr.embeddings(model="mistral-embed", input=[query]).data[0].embedding
    surql = `
    LET $q := $vec;
    SELECT id, text, vector::distance::knn() AS score
    FROM $tb
    WHERE embedding <|{k},{ef}|> $q
    ORDER BY score;
    """
    res = await sdb.query(surql, {"vec": q_vec, "tb": TABLE})
    return res[0].result


# ───────────────────────── 4 · Main entry - async all-in-one ─────────────
async def main():
    await init_db()

    # ingest only if empty
    count = (await sdb.query(f"SELECT count() FROM {TABLE};"))[0].result[0]["count"]
    if count == 0:
        await insert_docs(DOCS)

    hits = await search("Which DB offers native vector search?")
    for h in hits:
        print(f"⭐ {h['text']}  (score={h['score']:.4f})")

asyncio.run(main()) */}

</TabItem>
<TabItem label="Rust">

## Setup

Create a new Cargo project with `cargo new project_name` and go into the project folder, then add the following dependencies inside `Cargo.toml`:

```toml
anyhow = "1.0.98"
mistralai-client = "0.14.0"
serde = "1.0.219"
surrealdb = { version = "2.3", features = ["kv-mem"] }
tokio = "1.45.0"
```
<br />

You can add the same dependencies on the command line through a single command:

```
cargo add anyhow mistralai-client serde tokio surrealdb --features surrealdb/kv-mem
```
<br />

Connect to a database using "memory" for an embedded instance:

```rust
use anyhow::Error;
use surrealdb::engine::any::connect;

#[tokio::main]
async fn main() -> Result<(), Error> {
    let db = connect("memory").await?;
    Ok(())
}
```
<br />

Or another address if accessing a Cloud or local instance, such as:

```rust
// Cloud address
let db = connect("wss://myinstance-06a4h41t12rtj7lsg45m3prm1k.aws-use1.surreal.cloud").await?;

// Local address
let db = connect("ws://localhost:8000").await?;
```
<br />

Then select a namespace and database name.

```rust
db.use_ns("ns").use_db("db").await?;
```
<br />

## Create a vector table and index

Create a table called `document` to store documents and embeddings. The `HNSW` index is one way to [maintain performance](/docs/surrealql/operators#hnsw-method) if the dataset becomes quite large; otherwise, it can be left out.

```surql
DEFINE TABLE document;
DEFINE FIELD text ON document TYPE string;
DEFINE FIELD embedding ON document TYPE array<float>;
DEFINE INDEX hnsw_embed ON document FIELDS embedding HNSW DIMENSION 1024 DIST COSINE;
```
<br />

The size of the vector (1024 here) represents the number of dimensions in the embedding. This is to match Mistral AI's `mistral-embed` model, which uses [1024 as its length](https://docs.mistral.ai/getting-started/models/models_overview/#premier-models).

These statements can all be put intside a single `.query()` call in the Rust SDK, followed by a line to check for any errors.

```rust
let mut res = db
    .query(
        "DEFINE TABLE document;
DEFINE FIELD text ON document TYPE string;
DEFINE FIELD embedding ON document TYPE array<float>;
DEFINE INDEX hnsw_embed ON document FIELDS embedding HNSW DIMENSION 1024 DIST COSINE;",
    )
    .await?;
for (index, error) in res.take_errors() {
    println!("Error in query {index}: {error}");
}
```
<br />

## Generate Mistral AI embeddings

At this point, you will need a [key](https://console.mistral.ai/api-keys) to interact with Mistral AI's platform. They offer a free tier for experimentation, after which you will be able to create a key to interact with it via the code below.

The best way to set the key is as an environment variable, which we will set to be a static called `KEY`. The client will look for one called `MISTRAL_API_KEY`, though you can change this when setting up the Mistral AI Rust client if you like.

```rust
// Looks for MISTRAL_API_KEY
let client = Client::new(Some(KEY.to_string()), None, None, None)?;
// Looks for OTHER_ENV_VAR
let client = Client::new(Some(KEY.to_string()), Some("OTHER_ENV_VAR".to_string()), None, None)?;
```

Using a `LazyLock` will let us call it via `std::env::var()` function the first time it is accessed. You can of course simply put it into a `const` for simplicity when first testing, but always remember to never hard-code API keys in your code in production.

```rust
static KEY: LazyLock<String> = LazyLock::new(|| {
    std::env::var("MISTRAL_API_KEY").unwrap()
});
```
<br />

And then run the code like this:

```bash
MISTRAL_API_KEY=whateverthekeyis cargo run
```
<br />

Or like this if you are using PowerShell on Windows.

```powershell
$env:MISTRAL_API_KEY = "whateverthekeyis"
cargo run
```
<br />

We will also create a `const MODEL` to hold the Mistral AI model used, which in this case is an `EmbedModel::MistralEmbed`.

```rust
const MODEL: EmbedModel = EmbedModel::MistralEmbed;
```

Inside `main()`, [create a client](https://docs.rs/mistralai-client/0.14.0/mistralai_client/v1/client/struct.Client.html#method.new) from the `mistralai-client` crate.

```rust
let client = Client::new(Some(KEY.to_string()), None, None, None)?;
```
<br />


The client can be used to generate a Mistral AI embedding using the [`mistral-embed`](https://docs.mistral.ai/getting-started/models/models_overview/#premier-models) model. Since SurrealDB uses the tokio runtime, the async `.embeddings_async()` method will be used.

```rust
let input = vec!["Joram is the main character in the Darksword Trilogy.".to_string()];

let result = client.embeddings_async(MODEL, input, None).await?;
println!("{:?}", result);
```
<br />

The output in your console should include an embedding 1024 floats in length.

## Store embeddings in database

The embeddings returned from Mistral AI can now be stored in the database. The [response](https://docs.rs/mistralai-client/0.14.0/mistralai_client/v1/embedding/struct.EmbeddingResponse.html) returned from the `mistralai-client` crate looks like this, with a `Vec` of `EmbeddingResponseDataItem` structs that hold a `Vec<f32>`.

```rust
pub struct EmbeddingResponse {
    pub id: String,
    pub object: String,
    pub model: EmbedModel,
    pub data: Vec<EmbeddingResponseDataItem>,
    pub usage: ResponseUsage,
}

pub struct EmbeddingResponseDataItem {
    pub index: u32,
    pub embedding: Vec<f32>,
    pub object: String,
}
```
<br />

Using `.remove(0)` will allow us to get the raw embeddings here. In a more complex response you might opt for a match on `.get(0)` to handle any possible errors.

```rust
let embeds = result.data.remove(0).embedding;
```
<br />

There are a [number of ways](/docs/sdk/rust/concepts/flexible-typing) to work with or avoid structs when using the Rust SDK, including creating structs: one to represent the input into a `.create()` statement, which will implement `Serialize`, and another that implements `Deserialize` to show the result.

```rust
#[derive(Serialize)]
struct DocumentInput {
    text: String,
    embedding: Vec<f32>,
}

#[derive(Debug, Deserialize)]
struct Document {
    id: RecordId,
    embedding: Vec<f32>,
    text: String,
}
```
<br />

This can be tested by printing out the created documents as a `Document` struct.

```rust
let input = "Octopuses solve puzzles and escape enclosures, showing advanced intelligence.";

let mut result = client
    .embeddings_async(MODEL, vec![input.to_string()], None)
    .await?;
let embeds = result.data.remove(0).embedding;
let in_db = db
    .create::<Option<Document>>("document")
    .content(DocumentInput {
        text: input.into(),
        embedding: embeds.to_vec(),
    })
    .await?;
println!("{in_db:?}");
```
<br />

We will now move the logic to create the embeddings into a function of its own. Since the `embeddings_async()` method takes a single `Vec<String>`, we'll first clone it to keep the original `Vec<String>`, then zip it together with the embeddings returned so that they can be put into the database along with the original input.

```rust
async fn create_embeds(
    input: Vec<String>,
    db: &Surreal<Any>,
    client: &Client,
) -> Result<(), Error> {
    let cloned = input.clone();
    let embeds = client.embeddings_async(MODEL, input, None).await?;
    let zipped = cloned
        .into_iter()
        .zip(embeds.data.into_iter().map(|item| item.embedding));

    for (text, embeds) in zipped {
        let _in_db = db
            .create::<Option<Document>>("document")
            .content(DocumentInput {
                text,
                embedding: embeds,
            })
            .await?;
    }
    Ok(())
}
```
<br />

Then we'll create four facts for each of four topics: sea creatures, Korean and Japanese cities, historical figures, and planets of the Solar System.

```rust
let embeds = [
    "Octopuses solve puzzles and escape enclosures, showing advanced intelligence.",
    "Sharks exhibit learning behavior, but their intelligence is instinct-driven.",
    "Sea cucumbers lack a brain and show minimal cognitive response.",
    "Clams have simple nervous systems with no known intelligent behavior.",
    //
    "Seoul is South Korea’s capital and a global tech hub.",
    "Sejong is South Korea’s planned administrative capital.",
    "Busan a major South Korean port located in the far southeast.",
    "Tokyo is Japan’s capital, known for innovation and dense population.",
    //
    "Wilhelm II was Germany’s last Kaiser before World War I.",
    "Cyrus the Great founded the Persian Empire with tolerant rule.",
    "Napoleon Bonaparte was a French emperor and brilliant military strategist.",
    "Aristotle was a Greek philosopher who shaped Western intellectual thought.",
    //
    "Venus’s atmosphere ranges from scorching surface to Earth-like upper clouds.",
    "Mars has a thin, cold atmosphere with seasonal dust storms.",
    "Ceres has a tenuous exosphere with sporadic water vapor traces.",
    "Saturn’s atmosphere spans cold outer layers to a deep metallic hydrogen interior",
]
.into_iter()
.map(|s| s.to_string())
.collect::<Vec<String>>();

create_embeds(embeds, &db, &client).await?;
```
<br />

## Semantic search

Finally let's perform semantic search over the embeddings in our database. We'll go with this query that uses the KNN operator to return the closest four matches to an embedding.

```surql
SELECT 
    text,
    vector::distance::knn() AS distance FROM document
    WHERE embedding <|4,COSINE|> $embeds
    ORDER BY distance;
```
<br />

To use the HNSW index instead, just change the KNN operator from `<|4,COSINE|>` to a number like `<|4,40|>`. The 40 here represents the size of the dynamic candidate list used during the search.

```surql
SELECT 
    text,
    vector::distance::knn() AS distance FROM document
    WHERE embedding <|4,40|> $embeds
    ORDER BY distance;
```
<br />

You can customise this [with other algorithms](/docs/surrealdb/models/vector#computation-on-vectors-vector-package-of-functions) such as Euclidean, Hamming, and so on.

We will then put this into a separate function called `ask_question()`, which first prints out its input and then uses its embedding retrieved from Mistral AI to query the database against existing documents.

```rust
async fn ask_question(input: &str, db: &Surreal<Any>, client: &Client) -> Result<(), Error> {
    println!("{input}");
    let embeds = client
        .embeddings_async(MODEL, vec![input.to_string()], None)
        .await?
        .data
        .remove(0)
        .embedding;

    let mut response = db.query("SELECT text, vector::distance::knn() AS distance FROM document WHERE embedding <|4,COSINE|> $embeds ORDER BY distance;").bind(("embeds", embeds)).await?;
    let as_val: Value = response.take(0)?;
    println!("{as_val}\n");
    Ok(())
}
```
<br />

This function can now be called inside `main()` to confirm that the results match with our expectations.

```rust
ask_question("Which Korean city is just across the sea from Japan?", &db, &client).await?;
ask_question("Who was Germany's last Kaiser?", &db, &client).await?;
ask_question("Which sea animal is most intelligent?", &db, &client).await?;
ask_question("Which planet's atmosphere has a part with the same temperature as Earth?", &db, &client).await?;
```
<br />

```
Which Korean city is just across the sea from Japan?
[{ distance: 0.19170371029549582f, text: 'Busan is a major South Korean port located in the far southeast.' }, { distance: 0.2399314515762122f, text: 'Tokyo is Japan’s capital, known for innovation and dense population.' }, { distance: 0.2443623703771407f, text: 'Sejong is South Korea’s planned administrative capital.' }, { distance: 0.24488082839731895f, text: 'Seoul is South Korea’s capital and a global tech hub.' }]

Who was Germany's last Kaiser?
[{ distance: 0.11228576780228805f, text: 'Wilhelm II was Germany’s last Kaiser before World War I.' }, { distance: 0.2957177300085634f, text: 'Napoleon Bonaparte was a French emperor and brilliant military strategist.' }, { distance: 0.34394473621670896f, text: 'Cyrus the Great founded the Persian Empire with tolerant rule.' }, { distance: 0.34911517400935843f, text: 'Sejong is South Korea’s planned administrative capital.' }]

Which sea animal is most intelligent?
[{ distance: 0.2342596053829904f, text: 'Octopuses solve puzzles and escape enclosures, showing advanced intelligence.' }, { distance: 0.24131327939924785f, text: 'Sharks exhibit learning behavior, but their intelligence is instinct-driven.' }, { distance: 0.2426242772516931f, text: 'Clams have simple nervous systems with no known intelligent behavior.' }, { distance: 0.24474598154128135f, text: 'Sea cucumbers lack a brain and show minimal cognitive response.' }]

Which planet's atmosphere has a part with the same temperature as Earth?
[{ distance: 0.20653440713083582f, text: 'Venus’s atmosphere ranges from scorching surface to Earth-like upper clouds.' }, { distance: 0.23354208810464594f, text: 'Mars has a thin, cold atmosphere with seasonal dust storms.' }, { distance: 0.24560810032473468f, text: 'Saturn’s atmosphere spans cold outer layers to a deep metallic hydrogen interior' }, { distance: 0.2761595357544341f, text: 'Ceres has a tenuous exosphere with sporadic water vapor traces.' }]
```
<br />

Here is the entire code:

```rust
use std::sync::LazyLock;

use anyhow::Error;
use mistralai_client::v1::{client::Client, constants::EmbedModel};
use serde::{Deserialize, Serialize};
use surrealdb::{
    RecordId, Surreal, Value,
    engine::any::{Any, connect},
};

static KEY: LazyLock<String> = LazyLock::new(|| std::env::var("MISTRAL_API_KEY").unwrap());

// Experiment plan
const MODEL: EmbedModel = EmbedModel::MistralEmbed;

#[derive(Serialize)]
struct DocumentInput {
    text: String,
    embedding: Vec<f32>,
}

#[derive(Debug, Deserialize)]
struct Document {
    id: RecordId,
    embedding: Vec<f32>,
    text: String,
}

async fn create_embeds(
    input: Vec<String>,
    db: &Surreal<Any>,
    client: &Client,
) -> Result<(), Error> {
    let cloned = input.clone();
    let embeds = client.embeddings_async(MODEL, input, None).await?;
    let zipped = cloned
        .into_iter()
        .zip(embeds.data.into_iter().map(|item| item.embedding));

    for (text, embeds) in zipped {
        let _in_db = db
            .create::<Option<Document>>("document")
            .content(DocumentInput {
                text,
                embedding: embeds,
            })
            .await?;
    }
    Ok(())
}

async fn ask_question(input: &str, db: &Surreal<Any>, client: &Client) -> Result<(), Error> {
    println!("{input}");
    let embeds = client
        .embeddings_async(MODEL, vec![input.to_string()], None)
        .await?
        .data
        .remove(0)
        .embedding;

    let mut response = db.query("SELECT text, vector::distance::knn() AS distance FROM document WHERE embedding <|4,COSINE|> $embeds ORDER BY distance;").bind(("embeds", embeds)).await?;
    let as_val: Value = response.take(0)?;
    println!("{as_val}\n");
    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    let db = connect("memory").await.unwrap();

    db.use_ns("ns").use_db("db").await.unwrap();

    let mut res = db
        .query(
            "DEFINE TABLE document;
             DEFINE FIELD text ON document TYPE string;
             DEFINE FIELD embedding ON document TYPE array<float>;
             DEFINE INDEX hnsw_embed ON document FIELDS embedding HNSW DIMENSION 1024 DIST COSINE;",
        )
        .await
        .unwrap();
    for (index, error) in res.take_errors() {
        println!("Error in query {index}: {error}");
    }

    let client = Client::new(Some(KEY.to_string()), None, None, None)?;

    let embeds = [
        "Octopuses solve puzzles and escape enclosures, showing advanced intelligence.",
        "Sharks exhibit learning behavior, but their intelligence is instinct-driven.",
        "Sea cucumbers lack a brain and show minimal cognitive response.",
        "Clams have simple nervous systems with no known intelligent behavior.",
        //
        "Seoul is South Korea’s capital and a global tech hub.",
        "Sejong is South Korea’s planned administrative capital.",
        "Busan is a major South Korean port located in the far southeast.",
        "Tokyo is Japan’s capital, known for innovation and dense population.",
        //
        "Wilhelm II was Germany’s last Kaiser before World War I.",
        "Cyrus the Great founded the Persian Empire with tolerant rule.",
        "Napoleon Bonaparte was a French emperor and brilliant military strategist.",
        "Aristotle was a Greek philosopher who shaped Western intellectual thought.",
        //
        "Venus’s atmosphere ranges from scorching surface to Earth-like upper clouds.",
        "Mars has a thin, cold atmosphere with seasonal dust storms.",
        "Ceres has a tenuous exosphere with sporadic water vapor traces.",
        "Saturn’s atmosphere spans cold outer layers to a deep metallic hydrogen interior",
    ]
    .into_iter()
    .map(|s| s.to_string())
    .collect::<Vec<String>>();

    create_embeds(embeds, &db, &client).await?;

    ask_question("Which Korean city is just across the sea from Japan?", &db, &client).await?;
    ask_question("Who was Germany's last Kaiser?", &db, &client).await?;
    ask_question("Which sea animal is most intelligent?", &db, &client).await?;
    ask_question("Which planet's atmosphere has a part with the same temperature as Earth?", &db, &client).await?;

    Ok(())
}
```
</TabItem>

</Tabs>


================================================
FILE: src/content/doc-integrations/Embeddings/openai.mdx
================================================
---
sidebar_position: 5
sidebar_label: OpenAI
title: OpenAI | Embeddings
description: This section contains information about the OpenAI embeddings feature of SurrealDB.
---

import Label from "@components/shared/Label.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# OpenAI

<Tabs>
<TabItem label="Python">

SurrealDB provides a number of different embeddings features that can be used to manage your data. This walkthrough shows how to embed your text with OpenAI, store the vectors in SurrealDB, and run fast k‑nearest‑neighbour (KNN) searches—all from Python. It follows the same flow you might have seen for Qdrant, but swaps in SurrealDB’s native vector‑search features so you can keep documents, graphs, and embeddings in one place.

## Install the two clients

OpenAI calls the API that turns text into a 1 536‑dimensional vector, while SurrealDB lets your Python code connect over WebSocket or HTTP to any SurrealDB server.

If you do not have SurrealDB running already you can spin up an in‑memory node in one line:

```bash
pip install openai surrealdb   
```

SurrealDB must be running somewhere.
For local testing you can spin it up quickly:

```bash
docker run -p 8000:8000 surrealdb/surrealdb:latest start --user root --pass secret memory
```

## Set up the OpenAI & SurrealDB clients

```python
import asyncio
import openai
from surrealdb import Surreal

openai_client = openai.Client(api_key="YOUR_OPENAI_KEY")

TEXTS = [
    "SurrealDB is a multi-model database you can embed anywhere!",
    "Loved by devs who need graphs, documents **and** vector search in one box.",
]

async def init_db() -> Surreal:
    db = Surreal("ws://localhost:8000/rpc")          # change URL if remote
    await db.signin({"username": "root", "password": "secret"})
    await db.use("demo_ns", "demo_db")
    return db
```

## Create the embeddings with OpenAI

`text‑embedding‑3‑small` is compact, cheap, and surprisingly accurate for semantic search. If you need more nuance (or plan to quantise heavily) you can upgrade to `text‑embedding‑3‑large` (3 072 dimensions) at roughly twice the cost.

```python
EMBED_MODEL = "text-embedding-3-small"

emb_resp = openai_client.embeddings.create(
    input=TEXTS,
    model=EMBED_MODEL
)
emb_vectors = [row.embedding for row in emb_resp.data]   # list[list[float]]
```

## Insert the documents into SurrealDB

SurrealDB is schemaless by default, so you can drop JSON directly into a table named article:

*(table `article` with a vector field called `embedding`)*

```python
async def load_documents(db: Surreal):
    docs = [
        {"text": txt, "embedding": vec}
        for txt, vec in zip(TEXTS, emb_vectors)
    ]
    await db.create("article", docs)

asyncio.run(load_documents(asyncio.run(init_db())))
```

## Add a vector index (HNSW)

The Hierarchical Navigable Small World (HNSW) index trades a tiny bit of accuracy for dramatic speed‑ups compared with brute‑force scanning—ideal once your table grows beyond a few thousand rows.Because HNSW lives in RAM today, index creation is instant but counts against your memory budget. 

SurrealQL lets you add the index once; after that inserts are indexed automatically.

```python
async def add_index(db: Surreal):
    await db.query("""
        DEFINE INDEX article_embedding_hnsw 
        ON article
        FIELDS embedding
        HNSW DIMENSION 1536;
    """)

asyncio.run(add_index(asyncio.run(init_db())))
```

The `DIMENSION` must match the length of the OpenAI vectors (1536 in this model). ([SurrealDB][1])


## Search for the most relevant documents

```python
async def semantic_search(question: str, k: int = 3):
    query_vec = openai_client.embeddings.create(
        input=[question],
        model=EMBED_MODEL
    ).data[0].embedding

    db = await init_db()

    # KNN search: <|k, ef|> – ef is “search breadth”. 100 is a decent default.
    result = await db.query(`
        LET $q := {query_vec};

        SELECT id, text,
               vector::distance::knn() AS distance
        FROM article
        WHERE embedding <|{k},100|> $q
        ORDER BY distance;
    """)
    return result[0]['result']

hits = asyncio.run(semantic_search("What’s the best database for unified search?"))
for hit in hits:
    print(hit["distance"], hit["text"])
```

The `vector::distance::knn()` helper returns the exact distance that the KNN operator just computed, so SurrealDB can immediately sort or filter without recalculating.

Two knobs to remember:

- `k` – the number of neighbours you want back.
- `ef` (the second number) – search breadth. Higher values spend more CPU for slightly better accuracy; 100–200 is a safe default.

## (Optional) Binary-quantise the vectors

SurrealDB stores vectors as arrays of floats (`F32` by default) and doesn’t yet expose built-in binary quantisation the way Qdrant does.
If you need ultra-compact storage you can:

1. **Quantise offline** (e.g. convert to `int32` with `numpy`).
2. Store the compressed list in a separate field (`embedding_q32`) and build an index on that instead:

```sql
DEFINE INDEX article_embedding_q32_mt
ON article
FIELDS embedding_q8
HNSW DIMENSION 1536 TYPE I32;
```

This keeps the SurrealDB side simple while you experiment with different quantisers. For more information about vector search in SurrealDB, see the [Vector Search Reference guides](/docs/surrealdb/models/vector).

</TabItem>
<TabItem label="Rust">

# Semantic search using SurrealDB

## Intro

This guide demonstrates how to store OpenAI embeddings as [SurrealDB vectors](/docs/surrealdb/models/vector) via the Rust SDK for the purposes of semantic search.

## Setup

First set up a new Cargo project with `cargo new project_name` and add the following dependencies to `Cargo.toml`:

```toml
anyhow = "1.0.98"
async-openai = "0.28.3"
serde = "1.0.219"
surrealdb = { version = "2.3", features = ["kv-mem"] }
tokio = "1.45.0"
```
<br />

Inside `main()`, call the `connect` function with `"memory"` to instantiate an embedded database in memory.

```rust
use anyhow::Error;
use surrealdb::engine::any::connect;

#[tokio::main]
async fn main() -> Result<(), Error> {
    let db = connect("memory").await?;
    Ok(())
}
```
<br />

If you have a Cloud or local instance to connect to, you can pass that path into the connect function instead.

```rust
// Cloud address
let db = connect("wss://myinstance-06a4h41t12rtj7lsg45m3prm1k.aws-use1.surreal.cloud").await?;

// Local address
let db = connect("ws://localhost:8000").await?;
```
<br />

After connecting, select a namespace and database name, such as `ns` and `db`.

```rust
db.use_ns("ns").use_db("db").await?;
```
<br />

## Create a vector table

Create a table to store documents and embeddings, along with an index for the embeddings:

```surql
DEFINE TABLE document;
DEFINE FIELD text ON document TYPE string;
DEFINE FIELD embedding ON document TYPE array<float>;
DEFINE INDEX hnsw_embed ON document FIELDS embedding HNSW DIMENSION 1536;
```
<br />

These can be called via a single `.query()` method.

```rust
let mut res = db
    .query(
        "DEFINE TABLE document;
DEFINE FIELD text ON document TYPE string;
DEFINE FIELD embedding ON document TYPE array<float>;
DEFINE INDEX hnsw_embed ON document FIELDS embedding HNSW DIMENSION 1536;",
    )
    .await?;
```
<br />

The size of the vector (1536 here) represents the number of dimensions in the embedding. Since OpenAI's `text-embedding-3-small` model in this example uses [1536 as its default length](https://platform.openai.com/docs/guides/embeddings), the vector size must be set to 1536.

The [HNSW index](/docs/surrealdb/models/vector#vector-indexes) is not strictly necessary to use the KNN operator (`<||>`) to find an embedding's closest neighbours, and for our small sample code we will use the simple [brute force method](/docs/surrealql/operators#brute-force-method) which chooses [an algorithm](/docs/surrealdb/models/vector#computation-on-vectors-vector-package-of-functions) such as Euclidean, Hamming, and so on. The following is the code that we will use, which uses the cosine of an embedding to find the four closest neighbours.

```surql
SELECT 
    text,
    vector::distance::knn() AS distance FROM document
    WHERE embedding <|2,COSINE|> $embeds
    ORDER BY distance;
```

As the dataset grows, if some loss of accuracy is acceptable then the syntax can be changed to use [the HNSW index](/docs/surrealql/operators#hnsw-method), by replacing an algorithm with a number that represents the size of the dynamic candidate list.

```surql
SELECT 
    text,
    vector::distance::knn() AS distance FROM document
    WHERE embedding <|2,40|> $embeds
    ORDER BY distance;
```

## Generate OpenAI embeddings

At this point, you will need an [OpenAI API key](https://platform.openai.com/api-keys) to interact with the OpenAI API.

<br />

The best way to set the key is as an environment variable, `OPENAI_API_KEY` in this case. Using a `LazyLock` will let us call it via `std::env::var()` function the first time it is accessed. You can of course simply put it into a `const` for simplicity when first testing, but always remember to never hard-code API keys in your code in production.

```rust
static KEY: LazyLock<String> = LazyLock::new(|| {
    std::env::var("OPENAI_API_KEY").unwrap()
});
```
<br />

And then run the code like this:

```bash
OPENAI_API_KEY=whateverthekeyis cargo run
```
<br />

Or like this if you are using PowerShell on Windows.

```powershell
$env:OPENAI_API_KEY = "whateverthekeyis"
cargo run
```
<br />

Inside `main()`, [create a client](https://docs.rs/async-openai/0.28.3/async_openai/struct.Client.html) from the async-openai crate holding this config inside `main()`.

```rust
let config = OpenAIConfig::new().with_api_key(KEY);
let client = Client::with_config(config);
```
<br />


Then that to generate an OpenAI embedding using [`text-embedding-3-small`](https://platform.openai.com/docs/guides/embeddings/embedding-models) that can be seen using a `println!` statement.

```rust
let input = "Octopuses solve puzzles and escape enclosures, showing advanced intelligence.";

let request = CreateEmbeddingRequestArgs::default()
        .model("text-embedding-3-small")
        .input(input)
        .dimensions(1536u32)
        .build()?;
let result = client.embeddings().create(request).await?;
println!("{result:?}");
```
<br />

## Store embeddings in database

With the embeddings returned from the OpenAI client, they can be stored in the database. The [response](https://docs.rs/async-openai/0.28.3/async_openai/types/struct.CreateEmbeddingResponse.html) returned from the async-openai crate looks like this, with a `Vec` of `Embedding` structs that hold a `Vec<f32>`.

```rust
pub struct CreateEmbeddingResponse {
    pub object: String,
    pub model: String,
    pub data: Vec<Embedding>,
    pub usage: EmbeddingUsage,
}

pub struct Embedding {
    pub index: u32,
    pub object: String,
    pub embedding: Vec<f32>,
}
```
<br />

This simple request only returned a single embedding, so `.remove(0)` will do the job. In a more complex codebase you would probably opt for a match on `.get(0)` to handle any possible errors.

```rust
let embeds = result.data.remove(0).embedding;
```
<br />

Two structs can be put together here: one that implements `Serialize` to serve as the input put in a `.create()` statement, and another that implements `Deserialize` to show the result with the `RecordId` included.

```rust
#[derive(Serialize)]
struct DocumentInput {
    text: String,
    embedding: Vec<f32>,
}

#[derive(Debug, Deserialize)]
struct Document {
    id: RecordId,
    embedding: Vec<f32>,
    text: String,
}
```
<br />

Once that is done, we can print out the created documents as a `Document` struct.

```rust
let in_db = db
    .create::<Option<Document>>("document")
    .content(DocumentInput {
        text: input.into(),
        embedding: embeds.to_vec()
    })
    .await?;
println!("{in_db:?}");
```
<br />

We should now add some more `document` records. To do this, we'll move the logic to create them inside a function of its own:

```rust
async fn create_embed(
    input: &str,
    db: &Surreal<Any>,
    client: &Client<OpenAIConfig>,
) -> Result<(), Error> {
    let request = CreateEmbeddingRequestArgs::default()
        .model("text-embedding-3-small")
        .input(input)
        .dimensions(1536u32)
        .build()?;
    let result = client.embeddings().create(request).await?;

    let embeds = &result.data.get(0).unwrap().embedding;

    let _in_db = db
        .create::<Option<Document>>("document")
        .content(DocumentInput {
            text: input.into(),
            embedding: embeds.to_vec(),
        })
        .await?;
    Ok(())
}
```
<br />

And then call it a few times inside `main()`. See if you can guess the answers yourself!

```rust
for input in [
    "Octopuses solve puzzles and escape enclosures, showing advanced intelligence.",
    "Sharks are primarily driven by instinct, but are capable of learning.",
    "Sea cucumbers lack a brain and show minimal cognitive response.",
    "Clams have simple nervous systems with no known intelligent behavior.",
    //
    "Seoul is South Korea’s capital and a global tech hub.",
    "Sejong is South Korea’s planned administrative capital.",
    "Busan a major South Korean port located in the far southeast.",
    "Tokyo is Japan’s capital, known for innovation and dense population.",
    //
    "Wilhelm II was Germany’s last Kaiser before World War I.",
    "Cyrus the Great founded the Persian Empire with tolerant rule.",
    "Napoleon Bonaparte was a French emperor and brilliant military strategist.",
    "Aristotle was a Greek philosopher who shaped Western intellectual thought.",
    //
    "Venus’s atmosphere ranges from scorching surface to Earth-like upper clouds.",
    "Mars has a thin, cold atmosphere with seasonal dust storms.",
    "Ceres has a tenuous exosphere with sporadic water vapor traces.",
    "Saturn’s atmosphere spans cold outer layers to a deep metallic hydrogen interior",
] {
    create_embed(input, &db, &client).await?
}
```
<br />

## Semantic search

Finally, let's perform semantic search over the embeddings in our database. Here is the query again:

```surql
SELECT 
    text,
    vector::distance::knn() AS distance FROM document
    WHERE embedding <|2,COSINE|> $embeds
    ORDER BY distance;
```
<br />

We will then put this into a separate function called `ask_question()` which uses the embedding retrieved from OpenAI to query the database against existing documents.

```rust
async fn ask_question(
    input: &str,
    db: &Surreal<Any>,
    client: &Client<OpenAIConfig>,
) -> Result<(), Error> {
    println!("{input}");
    let request = CreateEmbeddingRequestArgs::default()
        .model("text-embedding-3-small")
        .input(input)
        .dimensions(1536u32)
        .build()?;
    let mut result = client.embeddings().create(request).await?;

    let embeds = result.data.remove(0).embedding;

    let mut response = db.query("SELECT text, vector::distance::knn() AS distance FROM document WHERE embedding <|2,COSINE|> $embeds ORDER BY distance;").bind(("embeds", embeds)).await?;
    let as_val: Value = response.take(0)?;
    println!("{as_val}\n");
    Ok(())
}
```
<br />

You can now call this function a few times inside `main()` to confirm that the results are what we expect them to be.

```rust
ask_question("Which Korean city is just across the sea from Japan?", &db, &client).await?;
ask_question("Who was Germany's last Kaiser?", &db, &client).await?;
ask_question("Which sea animal is most intelligent?", &db, &client).await?;
ask_question("Which planet's atmosphere has a part with the same temperature as Earth?", &db, &client).await?;
```
<br />

The output shows that the closest documents to our question do indeed show up first.

```
Which Korean city is just across the sea from Japan?
[{ distance: 0.4879310782198243f, text: 'Busan a major South Korean port located in the far southeast.' }, { distance: 0.572999190509329f, text: 'Seoul is South Korea’s capital and a global tech hub.' }]

Who was Germany's last Kaiser?
[{ distance: 0.3236345624131668f, text: 'Wilhelm II was Germany’s last Kaiser before World War I.' }, { distance: 0.7554141523606017f, text: 'Napoleon Bonaparte was a French emperor and brilliant military strategist.' }]

Which sea animal is most intelligent?
[{ distance: 0.45382501257446206f, text: 'Octopuses solve puzzles and escape enclosures, showing advanced intelligence.' }, { distance: 0.4951347026545868f, text: 'Clams have simple nervous systems with no known intelligent behavior.' }]

Which planet's atmosphere has a part with the same temperature as Earth?
[{ distance: 0.4445578407153489f, text: 'Venus’s atmosphere ranges from scorching surface to Earth-like upper clouds.' }, { distance: 0.5039940919211086f, text: 'Saturn’s atmosphere spans cold outer layers to a deep metallic hydrogen interior' }]
```
<br />

At this point, you could give the HNSW index a try by changing the `<|2,COSINE|>` in the query to something like `<|2,40|>`. The distance numbers will end up looking quite different, but the ordering of the closest neighbours will probably be the same in this small example.

<br />

Here is the final code:

```rust
use std::sync::LazyLock;

use anyhow::Error;
use async_openai::{Client, config::OpenAIConfig, types::CreateEmbeddingRequestArgs};
use serde::{Deserialize, Serialize};
use surrealdb::{
    RecordId, Surreal, Value,
    engine::any::{Any, connect},
};

static KEY: LazyLock<String> = LazyLock::new(|| std::env::var("OPENAI_API_KEY").unwrap());

#[derive(Serialize)]
struct DocumentInput {
    text: String,
    embedding: Vec<f32>,
}

#[derive(Debug, Deserialize)]
struct Document {
    id: RecordId,
    embedding: Vec<f32>,
    text: String,
}

async fn create_embed(
    input: &str,
    db: &Surreal<Any>,
    client: &Client<OpenAIConfig>,
) -> Result<(), Error> {
    let request = CreateEmbeddingRequestArgs::default()
        .model("text-embedding-3-small")
        .input(input)
        .dimensions(1536u32)
        .build()?;
    let mut result = client.embeddings().create(request).await?;

    let embeds = result.data.remove(0).embedding;

    let _in_db = db
        .create::<Option<Document>>("document")
        .content(DocumentInput {
            text: input.into(),
            embedding: embeds.to_vec(),
        })
        .await?;
    Ok(())
}

async fn ask_question(
    input: &str,
    db: &Surreal<Any>,
    client: &Client<OpenAIConfig>,
) -> Result<(), Error> {
    println!("{input}");
    let request = CreateEmbeddingRequestArgs::default()
        .model("text-embedding-3-small")
        .input(input)
        .dimensions(1536u32)
        .build()?;
    let mut result = client.embeddings().create(request).await?;

    let embeds = result.data.remove(0).embedding;

    let mut response = db.query("SELECT text, vector::distance::knn() AS distance FROM document WHERE embedding <|2,COSINE|> $embeds ORDER BY distance;").bind(("embeds", embeds)).await?;
    let as_val: Value = response.take(0)?;
    println!("{as_val}\n");
    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    let db = connect("memory").await?;

    db.use_ns("ns").use_db("db").await?;

    let mut res = db
        .query(
            "DEFINE TABLE document;
             DEFINE FIELD text ON document TYPE string;
             DEFINE FIELD embedding ON document TYPE array<float>;
             DEFINE INDEX hnsw_embed ON document FIELDS embedding HNSW DIMENSION 1536 DIST COSINE;",
        )
        .await?;
    for (index, error) in res.take_errors() {
        println!("Error in query {index}: {error}");
    }

    let config = OpenAIConfig::new().with_api_key(&*KEY);

    let client = Client::with_config(config);

    for input in [
        "Octopuses solve puzzles and escape enclosures, showing advanced intelligence.",
        "Sharks are primarily driven by instinct, but are capable of learning.",
        "Sea cucumbers lack a brain and show minimal cognitive response.",
        "Clams have simple nervous systems with no known intelligent behavior.",
        //
        "Seoul is South Korea’s capital and a global tech hub.",
        "Sejong is South Korea’s planned administrative capital.",
        "Busan a major South Korean port located in the far southeast.",
        "Tokyo is Japan’s capital, known for innovation and dense population.",
        //
        "Wilhelm II was Germany’s last Kaiser before World War I.",
        "Cyrus the Great founded the Persian Empire with tolerant rule.",
        "Napoleon Bonaparte was a French emperor and brilliant military strategist.",
        "Aristotle was a Greek philosopher who shaped Western intellectual thought.",
        //
        "Venus’s atmosphere ranges from scorching surface to Earth-like upper clouds.",
        "Mars has a thin, cold atmosphere with seasonal dust storms.",
        "Ceres has a tenuous exosphere with sporadic water vapor traces.",
        "Saturn’s atmosphere spans cold outer layers to a deep metallic hydrogen interior",
    ] {
        create_embed(input, &db, &client).await?
    }

    ask_question(
        "Which Korean city is just across the sea from Japan?",
        &db,
        &client,
    )
    .await?;

    ask_question("Which Korean city is just across the sea from Japan?", &db, &client).await?;
    ask_question("Who was Germany's last Kaiser?", &db, &client).await?;
    ask_question("Which sea animal is most intelligent?", &db, &client).await?;
    ask_question("Which planet's atmosphere has a part with the same temperature as Earth?", &db, &client).await?;

    Ok(())
}
```

</TabItem>

</Tabs>


================================================
FILE: src/content/doc-integrations/Embeddings/python.mdx
================================================
---
sidebar_position: 2
sidebar_label: Quick start with Python
title: Embeddings models for Python
description: This section contains information about different embedding models you can use with SurrealDB.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# 🐍 Embeddings

SurrealDB offers comprehensive support for vector embeddings, enabling powerful semantic search and machine learning capabilities across your data. Through integrations with leading embedding providers, you can easily store, index and query high-dimensional vectors alongside your regular data.

<Tabs>
<TabItem label="LangChain">

More details and providers in [LangChain Embedding models](https://python.langchain.com/docs/integrations/text_embedding/) documentation.

<Tabs>
<TabItem label="Ollama">

## Ollama

```python
from langchain_ollama import OllamaEmbeddings

vector_store = SurrealDBVectorStore(
    OllamaEmbeddings(model="all-minilm:22m"),
    conn
)
```

More [Ollama embedding models](https://ollama.com/search?c=embedding) in their documentation.

</TabItem>

<TabItem label="OpenAI">

## OpenAI

Requires `OPENAI_API_KEY` environment variable.

```python
from langchain_openai import OpenAIEmbeddings

vector_store = SurrealDBVectorStore(
    OpenAIEmbeddings(model="text-embedding-3-large"),
    conn
)
```
</TabItem>

<TabItem label="Mistral">

## Mistral

Requires `MISTRALAI_API_KEY` environment variable.

```python
from langchain_mistralai import MistralAIEmbeddings

vector_store = SurrealDBVectorStore(
    MistralAIEmbeddings(model="mistral-embed"),
    conn
)
```
</TabItem>

<TabItem label="SentenceTransformer">

## SentenceTransformer

```python
from langchain_huggingface import HuggingFaceEmbeddings

vector_store = SurrealDBVectorStore(
    HuggingFaceEmbeddings(
        model_name="sentence-transformers/all-MiniLM-L6-v2"
    ),
    conn
)
```

More [SentenceTransformer models](https://www.sbert.net/docs/sentence_transformer/pretrained_models.html) in their documentation.
</TabItem>

<TabItem label="AWS Bedrock">

## AWS Bedrock

```python
from langchain_aws import BedrockEmbeddings

vector_store = SurrealDBVectorStore(
    BedrockEmbeddings(model_id="amazon.titan-embed-text-v2:0"),
    conn
)
```
</TabItem>

<TabItem label="Gemini">

## Gemini

Requires `GOOGLE_API_KEY` environment variable.

```python
from langchain_google_genai import GoogleGenerativeAIEmbeddings

vector_store = SurrealDBVectorStore(
    GoogleGenerativeAIEmbeddings(model="models/embedding-001"),
    conn
)
```
</TabItem>

</Tabs> {/* LangChain tabs */}

<br />

Then, to query the vector store using similarity search:

```python
doc1 = Document(
    page_content="SurrealDB is the ultimate multi-model database for AI applications",
    metadata={"key": "sdb"},
)
doc2 = Document(
    page_content="Surrealism is an artistic and cultural movement that emerged in the early 20th century",
    metadata={"key": "surrealism"},
)
vector_store.add_documents(documents=[doc1, doc2], ids=["1", "2"])

results = vector_store.similarity_search_with_score(query=q, k=2)
for doc, score in results:
    print(f"• [{score:.0%}]: {doc.page_content}")
top_match = results[0][0]
```

Find an example in [Minimal LangChain chatbot example with vector and graph](/blog/minimal-langchain-chatbot-example-with-vector-and-graph).

</TabItem>

<TabItem label="Vanilla">

<Tabs>
<TabItem label="Ollama">

## Ollama

```python
import ollama

embedding = ollama.embed(model="all-minilm:22m", input=text)
conn.create("documents", { "content": text, "embedding": embedding })
```

More [Ollama embedding models](https://ollama.com/search?c=embedding) in their documentation.

</TabItem>

<TabItem label="OpenAI">

## OpenAI

```python
from openai import OpenAI
client = OpenAI()

text = "Your text string"
response = client.embeddings.create(
    input=text,
    model="text-embedding-3-small"
)

conn.create("documents", { "content": text, "embedding": response.data[0].embedding })
```

More info in [OpenAI embeddings](https://platform.openai.com/docs/guides/embeddings?lang=python) documentation.

</TabItem>

<TabItem label="Sentence Transformers">

## Sentence Transformers

```python
from sentence_transformers import SentenceTransformer

st = SentenceTransformer("all-MiniLM-L6-v2")
embedding = st.encode(text).tolist()
conn.create("documents", { "content": text, "embedding": embedding })
```

More [SentenceTransformer models](https://www.sbert.net/docs/sentence_transformer/pretrained_models.html) in their documentation.

</TabItem>

To query the vector store using similarity search:

```python
k = 5
query_embedding = st.encode("this is your query text")
res = conn.query(
    f"""
    SELECT
        *,
        vector::similarity::knn() AS dist
    FROM documents
    WHERE embedding <|{k}|> $vector;
    """,
    {
        "vector": query_embedding.tolist(),
    },
)
```

This requires an index the be created beforehand. Refer to the [vector search cheat sheet](/docs/surrealdb/models/vector#vector-search-cheat-sheet).

</Tabs>
</TabItem>


</Tabs>

<br />

Examples above assume you have a DB connection like this:

```python
conn = Surreal("localhost")
conn.signin({"username": "root", "password": "secret"})
conn.use("test_ns", "test_db")
```



================================================
FILE: src/content/doc-integrations/Embeddings/rust.mdx
================================================
---
sidebar_position: 3
sidebar_label: Quick start with Rust
title: Embeddings models for Rust
description: This section contains information about different embedding models you can use with SurrealDB.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# 🦀 Embeddings

SurrealDB offers comprehensive support for vector embeddings, enabling powerful semantic search and machine learning capabilities across your data. Through integrations with leading embedding providers, you can easily store, index and query high-dimensional vectors alongside your regular data.

<Tabs>
<TabItem label="Mistral">

## Mistral

```rust
use mistralai_client::v1::{client::Client, constants::EmbedModel};

static KEY = std::env::var("MISTRAL_API_KEY").unwrap();

// ...

let client = Client::new(Some(KEY.to_string()), None, None, None)?;
let input = vec!["Joram is the main character in the Darksword Trilogy.".to_string()];

let result = client.embeddings_async(MODEL, input, None).await?;
println!("{:?}", result);
```

Find a full example in [Semantic search in Rust with SurrealDB and Mistral AI](/blog/semantic-search-in-rust-with-surrealdb-and-mistral-ai#generate-mistral-ai-embeddings).

</TabItem>
<TabItem label="Ollama">

## Ollama

```rust
use ollama_rs::{Ollama, generation::embeddings::GenerateEmbeddingsRequest};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let ollama = Ollama::default();

    let model = "all-minilm:22m".to_string()
    let prompt = "this is your input text".to_string();

    let request = GenerateEmbeddingsRequest::new(model, prompt);
    let response = ollama.generate_embeddings(request).await?;

    println!("Generated embeddings (first 5): {:?}", &response.embeddings[..5]);
    println!("Embedding vector length: {}", response.embeddings.len());

    Ok(())
}
```

</TabItem>
<TabItem label="SentenceTransformer">

## SentenceTransformer

```rust
use rust_bert::sentence_embeddings::{
    SentenceEmbeddingsBuilder, SentenceEmbeddingsModelType,
};

fn main() -> anyhow::Result<()> {
    // Set up the model builder, specifying the model type
    let model = SentenceEmbeddingsBuilder::remote(
        SentenceEmbeddingsModelType::AllMiniLmL6V2
    ).create_model()?;

    // Define the sentences to embed
    let sentences = [
        "this is your text",
        "you can encode more than one in batch"
    ];

    // Generate the embeddings
    let embeddings = model.encode(&sentences)?;

    // Print the results
    for (i, embedding) in embeddings.iter().enumerate() {
        // Truncate for display purposes
        let truncated_embedding: Vec<_> = embedding.iter().take(5).cloned().collect();

        println!("\nSentence: '{}'", sentences[i]);
        println!("Embedding (first 5 values): {:?}", truncated_embedding);
        println!("Embedding dimensions: {}", embedding.len());
    }

    Ok(())
}
```

</TabItem>
</Tabs>



================================================
FILE: src/content/doc-integrations/Frameworks/agno.mdx
================================================
---
sidebar_position: 1
sidebar_label: Agno
title: Agno | Integrations
description: This section contains information about the Agno framework and how to integrate it with SurrealDB.
---

# Agno

[Agno](https://github.com/agno-agi/agno) is a python framework for building multi-agent systems with shared memory, knowledge and reasoning.

## Setup

```shell
docker run --rm \
  --pull always \
  -p 8000:8000 \
  surrealdb/surrealdb:latest \
  start \
  --user root \
  --pass root
```

or

```shell
./cookbook/scripts/run_surrealdb.sh
```

## Example

```python
from agno.agent import Agent
from agno.embedder.openai import OpenAIEmbedder
from agno.knowledge.pdf_url import PDFUrlKnowledgeBase
from agno.vectordb.surrealdb import SurrealDb
from surrealdb import Surreal

# SurrealDB connection parameters
SURREALDB_URL = "ws://localhost:8000"
SURREALDB_USER = "root"
SURREALDB_PASSWORD = "root"
SURREALDB_NAMESPACE = "test"
SURREALDB_DATABASE = "test"

# Create a client
client = Surreal(url=SURREALDB_URL)
client.signin({"username": SURREALDB_USER, "password": SURREALDB_PASSWORD})
client.use(namespace=SURREALDB_NAMESPACE, database=SURREALDB_DATABASE)

surrealdb = SurrealDb(
    client=client,
    collection="recipes",  # Collection name for storing documents
    efc=150,  # HNSW construction time/accuracy trade-off
    m=12,  # HNSW max number of connections per element
    search_ef=40,  # HNSW search time/accuracy trade-off
)


def sync_demo():
    """Demonstrate synchronous usage of SurrealDb"""
    knowledge_base = PDFUrlKnowledgeBase(
        urls=["https://agno-public.s3.amazonaws.com/recipes/ThaiRecipes.pdf"],
        vector_db=surrealdb,
        embedder=OpenAIEmbedder(),
    )

    # Load data synchronously
    knowledge_base.load(recreate=True)

    # Create agent and query synchronously
    agent = Agent(knowledge=knowledge_base, show_tool_calls=True)
    agent.print_response(
        "What are the 3 categories of Thai SELECT is given to restaurants overseas?",
        markdown=True,
    )


if __name__ == "__main__":
    # Run synchronous demo
    print("Running synchronous demo...")
    sync_demo()
```

## Developer Resources

* View [Cookbook (Sync)](https://github.com/agno-agi/agno/blob/main/cookbook/agent_concepts/knowledge/vector_dbs/surrealdb/surreal_db.py)
* View [Cookbook (Async)](https://github.com/agno-agi/agno/blob/main/cookbook/agent_concepts/knowledge/vector_dbs/surrealdb/async_surreal_db.py)
* View [Agno documentation](https://docs.agno.com/vectordb/surrealdb)



================================================
FILE: src/content/doc-integrations/Frameworks/camel.mdx
================================================
---
sidebar_position: 1
sidebar_label: Camel
title: Camel | Integrations
description: This section contains information about the Camel framework and how to integrate it with SurrealDB.
---

# CamelAI

[🐫 CAMEL](https://www.camel-ai.org) is an open-source community dedicated to finding the scaling laws of agents. We believe that studying these agents on a large scale offers valuable insights into their behaviors, capabilities, and potential risks. To facilitate research in this field, we implement and support various types of agents, tasks, prompts, models, and simulated environments.

## Setup

You can run SurrealDB locally or start with a [free SurrealDB Cloud account](/docs/cloud/getting-started).

For local, two options:

1. [Install SurrealDB](/docs/surrealdb/installation) and run [SurrealDB](/docs/surrealdb/installation/running). Run in-memory with:

    ```sh
    surreal start -u root -p root
    ```

2. [Run with Docker](/docs/surrealdb/installation/running/docker).

    ```sh
    docker run --rm --pull always -p 8000:8000 surrealdb/surrealdb:latest start
    ```

## Example

```python
import os

from camel.storages.vectordb_storages import (
    SurrealStorage,
    VectorDBQuery,
    VectorRecord,
)


def main():
    url = os.getenv("SURREAL_URL", "ws://localhost:8000/rpc")
    table = os.getenv("SURREAL_TABLE", "tb")
    vector_dim = int(os.getenv("SURREAL_VECTOR_DIM", 4))
    namespace = os.getenv("SURREAL_NAMESPACE", "ns")
    database = os.getenv("SURREAL_DATABASE", "db")
    user = os.getenv("SURREAL_USER", "user")
    password = os.getenv("SURREAL_PASSWORD")

    # Raise an error if password is not set
    if not password:
        raise ValueError(
            "Environment variable SURREAL_PASSWORD is not set. "
            "Please set it before running."
        )

    # Initialize the SurrealStorage instance with provided parameters
    storage = SurrealStorage(
        url=url,
        table=table,
        namespace=namespace,
        database=database,
        user=user,
        password=password,
        vector_dim=vector_dim,
    )

    # Clear existing data in storage
    storage.clear()

    # Print the current status after clearing
    print("[Step 1] After clear:", storage.status())

    vec1 = VectorRecord(vector=[1, 2, 3, 4], payload={"name": "test_1"})
    vec2 = VectorRecord(vector=[5, 6, 7, 8], payload={"name": "test_2"})
    vec3 = VectorRecord(vector=[9, 10, 11, 12], payload={"name": "test_3"})
    vec4 = VectorRecord(vector=[13, 14, 15, 16], payload={"name": "test_4"})
    storage.add([vec1, vec2, vec3, vec4])
    print("[Step 2] After add:", storage.status())

    res = storage.client.query_raw(
        "SELECT * FROM lyz_tb WHERE payload.name = 'test_3';"
    )["result"][0]["result"][0]["id"].id
    print("[Step 3] Query Result ID for 'test_3':", res)

    storage.delete(ids=[res])
    print("[Step 4] After delete 'test_3':", storage.status())

    res = storage.query(
        VectorDBQuery(query_vector=[1.1, 2.1, 3.1, 4.1], top_k=2)
    )
    print("[Step 5] Vector Query Result:", res)
```

The output should look like this:

```
[Step 1] After clear: vector_dim=4 vector_count=0oceanbasech
[Step 2] After add: vector_dim=4 vector_count=4
[Step 3] Query Result ID for 'test_3': lov5h16x6uog7l2xtsqp
[Step 4] After delete 'test_3': vector_dim=4 vector_count=3
[Step 5] Vector Query Result:
[VectorDBQueryResult(record=VectorRecord(vector=[],
id='9803ae3a-18da-4152-a522-48e1939a3604',
payload={'name': 'test_2'}), similarity=0.027665393972965968),
VectorDBQueryResult(record=VectorRecord(vector=[],
id='de3d085c-ed1b-4d23-9d12-d9fc64ae1e00',
payload={'name': 'test_1'}), similarity=0.00010404203326297434)]
```

## Resources

* [Camel documentation](https://docs.camel-ai.org/)



================================================
FILE: src/content/doc-integrations/Frameworks/crewai.mdx
================================================
---
sidebar_position: 1
sidebar_label: CrewAI
title: CrewAI | Integrations
description: How to plug SurrealDB into CrewAI as a memory and vector-search layer.
---

# CrewAI

[CrewAI](https://github.com/joaomdmoura/crewAI) lets you orchestrate role-playing AI agents that collaborate to complete complex tasks.  
This guide shows how to use SurrealDB `>v2.0.0` as the memory backend for CrewAI, giving agents:

- **Entity memory** for domain objects (products, people, places)  
- **Short-term memory** for recent conversations  
- **Vector search** to recall relevant information by semantic similarity  

The sample below creates two agents that recommend music festival trips:

1. **Researcher** – finds festivals and saves them to SurrealDB  
2. **Planner** – queries those saved festivals to build a weekend itinerary  

## Install

```bash
# CrewAI, SurrealDB Python SDK, and an embedder (OpenAI here; swap if you like)
pip install "crewai[tools]" surrealdb openai

# (optional) run SurrealDB locally – single binary, no deps
docker run --pull always -p 8000:8000 surrealdb/surrealdb:latest \
       start --user root --pass secret file:/data/db
````

SurrealDB v2 ships native HNSW indexes, so you get ANN vector search
without an extra service.


## SurrealDB storage adapter

Create `src/mycrew/surreal_storage.py`:

```python
from __future__ import annotations

import asyncio, hashlib, logging, os, threading
from typing import Any, Dict, List, Optional

import openai
from crewai.memory.storage.rag_storage import RAGStorage
from surrealdb import Surreal, AsyncSurreal

logger = logging.getLogger(__name__)
_EMBED_DIM = 1536  # OpenAI text-embedding-3-small


# ────────────────────────── embeddings ──────────────────────────
def _embed(text: str,
           api_key: Optional[str] = None,
           model: str = "text-embedding-3-small",
           dimensions: int = _EMBED_DIM) -> List[float]:
    """Return an L2-normalised embedding vector."""
    resp = openai.Embedding.create(
        model=model,
        input=[text],
        api_key=api_key or os.getenv("OPENAI_API_KEY"),
        dimensions=dimensions,
    )
    vec = resp["data"][0]["embedding"]
    norm = sum(x * x for x in vec) ** 0.5 or 1.0
    return [x / norm for x in vec]


# ─────────────────────────── storage ────────────────────────────
class SurrealStorage(RAGStorage):
    """CrewAI RAGStorage backend backed by SurrealDB v2."""

    _lock = threading.Lock()
    _tables_ready: set[str] = set()

    def __init__(
        self,
        typ: str,
        *,
        allow_reset: bool = True,
        embedder_config: Optional[Dict[str, Any]] = None,
        crew: Optional[Any] = None,
        url: str = "ws://localhost:8000/rpc",
        namespace: str = "crew",
        database: str = "memories",
        user: str = "root",
        password: str = "secret",
    ):
        super().__init__(typ, allow_reset, embedder_config, crew)
        self.url, self.ns, self.db = url, namespace, database
        self.user, self.pw = user, password
        self.table = f"mem_{typ.replace('-', '_')}"
        self._adb = AsyncSurreal(url)   # async client
        self._sdb = Surreal(url)        # sync client (DDL)
        self._embed_api_key = (embedder_config or {}).get("api_key")

    # ─────────── helpers ───────────
    def _run(self, coro):
        """Run *coro* in any context (sync script or async crew)."""
        try:
            loop = asyncio.get_running_loop()
            if loop.is_running():
                return asyncio.ensure_future(coro)
        except RuntimeError:
            pass
        return asyncio.run(coro)

    # ─────────── sync API (called by CrewAI) ───────────
    def save(self, value: Any, metadata: Dict[str, Any]):
        self._run(self._save_async(value, metadata))

    def search(
        self,
        query: str,
        limit: int = 3,
        filter: Optional[Dict[str, Any]] = None,
        score_threshold: float = 0.0,
    ):
        return self._run(
            self._search_async(query, limit, filter, score_threshold)
        )

    def reset(self):
        self._run(self._reset_async())

    # ─────────── async internals ───────────
    async def _save_async(self, value: Any, metadata: Dict[str, Any]):
        await self._ensure_schema()
        vec = _embed(str(value), self._embed_api_key)
        rec = {
            "id": hashlib.sha1(str(value).encode()).hexdigest(),
            "text": value,
            "metadata": metadata or {},
            "embedding": vec,
        }
        async with self._adb as db:
            await db.signin({"username": self.user, "password": self.pw})
            await db.use(self.ns, self.db)
            await db.create(self.table, rec)

    async def _search_async(
        self,
        query: str,
        limit: int,
        filter: Optional[Dict[str, Any]],
        score_threshold: float,
    ):
        await self._ensure_schema()
        vec = _embed(query, self._embed_api_key)

        filter_params, where_clause = {}, ""
        if filter:
            conds = []
            for i, (k, v) in enumerate(filter.items()):
                pname = f"f{i}"
                conds.append(f"metadata.{k} == ${pname}")
                filter_params[pname] = v
            where_clause = " AND " + " AND ".join(conds)

        async with self._adb as db:
            await db.signin({"username": self.user, "password": self.pw})
            await db.use(self.ns, self.db)
            rs = await db.query(
                f"""
                SELECT *,
                       vector::distance::knn() AS score
                FROM {self.table}
                WHERE embedding <|{limit}|> $vec{where_clause}
                ORDER BY score ASC;
                """,
                {"vec": vec, **filter_params},
            )
        rows = rs[0]["result"]
        return [
            {
                "id": r["id"],
                "metadata": r["metadata"],
                "context": r["text"],
                "score": r["score"],
            }
            for r in rows
            if (score_threshold == 0 or r["score"] <= score_threshold)
        ]

    async def _reset_async(self):
        async with self._adb as db:
            await db.signin({"username": self.user, "password": self.pw})
            await db.use(self.ns, self.db)
            await db.query(f"REMOVE TABLE {self.table};")
        self._tables_ready.discard(self.table)

    # ─────────── table / index setup ───────────
    async def _ensure_schema(self):
        if self.table in self._tables_ready:
            return
        with self._lock:
            if self.table in self._tables_ready:
                return
            self._sdb.signin({"username": self.user, "password": self.pw})
            self._sdb.use(self.ns, self.db)
            self._sdb.query(
                f"""
                DEFINE TABLE {self.table} SCHEMALESS;
                DEFINE FIELD id        ON {self.table} TYPE string;
                DEFINE FIELD text      ON {self.table} TYPE string;
                DEFINE FIELD metadata  ON {self.table} TYPE object;
                DEFINE FIELD embedding ON {self.table} TYPE array;
                DEFINE INDEX IF NOT EXISTS {self.table}_vec_idx
                  ON {self.table} FIELDS embedding
                  HNSW DIMENSION {_EMBED_DIM} DIST COSINE;
                """
            )
            self._tables_ready.add(self.table)
```

## Wire it into a crew

Create `src/mycrew/crew.py`:

```python
import asyncio, logging
from typing import Optional

from crewai import Agent, Task, Crew
from crewai.memory.entity.entity_memory import EntityMemory
from crewai.memory.short_term.short_term_memory import ShortTermMemory

from mycrew.surreal_storage import SurrealStorage, _EMBED_DIM

logging.basicConfig(level=logging.INFO)

async def create_crew(
    openai_api_key: Optional[str] = None,
    surreal_url: str = "ws://localhost:8000/rpc",
) -> Crew:
    embed_cfg = {"api_key": openai_api_key}

    researcher = Agent(
        name="GeoResearcher",
        role="Geo-intelligence analyst",
        goal="collect up-to-date info on travel destinations",
    )

    planner = Agent(
        name="TripPlanner",
        role="Personal itinerary planner",
        goal="craft a perfect 48-hour city break",
    )

    entity_mem = EntityMemory(
        storage=SurrealStorage("entity",
                               url=surreal_url,
                               embedder_config=embed_cfg)
    )
    short_mem = ShortTermMemory(
        storage=SurrealStorage("short-term",
                               url=surreal_url,
                               embedder_config=embed_cfg)
    )

    t1 = Task(
        description="Find vibrant European cities with art festivals in June 2025.",
        expected_output="Top 3 candidate cities with festival names and dates.",
        agent=researcher,
    )

    t2 = Task(
        description="Design a relaxed 2-day itinerary for the best candidate.",
        expected_output="Detailed schedule with cafes, galleries, evening events.",
        agent=planner,
        context=[t1],
    )

    crew = Crew(
        memory=True,
        entity_memory=entity_mem,
        short_term_memory=short_mem,
    )
    crew.add_agents(researcher, planner)
    crew.add_tasks(t1, t2)
    return crew

async def main():
    crew = await create_crew()
    result = await crew.run()
    print(result)

if __name__ == "__main__":
    asyncio.run(main())
```

Run the crew:

```bash
python -m mycrew.crew
```

## Customising further

| Piece             | How to tweak it                                                                                 |
| ----------------- | ----------------------------------------------------------------------------------------------- |
| Embedding model   | Swap `_embed()` for JinaAI, Instructor, or a local transformer; adjust `_EMBED_DIM`.            |
| Similarity metric | Change `DIST COSINE` to `L2` or `DOT` to match your embeddings.                                 |
| Metadata filters  | Extend the simple `filter` mapping to support CrewAI’s richer operators (`$gt`, `$in`, …).      |
| Remote / Cloud DB | Replace `ws://localhost:8000/rpc` with `wss://<YOUR-ENDPOINT>/rpc` and supply a token/password. |

## Resources

* [Vector Search reference guide](/docs/surrealdb/models/vector)
* [Using SurrealDB as a Vector Database](/docs/surrealdb/models/vector)
* [Python SDK docs](/docs/sdk/python)
* [DEFINE INDEX statement](/docs/surrealql/statements/define/indexes)



================================================
FILE: src/content/doc-integrations/Frameworks/dagster.mdx
================================================
---
sidebar_position: 1
sidebar_label: Dagster
title: Dagster | Integrations
description: This section contains information about the Dagster framework and how to integrate it with SurrealDB.
---

# Dagster

Dagster is a powerful tool for building data pipelines and workflows. It is a popular choice for data engineers and data scientists.

## Install

```bash title="Install"
pip install dagster surrealdb openai  # or swap out OpenAI for any embedder
# optional – launch a local SurrealDB daemon
docker run -p 8000:8000 surrealdb/surrealdb:latest \
       start --user root --pass secret file:/data/db
```

## A Dagster "SurrealResource"

```python title="src/dagster_surreal.py"
import dagster as dg
from surrealdb import Surreal
from typing import List, Sequence, Optional
import hashlib, json, os, contextlib

_EMBED_DIM = 1536  # match your embedder

def embed(text: str) -> List[float]:
    """Tiny helper – replace with your preferred model."""
    import openai
    resp = openai.Embedding.create(
        model="text-embedding-3-small",
        input=[text],
        dimensions=_EMBED_DIM,
        api_key=os.getenv("OPENAI_API_KEY"),
    )
    return resp["data"][0]["embedding"]


class SurrealConfig(dg.Config):
    url: str = dg.Field(str, default_value="ws://localhost:8000/rpc")
    namespace: str = dg.Field(str, default_value="dagster")
    database: str = dg.Field(str, default_value="vector")
    user: str = dg.Field(str, default_value="root")
    password: str = dg.Field(str, default_value="secret")


@dg.resource(config_schema=SurrealConfig)
class SurrealResource:
    """
    A very small wrapper that exposes .add() and .query() like dagster-qdrant.
    """

    def __init__(self, context):
        cfg: SurrealConfig = context.resource_config
        self.url = cfg.url
        self.namespace = cfg.namespace
        self.database = cfg.database
        self.user = cfg.user
        self.password = cfg.password

    # — helpers ----------------------------------------------------------
    def _ensure_table(self, table: str):
        with Surreal(self.url) as db:
            db.signin({"username": self.user, "password": self.password})
            db.use(self.namespace, self.database)
            db.query(
                """
                DEFINE TABLE $table SCHEMALESS;
                DEFINE FIELD id        ON $table TYPE string;
                DEFINE FIELD text      ON $table TYPE string;
                DEFINE FIELD embedding ON $table TYPE array;
                DEFINE INDEX IF NOT EXISTS ${table}_vec
                       ON $table FIELDS embedding
                       HNSW DIMENSION $dim DIST COSINE;
                """,
                {
                    "table": table,
                    "dim": _EMBED_DIM
                }
            )

    # — public API -------------------------------------------------------
    def add(self, collection_name: str, documents: Sequence[str]):
        self._ensure_table(collection_name)
        with Surreal(self.url) as db:
            db.signin({"username": self.user, "password": self.password})
            db.use(self.namespace, self.database)
            for doc in documents:
                rec = {
                    "id": hashlib.sha1(doc.encode()).hexdigest(),
                    "text": doc,
                    "embedding": embed(doc),
                }
                db.create(collection_name, rec)

    def query(
        self,
        collection_name: str,
        query_text: str,
        limit: int = 3,
        score_threshold: float = 0.4,
    ):
        self._ensure_table(collection_name)
        vec = embed(query_text)
        with Surreal(self.url) as db:
            db.signin({"username": self.user, "password": self.password})
            db.use(self.namespace, self.database)
            result = db.query(
                """
                SELECT text,
                       vector::distance::cosine(embedding, $vec) AS score
                FROM $table
                WHERE embedding <|$limit|> $vec
                ORDER BY score ASC
                """,
                {
                    "table": collection_name,
                    "vec": vec,
                    "limit": limit
                }
            )
            rows = result[0]["result"]
            return [r for r in rows if r['score'] <= score_threshold or score_threshold == 0]

    # Use the resource as a context-manager inside assets
    @contextlib.contextmanager
    def get_client(self):
        try:
            yield self
        finally:
            pass  # No need to close since we use context managers for each operation
```


================================================
FILE: src/content/doc-integrations/Frameworks/deepeval.mdx
================================================
---
sidebar_position: 1
sidebar_label: DeepEval
title: DeepEval | Integrations
description: This section contains information about the DeepEval framework and how to integrate it with SurrealDB.
---

# DeepEval

[DeepEval](https://deepeval.com) by Confident AI is an open-source framework for testing large language model systems. Similar to Pytest but designed for LLM outputs, it evaluates metrics like G-Eval, hallucination, answer relevancy.

DeepEval can be integrated with SurrealDB to evaluate RAG pipelines — ensuring your LLM applications return relevant, grounded, and faithful responses based on retrieved vector search context.

SurrealDB's *native* vector engine, allows you to store vectors, documents and metadata in the same database that already stores the rest of your app data.


## Install & run

```bash
pip install deepeval surrealdb openai   # swap OpenAI for any embedder you like
# optional – start a local SurrealDB node
docker run -p 8000:8000 surrealdb/surrealdb:latest \
       start --user root --pass secret file:/data/db
```

> [!NOTE]
> SurrealDB ≥ v1.5 ships HNSW indexes for sub-millisecond k-NN search.

## Set up a vector table & index (one-time)

```surql
-- SurrealQL – run in the DB console once.
DEFINE TABLE rag_docs SCHEMALESS;
DEFINE FIELD id        ON rag_docs TYPE string;  -- primary key
DEFINE FIELD text      ON rag_docs TYPE string;
DEFINE FIELD source    ON rag_docs TYPE string;
DEFINE FIELD embedding ON rag_docs TYPE array;   -- float[]

-- Fast approximate NN (cosine, 1536-D, OpenAI embeddings here)
DEFINE INDEX IF NOT EXISTS rag_docs_vec
  ON rag_docs FIELDS embedding
  HNSW DIMENSION 1536 DIST COSINE;
```

## Python helper: Surreal client with add/query

```python title="surreal_rag.py"
from surrealdb import AsyncSurreal
import hashlib, json, os
from typing import List, Dict, Any
import openai                         # or any local embedding model

_EMBED_DIM = 1536

def embed(text: str) -> List[float]:
    resp = openai.Embedding.create(
        model="text-embedding-3-small",
        input=[text],
        dimensions=_EMBED_DIM,
        api_key=os.getenv("OPENAI_API_KEY"),
    )
    return resp["data"][0]["embedding"]


class SurrealRAG:
    def __init__(
        self,
        url: str = "ws://localhost:8000/rpc",
        namespace: str = "rag",
        database: str = "demo",
        user: str = "root",
        password: str = "secret",
    ):
        self.url = url
        self.namespace = namespace
        self.database = database
        self.user = user
        self.password = password

    async def _ensure_table(self):
        async with AsyncSurreal(self.url) as db:
            await db.signin({"username": self.user, "password": self.password})
            await db.use(self.namespace, self.database)
            await db.query(
                """
                DEFINE TABLE rag_docs SCHEMALESS;
                DEFINE FIELD id        ON rag_docs TYPE string;
                DEFINE FIELD text      ON rag_docs TYPE string;
                DEFINE FIELD source    ON rag_docs TYPE string;
                DEFINE FIELD embedding ON rag_docs TYPE array;
                DEFINE INDEX IF NOT EXISTS rag_docs_vec
                    ON rag_docs FIELDS embedding
                    HNSW DIMENSION $dim DIST COSINE;
                """,
                {"dim": _EMBED_DIM}
            )

    # --- ingest --------------------------------------------------------
    async def add(self, docs: List[Dict[str, str]]):
        await self._ensure_table()
        async with AsyncSurreal(self.url) as db:
            await db.signin({"username": self.user, "password": self.password})
            await db.use(self.namespace, self.database)
            for d in docs:
                rec = {
                    "id": hashlib.sha1(d["text"].encode()).hexdigest(),
                    "text": d["text"],
                    "source": d["source"],
                    "embedding": embed(d["text"]),
                }
                await db.create("rag_docs", rec)

    # --- retrieve ------------------------------------------------------
    async def query(self, text: str, k: int = 4) -> List[Dict[str, Any]]:
        await self._ensure_table()
        vec = embed(text)
        async with AsyncSurreal(self.url) as db:
            await db.signin({"username": self.user, "password": self.password})
            await db.use(self.namespace, self.database)
            result = await db.query(
                """
                SELECT text, source,
                       vector::distance::cosine(embedding, $vec) AS score
                FROM rag_docs
                WHERE embedding <|$k|> $vec
                ORDER BY score ASC
                """,
                {
                    "vec": vec,
                    "k": k
                }
            )
            rows = result[0]["result"]
            return [{"context": r["text"], "source": r["source"], "score": r["score"]} for r in rows]
```

## Unique DeepEval example

We'll test whether an LLM correctly answers **"Which fruit is botanically a berry but commonly mistaken for a vegetable?"** using information fetched from SurrealDB.

```python
import asyncio
from surreal_rag import SurrealRAG
from deepeval.test_case import LLMTestCase
from deepeval.metrics import (
    AnswerRelevancyMetric,
    FaithfulnessMetric,
    ContextualPrecisionMetric,
)
from deepeval import evaluate
import openai

async def main():
    rag = SurrealRAG()

    # 1. Populate SurrealDB (first run only)
    await rag.add([
        {
            "text": "The tomato is botanically classified as a berry because it develops \
                     from a single ovary and contains seeds.",
            "source": "https://en.wikipedia.org/wiki/Tomato",
        },
        {
            "text": "A cucumber is a pepo, a type of berry with a hard rind.",
            "source": "https://en.wikipedia.org/wiki/Cucumber",
        },
        {
            "text": "Strawberries are accessory fruits; their 'seeds' are achenes.",
            "source": "https://en.wikipedia.org/wiki/Strawberry",
        },
    ])

    # 2. Retrieve context
    query = "Which fruit is a berry but people think it's a vegetable?"
    context = await rag.query(query, k=3)

    # 3. Build prompt & generate answer
    prompt = f"""Answer the question.\n\nContext:\n{context}\n\nQ: {query}\nA:"""
    resp = openai.ChatCompletion.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
    )
    answer = resp.choices[0].message.content.strip()

    # 4. DeepEval test case
    test_case = LLMTestCase(
        input=query,
        actual_output=answer,
        expected_output="tomato",
        retrieval_context=context,
    )

    # 5. Evaluate
    evaluate(
        test_cases=[test_case],
        metrics=[
            AnswerRelevancyMetric(threshold=0.7),
            FaithfulnessMetric(threshold=0.7),
            ContextualPrecisionMetric(top_k=3),
        ],
    )

if __name__ == "__main__":
    asyncio.run(main())
```

Running this script prints a local score report **and** uploads the run to the Confident AI dashboard for historical tracking (after you've logged in with `deepeval login`).

Because the context objects already include `score` and `source`, DeepEval can show traceability back to the exact SurrealDB rows that justified the answer.

## Scaling up

* Replace the quick `rag.add()` list with a real corpus (CSV, PDFs, etc.).
* Encapsulate the *embed + insert* logic inside a Dagster or Airflow asset if you already orchestrate ETL.
* Use SurrealDB's metadata fields and SurrealQL predicates (`WHERE metadata.topic = 'law'`) to test retrieval recall for specific slices of your knowledge base.
* Evaluate hundreds of examples by looping through a HuggingFace dataset and appending each `LLMTestCase` to a list before calling `evaluate()`.

### Why SurrealDB + DeepEval?

<table>
    <thead>
        <tr>
            <th>Benefit</th>
            <th>Why it matters</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><strong>Single data plane</strong></td>
            <td>Store documents, vectors and relational metadata together – fewer moving parts.</td>
        </tr>
        <tr>
            <td><strong>Built-in ANN index</strong></td>
            <td>Define HNSW with one DDL statement; no external vector service to deploy.</td>
        </tr>
        <tr>
            <td><strong>SurrealQL</strong></td>
            <td>Flexible `SELECT … WHERE … <K>` queries mix Boolean filters with vector similarity.</td>
        </tr>
        <tr>
            <td><strong>DeepEval dashboards</strong></td>
            <td>Track how retrieval quality + answer faithfulness change as you tweak prompts or embeddings.</td>
        </tr>
    </tbody>
</table>

With these snippets you can drop SurrealDB into any DeepEval-based RAG test harness and keep the rest of your metric logic unchanged. Happy evaluating!

## Resources

- [Vector Search reference guide](/docs/surrealdb/models/vector)
- [DEFINE INDEX statement](/docs/surrealql/statements/define/indexes)



================================================
FILE: src/content/doc-integrations/Frameworks/dynamiq.mdx
================================================
---
sidebar_position: 1
sidebar_label: Dynamiq
title: Dynamiq | Framework
description: A Python framework for building multi-agent LLM systems with SurrealDB vector storage capabilities.
---

# Dynamiq

Dynamiq is a Python framework for building multi-agent LLM systems with SurrealDB vector storage capabilities.

## Installation

```bash
pip install dynamiq surrealdb openai         # swap OpenAI for any embedder you like
# one-liner dev DB
docker run -p 8000:8000 surrealdb/surrealdb:latest \
       start --user root --pass secret file:/data/db
```

SurrealDB ≥ v1.5 has built-in HNSW vector indexes, queried with SurrealQL's `<| K |>` operator and [`vector::distance::*` functions](/docs/surrealql/functions/database/vector).

## Define the one-time vector table & index

```surql
-- run this once in your DB console
DEFINE TABLE ai_docs SCHEMALESS;
DEFINE FIELD id        ON ai_docs TYPE string;
DEFINE FIELD text      ON ai_docs TYPE string;
DEFINE FIELD metadata  ON ai_docs TYPE object;
DEFINE FIELD embedding ON ai_docs TYPE array;

-- Fast ANN (1536-D cosine; change DIST/ DIMENSION to fit your embedder)
DEFINE INDEX IF NOT EXISTS ai_docs_vec
  ON ai_docs FIELDS embedding
  HNSW DIMENSION 1536 DIST COSINE;
```

## SurrealDB nodes for Dynamiq

```python title="dynamiq_surreal.py"
from dynamiq.nodes.node import ConnectionNode
from typing import List, Dict, Any, Optional
from surrealdb import AsyncSurreal
import hashlib, json, os
import openai                                # or any local embedding model

_EMBED_DIM = 1536

def embed(text: str) -> List[float]:
    """Tiny helper – replace with your preferred model."""
    resp = openai.Embedding.create(
        model="text-embedding-3-small",
        input=[text],
        dimensions=_EMBED_DIM,
        api_key=os.getenv("OPENAI_API_KEY"),
    )
    return resp["data"][0]["embedding"]


# ---------------------------------------------------------------------#
#  A lightweight Connection object so Dynamiq can share sockets
# ---------------------------------------------------------------------#
class SurrealConnection:
    def __init__(
        self,
        url: str = "ws://localhost:8000/rpc",
        namespace: str = "dynamiq",
        database: str = "rag",
        user: str = "root",
        password: str = "secret",
    ):
        self.url = url
        self.namespace = namespace
        self.database = database
        self.user = user
        self.password = password

    async def _ensure_table_and_index(self, table_name: str):
        async with AsyncSurreal(self.url) as db:
            await db.signin({"username": self.user, "password": self.password})
            await db.use(self.namespace, self.database)
            await db.query(
                """
                DEFINE TABLE $table SCHEMALESS;
                DEFINE FIELD id        ON $table TYPE string;
                DEFINE FIELD text      ON $table TYPE string;
                DEFINE FIELD metadata  ON $table TYPE object;
                DEFINE FIELD embedding ON $table TYPE array;
                DEFINE INDEX IF NOT EXISTS ${table}_vec
                   ON $table FIELDS embedding
                   HNSW DIMENSION $dim DIST COSINE;
                """,
                {
                    "table": table_name,
                    "dim": _EMBED_DIM
                }
            )


class SurrealDocumentWriter(ConnectionNode):
    def __init__(
        self,
        index_name: str,
        create_if_not_exist: bool = True,
        connection: Optional[SurrealConnection] = None,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.index_name = index_name
        self.connection = connection or SurrealConnection()
        self.create_if_not_exist = create_if_not_exist

    async def run(self, documents: List[Dict[str, Any]], **_) -> Dict[str, Any]:
        if self.create_if_not_exist:
            await self.connection._ensure_table_and_index(self.index_name)

        rows = []
        for doc in documents:
            rows.append({
                "id": hashlib.sha1(doc["text"].encode()).hexdigest(),
                "text": doc["text"],
                "metadata": doc.get("metadata", {}),
                "embedding": doc["embedding"] or embed(doc["text"]),
            })

        async with AsyncSurreal(self.connection.url) as db:
            await db.signin({"username": self.connection.user, "password": self.connection.password})
            await db.use(self.connection.namespace, self.connection.database)
            for r in rows:
                await db.create(self.index_name, r)
        return {"status": "ok", "count": len(rows)}


class SurrealDocumentRetriever(ConnectionNode):
    def __init__(
        self,
        index_name: str,
        top_k: int = 5,
        filters: Optional[Dict[str, Any]] = None,
        connection: Optional[SurrealConnection] = None,
        **kwargs,
    ):
        super().__init__(**kwargs)
        self.index_name = index_name
        self.top_k = top_k
        self.filters = filters or {}
        self.connection = connection or SurrealConnection()

    async def run(self, embedding: List[float], **_) -> Dict[str, Any]:
        # Build filter conditions
        filter_params = {}
        where_clause = ""
        if self.filters:
            conditions = []
            for i, (k, v) in enumerate(self.filters.items()):
                param_name = f"filter_{i}"
                conditions.append(f"metadata.{k} == ${param_name}")
                filter_params[param_name] = v
            where_clause = " AND " + " AND ".join(conditions)

        async with AsyncSurreal(self.connection.url) as db:
            await db.signin({"username": self.connection.user, "password": self.connection.password})
            await db.use(self.connection.namespace, self.connection.database)
            result = await db.query(
                f"""
                SELECT text, metadata,
                       vector::distance::cosine(embedding, $vec) AS score
                FROM {self.index_name}
                WHERE embedding <|$top_k|> $vec{where_clause}
                ORDER BY score ASC
                """,
                {
                    "vec": embedding,
                    "top_k": self.top_k,
                    **filter_params
                }
            )
            return {"results": result[0]["result"]}
```

## Unique workflow example: **"Snack-Bot"**

```python title="dynamiq_surreal.py"
import asyncio
from dynamiq import Workflow
from dynamiq_surreal import (
    SurrealDocumentWriter,
    SurrealDocumentRetriever,
)
from dynamiq.nodes.llms import OpenAIChat

async def main():
    # --- 1. Writer node ingests knowledge ---------------------------------
    writer = SurrealDocumentWriter(
        index_name="snack_mem",
        create_if_not_exist=True,
    )

    docs = [
        {"text": "Hummus is traditionally made from chickpeas.", "embedding": None},
        {"text": "Trail mix usually combines nuts, dried fruit, and chocolate.", "embedding": None},
        {"text": "Edamame are young soybeans, often served steamed.", "embedding": None},
    ]

    # --- 2. Retriever node pulls context for the LLM ----------------------
    retriever = SurrealDocumentRetriever(
        index_name="snack_mem",
        top_k=2,
    )

    # --- 3. LLM node ------------------------------------------------------
    llm = OpenAIChat(
        prompt_template="""
        Answer the question using ONLY the context below.
        Context: {{retrieved_docs}}
        Question: {{question}}
        """.strip()
    )

    # --- 4. Build workflow ------------------------------------------------
    wf = Workflow()
    wf.flow.add_nodes(writer, retriever, llm)

    # wire outputs/inputs
    wf.flow.connect(writer, retriever, mapping={"output": "documents"})   # passive write
    wf.flow.connect(retriever, llm, mapping={"results": "retrieved_docs"})
    wf.flow.set_entry_nodes(retriever, llm)

    # --- 5. Run -----------------------------------------------------------
    # step-A: ingest once
    await writer.run(input_data={"documents": docs})

    # step-B: query + answer
    query = "What legumes are eaten steamed in their pods?"
    emb = embed(query)                       # same helper as above
    answer = await wf.run(input_data={
        "embedding": emb,
        "question": query
    })
    print(answer["OpenAIChat"])

if __name__ == "__main__":
    asyncio.run(main())
```

**What happens**

1. `SurrealDocumentWriter` embeds & inserts snack facts into `snack_mem` with an HNSW index.
2. `SurrealDocumentRetriever` performs a cosine k-NN query on `embedding <|2|>` and passes the top-2 passages to the LLM.
3. The LLM answers *"Edamame are steamed young soybeans."* grounded by the retrieved context.

### Why SurrealDB for Dynamiq?

<table>
    <thead>
        <tr>
            <th>Feature</th>
            <th>Benefit</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><strong>Unified store</strong></td>
            <td>Keep vectors, relational data, graph edges & real-time queries in one DB.</td>
        </tr>
        <tr>
            <td><strong>Native ANN</strong></td>
            <td><code>DEFINE INDEX … HNSW</code> avoids an extra service.</td>
        </tr>
        <tr>
            <td><strong>SurrealQL filters</strong></td>
            <td>Mix vector similarity with rich metadata predicates (<code>WHERE metadata.cuisine = 'asian' AND …</code>).</td>
        </tr>
    </tbody>
</table>

Copy the snippets above into your Dynamiq repo and you're ready to build end-to-end RAG and agent flows with SurrealDB as the memory spine. Happy hacking!

## Resources

- [Vector Search reference guide](/docs/surrealdb/models/vector)
- [DEFINE INDEX statement](/docs/surrealql/statements/define/indexes)
- [Vector functions](/docs/surrealql/functions/database/vector)
- [Operators](/docs/surrealql/operators)



================================================
FILE: src/content/doc-integrations/Frameworks/feast.mdx
================================================
---
sidebar_position: 1
sidebar_label: Feast
title: Feast
description: Feast is a feature store for ML that supports feature retrieval and serving.
---

# Feast

[Feast](https://docs.feast.dev) (**Fea**ture **St**ore) is an open-source feature store for production ML.
You define your features once and Feast handles validation, materialisation and low-latency online look-ups.

## Installation

```bash
pip install feast surrealdb openai     # swap OpenAI for any embedder you like
```


## Configuring Feast with SurrealDB

Feast lets you plug in a custom online store by pointing to a Python class.
Create `surreal_online_store.py` in your repo:

```python
# surreal_online_store.py
from feast.infra.online_stores.base import OnlineStore, OnlineReadOptions
from typing import List, Tuple, Any, Dict
from surrealdb import AsyncSurreal
import json, os, asyncio

class SurrealOnlineStore(OnlineStore):
    """
    Minimal SurrealDB-backed online store for embedding vectors.
    Stores one table per feature view: <project>__<entity>.
    """

    def __init__(
        self,
        *,
        url: str = "ws://localhost:8000/rpc",
        namespace: str = "feast",
        database: str = "online",
        user: str = "root",
        password: str = "secret",
        **_,
    ):
        self.url = url
        self.namespace = namespace
        self.database = database
        self.user = user
        self.password = password

    # ---------- write --------------------------------------------------
    def online_write_batch(self, project, table, data, progress=None):
        asyncio.run(self._write_batch(table, data))

    async def _write_batch(self, table, data):
        async with AsyncSurreal(self.url) as db:
            await db.signin({"username": self.user, "password": self.password})
            await db.use(self.namespace, self.database)
            
            await self._ensure_table(db, table)
            for entity_key, values, timestamp in data:
                row = {
                    "id": "_".join(map(str, entity_key.entity_id)),
                    **{fv: v for fv, v in values.items()},
                    "_timestamp": int(timestamp.timestamp()),
                }
                await db.create(table, row)

    # ---------- read ---------------------------------------------------
    def online_read(
        self,
        project,
        table,
        entity_keys: List[Any],
        requested_features: List[str],
        options: OnlineReadOptions,
    ) -> List[Tuple[Any, Dict[str, Any]]]:
        return asyncio.run(self._read(table, entity_keys, requested_features))

    async def _read(
        self,
        table: str,
        entity_keys: List[Any],
        requested_features: List[str],
    ) -> List[Tuple[Any, Dict[str, Any]]]:
        async with AsyncSurreal(self.url) as db:
            await db.signin({"username": self.user, "password": self.password})
            await db.use(self.namespace, self.database)

            keys = ["_".join(map(str, k.entity_id)) for k in entity_keys]
            results = []
            for k in keys:
                res = await db.select(f"{table}:{k}")
                if res:
                    row = res[0]
                    results.append((k, {f: row.get(f) for f in requested_features}))
                else:
                    results.append((k, {}))
            return results

    # ---------- vector helper -----------------------------------------
    def retrieve_online_documents(
        self,
        table: str,
        query_vector: List[float],
        top_k: int = 5,
        distance: str = "COSINE",
    ):
        return asyncio.run(self._retrieve_documents(table, query_vector, top_k, distance))

    async def _retrieve_documents(
        self,
        table: str,
        query_vector: List[float],
        top_k: int = 5,
        distance: str = "COSINE",
    ):
        async with AsyncSurreal(self.url) as db:
            await db.signin({"username": self.user, "password": self.password})
            await db.use(self.namespace, self.database)

            result = await db.query(
                """
                SELECT id, 
                       vector::distance::cosine(embedding, $vec) AS score
                FROM $table
                WHERE embedding <|$k|> $vec
                ORDER BY score ASC
                """,
                {
                    "table": table,
                    "vec": query_vector,
                    "k": top_k
                }
            )
            return result[0]["result"]

    # ---------- internals ---------------------------------------------
    async def _ensure_table(self, db: AsyncSurreal, table: str):
        await db.query(
            """
            DEFINE TABLE $table SCHEMALESS;
            DEFINE FIELD id        ON $table TYPE string;
            DEFINE FIELD embedding ON $table TYPE array;
            DEFINE INDEX IF NOT EXISTS ${table}_vec
                ON $table FIELDS embedding
                HNSW DIMENSION 384 DIST COSINE;
            """,
            {"table": table}
        )
```

### YAML config

```yaml
# feature_store.yaml
project: my_feature_repo
registry: data/registry.db
provider: local
online_store:
  path: surreal_online_store.SurrealOnlineStore   # ← Python path
  url: ws://localhost:8000/rpc
  namespace: feast
  database: online
  vector_len: 384
  write_batch_size: 100
```

## Retrieving vectors online

```python
from feast import FeatureStore
from typing import List

store = FeatureStore(repo_path="feature_store.yaml")

# The custom store adds `.retrieve_online_documents`
query_vector: List[float] = [1.0, 2.0, 3.0, 4.0]   # 384-D in real life

top_k = 5
rows = store.online_store.retrieve_online_documents(
    table="my_feature_view__user_id",
    query_vector=query_vector,
    top_k=top_k,
)

for r in rows:
    print(r["id"], r["score"])
```
## Why SurrealDB?

SurrealDB is a **multi-model database with native vector search**.
Key capabilities that map well to Feast's needs:

<table>
    <thead>
        <tr>
            <th>SurrealDB feature</th>
            <th>Benefit for a feature-store</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><strong><code>DEFINE INDEX … HNSW</code></strong> – build an approximate-NN index in one DDL line (<a href="#" rel="noopener noreferrer">SurrealDB</a>)</td>
            <td>Millisecond-latency k-NN retrieval without an extra service</td>
        </tr>
        <tr>
            <td><strong><code>vector::similarity::cosine()</code></strong> & [other vector functions](/docs/surrealql/functions/database/vector)</td>
            <td>Compute similarity scores directly in the query plan</td>
        </tr>
        <tr>
            <td><strong><code>&lt;|K|&gt;</code></strong> operator for "return <em>K</em> [nearest neighbours](/docs/surrealql/operators)"</td>
            <td>Simple, declarative top-K semantics for online reads</td>
        </tr>
        <tr>
            <td>Document / table / graph in one engine</td>
            <td>Store scalar features <strong>and</strong> embeddings side-by-side</td>
        </tr>
    </tbody>
</table>



### Going further

- **HNSW tune-ups** – adjust `EF`/`M` parameters in the `DEFINE INDEX …` line to trade search speed vs. recall.
- **Multi-vector features** – SurrealQL supports **named vectors**; simply add another `embedding₂` field and index.
- **SQL + vector filters** – mix Boolean predicates with similarity (`WHERE metadata.region = 'EU' AND embedding <|…|>`).
- **Streaming updates** – SurrealDB's live queries let downstream services react instantly when features change.

With these few steps, Feast can serve scalar features and high-dimensional embeddings straight out of SurrealDB—zero micro-services, one binary. Happy feasting!

## Resources

- [DEFINE INDEX statement](/docs/surrealql/statements/define/indexes)
- [Vector functions](/docs/surrealql/functions/database/vector)
- [Operators](/docs/surrealql/operators)




================================================
FILE: src/content/doc-integrations/Frameworks/googleagent.mdx
================================================
---
sidebar_position: 1
sidebar_label: Google Agent
title: Google Agent
description: Google Agent is a framework for building and deploying agents.
---

# Google Agent

Vertex AI Agent Builder provides a powerful framework for developing and deploying intelligent agents in Google Cloud. This integration is particularly valuable since any agent running on Vertex AI Agent Engine or the open-source ADK runtime can be seamlessly [surfaced through Agentspace](https://cloud.google.com/products/agentspace), making it easily accessible to your organization.

### TL;DR

*Build the agent with ADK → deploy to Agent Engine → "Add to Agentspace"*—the SurrealDB retrieval tool keeps working unchanged, giving your Gemini-based agent sub-second RAG over your own vector index, all inside Google Cloud.

Below is a concise walkthrough that shows:

1. creating a SurrealDB-powered retrieval tool
2. wiring it into an **ADK** agent
3. deploying that agent to Agent Engine
4. registering it in Agentspace so employees can chat with it from the Agentspace UI.

## Prerequisites

```bash
pip install google-adk google-genai surrealdb    # ADK + Gemini SDK + SurrealDB
docker run -p 8000:8000 surrealdb/surrealdb:latest \
       start --user root --pass secret file:/data/db   # optional local DB
export GOOGLE_API_KEY=<your-Gemini-key>
```

## Prepare SurrealDB (one-time DDL)

```surql
DEFINE TABLE kb_docs SCHEMALESS;
DEFINE FIELD id        ON kb_docs TYPE string;
DEFINE FIELD text      ON kb_docs TYPE string;
DEFINE FIELD source    ON kb_docs TYPE string;
DEFINE FIELD embedding ON kb_docs TYPE array;

-- 1 536-D cosine HNSW (matches Gemini embeddings)
DEFINE INDEX IF NOT EXISTS kb_vec
  ON kb_docs FIELDS embedding
  HNSW DIMENSION 1536 DIST COSINE;
```

## Custom "Surreal Retrieve" tool

```python
from typing import List, Dict, Any, Optional
from google import genai
from surrealdb import AsyncSurreal
from surrealdb.exception import SurrealException
import os
import json
import hashlib
import logging
from dataclasses import dataclass
from contextlib import asynccontextmanager

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class SurrealConfig:
    """Configuration for SurrealDB connection."""
    url: str = "ws://localhost:8000/rpc"
    namespace: str = "agent"
    database: str = "demo"
    username: str = "root"
    password: str = "secret"

class SurrealRetriever:
    """SurrealDB-powered retrieval tool for Google Agent."""
    
    def __init__(
        self,
        config: Optional[SurrealConfig] = None,
        api_key: Optional[str] = None
    ):
        """Initialize the retriever.
        
        Args:
            config: Optional SurrealDB configuration
            api_key: Optional Google API key
        """
        self.config = config or SurrealConfig()
        self.api_key = api_key or os.environ.get("GOOGLE_API_KEY")
        if not self.api_key:
            raise ValueError("Google API key is required")
            
        genai.configure(api_key=self.api_key)
        self.embedder = genai.Client().models.get_embedding_model("models/embedding-001")
        
    @asynccontextmanager
    async def _get_connection(self) -> AsyncSurreal:
        """Get a database connection with proper authentication.
        
        Yields:
            Connected AsyncSurreal instance
            
        Raises:
            SurrealException: If connection fails
        """
        db = AsyncSurreal(self.config.url)
        try:
            await db.signin({
                "username": self.config.username,
                "password": self.config.password
            })
            await db.use(self.config.namespace, self.config.database)
            yield db
        except SurrealException as e:
            logger.error(f"Failed to connect to SurrealDB: {str(e)}")
            raise SurrealException(f"Connection failed: {str(e)}")
        finally:
            await db.close()

    async def _embed(self, text: str) -> List[float]:
        """Generate embeddings for text.
        
        Args:
            text: Text to embed
            
        Returns:
            List of embedding values
            
        Raises:
            Exception: If embedding generation fails
        """
        try:
            return self.embedder.embed(content=text).embedding
        except Exception as e:
            logger.error(f"Failed to generate embeddings: {str(e)}")
            raise Exception(f"Embedding generation failed: {str(e)}")

    async def retrieve(self, question: str, k: int = 4) -> str:
        """Retrieve top-k passages related to question from SurrealDB.
        
        Args:
            question: Search query
            k: Number of results to return
            
        Returns:
            Formatted string of matching passages
            
        Raises:
            SurrealException: If database operations fail
        """
        try:
            qv = await self._embed(question)
            async with self._get_connection() as db:
                result = await db.query("""
                    SELECT text, source,
                           vector::distance::cosine(embedding, $vec) AS score
                    FROM kb_docs
                    WHERE embedding <|$k|> $vec
                    ORDER BY score ASC
                """, {
                    "vec": qv,
                    "k": k
                })
                
                rows = result[0]["result"]
                return "\n".join(
                    f"- {r['text']} (src: {r['source']})"
                    for r in rows
                )
        except SurrealException as e:
            logger.error(f"Retrieval failed: {str(e)}")
            raise SurrealException(f"Retrieval failed: {str(e)}")

    async def ingest(self, docs: List[Dict[str, str]]) -> None:
        """Ingest documents into SurrealDB.
        
        Args:
            docs: List of documents with text and source
            
        Raises:
            SurrealException: If database operations fail
        """
        try:
            async with self._get_connection() as db:
                for doc in docs:
                    rec = {
                        "id": hashlib.sha1(doc["text"].encode()).hexdigest(),
                        "text": doc["text"],
                        "source": doc["source"],
                        "embedding": await self._embed(doc["text"]),
                    }
                    await db.create("kb_docs", rec)
                logger.info(f"Ingested {len(docs)} documents")
        except SurrealException as e:
            logger.error(f"Ingestion failed: {str(e)}")
            raise SurrealException(f"Ingestion failed: {str(e)}")

    async def ensure_schema(self) -> None:
        """Ensure the required table and index exist.
        
        Raises:
            SurrealException: If schema operations fail
        """
        try:
            async with self._get_connection() as db:
                await db.query("""
                    DEFINE TABLE IF NOT EXISTS kb_docs SCHEMALESS;
                    DEFINE FIELD id        ON kb_docs TYPE string;
                    DEFINE FIELD text      ON kb_docs TYPE string;
                    DEFINE FIELD source    ON kb_docs TYPE string;
                    DEFINE FIELD embedding ON kb_docs TYPE array;
                    DEFINE INDEX IF NOT EXISTS kb_vec
                        ON kb_docs FIELDS embedding
                        HNSW DIMENSION 1536 DIST COSINE;
                """)
                logger.info("Schema ensured successfully")
        except SurrealException as e:
            logger.error(f"Schema setup failed: {str(e)}")
            raise SurrealException(f"Schema setup failed: {str(e)}")

# Example usage
async def main():
    retriever = SurrealRetriever()
    
    try:
        # Ensure schema exists
        await retriever.ensure_schema()
        
        # Ingest sample documents
        await retriever.ingest([
            {
                "text": "Nikola Tesla patented the first practical AC induction motor in 1888.",
                "source": "wiki/Tesla"
            },
            {
                "text": "The Wright brothers achieved powered flight on 17 Dec 1903.",
                "source": "wiki/Wright"
            },
        ])
        
        # Test retrieval
        result = await retriever.retrieve(
            "Who invented the AC motor and when?",
            k=2
        )
        print(result)
        
    except Exception as e:
        logger.error(f"Error: {str(e)}")
        raise

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
```

## Build an ADK agent that uses the tool

```python
from typing import Optional
from adk import Agent, Tool
from surreal_tool import SurrealRetriever
import asyncio
import logging
from contextlib import asynccontextmanager

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize retriever
retriever = SurrealRetriever()

@Tool
async def knowledge_search(query: str) -> str:
    """Search SurrealDB for passages relevant to the query.
    
    Args:
        query: Search query
        
    Returns:
        Formatted string of matching passages
    """
    try:
        return await retriever.retrieve(query, k=4)
    except Exception as e:
        logger.error(f"Knowledge search failed: {str(e)}")
        return f"Error searching knowledge base: {str(e)}"

@asynccontextmanager
async def get_agent():
    """Get an agent instance with proper setup and teardown.
    
    Yields:
        Configured Agent instance
    """
    try:
        agent = Agent(
            name="Surreal-Facts-Bot",
            llm="gemini-pro",
            instructions="""
You are a helpful assistant that must cite retrieved passages verbatim.
When knowledge is required, call knowledge_search().
""",
            tools=[knowledge_search],
        )
        logger.info("Agent created successfully")
        yield agent
    except Exception as e:
        logger.error(f"Failed to create agent: {str(e)}")
        raise

async def main():
    """Run the agent."""
    try:
        async with get_agent() as agent:
            response = await agent.chat("Who invented the AC motor and when?")
            print(response)
            logger.info("Agent execution completed successfully")
    except Exception as e:
        logger.error(f"Agent execution failed: {str(e)}")
        raise

if __name__ == "__main__":
    asyncio.run(main())
```

Run locally (`python agent.py`) to verify the agent calls your SurrealDB tool.

## Deploy to **Vertex AI Agent Engine**

Create `agent.yaml` (full schema in the ADK docs):

```yaml
name: surreal-facts
entrypoint: agent:agent        # python-module:object
requirements:
  - surrealdb
  - google-genai
  - google-adk
  - google-cloud-aiplatform
```

```bash
gcloud ai agent-engines deploy surreal-facts \
  --agent-spec=agent.yaml \
  --region=us-central1
```

## Publish in **Agentspace**

Agentspace can list any agent that's running on Agent Engine ([Google Cloud][3], [Medium][4]).

* **Console path:** *Agentspace → Agent Gallery → "Add agent" → Source: Agent Engine*
* **CLI (preview):**

```bash
gcloud ai agentspace agent-galleries add-agent \
  --agent-engine=projects/$PROJECT/locations/us-central1/agentEngines/surreal-facts
```

Once added, employees will see **"Surreal Facts Bot"** in the gallery and can chat with it from the Agentspace UI; every time it needs knowledge it silently calls your SurrealDB index.

## Operational notes

<table>
  <thead>
    <tr>
      <th>Topic</th>
      <th>Guidance</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Networking</strong></td>
      <td>Run SurrealDB on Cloud Run, GKE, or a VM inside the same VPC; use Private Service Connect so the Agent Engine can reach it.</td>
    </tr>
    <tr>
      <td><strong>Security</strong></td>
      <td>Protect the DB with <code>DEFINE ACCESS</code> tokens or basic auth; Agentspace inherits IAM & VPC-SC you already set in Agent Builder (<a href="[Google Cloud][5]">Google Cloud</a>).</td>
    </tr>
    <tr>
      <td><strong>Hybrid search</strong></td>
      <td>Mix Boolean filters with the <code>&lt;|K|&gt;</code> operator (<code>WHERE source ~ 'wiki' AND embedding &lt;|3|&gt;</code>).</td>
    </tr>
    <tr>
      <td><strong>Updates</strong></td>
      <td>New docs can be inserted at any time; SurrealDB's HNSW index updates incrementally, or run <code>REBUILD INDEX</code> during low-traffic windows (<a href="[SurrealDB][6]">SurrealDB</a>).</td>
    </tr>
  </tbody>
</table>


## Resources 

- [Google Next 25 Updates: ADK, Agentspace, Application Integration](https://www.googlecloudcommunity.com/gc/Cloud-Product-Articles/Google-Next-25-Updates-ADK-Agentspace-Application-Integration/ta-p/898343)
- [DEFINE INDEX statement](/docs/surrealql/statements/define/indexes)
- [Vertex AI Agent Builder](https://cloud.google.com/products/agent-builder)
- [A Foundational Framework for Agentic AI Ecosystems: Enabling](https://medium.com/google-cloud/a-foundational-framework-for-agentic-ai-ecosystems-enabling-development-discovery-and-2aeb120949f6)
- [Introduction to Google Agentspace](https://cloud.google.com/agentspace/docs/overview)
- [REBUILD statement](/docs/surrealql/statements/rebuild)





================================================
FILE: src/content/doc-integrations/Frameworks/index.mdx
================================================
---
sidebar_position: 3
sidebar_label: Frameworks
title: Frameworks | Overview
description: This section contains information about the different frameworks that can be used to integrate with SurrealDB.
---

import Boxes from "@components/boxes/Boxes.astro";
import IconBox from "@components/boxes/IconBox.astro";
import Version from '@components/Version.astro';

# Frameworks
SurrealDB seamlessly integrates with popular AI and data frameworks, enabling you to leverage SurrealDB's powerful features like vector search, graph relationships, and structured data storage. These integrations make it easy to build sophisticated applications combining LLMs, agents, data pipelines and more - all while using familiar tools and frameworks.

<style>{`
  td:first-child a { white-space: nowrap; word-break: keep-all; }
`}</style>

<table style={{ width: '100%' }}>
    <thead>
        <tr>
            <th>Integration</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><a href="/docs/integrations/frameworks/agno">Agno</a></td>
            <td>Agno is a python framework for building multi-agent systems with shared memory, knowledge and reasoning.</td>
        </tr>
        <tr>
            <td><a href="/docs/integrations/frameworks/camel">Camel</a></td>
            <td>A Python framework for building multi-agent LLM systems with SurrealDB vector storage capabilities.</td>
        </tr>
        <tr>
            <td><a href="/docs/integrations/frameworks/crewai">CrewAI</a></td>
            <td>A framework for orchestrating role-playing AI agents with SurrealDB for entity and short-term memory.</td>
        </tr>
        <tr>
            <td><a href="/docs/integrations/frameworks/dagster">Dagster</a></td>
            <td>A data orchestration framework with SurrealDB vector search integration for ML pipelines.</td>
        </tr>
        <tr>
            <td><a href="/docs/integrations/frameworks/deepeval">DeepEval</a></td>
            <td>A testing framework for LLM systems that uses SurrealDB's vector capabilities to evaluate RAG pipeline quality.</td>
        </tr>
        <tr>
            <td><a href="/docs/integrations/frameworks/dynamiq">Dynamiq</a></td>
            <td>Dynamiq is a Python framework for building multi-agent LLM systems with SurrealDB vector storage capabilities.</td>
        </tr>
        <tr>
            <td><a href="/docs/integrations/frameworks/feast">Feast</a></td>
            <td>A feature store for ML pipelines with SurrealDB vector search integration.</td>
        </tr>
        <tr>
            <td><a href="/docs/integrations/frameworks/googleagent">Google Agent</a></td>
            <td>A framework for building and deploying intelligent agents in Google Cloud with SurrealDB vector storage for RAG.</td>
        </tr>
        <tr>
            <td><a href="/docs/integrations/frameworks/langchain">LangChain</a></td>
            <td>A framework for building LLM based applications.</td>
        </tr>
        <tr>
            <td><a href="/docs/integrations/frameworks/llama-index">Llama Index</a></td>
            <td>A framework for building RAG pipelines with SurrealDB's native HNSW vector index as the backing store.</td>
        </tr>
        <tr>
            <td><a href="/docs/integrations/frameworks/smolagents">Smol Agents</a></td>
            <td>A complete walkthrough for building a code-generating AI agent that recommends grocery items by querying SurrealDB's HNSW vector index.</td>
        </tr>
    </tbody>
</table>



================================================
FILE: src/content/doc-integrations/Frameworks/langchain.mdx
================================================
---
sidebar_position: 1
sidebar_label: Langchain
title: Langchain
description: Use SurrealDB native vector indexes as a drop-in **Vector Store** for LangChain.
---
import VidMp4 from "@assets/video/langchain-vectorstore.mp4";
import VidWebm from "@assets/video/langchain-vectorstore.webm";

# Langchain

[LangChain](https://python.langchain.com/docs/introduction/) is a framework for developing applications powered by large language models (LLMs). SurrealDB is an excellent database choice for [LangChain](https://python.langchain.com/docs/introduction/) projects primarily because of its [multi-model capabilities](/docs/surrealdb/models), which streamline data management by requiring only a single database.

This unified system adeptly handles structured and unstructured data, incorporating vector search, [graph traversal](/docs/surrealdb/models/graph), [relational queries](/docs/surrealdb/models), [full-text search](/docs/surrealdb/models/full-text-search), [document storage](/docs/surrealdb/models/document), and [time-series data](/docs/surrealdb/models/time-series) all within one ACID-compliant engine. 

For LangChain applications, which often juggle diverse data types for tasks like context retrieval and complex data interactions, SurrealDB's ability to consolidate these needs into one platform simplifies architecture, reduces latency, and ensures data consistency, making it a highly efficient and powerful backend solution.

In this guide, we'll walk through how to use SurrealDB as a vector store for LangChain.


{/* Commented out until our LangChain vector store supports both algorithms. At the moment it only supports M-Tree */}

{/*
SurrealDB is a multi-model database that ships two built-in vector-search algorithms:

| Algorithm | Kind | When to use |
|-----------|------|-------------|
| **HNSW**  | Approx. ANN, in-memory or on-disk | Low-latency semantic search / RAG |
| **M-Tree**| Exact metric tree, on-disk       | Smaller datasets where recall = 100 % matters |

You expose either one with a single `DEFINE INDEX … HNSW|MTREE` statement in SurrealQL
*/}

<video class="w-full" width="630" height="300" controls>
    <source src={VidMp4} type="video/mp4" />
    <source src={VidWebm} type="video/webm" />
</video>

## Setup

You can run SurrealDB locally or start with a [free SurrealDB Cloud account](/docs/cloud/getting-started).

For local, two options:

1. [Install SurrealDB](/docs/surrealdb/installation) and run [SurrealDB](/docs/surrealdb/installation/running). Run in-memory with:

    ```sh
    surreal start -u root -p root
    ```

2. [Run with Docker](/docs/surrealdb/installation/running/docker).

    ```sh
    docker run --rm --pull always -p 8000:8000 surrealdb/surrealdb:latest start
    ```

## Install dependencies

```bash
# -- Using pip
pip install -U langchain-surrealdb langchain_ollama surrealdb
# -- Using poetry
poetry add langchain-surrealdb langchain_ollama surrealdb
# -- Using uv
uv add --upgrade langchain-surrealdb langchain_ollama surrealdb
````

* `surrealdb` → [SurrealDB Python SDK](/docs/sdk/python/)
* `langchain-surrealdb` → houses `SurrealDBVectorStore`
* `langchain_ollama`, `langchain-openai` (or HF, Cohere, etc.) → embeddings

## Quick start

Create a vector store, and documents with embeddings, and do a similarity search.

```python
from langchain_core.documents import Document
from langchain_surrealdb.vectorstores import SurrealDBVectorStore
from langchain_ollama import OllamaEmbeddings
from surrealdb import Surreal

conn = Surreal("ws://localhost:8000/rpc")
conn.signin({"username": "root", "password": "secret"})
conn.use("langchain", "demo")
vector_store = SurrealDBVectorStore(OllamaEmbeddings(model="llama3.2"), conn)

doc_1 = Document(page_content="foo", metadata={"source": "https://surrealdb.com"})
doc_2 = Document(page_content="SurrealDB", metadata={"source": "https://surrealdb.com"})

vector_store.add_documents(documents=[doc_1, doc_2], ids=["1", "2"])

results = vector_store.similarity_search_with_score(
    query="surreal", k=1, custom_filter={"source": "https://surrealdb.com"}
)

for doc, score in results:
    print(f"* [SIM={score:3f}] {doc.page_content} [{doc.metadata}]")
```

Under the hood the helper will:

1. Create table **`documents`** (if it doesn’t exist).
2. Add an **M-Tree** index with the correct dimensionality.
3. Insert each text with its freshly generated embedding.


## Similarity search

```python
query = "How do I enable vector search in SurrealDB?"
docs = vector_store.similarity_search(
    query=query, k=1, custom_filter={"source": "https://surrealdb.com"}
)
for doc in results:
    print(f"{doc.page_content} [{doc.metadata}]")
```

```
The Vector Search feature of SurrealDB... [{'source': 'https://surrealdb.com'}]
```

If you want to get the score with the results, use `similarity_search_with_score` instead.

You can also transform the vector store into a retriever for easier usage in your chains.

```python
query = "How do I enable vector search in SurrealDB?"
docs = vector_store.similarity_search(
retriever = vector_store.as_retriever(
    search_type="mmr", search_kwargs={"k": 1, "lambda_mult": 0.5}
)
retriever.invoke(query)
```

```
[Document(id='4', metadata={'source': 'https://surrealdb.com'}, page_content='The Vector Search feature of SurrealDB...')]
```

## Next steps

Now that you have a basic understanding of how to use SurrealDB with LangChain, let's explore some additional resources to help you dive deeper and build more sophisticated applications.

To help you get started quickly, we provide several example implementations:

* A [basic example](https://github.com/surrealdb/langchain-surrealdb/tree/main/examples/basic) with a ready-to-use Dockerfile - perfect for your first steps
* A more advanced [graph example](https://github.com/surrealdb/langchain-surrealdb/tree/main/examples/graph) showcasing graph capabilities
* An interactive [Jupyter notebook](https://github.com/langchain-ai/langchain/blob/master/docs/docs/integrations/vectorstores/surrealdb.ipynb) for hands-on learning

### Further reading and resources

For a deeper understanding of the technology stack:

* Explore the [SurrealDB vector-search reference](/docs/surrealdb/models/vector) for detailed technical information
* Check out the [LangChain API docs for `SurrealDBStore`](https://api.python.langchain.com/en/latest/vectorstores/langchain_community.vectorstores.surrealdb.SurrealDBStore.html) for comprehensive API documentation
* Browse [Awesome SurrealDB](https://github.com/surrealdb/awesome-surreal) for a curated collection of resources, tools, and applications
That’s it – you now have a fully-featured LangChain vector store powered by SurrealDB, no boilerplate required. 🚀



================================================
FILE: src/content/doc-integrations/Frameworks/llama-index.mdx
================================================
[Binary file]


================================================
FILE: src/content/doc-integrations/Frameworks/smolagents.mdx
================================================
---
sidebar_position: 1
sidebar_label: Smolagents
title: SmolAgents— Grocery Finder
description: A complete walkthrough for building a code-generating AI agent that recommends grocery items by querying SurrealDB's HNSW vector index.
---

# Smolagents

In this guide you will build an agent that, given a natural-language shopping request, finds the most relevant grocery items in your database and returns them in a single reply.

## Install the dependencies

```bash
pip install smolagents surrealdb fastembed datasets
```

| Library        | Purpose                                |
| -------------- | -------------------------------------- |
| **surrealdb**  | Async Python SDK for SurrealDB         |
| **smolagents** | Code-generating agent framework        |
| **fastembed**  | Local Jina v2 embedding model (768-D)  |
| **datasets**   | Pulls the public *GroceryList* dataset |

## Create a SurrealDB "grocery search" tool

```python
from fastembed import TextEmbedding
from surrealdb import AsyncSurreal
from smolagents import Tool
from datasets import load_dataset
import asyncio, os
from typing import List, Dict, Any

class GroceryQueryTool(Tool):
    name = "surreal_grocery_search"
    description = "Semantic search over grocery items stored in SurrealDB."
    inputs = {
        "query": {
            "type": "string",
            "description": "A natural-language description of a grocery need.",
        }
    }
    output_type = "string"

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Connection details
        self.uri = "ws://localhost:8000/rpc"
        self.ns = "demo"
        self.dbname = "demo"
        self.table = "groceries"
        self.user = os.getenv("SURREAL_USER", "root")
        self.pw = os.getenv("SURREAL_PASS", "secret")

        self.emb = TextEmbedding(model_name="jinaai/jina-embeddings-v2-base-en")

        # one-time async bootstrap
        asyncio.run(self._setup())

    async def _setup(self):
        """Connect, create schema, and ingest groceries if empty."""
        async with AsyncSurreal(self.uri) as db:
            await db.signin({"username": self.user, "password": self.pw})
            await db.use(self.ns, self.dbname)

            schema = """
            DEFINE TABLE $tb SCHEMALESS PERMISSIONS NONE;
            DEFINE FIELD item_name   ON $tb TYPE string;
            DEFINE FIELD category    ON $tb TYPE string;
            DEFINE FIELD description ON $tb TYPE string;
            DEFINE FIELD embedding   ON $tb TYPE array;

            DEFINE INDEX idx_hnsw ON $tb
              FIELDS embedding
              HNSW DIMENSION 768
              DIST   COSINE;
            """
            await db.query(schema, {"tb": self.table})

            # skip ingest if we already have rows
            existing = await db.query(f"SELECT count() FROM {self.table};")
            if existing[0]["result"][0]["count"] > 0:
                return

            print("🛒 Ingesting GroceryList dataset …")
            ds = load_dataset("AmirMohseni/GroceryList")["train"]  # 225 rows

            BATCH = 64
            items = ds["item"]
            cats = ds["category"]
            descs = [f"{it.capitalize()} is in the {cat} aisle." for it, cat in zip(items, cats)]

            for i in range(0, len(descs), BATCH):
                vecs = self.emb.query_embed(descs[i:i+BATCH])
                rows = [
                    {
                        "id": f"{self.table}:{i+j}",
                        "item_name": items[i+j],
                        "category": cats[i+j],
                        "description": descs[i+j],
                        "embedding": list(vec),
                    }
                    for j, vec in enumerate(vecs)
                ]
                await db.create(self.table, rows)

    async def _lookup(self, query_vec: List[float]) -> List[Dict[str, Any]]:
        """Perform vector search with proper connection management."""
        async with AsyncSurreal(self.uri) as db:
            await db.signin({"username": self.user, "password": self.pw})
            await db.use(self.ns, self.dbname)

            surql = """
            LET $q := $vec;
            SELECT item_name, category, description,
                   vector::distance::knn() AS dist
            FROM $tb
            WHERE embedding <|$k,$ef|> $q      -- top-k, efSearch
            ORDER BY dist;
            """
            result = await db.query(
                surql,
                {
                    "vec": query_vec,
                    "tb": self.table,
                    "k": 5,
                    "ef": 64
                }
            )
            return result[0]["result"]

    def forward(self, query: str) -> str:
        """Return the five closest grocery items."""
        q_vec = next(self.emb.query_embed(query))
        hits = asyncio.run(self._lookup(q_vec))

        return "Retrieved items:\n" + "".join(
            f"== {hit['item_name'].title()} ==\n"
            f"Category: {hit['category']}\n"
            f"{hit['description']}\n\n"
            for hit in hits
        )
```


================================================
FILE: src/content/doc-sdk-dotnet/data-types.mdx
================================================
---
sidebar_position: 4
sidebar_label: Data Types
title: .NET | SDK | Data Types
description: The .NET SDK translates all datatypes native to SurrealQL into either datatypes native to .NET, or a custom implementation. This document describes all datatypes, and links to their respective documentation.
---

# Data Types

The .NET SDK translates datatypes native to SurrealQL into either datatypes native to .NET, or a custom implementation.
This document describes all datatypes, and links to their respective documentation.

## Data Types overview

<table>
    <thead>
        <tr>
            <th colspan="1" scope="col">Datatype</th>
            <th colspan="1" scope="col">Kind</th>
            <th colspan="2" scope="col">Documentation</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="1" scope="row">String</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://learn.microsoft.com/en-us/dotnet/api/system.string">
                    <code>String</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Number</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <span>Any number type, e.g. </span>
                <a href="https://learn.microsoft.com/en-us/dotnet/api/system.int32">
                    <code>Int32</code>
                </a>
                <span>,</span>
                <a href="https://learn.microsoft.com/fr-fr/dotnet/api/system.single">
                    <code>Single</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Float</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <span>Any number type, e.g. </span>
                <a href="https://learn.microsoft.com/en-us/dotnet/api/system.int32">
                    <code>Int32</code>
                </a>
                <span>,</span>
                <a href="https://learn.microsoft.com/fr-fr/dotnet/api/system.single">
                    <code>Single</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Bool</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://learn.microsoft.com/en-us/dotnet/api/system.boolean">
                    <code>Boolean</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Null</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/null">
                    <code>null</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">None</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[None](#none)</code>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Array</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                Any <code>IEnumerable</code> representation
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Object</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                Any <code>Object</code> representation
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Datetime</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://learn.microsoft.com/fr-fr/dotnet/api/system.datetime">
                    <code>DateTime</code>
                </a>
                <span>or</span>
                <a href="https://learn.microsoft.com/fr-fr/dotnet/api/system.dateonly">
                    <code>DateOnly</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Binary</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <code>byte[]</code>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Uuid</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://learn.microsoft.com/fr-fr/dotnet/api/system.guid">
                    <code>Guid</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Duration</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://learn.microsoft.com/fr-fr/dotnet/api/system.timespan">
                    <code>TimeSpan</code>
                </a>
                <span>or</span>
                <a href="https://learn.microsoft.com/fr-fr/dotnet/api/system.timeonly">
                    <code>TimeOnly</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Decimal</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://learn.microsoft.com/fr-fr/dotnet/api/system.decimal">
                    <code>Decimal</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Geometry</td>
            <td colspan="1" scope="row">via [Microsoft.Spatial](https://www.nuget.org/packages/Microsoft.Spatial)</td>
            <td colspan="2" scope="row">
                <code>Geometry</code> or <code>Geography</code> representations
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Table</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://learn.microsoft.com/en-us/dotnet/api/system.string">
                    <code>String</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">RecordId</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[RecordId](#recordid)</code>
            </td>
        </tr>
    </tbody>
</table>

<br /><br />

## `None`

The `None` type is a custom type that represents the absence of a value.

```csharp title="Signature"
public readonly struct None { }
```

### Working with `None`

```csharp title="Constructing"
var none = new None();

// Change the value of a record to None
var myRecord = new MyRecord();
myRecord.Value = new None();
```

<br />

##  `RecordId`

When you receive a RecordId back from SurrealDB, it will always be represented as a `RecordId`.
The class holds `Table` and `Id` fields, representing the table name, and a unique identifier for the record on that table.

```csharp title="Signature"
public class RecordId
{
    public string Table { get; }

    public T DeserializeId<T>();

    // ... The rest is omitted for brevity
}
```

The `RecordId` is a non-generic class, allowing you to extract the `Id` field by providing the output type via the `DeserializeId` method.
This can helpful when the `RecordId` is used in a generic context, for when you store the `Id` as an Object or an Array for example.

For cases where you are aware of the type of the `Id` field, you can use the generic version of `RecordId` to avoid the need for manual deserialization.

```csharp title="Signature with generics"
public class RecordIdOf<T> : RecordId
{
    public T Id { get; }
}
```

The default type of an `Id` in SurrealDB being a `string`, you can choose to use the default provided type `RecordIdOfString`.

```csharp title="Default RecordId"
public class RecordIdOfString : RecordIdOf<string>
{
    // The available properties, inherited from `RecordId` and `RecordIdOf<string>`
    public string Table { get; }
    public string Id { get; }
}
```

### Working with `RecordId`

The simplest and most common way to construct a `RecordId` is with a tuple `(table, id)`.

```csharp title="Constructing"
// Table is "person"
// Unique identifier on the table is "john"
RecordId personId = ("person", "john");
// or
var personId = (RecordId)("person", "john");
```

This tuple is implicitly converted into a `RecordId` object.
You can use it with all SDK methods:

```csharp title="Using RecordId"
await db.Select<Person>(("person", "john"));
await db.Delete(("person", "john"));
```

You are not exclusively limited to the `string` type for the `Id` part. Several overloads exist for different `id` types:

```csharp title="Constructing"
RecordId rid1 = ("person", "alice");           // string
RecordId rid2 = ("person", 123);               // int
RecordId rid3 = ("person", 123L);              // long
RecordId rid4 = ("person", (short)5);          // short
RecordId rid5 = ("person", (byte)7);           // byte
RecordId rid6 = ("person", Guid.NewGuid());    // Guid
```

### Extracting data

The .NET SDK handles serialization and deserialization of the `Table` and `Id` parts in Record Id.
The serialization is done automatically when sending data to the server.
However, deserialization may need to be done manually according to the data type of the `Id` field.
Below are some examples:

```csharp title="Simple record id"
RecordId rid = ("person", "john");
string table = rid.Table; // "person"
string id = rid.DeserializeId<string>(); // "john"
```

```csharp title="Record id with simple data type (other than string)"
RecordId rid = ("table", 42);
string table = rid.Table; // "table"
int id = rid.DeserializeId<int>(); // 42
```

```csharp title="Record id with complex data types"
var rid = new RecordIdOf<CityId>("table", new CityId { City = "London" });
var id = rid.DeserializeId<CityId>(); // CityId { City = "London" }

var rid = new RecordIdOf<(string, int)>("table", ("London", 42));
var id = rid.DeserializeId<(string, int)>(); // ("London", 42)
```

### Send back string

If you need to send back a Record Id in string format, you can do so with the `StringRecordId` class.

We do not implement the parsing of Record Ids in the .NET SDK, as that would mean that we need to be able to parse any SurrealQL value, which comes with a cost.
Instead you can send it over as a string with `StringRecordId`, allowing the server to handle the parsing.

```csharp title="Signature"
public class StringRecordId
{
    public string Value { get; }
}
```

### Working with a `StringRecordId`

```csharp title="Constructing"
// Table is "person"
// Unique identifier on the table is "john"
var rid = new StringRecordId("person:john");

// Alternatively, a StringRecordId can be inferred explicitly from a string
var rid = (StringRecordId)"person:john";
await client.Select<Person>((StringRecordId)"person:john");
```

### Working with `RecordIdOfString`

For string-based identifiers, you can also use the specialized type RecordIdOfString:

```csharp title="Using RecordIdOfString"
var rid = new RecordIdOfString("person", "john");
// or
Console.WriteLine(rid.Table); // "person"
Console.WriteLine(rid.Id);    // "john"
```

### Working with `RecordIdOf<T>`

For complex or structured identifiers, use the generic type RecordIdOf\<T\>:

```csharp title="Using RecordIdOf<T>"
public class CityId
{
    public string City { get; set; } = string.Empty;
}

var rid = new RecordIdOf<CityId>("city", new CityId { City = "London" });
```

This enables strongly-typed IDs that map directly to your domain objects.

### Inheriting from Record

If your model class inherits from Record, it will automatically include an Id property of type `RecordId`.

```csharp title="Inheriting from Record"
public class Person : Record
{
    public string Name { get; set; } = string.Empty;
}

// Example usage
var person = new Person { Name = "Alice" };
Console.WriteLine(person.Id); // RecordId ("person", "…")
```

### Using Data Annotations

The SDK supports attributes for serialization and deserialization.

#### CBOR serialization

Use [CborProperty](https://github.com/dahomey-technologies/Dahomey.Cbor) to map C# properties to SurrealDB fields:

```csharp title="Using CborProperty"
[CborProperty("first_name")]
public string FirstName { get; set; } = string.Empty;
```

#### RecordIdJsonConverter

Use RecordIdJsonConverter to indicate that a property should be serialized as a RecordId reference to another table:

```csharp title="Using RecordIdJsonConverter"
[RecordIdJsonConverter("payment_details")]
public RecordId? PaymentDetails { get; set; }

[RecordIdJsonConverter("payment_details")]
public RecordId? PaymentDetails { get; set; }
```

#### Combining attributes
You can combine both attributes on the same property:

```csharp title="Combining attributes"
[CborProperty("payment_details")]
[RecordIdJsonConverter("payment_details")]
public RecordId? PaymentDetails { get; set; }
```



================================================
FILE: src/content/doc-sdk-dotnet/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Overview
title: .NET | SDK | Overview
description: The SurrealDB SDK for .NET provides a number of methods for interacting with your SurrealDB database.
---

import Boxes from "@components/boxes/Boxes.astro";
import IconBox from "@components/boxes/IconBox.astro";
import Version from '@components/Version.astro';
import Image from "@components/Image.astro";

import LightLogo from "@img/icon/light/dotnet.png";
import DarkLogo from "@img/icon/dark/dotnet.png";

<div class="flag-title">
	<Image
		alt=".NET"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# .NET SDK
</div>

The SurrealDB SDK for C# and .NET is the primary SDK for interacting with SurrealDB from server-side applications, systems, and APIs, allowing you to integrate SurrealDB into your website or application backend, and serve dynamic content to your users. You can use the .NET SDK to interact with your SurrealDB database instances, or to run SurrealDB as an embedded database within your C# application, with functionality for executing queries, managing data, running database functions, authenticating to the database, building user signup and authentication functionality, and subscribing to data changes with live queries. When connecting to remote database instances, connections automatically reconnect when terminated.

> [!IMPORTANT]
> The SDK requires either .NET version `6.0` or greater or .NET Standard `2.1` or higher.
> The SDK is available as a [NuGet package](https://www.nuget.org/packages/SurrealDb.Net).

> [!NOTE]
> The SDK works seamlessly with SurrealDB versions `v2.0.0` to <Version />, ensuring compatibility with the latest version.

> [!WARNING]
> This API is not yet fully stabilized and may be subject to change until the SDK reaches `1.0.0`.

To contribute to the SDK code, submit an Issue or Pull Request in the [surrealdb.net](https://github.com/surrealdb/surrealdb.net) repository. To contribute to this documentation, submit an Issue or Pull Request in the [docs.surrealdb.com](https://github.com/surrealdb/docs.surrealdb.com) repository.

## Example projects

You can find example repositories that demonstrate how to integrate SurrealDB in a number of different environments:

<Boxes>
    <IconBox
        title="Console App"
        description="A simple Console app example using the .NET SDK for SurrealDB."
        href="https://github.com/surrealdb/surrealdb.net/tree/main/SurrealDb.Examples.Console"
    />

    <IconBox
        title="Minimal APIs"
        description="A simple ASP.NET API example project using Minimal APIs."
        href="https://github.com/surrealdb/surrealdb.net/tree/main/SurrealDb.Examples.MinimalApis"
    />

    <IconBox
        title="Blazor Server"
        description="A Blazor Server app example querying data and consuming Live Query from a remote database."
        href="https://github.com/surrealdb/surrealdb.net/tree/main/SurrealDb.Examples.Blazor.Server"
    />
</Boxes>

## Sources

- [GitHub repository](https://github.com/surrealdb/surrealdb.net)
- [NuGet package](https://nuget.org/packages/surrealdb.net)



================================================
FILE: src/content/doc-sdk-dotnet/installation.mdx
================================================
---
sidebar_position: 2
sidebar_label: Installation
title: .NET | SDK | Installation
description: In this section, you will learn how to install the .NET SDK in your project.
---

import Image from "@components/Image.astro";
import NugetSearchImg from "@img/dotnet-nuget-search.png";

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";
import { packageName, fetchNugetVersion } from './utils';

export const value = await fetchNugetVersion();
export const packageReferenceXml = `<PackageReference Include="SurrealDb.Net" Version="${value}" />`;

# Installation

Before you can use this SDK in your .NET applications regardless of your environment, you need to install and import it into your project.
This guide will walk you through the process of installing and importing the SDK into your project.

## Install the SDK

- Create a new project using your favorite IDE (Visual Studio, JetBrains Rider, etc...) 
- or use an existing template from the <code>dotnet new</code> command.

Once ready, add the SurrealDB SDK to your dependencies:


<Tabs groupId="dotnet-package-manager">
  <TabItem value="dotnet-cli" label=".NET CLI" default>

```bash
dotnet add package SurrealDb.Net
```

  </TabItem>
  <TabItem value="package-reference" label="PackageReference">

<pre>
  <code class="language-xml">
    {packageReferenceXml}
  </code>
</pre>

  </TabItem>
</Tabs>

<br />

Alternatively, you can install the SDK via the NuGet user interface provided in your IDE.
Here is an example within Visual Studio:

<Image
    alt="Visual Studio NuGet Package Manager"
    src={NugetSearchImg}
/>

## Initialize the SDK

The SDK's initialization may vary depending on the context of your project.

The de facto initialization method is to create and [consume a SurrealDbClient created manually](/docs/sdk/dotnet/core/create-a-new-connection).
Most .NET projects provide a way to configure services using [Dependency Injection](/docs/sdk/dotnet/core/dependency-injection), which is the recommended way to use the SDK in your application.


================================================
FILE: src/content/doc-sdk-dotnet/start.mdx
================================================
---
sidebar_position: 3
sidebar_label: Quick start
title: .NET | SDK | Quick start
description: In this guide, we will walk you through setting up and querying your first project with the .NET SDK for SurrealDB.
---

# Quick start

Now that you have a more comprehensive understanding of the SurrealDB SDK for .NET, let's create a simple project to get you started.
This guide will walk you through creating a simple console application that uses the SurrealDB SDK for .NET to interact with a SurrealDB instance.

> [!IMPORTANT]
> If you want to see the final project for this guide, you can find it [here](https://github.com/surrealdb/surrealdb.net/tree/main/SurrealDb.Examples.Console) and follow the instructions in the `README.md` file to get the project running.

## Prerequisites

This guide assumes the following:
- You have a basic understanding of the .NET ecosystem and the C# language.
- You have an install version of SurrealDB `>1.4.2` installed on your machine.

## Setup your project

Let's start by creating a new console app.

```bash
# Create a new console app
dotnet new console -o SurrealDbExample

# Navigate into the generated directory
cd SurrealDbExample

# Add the SurrealDB SDK to your project via the dotnet CLI
dotnet add package SurrealDb.Net
```

Open <code>Program.cs</code> and replace everything in there with the following code to try out some basic operations using the SurrealDB SDK.

```csharp
using SurrealDb.Net;
using SurrealDb.Net.Models;
using SurrealDb.Net.Models.Auth;
using System.Text.Json;

const string TABLE = "person";

using var db = new SurrealDbClient("ws://127.0.0.1:8000/rpc");

await db.SignIn(new RootAuth { Username = "root", Password = "secret" });
await db.Use("test", "test");

var person = new Person
{
	Title = "Founder & CEO",
	Name = new() { FirstName = "Tobie", LastName = "Morgan Hitchcock" },
	Marketing = true
};
var created = await db.Create(TABLE, person);
Console.WriteLine(ToJsonString(created));

var updated = await db.Merge<ResponsibilityMerge, Person>(
	new() { Id = (TABLE, "jaime"), Marketing = true }
);
Console.WriteLine(ToJsonString(updated));

var people = await db.Select<Person>(TABLE);
Console.WriteLine(ToJsonString(people));

var queryResponse = await db.Query(
    $"SELECT Marketing, count() AS Count FROM type::table({TABLE}) GROUP BY Marketing"
);
var groups = queryResponse.GetValue<List<Group>>(0);
Console.WriteLine(ToJsonString(groups));

static string ToJsonString(object? o)
{
    return JsonSerializer.Serialize(o, new JsonSerializerOptions { WriteIndented = true, });
}

public class Person : Record
{
	public string? Title { get; set; }
	public Name? Name { get; set; }
	public bool Marketing { get; set; }
}
public class Name
{
	public string? FirstName { get; set; }
	public string? LastName { get; set; }
}
public class ResponsibilityMerge : Record
{
	public bool Marketing { get; set; }
}
public class Group
{
	public bool Marketing { get; set; }
	public int Count { get; set; }
}
```

Then make sure your SurrealDB server is running on <code>127.0.0.1:8000</code> and run your app from the command line with:

```bash
dotnet run
```

## Next steps

Now that you have learned the basics of the .NET SDK for SurrealDB, you can learn more about the SDK and its methods [in the methods section](/docs/sdk/dotnet/methods) and [data types section](/docs/sdk/dotnet/data-types).


================================================
FILE: src/content/doc-sdk-dotnet/core/authentication.mdx
================================================
---
sidebar_position: 2
sidebar_label: Handle authentication
title: Handle authentication | .NET | SDK | Concepts
description: In this section, we will walk you through the process of authenticating users and securing your SurrealDB database.
---

import Label from "@components/shared/Label.astro";
import Version from '@components/Version.astro';
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Handle authentication

Since SurrealDB is a database that is designed to be used in a distributed environment, it is important to secure the database and the data that is stored in it.
SurrealDB provides a number of methods for authenticating users and securing the database.

In your SurrealDB database, you can create authentication login using the [`DEFINE ACCESS`](/docs/surrealql/statements/define/access) statement which supports [JWT](/docs/surrealql/statements/define/access/jwt) and [Record](/docs/surrealql/statements/define/access/record) Access methods.

The access method used will inform the input for `Access` in the `.SignUp()` and `.SignIn()` methods.

> [!IMPORTANT]
> If you are not on Version <Version /> of SurrealDB, you will use the `Scope` property instead of `Access`.

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#signup"> <code> db.SignUp() </code></a></td>
			<td scope="row" data-label="Description">Connects to a local or remote database endpoint</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#signin"> <code> db.SignIn() </code></a></td>
            <td scope="row" data-label="Description">Signs in to a root, namespace, database or scope user</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#invalidate"> <code> db.Invalidate() </code></a></td>
            <td scope="row" data-label="Description">Invalidates the current session</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#authenticate"> <code> db.Authenticate() </code></a></td>
            <td scope="row" data-label="Description">Authenticates a user with a token</td>
        </tr>
	</tbody>
</table>

## Defining access in your application

The .NET SDK has a [`.Query()` method](/docs/sdk/dotnet/core/writing-surrealql) which allows you to write secure SurrealQL statements from within your application. Using this method, you can define access for your users and securely manage authentication. See the code example below:

<Tabs groupId="define-access">
  <TabItem value="V2" label="V2.x" >

```csharp
await db.Query(
    $"""
    DEFINE ACCESS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 15m, FOR SESSION 12h;
    """
);
```

  </TabItem>
  <TabItem value="V1" label="V1.x" >

```csharp
await db.Query(
    $"""
    DEFINE SCOPE user SESSION 24h
	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) );
    """
);
```

  </TabItem>
</Tabs>


> [!NOTE]
> Depending on the connection protocol you choose, authentication tokens and sessions lifetime work differently. Refer to the [connection options](/docs/sdk/dotnet/core/create-a-new-connection#connection-options) documentation for more information.

## User authentication

After you have defined your authentication login, you can use the following methods to authenticate users:

## `.SignUp()` {#signup}

Signs up to a specific authentication scope / access method.

```csharp title="Method Syntax"
await db.SignUp(credentials)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>credentials</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Credentials to sign up as a scoped user.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

<Tabs groupId="signup-example">
<TabItem value="V2" label="V2.x">

```csharp
// With Record Access
var authParams = new AuthParams
{
    Namespace = "test",
    Database = "test",
    Access = "user",
	// Also pass any properties required by the access definition
    Email = "info@surrealdb.com",
    Password = "123456"
};

Jwt jwt = await db.SignUp(authParams);

public class AuthParams : ScopeAuth
{
	public string? Username { get; set; }
	public string? Email { get; set; }
	public string? Password { get; set; }
}
```

</TabItem>
<TabItem value="V1" label="V1.x">

```csharp
// With Scopes
var authParams = new AuthParams
{
    Namespace = "test",
    Database = "test",
    Scope = "user",
	// Also pass any properties required by the scope definition
    Email = "info@surrealdb.com",
    Password = "123456"
};

Jwt jwt = await db.SignUp(authParams);

public class AuthParams : ScopeAuth
{
	public string? Username { get; set; }
	public string? Email { get; set; }
	public string? Password { get; set; }
}
```

</TabItem>
</Tabs>

<br />

## `.SignIn()` {#signin}

Signs in to a root, namespace, database or scope user.

```csharp title="Method Syntax"
await db.SignIn(credentials)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>credentials</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Variables used in a signin query.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

<Tabs groupId="signin-example">
<TabItem value="root" label="Root user">

```csharp
// Sign in as root user
await db.SignIn(new RootAuth { Username = "root", Password = "secret" });
```

</TabItem>

<TabItem value="namespace" label="Namespace user">

```csharp
// Sign in using namespace auth
await db.SignIn(
    new NamespaceAuth
    {
        Namespace = "test", 
        Username = "johndoe", 
        Password = "password123" 
    }
);
```

</TabItem>

<TabItem value="database" label="Database user">

```csharp
// Sign in using database auth
await db.SignIn(
    new DatabaseAuth
    {
        Namespace = "test", 
        Database = "test", 
        Username = "johndoe", 
        Password = "password123" 
    }
);
```

</TabItem>

<TabItem value="record" label="Record Access">

```csharp
// Sign in with Record Access
var authParams = new AuthParams
{
    Namespace = "test",
    Database = "test",
    Access = "user",
    Email = "info@surrealdb.com",
    Password = "123456"
};

Jwt jwt = await db.SignIn(authParams);

public class AuthParams : ScopeAuth
{
	public string? Username { get; set; }
	public string? Email { get; set; }
	public string? Password { get; set; }
}
```

</TabItem>

<TabItem value="scope" label="Scopes">

```csharp
// Sign in as a scoped user
var authParams = new AuthParams
{
    Namespace = "test",
    Database = "test",
    Scope = "user",
    Email = "info@surrealdb.com",
    Password = "123456"
};

Jwt jwt = await db.SignIn(authParams);

public class AuthParams : ScopeAuth
{
	public string? Username { get; set; }
	public string? Email { get; set; }
	public string? Password { get; set; }
}
```

</TabItem>
</Tabs>

<br />

## `.Authenticate()` {#authenticate}

Authenticates the current connection with a JWT token.

```csharp title="Method Syntax"
await db.Authenticate(jwt)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>jwt</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The JWT object holder of the authentication token.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
var jwt = new Jwt("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJTdXJyZWFsREIiLCJpYXQiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwiZXhwIjoxODM2NDM5MDIyLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJTQyI6InVzZXIiLCJJRCI6InVzZXI6dG9iaWUifQ.N22Gp9ze0rdR06McGj1G-h2vu6a6n9IVqUbMFJlOxxA");
await db.Authenticate(jwt);
```

<br />

## `.Invalidate()` {#invalidate}

Invalidates the authentication for the current connection.

```csharp title="Method Syntax"
await db.Invalidate()
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Properties</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Properties">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
await db.Invalidate();
```


================================================
FILE: src/content/doc-sdk-dotnet/core/connection-strings.mdx
================================================
---
sidebar_position: 7
sidebar_label: Connection Strings
title: Connection Strings | .NET | SDK | Concepts
description: The .NET SDK for SurrealDB supports the familiar concept of ConnectionString.
---

import Label from "@components/shared/Label.astro";

# Connection Strings

Connection Strings are an easy way to configure your application to connect to a SurrealDB instance.
They are stored in the <code>appsettings.json</code> file and can be used to configure the <code>SurrealDbClient</code>.

In general, it is known as a best practice to:
- set a development Connection String in <code>appsettings.Development.json</code>,
- store your production Connection String in a Secret environment variable, or even better in a Vault.

<table>
    <thead>
        <tr>
            <th scope="col">Keys</th>
            <th colspan="2" scope="col">Description</th>
            <th scope="col">Aliases</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Keys">
                <code>Endpoint</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database endpoint to connect to. <br />
                The disctinction between <code>Server</code> and <code>Client</code> can help you ensure you only call a distant database (server mode) or a local database (client mode).
            </td>
            <td scope="row" data-label="Aliases">
                <code>Server</code>
                <code>Client</code>
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Keys">
                <code>Namespace</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Switches to a specific namespace.
            </td>
            <td scope="row" data-label="Aliases">
                <code>NS</code>
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Keys">
                <code>Database</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Switches to a specific database.
            </td>
            <td scope="row" data-label="Aliases">
                <code>DB</code>
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Keys">
                <code>Username</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Username used to have root access.
            </td>
            <td scope="row" data-label="Aliases">
                <code>User</code>
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Keys">
                <code>Password</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Password used to have root access.
            </td>
            <td scope="row" data-label="Aliases">
                <code>Pass</code>
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Keys">
                <code>Token</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Token (JWT) used to have user access.
            </td>
            <td scope="row" data-label="Aliases"></td>
        </tr>
        <tr>
            <td scope="row" data-label="Keys">
                <code>NamingPolicy</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Naming policy used to interact with the database. <br />
                Valid options are <code>CamelCase</code>, <code>SnakeCaseLower</code>, <code>SnakeCaseUpper</code>, <code>KebabCaseLower</code> and <code>KebabCaseUpper</code>.
            </td>
            <td scope="row" data-label="Aliases"></td>
        </tr>
        <tr>
            <td scope="row" data-label="Keys">
               <code>AuthLevel</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Auth level when connecting to the SurrealDB instance. <br />
                Valid options are <code>Root</code>, <code>Namespace</code> or <code>Database</code>. <br />
                Defaults to <code>Root</code>.
            </td>
            <td scope="row" data-label="Aliases"></td>
        </tr>
    </tbody>
</table>

## Examples

Here is a couple of examples of Connection Strings:

```sh
Server=http://127.0.0.1:8000;Namespace=test;Database=test;Username=root;Password=root
```

```sh
Endpoint=http://127.0.0.1:8000;NS=test;DB=test;User=root;Pass=root
```

```sh
Endpoint=http://127.0.0.1:8000;NS=test;DB=test;User=root;Pass=root;NamingPolicy=SnakeCaseLower
```

```sh
Server=ws://127.0.0.1:8000;AuthLevel=Namespace;NS=test;DB=test;User=root;Pass=root
```

```sh
Client=mem://;Namespace=test;Database=test
```



================================================
FILE: src/content/doc-sdk-dotnet/core/create-a-new-connection.mdx
================================================
---
sidebar_position: 1
sidebar_label: Create a new connection 
title: Create a new connection | .NET | SDK | Concepts
description: The SurrealDB SDK for .NET enables simple and advanced querying of a remote or embedded database.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Create a new connection

After [installing the SDK](/docs/sdk/dotnet/installation), you can initialize a new instance of a SurrealDB client.
When creating a new connection to a SurrealDB instance, you can choose to connect to a local or remote endpoint.

```csharp
using SurrealDb.Net;

using var db = new SurrealDbClient("ws://127.0.0.1:8000/rpc");

await db.Connect();
await db.Use("test", "test");
```

From the code snippet above, you can see that the .NET SDK has a couple of methods that you can use to initialize a new project with SurrealDB. 

## `SurrealDbClient`

Creates a new client, detecting the right protocol from the provided endpoint.

```csharp title="Method Syntax"
new SurrealDbClient(endpoint)
```

### Connection options

You can specify your connection protocol either as `http`, `https`, `ws`, or `wss`.
Since SurrealDB also supports RPC over WebSocket, by default, it is specified with a `/rpc` suffix. 

<Tabs groupId="connection-options">
  <TabItem value="local" label="Local endpoint" default>

```csharp
// Creates a new client using a local endpoint
using var db = new SurrealDbClient("http://127.0.0.1:8000");
```

  </TabItem>
  <TabItem value="remote" label="Remote endpoint">

```csharp
// Creates a new client using a remote endpoint
using var db = new SurrealDbClient("wss://cloud.surrealdb.com/rpc");
```

  </TabItem>
  <TabItem value="ns-db" label="Namespace and database">

```csharp
var options = new SurrealDbOptions
{
    Endpoint = "wss://cloud.surrealdb.com/rpc",
    Namespace = "surrealdb",
    Database = "docs",
};

// Specify a namespace and database pair to use
using var db = new SurrealDbClient(options);
```

  </TabItem>
  <TabItem value="token" label="Token">

```csharp
var options = new SurrealDbOptions
{
    Endpoint = "wss://cloud.surrealdb.com/rpc",
    Token = "......",
};

// Authenticate with an existing token
using var db = new SurrealDbClient(options);
```

  </TabItem>
  <TabItem value="credentials" label="Credentials">

```csharp
var options = new SurrealDbOptions
{
    Endpoint = "wss://cloud.surrealdb.com/rpc",
    Username = "root",
    Password = "surrealdb",
};

// Authenticate using a pair of credentials
using var db = new SurrealDbClient(options);
```

  </TabItem>
</Tabs>

> [!NOTE]
> Having to manually set all these options into a `SurrealDbOptions` object can be cumbersome.
> If you are familiar with the concept of Connection Strings, you can simply pass a connection string to the `SurrealDbClient` constructor.
> See the [Connection Strings](/docs/sdk/dotnet/core/connection-strings) section for more information.

<br />

### Effect of connection protocol on token & session duration

The connection protocol you choose affects how authentication tokens and sessions work:

With websockets connections (`ws://`, `wss://`) you open a single long-lived stateful connection where after the initial authentication, the session duration applies and if not specified, defaults to `NONE` meaning that the session never expires unless otherwise specified. 

When you connect with a HTTP connection (`http://`, `https://`), every request you make is short-lived and stateless, requiring you to authenticate every request individually for which the token is used, creating a short lived session. Hence, the token duration which defaults to 1 hour applies.

You can extend the session duration of a token or a session by setting the `DURATION` clause when creating a new access method with the [`DEFINE ACCESS METHOD`](/docs/surrealql/statements/define/access) statement or when defining a new user with the [`DEFINE USER`](/docs/surrealql/statements/define/user) statement. 

Learn more about token and session duration in our [security best practices](/docs/surrealdb/reference-guide/security-best-practices#expiration) documentation.

<br />
## `.Connect()` {#connect}

The `.Connect()` executes a connection attempt to the underlying endpoint using the provided connection options.

> [!NOTE]
>This method is automatically called before executing any other call to the SurrealDB instance.
>It means that you do not have to explicitely call this method.
>Just note that in some contexts, calling this method before hand can improve performance by avoiding cold starts.

### Example usage

```csharp
await db.Connect();
```

<br />

## `.Use()` {#use}

Depending on the complexity of your use case, you can switch to a specific namespace and database using the `.Use()` method.
This is particularly useful if you want to switch to a different setup after connecting.

Learn more about the `.Use()` method [in the methods section](/docs/sdk/dotnet/methods/use).

### Example usage

```csharp
await db.Use("test", "test");
```



================================================
FILE: src/content/doc-sdk-dotnet/core/data-manipulation.mdx
================================================
---
sidebar_position: 4
sidebar_label: Data Manipulation
title: Data Manipulation | .NET | SDK | Concepts
description: SurrealDB supports a number of methods for interacting with the database and performing CRUD operations.
---

import Label from "@components/shared/Label.astro";

# Data Manipulation

SurrealDB supports a number of methods for interacting with the database and performing CRUD operations.

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#select"> <code> db.Select() </code></a></td>
			<td scope="row" data-label="Description">Selects all records in a table, or a specific record, from the database</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#create"> <code> db.Create() </code></a></td>
            <td scope="row" data-label="Description">Creates a record in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#insert"> <code> db.Insert() </code></a></td>
            <td scope="row" data-label="Description">Inserts one or multiple records in the database</td>
		</tr>
		<tr>
			<td scope="row" data-label="Method"><a href="#insert_relation"> <code> db.InsertRelation() </code></a></td>
			<td scope="row" data-label="Description">Inserts one or multiple relations in the database</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#update"> <code> db.Update() </code></a></td>
            <td scope="row" data-label="Description">Updates all records in a table, or a specific record, in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#upsert"> <code> db.Upsert() </code></a></td>
            <td scope="row" data-label="Description">Creates or updates a set of records in a table, or a specific record, in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#merge"> <code> db.Merge() </code></a></td>
            <td scope="row" data-label="Description">Modifies all records in a table, or a specific record, in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#patch"> <code> db.Patch() </code></a></td>
            <td scope="row" data-label="Description">Applies JSON Patch changes to all records, or a specific record, in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#delete"> <code> db.Delete() </code></a></td>
            <td scope="row" data-label="Description">Deletes all records in a table, or a specific record, from the database</td>
        </tr>
	</tbody>
</table>

## `.Select<T>()` {#select}

Selects all records in a table, or a specific record, from the database.

```csharp title="Method Syntax"
await db.Select<T>(resource)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to select.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
// Select all records from a table
var people = await db.Select<Person>("person");

// Select a specific record from a table
var person = await db.Select<Person>(("person", "h5wxrf2ewk8xjxosxtyc"));
var person = await db.Select<Person>(new StringRecordId("person:h5wxrf2ewk8xjxosxtyc"));

// Select a specific record from a table, given a non-string id
var person = await db.Select<Person>(("person", new Guid("8424486b-85b3-4448-ac8d-5d51083391c7")));
```

<br />

## `.Create<T>()` {#create}

Creates a record in the database.

```csharp title="Method Syntax"
await db.Create<T>(resource, data)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
// Create a record with a random ID
var person = await db.Create<Person>("person");

// Create a record with a random ID & specific fields
var person = await db.Create("person", new Person { Name = "Tobie" });

// Create a record with a specific ID
var personToCreate = new Person
{
    Id = ("person", "tobie"),
    Name = "Tobie",
    Settings = new Settings
    {
        Active = true,
        Marketing = true,
    },
};
var result = await db.Create(personToCreate);
```

<br />

## `.Insert<T>()` {#insert}

Inserts one or multiple records in the database.

```csharp title="Method Syntax"
await db.Insert<T>(table, data)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Optionally pass along a table to insert into.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Either a single document/record or an array of documents/records to insert
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
var posts = new List<Post>
{
    new Post
    {
        Id = ("post", "First"),
        Title = "An article",
        Content = "This is the first article"
    },
    new Post
    {
        Id = ("post", "Second"),
        Title = "An article",
        Content = "This is the second article"
    }
};

await db.Insert("post", posts);
```

<br />

## `.InsertRelation<T>()` {#insert_relation}

Inserts one or multiple relations in the database.

```csharp title="Method Syntax"
await db.InsertRelation<T>(table, data)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Optionally pass along a table to insert into.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Either a single document/record or an array of documents/records to insert
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
await db.InsertRelation(
    new WroteRelation
    {
        In = ("user", "u1"),
        Out = ("post", "p1"),
        CreatedAt = now,
        NumberOfPages = 144
    }
);
```

<br />

## `.Update<T>()` {#update}

Updates all records in a table, or a specific record, in the database.

```csharp title="Method Syntax"
await db.Update<T>(thing, data)
```

> [!NOTE]
> This function replaces the current document / record data with the specified data.

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to update.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to update.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
var post = new Post
{
    Id = ("post", "another"),
    Title = "A new article",
    Content = "This is a new article created using the .NET SDK"
};

// Updates a single record
await db.Update(post);

var data = new Person
{
    Name = "Tobie",
    Settings = new Settings
    {
        Active = true,
        Marketing = true,
    },
};

// Updates all records inside the "person" table
await db.Update("person", data);
```

<br />

## `.Upsert<T>()` {#upsert}

Creates or updates a specific record.

```csharp title="Method Syntax"
await db.Upsert<T>(data)
```

> [!NOTE]
> This function creates a new document / record or replaces the current one with the specified data.

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
var person = new Person
{
    Id = ("person", "tobie"), // Id is mandatory to apply create or update
    Name = "Tobie",
    Settings = new Settings
    {
        Active = true,
        Marketing = true,
    },
};

// Create a new record when it doesn't exist
var created = await db.Upsert(person);

// Update an existing record when it does exist
var updated = await db.Upsert(person);
```

<br />

## `.Merge<T>()` {#merge}

Modifies all records in a table, or a specific record.

```csharp title="Method Syntax"
await db.Merge<T>(resource, data)
```

> [!NOTE]
> This function merges the current document / record data with the specified data.

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to merge.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The data with which to modify the records.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp title="Merging data within a single record"
// Only changes the fields specified in the merge object
var merge = new PersonMerge
{
    Id = ("person", "tobie"),
    Settings = new Settings
    {
        Active = true,
        Marketing = false,
    },
};
var result = await db.Merge<PersonMerge, Person>(merge);

// Only changes the fields specified in the Dictionary
var data = new Dictionary<string, object>
{
    { "tags", new List<string> { "developer", "engineer" } }
};

var result = await db.Merge<Person>(("person", "tobie"), data);
```

```csharp title="Merging data for every record in a table"
// Only changes the fields specified in the merge object
var merge = new PersonMerge
{
    Settings = new Settings
    {
        Active = true,
        Marketing = false,
    },
};
var result = await db.Merge<PersonMerge, Person>("person", merge);

// Only changes the fields specified in the Dictionary
var data = new Dictionary<string, object>
{
    { "tags", new List<string> { "developer", "engineer" } }
};

var result = await db.Merge<Person>("person", data);
```

<br />

## `.Patch<T>()` {#patch}

Applies JSON Patch changes to all records, or a specific record, in the database.

```csharp title="Method Syntax"
await db.Patch<T>(resource, data)
```

> [!NOTE]
> This function patches document / record data with the specified <a href="https://jsonpatch.com/">JSON Patch</a> data.

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to patch.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The JSON Patch data with which to patch the records.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
// Update a record with a specific ID
var result = await db.Patch(("person", "tobie"), patches);

// Update all records in a table
var result = await db.Patch("person", patches);
```

<br />

## `.Delete()` {#delete}

Deletes all records in a table, or a specific record, from the database.

```csharp title="Method Syntax"
await db.Delete(resource)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to delete.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
// Delete all records from a table
await db.Delete("person");

// Delete a specific record from a table
await db.Delete(("person", "h5wxrf2ewk8xjxosxtyc"));
```


================================================
FILE: src/content/doc-sdk-dotnet/core/dependency-injection.mdx
================================================
---
sidebar_position: 8
sidebar_label: Dependency Injection
title: Dependency Injection | .NET | SDK | Concepts
description: The SurrealDB SDK for .NET also supports the concept of Dependency Injection pattern.
---

# Dependency Injection

The .NET SDK also support Dependency Injection to ease the use of the <code>SurrealDbClient</code> in your application.

## Create a new project

Let's start by creating a new ASP.NET Core web app.

```sh
dotnet new webapp -o SurrealDbWeatherApi
cd SurrealDbWeatherApi
dotnet add package SurrealDb.Net
```

## Define a Connection String

Open <code>appsettings.Development.json</code> and replace everything in there with the following code.
We have added a new Connection String called <code>SurrealDB</code> with the default configuration.

```bash
{
  "AllowedHosts": "*",
  "Logging": {
    "LogLevel": {
    "Default": "Information",
    "Microsoft.AspNetCore": "Warning"
    }
  },
  "ConnectionStrings": {
    "SurrealDB": "Server=http://127.0.0.1:8000;Namespace=test;Database=test;Username=root;Password=root"
  }
}
```

## Register services

Open <code>Program.cs</code> and replace everything in there with the following code.
This code is using the <code>AddSurreal()</code> extension method to inject services automatically.
Notice that all we have to do is one line of code to configure the SurrealDB client with the previously set Connection String.

> [!NOTE]
> By default, this function will register both <code>ISurrealDbClient</code> and <code>SurrealDbClient</code> using the <code>Singleton</code> service lifetime.


```csharp
var builder = WebApplication.CreateBuilder(args);

var services = builder.Services;
var configuration = builder.Configuration;

services.AddControllers();
services.AddEndpointsApiExplorer();
services.AddSwaggerGen();
services.AddSurreal(configuration.GetConnectionString("SurrealDB"));

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
	app.UseSwagger();
	app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthorization();

app.MapControllers();

app.Run();
```

> [!NOTE]
> In this example, we use a [Connection String](/docs/sdk/dotnet/core/connection-strings) to configure services.
> This is the most convenient way to initialize the <code>SurrealDbClient</code> in your application.
> You can always choose to construct a Connection String manually via a <code>SurrealDbOptionsBuilder</code> and pass it to the <code>AddSurreal()</code> method.

## Consume the SurrealDB client

Open <code>WeatherForecastController.cs</code> and replace everything in there with the following code.
Finally, we can inject the <code>ISurrealDbClient</code> inside our Controller.

```csharp
using Microsoft.AspNetCore.Mvc;

namespace SurrealDbWeatherApi.Controllers;

[ApiController]
[Route("[controller]")]
public class WeatherForecastController : ControllerBase
{
	private const string Table = "weatherForecast";

	private readonly ISurrealDbClient _surrealDbClient;

	public WeatherForecastController(ISurrealDbClient surrealDbClient)
	{
		_surrealDbClient = surrealDbClient;
	}

	[HttpGet]
	[Route("/")]
	public Task<List<WeatherForecast>> GetAll(CancellationToken cancellationToken)
	{
		return _surrealDbClient.Select<WeatherForecast>(Table, cancellationToken);
	}

	[HttpPost]
	[Route("/")]
	public Task<WeatherForecast> Create(CreateWeatherForecast data, CancellationToken cancellationToken)
	{
		var weatherForecast = new WeatherForecast
		{
			Date = data.Date,
			Country = data.Country,
			TemperatureC = data.TemperatureC,
			Summary = data.Summary
		};

		return _surrealDbClient.Create(Table, weatherForecast, cancellationToken);
	}

    // ...
	// Other methods omitted for brevity
}

public class CreateWeatherForecast
{
	public DateTime Date { get; set; }
	public string? Country { get; set; }
	public int TemperatureC { get; set; }
	public string? Summary { get; set; }
}
```

Then make sure your SurrealDB server is running on <code>127.0.0.1:8000</code> and run your app from the command line with:

```sh
dotnet run
```


================================================
FILE: src/content/doc-sdk-dotnet/core/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: SDK Concepts
title: .NET | SDK | Concepts
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

# Concepts 

In this section, we will go over the core concepts of the SurrealDB SDK for .NET. You will learn how to connect to a SurrealDB instance, manage authentication, and interact with the database.

- [Create a new Connection](/docs/sdk/dotnet/core/create-a-new-connection)
- [Handle authentication](/docs/sdk/dotnet/core/authentication)
- [Set parameters](/docs/sdk/dotnet/core/parameters)
- [Data manipulation](/docs/sdk/dotnet/core/data-manipulation)
- [Realtime Streaming](/docs/sdk/dotnet/core/streaming)
- [Run SurrealQL queries](/docs/sdk/dotnet/core/writing-surrealql)
- [Connection Strings](/docs/sdk/dotnet/core/connection-strings)
- [Dependency Injection](/docs/sdk/dotnet/core/dependency-injection)





================================================
FILE: src/content/doc-sdk-dotnet/core/parameters.mdx
================================================
---
sidebar_position: 3
sidebar_label: Set parameters 
title: Set parameters | .NET | SDK | Concepts
description: In this section, you will learn how to set parameters in the .NET SDK for SurrealDB.
---

import Label from "@components/shared/Label.astro";

# Set parameters

Within your application, you can define parameters that can be used to store and retrieve data from SurrealDB.
Parameters are used to store data in a structured format, and can be used to store data in a key-value pair format.

>[!IMPORTANT]
> Parameters allow you to define global (database-wide) parameters that are available to every client.

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#set"> <code> db.Set(key, value) </code></a></td>
			<td scope="row" data-label="Description">Assigns a value as a parameter for this connection</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#unset"> <code> db.Unset(key) </code></a></td>
            <td scope="row" data-label="Description">Removes a parameter for this connection</td>
        </tr>
	</tbody>
</table>

## `.Set()` {#set}

Assigns a value as a parameter for this connection.

```csharp title="Method Syntax"
await db.Set(key, val)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>value</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Assigns the value to the variable name.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
// Assign the variable on the connection
await db.Set("name", new Name { FirstName = "Tobie", LastName = "Morgan Hitchcock" });

// Use the variable in a subsequent query
await db.Query($"CREATE person SET name = $name");

// Use the variable in a subsequent query
await db.Query($"SELECT * FROM person WHERE name.first_name = $name.first_name");
```

<br />

## `.Unset()` {#unset}

Removes a parameter for this connection.

```csharp title="Method Syntax"
await db.Unset(key)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
await db.Unset("name");
```


================================================
FILE: src/content/doc-sdk-dotnet/core/streaming.mdx
================================================
---
sidebar_position: 5
sidebar_label: Realtime data streaming
title: Realtime data streaming | .NET | SDK | Concepts
description: The SurrealDB SDK for .NET allows you to create live queries that listen for changes in the database and automatically update your application when changes occur.
---

import Label from "@components/shared/Label.astro";

# Realtime data streaming

You can use the SurrealDB SDK to create live queries that listen for changes in the database and automatically update your application when changes occur.
This feature is useful for building real-time applications that need to respond to changes in the database.

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#listen-live"> <code> db.ListenLive(queryUuid) </code></a></td>
			<td scope="row" data-label="Description">Listen responses from an existing live query</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#live-query"> <code> db.LiveQuery(sql) </code></a></td>
            <td scope="row" data-label="Description">Initiate a live query from a SurrealQL statement</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#live-raw-query"> <code> db.LiveRawQuery(sql, params) </code></a></td>
			<td scope="row" data-label="Description">Initiate a live query from a SurrealQL statement, based on a raw SurrealQL query</td>
		</tr>
		<tr>
			<td scope="row" data-label="Method"><a href="#live-table"> <code> db.LiveTable(table, diff) </code></a></td>
			<td scope="row" data-label="Description">Initiate a live query from a table</td>
		</tr>
		<tr>
			<td scope="row" data-label="Method"><a href="#kill"> <code> db.Kill(queryUuid) </code></a></td>
			<td scope="row" data-label="Description">Kills a running live query by it's UUID</td>
		</tr>
	</tbody>
</table>

## `.ListenLive<T>()` {#listen-live}

Listen responses from an existing live query.

```csharp title="Method Syntax"
db.ListenLive<T>(queryUuid)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>queryUuid</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The UUID of the live query to consume.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
await using var liveQuery = db.ListenLive<Person>(queryUuid);

// Consume the live query...
```

You can then consume the live query using either an `IAsyncEnumerable` or an `Observable`.

#### Using an `IAsyncEnumerable`

:::note 
___NOTE:___ This will block the current thread until the query is killed.
:::

```csharp title="Option 1: Consume the live query via an IAsyncEnumerable"
await foreach (var response in liveQuery)
{
    // Either an Open, Create, Update, Delete or Close notification...

    if (response is SurrealDbLiveQueryOpenResponse)
    {
        // Do something...
    }
    if (response is SurrealDbLiveQueryCreateResponse<Person> create)
    {
        // Use the `Result` record
    }
    if (response is SurrealDbLiveQueryUpdateResponse<Person> update)
    {
        // Use the `Result` record
    }
    if (response is SurrealDbLiveQueryDeleteResponse<Person> delete)
    {
        // Use the `Result` record
    }
    if (response is SurrealDbLiveQueryCloseResponse)
    {
        // Do something...
    }
}
```

#### Using an `Observable`

```csharp title="Option 2: Consume the live query via an Observable"
liveQuery
    .ToObservable()
    .Subscribe((response) => 
    {
        // Either an Open, Create, Update, Delete or Close notification...

        if (response is SurrealDbLiveQueryOpenResponse)
        {
            // Do something...
        }
        if (response is SurrealDbLiveQueryCreateResponse<Person> create)
        {
            // Use the `Result` record
        }
        if (response is SurrealDbLiveQueryUpdateResponse<Person> update)
        {
            // Use the `Result` record
        }
        if (response is SurrealDbLiveQueryDeleteResponse<Person> delete)
        {
            // Use the `Result` record
        }
        if (response is SurrealDbLiveQueryCloseResponse)
        {
            // Do something...
        }
    });
```

You can also use the `OfType` operator to filter the responses.

```csharp
liveQuery
    .ToObservable()
    .OfType<SurrealDbLiveQueryCreateResponse<Person>>()
    .Select(response => response.Result)
    .Subscribe((record) => 
    {
        // Use the created record
    });
```

Note that this pattern is already simplified via methods available on the `SurrealDbLiveQuery` object.
You can learn more about these methods in the [LiveQuery methods](#surrealdblivequery-methods) section.

<br />

## `.LiveQuery<T>()` {#live-query}

Initiate a live query from a SurrealQL statement.

```csharp title="Method Syntax"
await db.LiveQuery<T>(sql)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
const string table = "person"; 
await using var liveQuery = await db.LiveQuery<Person>($"LIVE SELECT * FROM type::table({table});");

// Consume the live query...
```

### `SurrealDbLiveQuery` methods

The `SurrealDbLiveQuery` object provides the following methods:

#### `GetResults()` {#get-results}

Returns an enumerator that iterates asynchronously through the collection of results
(all actions `CREATE`, `UPDATE` and `DELETE`, except `OPEN` and `CLOSE`).

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
await using var liveQuery = await db.LiveRawQuery<Person>("LIVE SELECT * FROM person;");

// highlight-next-line
await foreach (var response in liveQuery.GetResults())
{
    // Either a Create, Update or Delete notification...

    if (response is SurrealDbLiveQueryCreateResponse<Person> create)
    {
        // Use the `Result` record
    }
    if (response is SurrealDbLiveQueryUpdateResponse<Person> update)
    {
        // Use the `Result` record
    }
    if (response is SurrealDbLiveQueryDeleteResponse<Person> delete)
    {
        // Use the `Result` record
    }
}
```

#### `GetCreatedRecords()` {#get-created-records}

Returns an enumerator that iterates asynchronously through the collection of created records.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
await using var liveQuery = await db.LiveRawQuery<Person>("LIVE SELECT * FROM person;");

// highlight-next-line
await foreach (var record in liveQuery.GetCreatedRecords())
{
    // Use the created record
}
```

#### `GetUpdatedRecords()` {#get-updated-records}

Returns an enumerator that iterates asynchronously through the collection of updated records.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
await using var liveQuery = await db.LiveRawQuery<Person>("LIVE SELECT * FROM person;");

// highlight-next-line
await foreach (var record in liveQuery.GetUpdatedRecords())
{
    // Use the updated record
}
```

#### `GetDeletedRecords()` {#get-deleted-records}

Returns an enumerator that iterates asynchronously through the collection of deleted records.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
await using var liveQuery = await db.LiveRawQuery<Person>("LIVE SELECT * FROM person;");

// highlight-next-line
await foreach (var record in liveQuery.GetDeletedRecords())
{
    // Use the deleted record
}
```

#### `KillAsync()` {#kill-async}

Kills the underlying live query.

```csharp title="Method Syntax"
await liveQuery.KillAsync(cancellationToken)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
var liveQuery = await db.LiveRawQuery<Person>("LIVE SELECT * FROM person;");

// Consume the live query...

// Manually kill the live query
// highlight-next-line
await liveQuery.KillAsync();
```

<br />

## `.LiveRawQuery<T>()` {#live-raw-query}

Initiate a live query from a SurrealQL statement, based on a raw SurrealQL query.

```csharp title="Method Syntax"
await db.LiveRawQuery<T>(sql, params)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>params</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```csharp
await using var liveQuery = await db.LiveRawQuery<Person>("LIVE SELECT * FROM person;");

// Consume the live query...
```

<br />

## `.LiveTable<T>()` {#live-table}

Initiate a live query from a table.

```csharp title="Method Syntax"
await db.LiveTable<T>(table, diff)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The table name to listen for changes for.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>diff</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                If set to true, live notifications will include an array of JSON Patch objects, rather than the entire record for each notification.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```csharp
await using var liveQuery = await db.LiveTable<Person>("person");

// Consume the live query...
```

<br />

## `.Kill()` {#kill}

Kills a running live query by it's UUID.

```csharp title="Method Syntax"
await db.Kill(queryUuid)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>queryUuid</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The UUID of the live query you wish to kill.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```csharp
await db.Kill(queryUuid);
```

<br />

## Live Actions

A live query event can be one of the following:

<table>
    <thead>
        <tr>
            <th colspan="1" scope="col">Action</th>
            <th colspan="1" scope="col">Result</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `OPEN`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                N/A
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when the live query is opened in the server.
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `CLOSE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `SocketClosed` or `QueryKilled`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when the live query is closed due to it either being killed or the connection being disconnected.
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `CREATE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `Result`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when a record within your subscription gets created
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `UPDATE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `Result`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when a record within your subscription gets updated
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `CREATE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `Result`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when a record within your subscription gets deleted
            </td>
        </tr>
    </tbody>
</table>


================================================
FILE: src/content/doc-sdk-dotnet/core/writing-surrealql.mdx
================================================
---
sidebar_position: 6
sidebar_label: Run SurrealQL queries
title: Run SurrealQL queries | .NET | SDK | Concepts
description: SurrealDB supports a number of methods for interacting with the database and performing CRUD operations.
---
import Label from "@components/shared/Label.astro";

# Run SurrealQL queries

The methods below are used to interact with the database and perform CRUD operations. You can also use the `query` method to run [SurrealQL statements](/docs/surrealql/statements) against the database.

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#query"> <code> db.Query() </code></a></td>
			<td scope="row" data-label="Description">Runs a set of SurrealQL statements against the database</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#raw_query"> <code> db.RawQuery() </code></a></td>
            <td scope="row" data-label="Description">Runs a set of SurrealQL statements against the database, based on a raw SurrealQL query</td>
        </tr>
	</tbody>
</table>

## `.Query()` {#query}

Runs a set of SurrealQL statements against the database.

```csharp title="Method Syntax"
await db.Query(sql)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
// Execute query with params
const string table = "person";
var result = await db.Query($"CREATE person; SELECT * FROM type::table({table});");

// Get the first result from the first query
var created = result.GetValue<Person>(0);

// Get all of the results from the second query
var people = result.GetValue<List<Person>>(1);
```

<br />

## `.RawQuery()` {#raw_query}

Runs a set of SurrealQL statements against the database, based on a raw SurrealQL query.

```csharp title="Method Syntax"
await db.RawQuery(sql, params)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>params</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
// Assign the variable on the connection
var @params = new Dictionary<string, object> { { "table", "person" } };
var result = await db.RawQuery("CREATE person; SELECT * FROM type::table($table);", @params);

// Get the first result from the first query
var created = result.GetValue<Person>(0);

// Get all of the results from the second query
var people = result.GetValue<List<Person>>(1);
```

<br />



================================================
FILE: src/content/doc-sdk-dotnet/methods/authenticate.mdx
================================================
---
sidebar_position: 1
sidebar_label: Authenticate
title: .NET | SDK | Methods | Authenticate
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Authenticate()` {#authenticate}

Authenticates the current connection with a JWT token.

```csharp title="Method Syntax"
await db.Authenticate(jwt)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>jwt</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The JWT object holder of the authentication token.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
Jwt jwt = new JWT("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJTdXJyZWFsREIiLCJpYXQiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwiZXhwIjoxODM2NDM5MDIyLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJTQyI6InVzZXIiLCJJRCI6InVzZXI6dG9iaWUifQ.N22Gp9ze0rdR06McGj1G-h2vu6a6n9IVqUbMFJlOxxA");
await db.Authenticate(jwt);
```

You can invalidate the authentication for the current connection using the [`Invalidate()` method](/docs/sdk/dotnet/methods/invalidate).



================================================
FILE: src/content/doc-sdk-dotnet/methods/connect.mdx
================================================
---
sidebar_position: 1
sidebar_label: Connect
title: .NET | SDK | Methods | Connect
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Connect()` {#connect}

Connects the client to the underlying endpoint, also improving performance to avoid cold starts.

```csharp title="Method Syntax"
await db.Connect()
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
await db.Connect();
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/create.mdx
================================================
---
sidebar_position: 1
sidebar_label: Create
title: .NET | SDK | Methods | Create
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Create<T>()` {#create}

Creates a record in the database.

```csharp title="Method Syntax"
await db.Create<T>(resource, data)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
// Create a record with a random ID
var person = await db.Create<Person>("person");

// Create a record with a random ID & specific fields
var person = await db.Create("person", new Person { Name = "Tobie" });

// Create a record with a specific ID
var personToCreate = new Person
{
    Id = ("person", "tobie"),
    Name = "Tobie",
    Settings = new Settings
    {
        Active = true,
        Marketing = true,
    },
};
var result = await db.Create(personToCreate);
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/delete.mdx
================================================
---
sidebar_position: 1
sidebar_label: Delete 
title: .NET | SDK | Methods | Delete
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Delete()` {#delete}


```csharp title="Method Syntax"
await db.Delete(resource)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to delete.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
// Delete all records from a table
await db.Delete("person");

// Delete a specific record from a table
await db.Delete(("person", "h5wxrf2ewk8xjxosxtyc"));
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/export.mdx
================================================
---
sidebar_position: 1
sidebar_label: Export
title: .NET | SDK | Methods | Export
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Export()`

Export the database as a SurrealQL script.
To use this method, you need to be connected to a SurrealDB instance that is version `>= 2.1.0`.

```csharp title="Method Syntax"
await db.Export(options)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>options</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Export configuration options.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp title="Only exporting db functions in a schema variable"
var options = new ExportOptions
{
    Users = false,
    Accesses = false,
    Params = false,
    Functions = true,
    Users = false,
    Versions = false,
    Tables = false,
    Records = false,
};

string schema = await db.Export(options);
```




================================================
FILE: src/content/doc-sdk-dotnet/methods/health.mdx
================================================
---
sidebar_position: 1
sidebar_label: Health
title: .NET | SDK | Methods | Health
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Health()` {#health}

Checks the status of the database server and storage engine.

```csharp title="Method Syntax"
await db.Health()
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
bool status = await db.Health();
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/import.mdx
================================================
---
sidebar_position: 1
sidebar_label: Import
title: .NET | SDK | Methods | Import
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Import()`

Imports data into a SurrealDB database.
To use this method, you need to be connected to a SurrealDB instance that is version `>= 2.0.0`.

```csharp title="Method Syntax"
await db.Import(string)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>input</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The SurrealQL script used to import data in the database.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
string input = 
        """
        DEFINE TABLE foo SCHEMALESS;
        DEFINE TABLE bar SCHEMALESS;
        CREATE foo:1 CONTENT { hello: "world" };
        CREATE bar:1 CONTENT { hello: "world" };
        DEFINE FUNCTION fn::foo() {
            RETURN "bar";
        };
        """;

await db.Import(input);
```




================================================
FILE: src/content/doc-sdk-dotnet/methods/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: SDK methods
title: .NET | SDK | Methods
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

# SDK methods

The .NET SDK for SurrealDB has a single SurrealDB class that provides methods for querying a remote SurrealDB database.
The class is designed to be simple to use and easy to understand for developers who are new to .NET or SurrealDB.
This page lists out the methods that are available in the SurrealDB class.

## Initialization methods

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/connect"> <code> db.Connect() </code></a></td>
			<td scope="row" data-label="Description">Connects the client to the underlying endpoint, also improving performance to avoid cold starts</td>
		</tr>
		<tr>
			<td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/use"> <code> db.Use(namespace, database)</code></a></td>
			<td scope="row" data-label="Description">Switch to a specific namespace and database</td>
		</tr>
		<tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/set"> <code>db.Set(key, value)</code></a></td>
            <td scope="row" data-label="Description">Assigns a value as a parameter for this connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/unset"> <code>db.Unset(key)</code></a></td>
            <td scope="row" data-label="Description">Removes a parameter for this connection</td>
        </tr>
	</tbody>
</table>

## Query methods

<table>
    <thead>
        <tr>
            <th scope="col">Method</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/query"> <code>db.Query&lt;T&gt;(sql)</code></a></td>
            <td scope="row" data-label="Description">Runs a set of [SurrealQL statements](/docs/surrealql) against the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/raw-query"> <code>db.RawQuery&lt;T&gt;(sql, vars)</code></a></td>
            <td scope="row" data-label="Description">Runs a set of [SurrealQL statements](/docs/surrealql) against the database, based on a raw SurrealQL query</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/select"> <code>db.Select&lt;T&gt;(thing)</code></a></td>
            <td scope="row" data-label="Description">Selects all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/core/streaming#live-query"> <code>db.LiveQuery&lt;T&gt;(sql)</code></a></td>
            <td scope="row" data-label="Description">Initiate a live query from a [SurrealQL statement](/docs/surrealql)</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/core/streaming#live-raw-query"> <code>db.LiveRawQuery&lt;T&gt;(sql)</code></a></td>
            <td scope="row" data-label="Description">Initiate a live query from a [SurrealQL statement](/docs/surrealql), based on a raw SurrealQL query</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/core/streaming#live-table"> <code>db.LiveTable&lt;T&gt;(table, diff)</code></a></td>
            <td scope="row" data-label="Description">Initiate a live query from a table</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/core/streaming#listen-live"> <code>db.ListenLive&lt;T&gt;(queryUuid)</code></a></td>
            <td scope="row" data-label="Description">Listen responses from an existing live query</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/core/streaming#kill"> <code>db.Kill(queryUuid)</code></a></td>
            <td scope="row" data-label="Description">Kill a running live query</td>
        </tr>
    </tbody>
</table>

## Mutation methods

<table>
    <thead>
        <tr>
            <th scope="col">Method</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/create"> <code>db.Create&lt;T&gt;(thing, data)</code></a></td>
            <td scope="row" data-label="Description">Creates a record in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/insert"> <code>db.Insert&lt;T&gt;(thing, data)</code></a></td>
            <td scope="row" data-label="Description">Inserts one or multiple records in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/update"> <code>db.Update&lt;T&gt;(thing, data)</code></a></td>
            <td scope="row" data-label="Description">Updates all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/upsert"> <code>db.Upsert&lt;T&gt;(thing, data)</code></a></td>
            <td scope="row" data-label="Description">Creates or updates a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/merge"> <code>db.Merge&lt;T&gt;(thing, data)</code></a></td>
            <td scope="row" data-label="Description">Modifies all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/patch"> <code>db.Patch&lt;T&gt;(thing, data)</code></a></td>
            <td scope="row" data-label="Description">Applies JSON Patch changes to all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/delete"> <code>db.Delete(thing)</code></a></td>
            <td scope="row" data-label="Description">Deletes all records, or a specific record</td>
        </tr>
    </tbody>
</table>

## Authentication methods

<table>
    <thead>
        <tr>
            <th scope="col">Method</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/signup"> <code>db.SignUp(credentials)</code></a></td>
            <td scope="row" data-label="Description">Signs this connection up to a specific authentication scope</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/signin"> <code>db.SignIn(credentials)</code></a></td>
            <td scope="row" data-label="Description">Signs this connection in to a specific authentication scope</td>
        </tr>
		<tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/invalidate"> <code>db.Invalidate()</code></a></td>
            <td scope="row" data-label="Description">Invalidates the authentication for the current connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/authenticate"> <code>db.Authenticate(token)</code></a></td>
            <td scope="row" data-label="Description">Authenticates the current connection with a JWT token</td>
        </tr>
		<tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/dotnet/methods/info"> <code>db.Info&lt;T&gt;()</code></a></td>
            <td scope="row" data-label="Description">Returns the record of an authenticated scope user</td>
        </tr>
    </tbody>
</table>


================================================
FILE: src/content/doc-sdk-dotnet/methods/info.mdx
================================================
---
sidebar_position: 1
sidebar_label: Info
title: .NET | SDK | Methods | Info
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Info<T>()`

This method returns the record of an authenticated scope user.

```csharp title="Method Syntax"
await db.Info<T>()
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Properties</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
var currentUser = await db.Info<User>();
```



================================================
FILE: src/content/doc-sdk-dotnet/methods/insert-relation.mdx
================================================
---
sidebar_position: 1
sidebar_label: InsertRelation
title: .NET | SDK | Methods | InsertRelation
description: The .NET SDK for SurrealDB enables you to insert a relation between two records.
---

import Label from "@components/shared/Label.astro";

# `.InsertRelation<T>()` {#insert_relation}

Inserts one or multiple relations in the database.

```csharp title="Method Syntax"
await db.InsertRelation<T>(table, data)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Optionally pass along a table to insert into.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Either a single document/record or an array of documents/records to insert
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
await db.InsertRelation(
    new WroteRelation
    {
        In = ("user", "u1"),
        Out = ("post", "p1"),
        CreatedAt = now,
        NumberOfPages = 144
    }
);
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/insert.mdx
================================================
---
sidebar_position: 1
sidebar_label: Insert
title: .NET | SDK | Methods | Insert
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Insert<T>()` {#insert}

Inserts one or multiple records in the database.

```csharp title="Method Syntax"
await db.Insert<T>(table, data)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Optionally pass along a table to insert into.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Either a single document/record or an array of documents/records to insert
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
var posts = new List<Post>
{
    new Post
    {
        Id = ("post", "First"),
        Title = "An article",
        Content = "This is the first article"
    },
    new Post
    {
        Id = ("post", "Second"),
        Title = "An article",
        Content = "This is the second article"
    }
};

await db.Insert("post", posts);
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/invalidate.mdx
================================================
---
sidebar_position: 1
sidebar_label: Invalidate
title: .NET | SDK | Methods | Invalidate
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Invalidate()` {#invalidate}

Invalidates the authentication for the current connection.

```csharp title="Method Syntax"
await db.Invalidate()
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Properties</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Properties">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
await db.Invalidate();
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/kill.mdx
================================================
---
sidebar_position: 1
sidebar_label: Kill
title: .NET | SDK | Methods | Kill
description: The .NET SDK for SurrealDB enables you to kill a running live query.
---

import Label from "@components/shared/Label.astro";

# `.Kill()` {#kill}

Kills a running live query by it's UUID.

```csharp title="Method Syntax"
await db.Kill(queryUuid)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>queryUuid</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The UUID of the live query you wish to kill.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
await db.Kill(queryUuid);
```



================================================
FILE: src/content/doc-sdk-dotnet/methods/listen_live.mdx
================================================
---
sidebar_position: 1
sidebar_label: ListenLive
title: .NET | SDK | Methods | ListenLive
description: The .NET SDK for SurrealDB enables you to listen for changes to records in a table.
---

import Label from "@components/shared/Label.astro";

# `.ListenLive<T>()` {#listen-live}

Listen responses from an existing live query.

```csharp title="Method Syntax"
db.ListenLive<T>(queryUuid)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>queryUuid</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The UUID of the live query to consume.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
await using var liveQuery = db.ListenLive<Person>(queryUuid);

// Consume the live query...
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/live-query.mdx
================================================
---
sidebar_position: 1
sidebar_label: LiveQuery
title: .NET | SDK | Methods | LiveQuery
description: The .NET SDK for SurrealDB enables you to listen for changes to records in a table.
---

import Label from "@components/shared/Label.astro";

# `.LiveQuery<T>()` {#live-query}

Initiate a live query from a SurrealQL statement.

```csharp title="Method Syntax"
await db.LiveQuery<T>(sql)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
const string table = "person"; 
await using var liveQuery = await db.LiveQuery<Person>($"LIVE SELECT * FROM type::table({table});");

// Consume the live query...
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/live-raw-query.mdx
================================================
---
sidebar_position: 1
sidebar_label: LiveRawQuery
title: .NET | SDK | Methods | LiveRawQuery
description: The .NET SDK for SurrealDB enables you to listen for changes to records in a table.
---

import Label from "@components/shared/Label.astro";

# `.LiveRawQuery<T>()` {#live-raw-query}

Initiate a live query from a SurrealQL statement, based on a raw SurrealQL query.

```csharp title="Method Syntax"
await db.LiveRawQuery<T>(sql, params)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>params</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```csharp
await using var liveQuery = await db.LiveRawQuery<Person>("LIVE SELECT * FROM person;");

// Consume the live query...
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/live-table.mdx
================================================
---
sidebar_position: 1
sidebar_label: LiveTable
title: .NET | SDK | Methods | LiveTable
description: The .NET SDK for SurrealDB enables you to listen for changes to records in a table.
---

import Label from "@components/shared/Label.astro";

# `.LiveTable<T>()` {#live-table}

Initiate a live query from a table.

```csharp title="Method Syntax"
await db.LiveTable<T>(table, diff)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The table name to listen for changes for.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>diff</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                If set to true, live notifications will include an array of JSON Patch objects, rather than the entire record for each notification.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```csharp
await using var liveQuery = await db.LiveTable<Person>("person");

// Consume the live query...
```



================================================
FILE: src/content/doc-sdk-dotnet/methods/merge.mdx
================================================
---
sidebar_position: 1
sidebar_label: Merge
title: .NET | SDK | Methods | Merge
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Merge<T>()` {#merge}

Modifies all records in a table, or a specific record.

```csharp title="Method Syntax"
await db.Merge<T>(resource, data)
```

> [!NOTE]
> This function merges the current document / record data with the specified data.

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to merge.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The data with which to modify the records.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp title="Merging data within a single record"
// Only changes the fields specified in the merge object
var merge = new PersonMerge
{
    Id = ("person", "tobie"),
    Settings = new Settings
    {
        Active = true,
        Marketing = false,
    },
};
var result = await db.Merge<PersonMerge, Person>(merge);

// Only changes the fields specified in the Dictionary
var data = new Dictionary<string, object>
{
    { "tags", new List<string> { "developer", "engineer" } }
};

var result = await db.Merge<Person>(("person", "tobie"), data);
```

```csharp title="Merging data for every record in a table"
// Only changes the fields specified in the merge object
var merge = new PersonMerge
{
    Settings = new Settings
    {
        Active = true,
        Marketing = false,
    },
};
var result = await db.Merge<PersonMerge, Person>("person", merge);

// Only changes the fields specified in the Dictionary
var data = new Dictionary<string, object>
{
    { "tags", new List<string> { "developer", "engineer" } }
};

var result = await db.Merge<Person>("person", data);
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/patch.mdx
================================================
---
sidebar_position: 1
sidebar_label: Patch
title: .NET | SDK | Methods | Patch
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Patch<T>()` {#patch}

Applies JSON Patch changes to all records, or a specific record, in the database.

```csharp title="Method Syntax"
await db.Patch<T>(resource, data)
```

> [!NOTE]
> This function patches document / record data with the specified <a href="https://jsonpatch.com/">JSON Patch</a> data.

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to patch.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The JSON Patch data with which to patch the records.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
// Update a record with a specific ID
var result = await db.Patch(("person", "tobie"), patches);

// Update all records in a table
var result = await db.Patch("person", patches);
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/query.mdx
================================================
---
sidebar_position: 1
sidebar_label: Query
title: .NET | SDK | Methods | Query
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Query()` {#query}

Runs a set of SurrealQL statements against the database.

```csharp title="Method Syntax"
await db.Query(sql)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
// Execute query with params
const string table = "person";
var result = await db.Query($"CREATE person; SELECT * FROM type::table({table});");

// Get the first result from the first query
var created = result.GetValue<Person>(0);

// Get all of the results from the second query
var people = result.GetValue<List<Person>>(1);
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/raw-query.mdx
================================================
---
sidebar_position: 1
sidebar_label: RawQuery
title: .NET | SDK | Methods | RawQuery
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.RawQuery()` {#query}

Runs a set of SurrealQL statements against the database, based on a raw SurrealQL query.

```csharp title="Method Syntax"
await db.RawQuery(sql, params)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>params</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
// Assign the variable on the connection
var @params = new Dictionary<string, object> { { "table", "person" } };
var result = await db.RawQuery("CREATE person; SELECT * FROM type::table($table);", @params);

// Get the first result from the first query
var created = result.GetValue<Person>(0);

// Get all of the results from the second query
var people = result.GetValue<List<Person>>(1);
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/relate.mdx
================================================
---
sidebar_position: 1
sidebar_label: Relate
title: .NET | SDK | Methods | Relate
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Relate()` {#relate}

Creates a relation between records.

```csharp title="Method Syntax"
await db.Relate(table, @in, @out, data)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>@in</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The edge of the relation.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>@out</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The other edge of the relation.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
var data = new WroteRelation { CreatedAt = DateTime.UtcNow, NumberOfPages = 14 };

await db.Relate<WroteRelation, WroteRelation>(
    "wrote",
    ("user", "one"),
    ("post", "one"),
    data
);
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/run.mdx
================================================
---
sidebar_position: 1
sidebar_label: Run
title: .NET | SDK | Methods | Run
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Run()` {#run}

Runs a [SurrealQL function](/docs/surrealql/functions/database).

```csharp title="Method Syntax"
await db.Run(name, version, args)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>name</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The name of the [SurrealQL function](/docs/surrealql/functions/database).
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>version</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The version of the [SurrealQL function](/docs/surrealql/functions/database).
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>args</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The arguments used by the [SurrealQL function](/docs/surrealql/functions/database).
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
DateTime now = await db.Run<DateTime>("time::now");

string result = await db.Run<string>("string::repeat", ["test", 3]);
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/select.mdx
================================================
---
sidebar_position: 1
sidebar_label: Select
title: .NET | SDK | Methods | Select
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Select<T>()` {#select}

Selects all records in a table, or a specific record, from the database.

```csharp title="Method Syntax"
await db.Select<T>(resource)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to select.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
// Select all records from a table
var people = await db.Select<Person>("person");

// Select a specific record from a table
var person = await db.Select<Person>(("person", "h5wxrf2ewk8xjxosxtyc"));
var person = await db.Select<Person>(new StringRecordId("person:h5wxrf2ewk8xjxosxtyc"));

// Select a specific record from a table, given a non-string id
var person = await db.Select<Person>(("person", new Guid("8424486b-85b3-4448-ac8d-5d51083391c7")));
```



================================================
FILE: src/content/doc-sdk-dotnet/methods/set.mdx
================================================
---
sidebar_position: 1
sidebar_label: Set
title: .NET | SDK | Methods | Set
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Set()` {#set}

Assigns a value as a parameter for this connection.

```csharp title="Method Syntax"
await db.Set(key, value)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>value</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Assigns the value to the variable name.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
// Assign the variable on the connection
await db.Set("name", new Name { FirstName = "Tobie", LastName = "Morgan Hitchcock" });

// Use the variable in a subsequent query
await db.Query($"CREATE person SET name = $name");

// Use the variable in a subsequent query
await db.Query($"SELECT * FROM person WHERE name.first_name = $name.first_name");
```

You can remove the variable from the connection using the [`Unset()` method](/docs/sdk/dotnet/methods/unset).



================================================
FILE: src/content/doc-sdk-dotnet/methods/signin.mdx
================================================
---
sidebar_position: 1
sidebar_label: SignIn
title: .NET | SDK | Methods | SignIn
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";
import Since from "@components/shared/Since.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# `.SignIn()` {#signin}

Signs in to a root, namespace, database or scope user.

```csharp title="Method Syntax"
await db.SignIn(credentials)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>credentials</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Variables used in a signin query.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

<Tabs groupId="signin-example">
<TabItem value="root" label="Root user">

```csharp
// Sign in as root user
await db.SignIn(new RootAuth { Username = "root", Password = "secret" });
```

</TabItem>

<TabItem value="namespace" label="Namespace user">

```csharp
// Sign in using namespace auth
await db.SignIn(
    new NamespaceAuth
    {
        Namespace = "test", 
        Username = "johndoe", 
        Password = "password123" 
    }
);
```

</TabItem>

<TabItem value="database" label="Database user">

```csharp
// Sign in using database auth
await db.SignIn(
    new DatabaseAuth
    {
        Namespace = "test", 
        Database = "test", 
        Username = "johndoe", 
        Password = "password123" 
    }
);
```

</TabItem>

<TabItem value="record" label="Record Access">

```csharp
// Sign in with Record Access
var authParams = new AuthParams
{
    Namespace = "test",
    Database = "test",
    Access = "user",
    Email = "info@surrealdb.com",
    Password = "123456"
};

Jwt jwt = await db.SignIn(authParams);

public class AuthParams : ScopeAuth
{
	public string? Username { get; set; }
	public string? Email { get; set; }
	public string? Password { get; set; }
}
```

</TabItem>

<TabItem value="scope" label="Scopes">

```csharp
// Sign in as a scoped user
var authParams = new AuthParams
{
    Namespace = "test",
    Database = "test",
    Scope = "user",
    Email = "info@surrealdb.com",
    Password = "123456"
};

Jwt jwt = await db.SignIn(authParams);

public class AuthParams : ScopeAuth
{
	public string? Username { get; set; }
	public string? Email { get; set; }
	public string? Password { get; set; }
}
```

</TabItem>
</Tabs>

You can invalidate the authentication for the current connection using the [`Invalidate()` method](/docs/sdk/dotnet/methods/invalidate).



================================================
FILE: src/content/doc-sdk-dotnet/methods/signup.mdx
================================================
---
sidebar_position: 1
sidebar_label: SignUp
title: .NET | SDK | Methods | SignUp
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";
import Since from "@components/shared/Since.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# `.SignUp()` {#signup}

Signs up to a specific authentication scope / access method.

```csharp title="Method Syntax"
await db.SignUp(credentials)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>credentials</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Credentials to sign up as a scoped user.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

<Tabs groupId="signup-example">
<TabItem value="V2" label="V2.x">

```csharp
// With Record Access
var authParams = new AuthParams
{
    Namespace = "test",
    Database = "test",
    Access = "user",
	// Also pass any properties required by the access definition
    Email = "info@surrealdb.com",
    Password = "123456"
};

Jwt jwt = await db.SignUp(authParams);

public class AuthParams : ScopeAuth
{
	public string? Username { get; set; }
	public string? Email { get; set; }
	public string? Password { get; set; }
}
```

</TabItem>
<TabItem value="V1" label="V1.x">

```csharp
// With Scopes
var authParams = new AuthParams
{
    Namespace = "test",
    Database = "test",
    Scope = "user",
	// Also pass any properties required by the scope definition
    Email = "info@surrealdb.com",
    Password = "123456"
};

Jwt jwt = await db.SignUp(authParams);

public class AuthParams : ScopeAuth
{
	public string? Username { get; set; }
	public string? Email { get; set; }
	public string? Password { get; set; }
}
```

</TabItem>
</Tabs>

You can invalidate the authentication for the current connection using the [`Invalidate()` method](/docs/sdk/dotnet/methods/invalidate).



================================================
FILE: src/content/doc-sdk-dotnet/methods/unset.mdx
================================================
---
sidebar_position: 1
sidebar_label: Unset
title: .NET | SDK | Methods | Unset
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Unset()` {#unset}

Removes a parameter for this connection.

```csharp title="Method Syntax"
await db.Unset(key)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
await db.Unset("name");
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/update.mdx
================================================
---
sidebar_position: 1
sidebar_label: Update
title: .NET | SDK | Methods | Update
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Update<T>()` {#update}

Updates all records in a table, or a specific record, in the database.

```csharp title="Method Syntax"
await db.Update<T>(thing, data)
```

> [!NOTE]
> This function replaces the current document / record data with the specified data.

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to update.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to update.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
var post = new Post
{
    Id = ("post", "another"),
    Title = "A new article",
    Content = "This is a new article created using the .NET SDK"
};

// Updates a single record
await db.Update(post);

var data = new Person
{
    Name = "Tobie",
    Settings = new Settings
    {
        Active = true,
        Marketing = true,
    },
};

// Updates all records inside the "person" table
await db.Update("person", data);
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/upsert.mdx
================================================
---
sidebar_position: 1
sidebar_label: Upsert
title: .NET | SDK | Methods | Upsert
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Upsert<T>()` {#upsert}

Creates or updates a specific record.

```csharp title="Method Syntax"
await db.Upsert<T>(data)
```

> [!NOTE]
> This function creates a new document / record or replaces the current one with the specified data.

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
var person = new Person
{
    Id = ("person", "tobie"), // Id is mandatory to apply create or update
    Name = "Tobie",
    Settings = new Settings
    {
        Active = true,
        Marketing = true,
    },
};

// Create a new record when it doesn't exist
var created = await db.Upsert(person);

// Update an existing record when it does exist
var updated = await db.Upsert(person);
```


================================================
FILE: src/content/doc-sdk-dotnet/methods/use.mdx
================================================
---
sidebar_position: 1
sidebar_label: Use
title: .NET | SDK | Methods | Use
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Use()` {#use}

Switch to a specific namespace and database.

```csharp title="Method Syntax"
await db.Use(ns, db)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>namespace</code>
                <Label label="initially required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Switches to a specific namespace.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>database</code>
                <Label label="initially required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Switches to a specific database.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
await db.Use("test", "test");
```



================================================
FILE: src/content/doc-sdk-dotnet/methods/version.mdx
================================================
---
sidebar_position: 1
sidebar_label: Version
title: .NET | SDK | Methods | Version
description: The .NET SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Version()` {#version}

Retrieves the version of the SurrealDB instance.

```csharp title="Method Syntax"
await db.Version()
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```csharp
string version = await db.Version(); // Will return "surrealdb-1.1.1"
```


================================================
FILE: src/content/doc-sdk-golang/connection-engines.mdx
================================================
---
sidebar_position: 5
sidebar_label: Connection Engines
title: Golang Connection Engines | SDKs | Integration
description: In this guide, we will walk you through setting up and querying your first project with the Golang SDK for SurrealDB.
---

# Connection Engines

There are two different connection engines you can use to connect to SurrealDb backend. You can do so via Websocket or through HTTP
connections

### Via Websocket
```go
db, err := surrealdb.New("ws://localhost:8000")
```
or for a secure connection
```go
db, err := surrealdb.New("wss://localhost:8000")
```

### Via HTTP
There are some functions that are not available on RPC when using HTTP but on Websocket. All these except
the "live" endpoint are effectively implemented in the HTTP library and provides the same result as though
it is natively available on HTTP. While using the HTTP connection engine, note that live queries will still
use a websocket connection if the backend supports it
```go
db, err := surrealdb.New("http://localhost:8000")
```
or for a secure connection
```go
db, err := surrealdb.New("https://localhost:8000")
```

### Effect of connection engine on token & session duration

The connection engine you choose affects how authentication tokens and sessions work:

With websockets connections (`ws://`, `wss://`) you open a single long-lived stateful connection where after the initial authentication, the session duration applies and if not specified, defaults to `NONE` meaning that the session never expires unless otherwise specified. 

When you connect with a HTTP connection (`http://`, `https://`), every request you make is short-lived and stateless, requiring you to authenticate every request individually for which the token is used, creating a short lived session. Hence, the token duration which defaults to 1 hour applies.

You can extend the session duration of a token or a session by setting the `DURATION` clause when creating a new access method with the [`DEFINE ACCESS METHOD`](/docs/surrealql/statements/define/access) statement or when defining a new user with the [`DEFINE USER`](/docs/surrealql/statements/define/user) statement. 

Learn more about token and session duration in our [security best practices](/docs/surrealdb/reference-guide/security-best-practices#expiration) documentation.

### Example of a secure connection

```go

package main

import (
	"os"

	surrealdb "github.com/surrealdb/surrealdb.go"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)

const (
	defaultURL = "ws://localhost:8000"
)

var currentURL = os.Getenv("SURREALDB_URL")

func getSurrealDBURL() string {
	if currentURL == "" {
		return defaultURL
	}
	return currentURL
}

func newSurrealDBConnection(namespace, database string, tables ...string) *surrealdb.DB {
	db, err := surrealdb.New(getSurrealDBURL())
	if err != nil {
		panic(err)
	}

	if err = db.Use(namespace, database); err != nil {
		panic(err)
	}

	authData := &surrealdb.Auth{
		Username: "root",
		Password: "root",
	}
	token, err := db.SignIn(authData)
	if err != nil {
		panic(err)
	}

	if err = db.Authenticate(token); err != nil {
		panic(err)
	}


	return db
}
```


================================================
FILE: src/content/doc-sdk-golang/data-types.mdx
================================================
---
sidebar_position: 4
sidebar_label: Data Types
title: Golang Data Types | SDKs | Integration
description: The Golang SDK translates all datatypes native to SurrealQL into either datatypes native to Golang, or a custom implementation. This document describes all datatypes, and links to their respective documentation.
---

import Table from "@components/shared/Table.astro";

# Data Types

This SDK facilitates communication between client and the backend service using the Concise Binary Object Representation (CBOR) format. It streamlines data serialization and deserialization while ensuring efficient and lightweight communication. The library also provides custom models tailored to specific Data models recognised by SurrealDb, which cannot be covered by idiomatic Go, enabling seamless interaction between the client and the backend.

## Data Types overview

<table><thead>
  <tr>
    <th>CBOR Type</th>
    <th>Go Representation</th>
    <th>Example</th>
  </tr></thead>
<tbody>
  <tr>
    <td>Null</td>
    <td>`nil`</td>
    <td>`var x interface{} = nil`</td>
  </tr>
  <tr>
    <td>None</td>
    <td>`surrealdb.None`</td>
    <td>`map[string]interface{}{"customer": surrealdb.None}`</td>
  </tr>
  <tr>
    <td>Boolean</td>
    <td>`bool`</td>
    <td>`true`, `false`</td>
  </tr>
  <tr>
    <td>Array</td>
    <td>`[]interface{}`</td>
    <td>`[]MyStruct{item1, item2}`</td>
  </tr>
  <tr>
    <td>Date/Time</td>
    <td>`time.Time`</td>
    <td>`time.Now()`</td>
  </tr>
  <tr>
    <td>Duration</td>
    <td>`time.Duration`</td>
    <td>`time.Duration(8821356)`</td>
  </tr>
  <tr>
    <td>UUID (string representation)</td>
    <td>`surrealdb.UUID(string)`</td>
    <td>`surrealdb.UUID("123e4567-e89b-12d3-a456-426614174000")`</td>
  </tr>
  <tr>
    <td>UUID (binary representation)</td>
    <td>`surrealdb.UUIDBin([]bytes)`</td>
    <td>`surrealdb.UUIDBin([]byte{0x01, 0x02, ...}`)`</td>
  </tr>
  <tr>
    <td>Integer</td>
    <td>`uint`, `uint64`,  `int`, `int64`</td>
    <td>`42`, `uint64(100000)`,  `-42`, `int64(-100000)`</td>
  </tr>
  <tr>
    <td>Floating Point</td>
    <td>`float32`, `float64`</td>
    <td>`3.14`, `float64(2.71828)`</td>
  </tr>
  <tr>
    <td>Byte String, Binary Encoded Data</td>
    <td>`[]byte`</td>
    <td>`[]byte{0x01, 0x02}`</td>
  </tr>
  <tr>
    <td>Text String</td>
    <td>`string`</td>
    <td>`"Hello, World!"`</td>
  </tr>
  <tr>
    <td>Map</td>
    <td>`map[interface{}]interface{}`</td>
    <td>`map[string]float64{"one": 1.0}`</td>
  </tr>
  <tr>
    <td>Table name</td>
    <td>`surrealdb.Table(name)`</td>
    <td>`surrealdb.Table("users")`</td>
  </tr>
  <tr>
    <td>Record ID</td>
    <td>`surrealdb.RecordID{Table: string, ID: interface{}}`</td>
    <td>`surrealdb.RecordID{Table: "customers", ID: 1}, surrealdb.NewRecordID("customers", 1)`</td>
  </tr>
  <tr>
    <td>Geometry Point</td>
    <td>`surrealdb.GeometryPoint{Latitude: float64, Longitude: float64}`</td>
    <td>`surrealdb.GeometryPoint{Latitude: 11.11, Longitude: 22.22`</td>
  </tr>
  <tr>
    <td>Geometry Line</td>
    <td>`surrealdb.GeometryLine{GeometricPoint1, GeometricPoint2,... }`</td>
  </tr>
  <tr>
    <td>Geometry Polygon</td>
    <td>`surrealdb.GeometryPolygon{GeometryLine1, GeometryLine2,... }`</td>
  </tr>
  <tr>
    <td>Geometry Multipoint</td>
    <td>`surrealdb.GeometryMultiPoint{GeometryPoint1, GeometryPoint2,... }`</td>
  </tr>
  <tr>
    <td>Geometry MultiLine</td>
    <td>`surrealdb.GeometryMultiLine{GeometryLine1, GeometryLine2,... }`</td>
  </tr>
  <tr>
    <td>Geometry MultiPolygon</td>
    <td>`surrealdb.GeometryMultiPolygon{GeometryPolygon1, GeometryPolygon2,... }`</td>
  </tr>
  <tr>
    <td>Geometry Collection</td>
    <td>`surrealdb.GeometryMultiPolygon{GeometryPolygon1, GeometryLine2, GeometryPoint3, GeometryMultiPoint4,... }`</td>
  </tr>
</tbody></table>

<br /><br />

## Encoding

The SDK uses CBOR for all client-server serialization. It does not use `encoding/json`, and `MarshalJSON` is not part of the serialization path.

- **fxamacker/cbor-based implementation**: see [`pkg/models/cbor.go`](https://github.com/surrealdb/surrealdb.go/blob/main/pkg/models/cbor.go)
- **surrealcbor implementation**: see [`surrealcbor/`](https://github.com/surrealdb/surrealdb.go/tree/main/surrealcbor)

Both implementations are supported; choose the one that fits your needs/performance characteristics.



================================================
FILE: src/content/doc-sdk-golang/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Overview
title: Golang SDKs | Integration
description: The SurrealDB SDK for Golang enables simple and advanced querying of a remote or embedded database.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/golang.png";
import DarkLogo from "@img/icon/dark/golang.png";
import Version from "@components/Version.astro";

<div class="flag-title">
	<Image
		alt="React"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Golang SDK
</div>

The SurrealDB SDK for Golang is the primary SDK for interacting with SurrealDB from server-side applications, systems, and APIs. You can use the Golang SDK to interact with your SurrealDB database instances, or to run SurrealDB as an embedded database within your Golang application, with functionality for executing queries, managing data, running database functions, authenticating to the database, building user signup and authentication functionality, and subscribing to data changes with live queries.

To contribute to the SDK code, submit an Issue or Pull Request in the [surrealdb.go](https://github.com/surrealdb/surrealdb.go) repository. To contribute to this documentation, submit an Issue or Pull Request in the [docs.surrealdb.com](https://github.com/surrealdb/docs.surrealdb.com) repository.

The SDK requires Golang version `1.18` or greater, is available as a [go.dev package](https://pkg.go.dev/github.com/surrealdb/surrealdb.go), and works seamlessly with SurrealDB versions `>v2.0.0`, ensuring compatibility with the latest version.

## Sources

- [GitHub repository](https://github.com/surrealdb/surrealdb.go)
- [go.dev package](https://pkg.go.dev/github.com/surrealdb/surrealdb.go)



================================================
FILE: src/content/doc-sdk-golang/installation.mdx
================================================
---
sidebar_position: 2
sidebar_label: Installation
title: Golang | SDKs | Installation
description: In this section, you will learn how to install the Golang SDK in your project.
---

# Installation

In this section, you will learn how to install the Golang SDK in your project.

### Install the SDK

First, install the [SDK from pkg.go.dev](https://pkg.go.dev/github.com/surrealdb/surrealdb.go) using the `go get` command:

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

<Tabs groupId="golang-package-manager">
  <TabItem value="golang-cli" label="go get" default>

```bash
go get github.com/surrealdb/surrealdb.go
  ```

  </TabItem>
</Tabs>

<br />

### Import the SDK to your project

After installing, you can then import the SDK into your project. 

```go
import (
	"fmt"
	surrealdb "github.com/surrealdb/surrealdb.go"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)
```

## Next Steps

After installing the SDK, check out the quick start guide to build your a simple application with the SDK. You can also learn more about carrying out common tasks with the SDK in the following sections:
- [Quick Start](/docs/sdk/golang/start)



================================================
FILE: src/content/doc-sdk-golang/start.mdx
================================================
---
sidebar_position: 3
sidebar_label: Quick start
title: Golang | SDK | Quick start
description: In this guide, we will walk you through setting up and querying your first project with the Golang SDK for SurrealDB.
---

# Quick start

Now that you have a more comprehensive understanding of the SurrealDB SDK for Golang, let's create a simple project to get you started.

This guide will walk you through connecting and authenticating to a SurrealDB server, set the namespace and database, and make several data manipulation requests.

## Prerequisites

This guide assumes the following:
- You have a basic understanding of the Go ecosystem and the Go language.
- You have an install version of SurrealDB `>1.4.2` installed on your machine.

## Setup your project

Create a new `main.go` file and add the following code to try out some basic operations using the SurrealDB SDK.

```go
package main

import (
	"encoding/json"
	"fmt"
	surrealdb "github.com/surrealdb/surrealdb.go"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)

type Person struct {
	ID      	*models.RecordID `json:"id,omitempty"`
	Name    	string `json:"name"`
	Surname 	string `json:"surname"`
	Location 	models.GeometryPoint `json:"location"`
}

func main() {
	// Connect to SurrealDB
	db, err := surrealdb.New("ws://localhost:8000")
	if err != nil {
		panic(err)
	}

	// Set the namespace and database
	if err = db.Use("testNS", "testDB"); err != nil {
		panic(err)
	}

	// Sign in to authentication `db`
	authData := &surrealdb.Auth{
		Username: "root", // use your setup username
		Password: "secret", // use your setup password
	}
	token, err := db.SignIn(authData)
	if err != nil {
		panic(err)
	}

	// Check token validity. This is not necessary if you called `SignIn` before. This authenticates the `db` instance too if sign in was
	// not previously called
	if err := db.Authenticate(token); err != nil {
		panic(err)
	}

	// And we can later on invalidate the token if desired
	defer func(token string) {
		if err := db.Invalidate(); err != nil {
			panic(err)
		}
	}(token)

	// Create an entry
	person1, err := surrealdb.Create[Person](db, models.Table("persons"), map[interface{}]interface{}{
		"Name":     "John",
		"Surname":  "Doe",
		"Location": models.NewGeometryPoint(-0.11, 22.00),
	})
	if err != nil {
		panic(err)
	}
	fmt.Printf("Created person with a map: %+v\n", person1)

	// Or use structs
	person2, err := surrealdb.Create[Person](db, models.Table("persons"), Person{
		Name:     "John",
		Surname:  "Doe",
		Location: models.NewGeometryPoint(-0.11, 22.00),
	})
	if err != nil {
		panic(err)
	}
	fmt.Printf("Created person with a struct: %+v\n", person2)

	// Get entry by Record ID
	person, err := surrealdb.Select[Person, models.RecordID](db, *person1.ID)
	if err != nil {
		panic(err)
	}
	fmt.Printf("Selected a person by record id: %+v\n", person)

	// Or retrieve the entire table
	persons, err := surrealdb.Select[[]Person, models.Table](db, models.Table("persons"))
	if err != nil {
		panic(err)
	}
	fmt.Printf("Selected all in persons table: %+v\n", persons)

	// Delete an entry by ID
	if _, err = surrealdb.Delete[Person](db, *person2.ID); err != nil {
		panic(err)
	}

	// Delete all entries
	if _, err = surrealdb.Delete[[]Person](db, models.Table("persons")); err != nil {
		panic(err)
	}

	// Confirm empty table
	persons, err = surrealdb.Select[[]Person](db, models.Table("persons"))
	if err != nil {
		panic(err)
	}
	fmt.Printf("No Selected person: %+v\n", persons)
}
```

### Run the example

- Run `go mod init github.com/<github-username>/<project-name>` to initialise a go.mod file
- Run `go mod tidy` to download the `surrealdb.go` dependency
- Run `go run main.go` to run the example.

## Next steps

Now that you have learned the basics of the Golang SDK for SurrealDB, you can learn more about the SDK and its methods [in the methods section](/docs/sdk/golang/methods) and [data types section](/docs/sdk/golang/data-types).



================================================
FILE: src/content/doc-sdk-golang/core/handling-authentication.mdx
================================================
---
sidebar_position: 2
sidebar_label: Handle authentication
title: Golang | SDK | Handle authentication
description: SurrealDB supports a number of methods for authenticating users and securing the database.
---

import Label from "@components/shared/Label.astro";
import Since from "@components/shared/Since.astro";
import Version from '@components/Version.astro';
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Handle authentication

Since SurrealDB is a database that is designed to be used in a distributed environment, it is important to secure the database and the data that is stored in it. SurrealDB provides a number of methods for authenticating users and securing the database.

In your SurrealDB database, you can create authentication login using the [`DEFINE ACCESS`](/docs/surrealql/statements/define/access) statement which supports [JWT](/docs/surrealql/statements/define/access/jwt) and [Record](/docs/surrealql/statements/define/access/record) Access methods.

The access method used will inform the input for `access` in the `.SignUp()` and `.SignIn()` methods.

> [!IMPORTANT]
> If you are not on Version <Version /> of SurrealDB, you will use the `scope` property instead of `access`. 

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/signup"> <code> db.SignUp() </code></a></td>
			<td scope="row" data-label="Description">Connects to a local or remote database endpoint</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/signin"> <code> db.SignIn() </code></a></td>
            <td scope="row" data-label="Description">Signs in to a root, namespace, database or scope user</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/invalidate"> <code> db.Invalidate() </code></a></td>
            <td scope="row" data-label="Description">Invalidates the current session</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/authenticate"> <code> db.Authenticate() </code></a></td>
            <td scope="row" data-label="Description">Authenticates a user with a token</td>
        </tr>
	</tbody>
</table>

## Defining access in your application

The Golang SDK has a [`.Query()` method](/docs/sdk/golang/methods/query) which allows you to write secure SurrealQL statements from within your application. Using this method, you can define access for your users and securely manage authentication. See the code example below:

<Tabs groupId="define-access">
<TabItem value="V2" label="V2.x" >
```go
package main

import (
	"context"
	"fmt"

	surrealdb "github.com/surrealdb/surrealdb.go"
	"github.com/surrealdb/surrealdb.go/contrib/testenv"
)

//nolint:funlen
func ExampleDB_record_user_auth_struct() {
	ns := "surrealdbexamples"
	db := testenv.MustNew(ns, "record_auth_demo", "user")

	setupQuery := `
		-- Define the user table with schema
		DEFINE TABLE user SCHEMAFULL
			PERMISSIONS
				FOR select, update, delete WHERE id = $auth.id;

		-- Define fields
		DEFINE FIELD name ON user TYPE string;
		DEFINE FIELD password ON user TYPE string;

		-- Define unique index on email
		REMOVE INDEX IF EXISTS name ON user;
		DEFINE INDEX name ON user FIELDS name UNIQUE;

		-- Define access method for record authentication
		REMOVE ACCESS IF EXISTS user ON DATABASE;
		DEFINE ACCESS user ON DATABASE TYPE RECORD
			SIGNIN (
				SELECT * FROM user WHERE name = $user AND crypto::argon2::compare(password, $pass)
			)
			SIGNUP (
				CREATE user CONTENT {
					name: $user,
					password: crypto::argon2::generate($pass)
				}
			);
	`

	if _, err := surrealdb.Query[any](context.Background(), db, setupQuery, nil); err != nil {
		panic(err)
	}

	fmt.Println("Database schema setup complete")

	// Refer to the next example, `ExampleDB_record_user_custom_struct`,
	// when you need to use fields other than `user` and `pass` in the query specified for SIGNUP.
	_, err := db.SignUp(context.Background(), &surrealdb.Auth{
		Namespace: ns,
		Database:  "record_auth_demo",
		Access:    "user",
		Username:  "yusuke",
		Password:  "VerySecurePassword123!",
	})
	if err != nil {
		panic(err)
	}
	fmt.Println("User signed up successfully")

	// Refer to the next example, `ExampleDB_record_user_custom_struct`,
	// when you need to use fields other than `user` and `pass` in the query specified for SIGNIN.
	//
	// For example, you might want to use `email` and `password` instead of `user` and `pass`.
	// In that case, you need to something that encodes to a cbor map containing those keys.
	_, err = db.SignIn(context.Background(), &surrealdb.Auth{
		Namespace: ns,
		Database:  "record_auth_demo",
		Access:    "user",
		Username:  "yusuke",
		Password:  "VerySecurePassword123!",
	})
	if err != nil {
		panic(err)
	}
	fmt.Println("User signed in successfully")

	info, err := db.Info(context.Background())
	if err != nil {
		panic(err)
	}
	fmt.Printf("Authenticated user name: %v\n", info["name"])

	// Output:
	// Database schema setup complete
	// User signed up successfully
	// User signed in successfully
	// Authenticated user name: yusuke
}

func ExampleDB_record_user_custom_struct() {
	ns := "surrealdbexamples"
	db := testenv.MustNew(ns, "record_user_custom", "user")

	setupQuery := `
		-- Define the user table with schema
		DEFINE TABLE user SCHEMAFULL
			PERMISSIONS
				FOR select, update, delete WHERE id = $auth.id;

		-- Define fields
		DEFINE FIELD name ON user TYPE string;
		DEFINE FIELD email ON user TYPE string;
		DEFINE FIELD password ON user TYPE string;

		-- Define unique index on email
		REMOVE INDEX IF EXISTS email ON user;
		DEFINE INDEX email ON user FIELDS email UNIQUE;

		-- Define access method for record authentication
		REMOVE ACCESS IF EXISTS user ON DATABASE;
		DEFINE ACCESS user ON DATABASE TYPE RECORD
			SIGNIN (
				SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(password, $password)
			)
			SIGNUP (
				CREATE user CONTENT {
					name: $name,
					email: $email,
					password: crypto::argon2::generate($password)
				}
			);
	`

	if _, err := surrealdb.Query[any](context.Background(), db, setupQuery, nil); err != nil {
		panic(err)
	}

	fmt.Println("Database schema setup complete")

	type User struct {
		Namespace string `json:"NS"`
		Database  string `json:"DB"`
		Access    string `json:"AC"`
		Name      string `json:"name"`
		Password  string `json:"password"`
		Email     string `json:"email"`
	}

	type LoginRequest struct {
		Namespace string `json:"NS"`
		Database  string `json:"DB"`
		Access    string `json:"AC"`
		Email     string `json:"email"`
		Password  string `json:"password"`
	}

	_, err := db.SignUp(context.Background(), &User{
		// Corresponds to the SurrealDB namespace
		Namespace: ns,
		// Corresponds to the SurrealDB database
		Database: "record_user_custom",
		// Corresponds to `user` in `DEFINE ACCESS USER ON ...`
		Access: "user",
		// Corresponds to the $name in the SIGNUP query and `name` in `DEFINE FIELD name ON user`
		Name: "yusuke",
		// Corresponds to the $password in the SIGNUP query and `password` in `DEFINE FIELD password ON user`
		Password: "VerySecurePassword123!",
		// Corresponds to the $email in the SIGNUP query and `email` in `DEFINE FIELD email ON user`
		Email: "yusuke@example.com",
	})
	if err != nil {
		panic(err)
	}
	fmt.Println("User signed up successfully")

	_, err = db.SignIn(context.Background(), &LoginRequest{
		Namespace: ns,
		Database:  "record_user_custom",
		Access:    "user",
		// Corresponds to the $email in the SIGNIN query and `email` in `DEFINE FIELD email ON user`
		Email: "yusuke@example.com",
		// Corresponds to the $password in the SIGNIN query and `password` in `DEFINE FIELD password ON user`
		Password: "VerySecurePassword123!",
	})
	if err != nil {
		panic(err)
	}
	fmt.Println("User signed in successfully")

	info, err := db.Info(context.Background())
	if err != nil {
		panic(err)
	}
	fmt.Printf("Authenticated user name: %v\n", info["name"])

	// Output:
	// Database schema setup complete
	// User signed up successfully
	// User signed in successfully
	// Authenticated user name: yusuke
}
```
</TabItem>
<TabItem value="V1" label="V1.x" >

```go
...
-- Define scope method for record authentication
		REMOVE SCOPE IF EXISTS user ON DATABASE;
		DEFINE SCOPE user ON DATABASE TYPE RECORD
			SIGNIN (
				SELECT * FROM user WHERE name = $user AND crypto::argon2::compare(password, $pass)
			)
			SIGNUP (
				CREATE user CONTENT {
					name: $user,
					password: crypto::argon2::generate($pass)
				}
			);
...
```
</TabItem>
</Tabs>

{/* > [!NOTE]
> Depending on the connection protocol you choose, authentication tokens and sessions lifetime work differently. Refer to the [connection options](/docs/sdk/golang/core/create-a-new-connection#connection-options) documentation for more information. */}


## Learn more

Learn more about authentication in SurrealDB in our [security best practices](/docs/surrealdb/reference-guide/security-best-practices#authentication) documentation and in the [security](/docs/surrealdb/security/authentication#expiration) section of the SurrealDB documentation.  


================================================
FILE: src/content/doc-sdk-golang/core/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: SDK Concepts
title: Golang SDK Concepts | SDKs | Integration
description: The SurrealDB SDK for Golang enables simple and advanced querying of a remote or embedded database.
---

# Concepts 

In this section, we will go over the core concepts of the SurrealDB SDK for Golang. You will learn how to connect to a SurrealDB instance, manage authentication, and interact with the database.

- [Handle authentication](/docs/sdk/golang/core/handling-authentication)




================================================
FILE: src/content/doc-sdk-golang/methods/authenticate.mdx
================================================
---
sidebar_position: 1
sidebar_label: Authenticate
title: Golang | SDK | Methods | Authenticate
description: The Golang SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Authenticate()` {#authenticate}

Authenticates the current connection with a JWT token.

```go title="Method Syntax"
db.Authenticate(token)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>token</code>
                <Label label="required" />
            </td>
            <td colspan="2">
                The JWT authentication token.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```go
db.Authenticate("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJTdXJyZWFsREIiLCJpYXQiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwiZXhwIjoxODM2NDM5MDIyLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJTQyI6InVzZXIiLCJJRCI6InVzZXI6dG9iaWUifQ.N22Gp9ze0rdR06McGj1G-h2vu6a6n9IVqUbMFJlOxxA");
```

```go
// Check token validity. This is not necessary if you called `SignIn` before. This authenticates the `db` instance too if sign in was
	// not previously called
	if err := db.Authenticate(token); err != nil {
		panic(err)
	}
```

You can invalidate the authentication for the current connection using the [`Invalidate()` method](/docs/sdk/golang/methods/invalidate).



================================================
FILE: src/content/doc-sdk-golang/methods/create.mdx
================================================
---
sidebar_position: 1
sidebar_label: Create
title: Golang | SDK | Methods | Create
description: The create method creates a record in the database.
---

import Label from "@components/shared/Label.astro";

# `.Create[T](table, data)` {#create}

Creates a record in the database.

```go title="Method Syntax"
db.Create[T](table, data)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
package main

import (
	"fmt"
	"time"

	surrealdb "github.com/surrealdb/surrealdb.go"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)

//nolint:funlen
func ExampleCreate() {
	
	db, err := surrealdb.New("ws://localhost:8000")
	if err != nil {
		panic(err)
	}
	if err = db.Use("test", "test"); err != nil { // set your namespace/database
		panic(err)
	}
	token, err := db.SignIn(&surrealdb.Auth{ // replace with your auth
		Username: "root",
		Password: "root",
	})
	if err != nil {
		panic(err)
	}
	if err = db.Authenticate(token); err != nil {
		panic(err)
	}

	type Person struct {
		Name string `json:"name"`
		// Note that you must use CustomDateTime instead of time.Time.
		CreatedAt models.CustomDateTime  `json:"created_at,omitempty"`
		UpdatedAt *models.CustomDateTime `json:"updated_at,omitempty"`
	}

	createdAt, err := time.Parse(time.RFC3339, "2023-10-01T12:00:00Z")
	if err != nil {
		panic(err)
	}

	// Unlike Insert which returns a pointer to the array of inserted records,
	// Create returns a pointer to the record itself.
	var inserted *Person
	inserted, err = surrealdb.Create[Person](
		db,
		"persons",
		map[string]any{
			"name":       "First",
			"created_at": createdAt,
		})
	if err != nil {
		panic(err)
	}
	fmt.Printf("Create result: %+s\n", *inserted)

	// You can throw away the result if you don't need it,
	// by specifying an empty struct as the type parameter.
	_, err = surrealdb.Create[struct{}](
		db,
		"persons",
		map[string]any{
			"name":       "Second",
			"created_at": createdAt,
		},
	)
	if err != nil {
		panic(err)
	}

	// You can also create a record by passing a struct directly.
	_, err = surrealdb.Create[struct{}](
		db,
		"persons",
		Person{
			Name: "Third",
			CreatedAt: models.CustomDateTime{
				Time: createdAt,
			},
		},
	)
	if err != nil {
		panic(err)
	}

	// You can also receive the result as a map[string]any.
	// It should be handy when you don't want to define a struct type,
	// in other words, when the schema is not known upfront.
	var fourthAsMap *map[string]any
	fourthAsMap, err = surrealdb.Create[map[string]any](
		db,
		"persons",
		map[string]any{
			"name": "Fourth",
			"created_at": models.CustomDateTime{
				Time: createdAt,
			},
		},
	)
	if err != nil {
		panic(err)
	}
	if _, ok := (*fourthAsMap)["id"].(models.RecordID); ok {
		delete((*fourthAsMap), "id")
	}
	fmt.Printf("Create result: %+s\n", *fourthAsMap)

	selected, err := surrealdb.Select[[]Person](
		db,
		"persons",
	)
	if err != nil {
		panic(err)
	}
	for _, person := range *selected {
		fmt.Printf("Selected person: %+s\n", person)
	}

	//nolint:lll
	// Unordered output:
	// Create result: {First {2023-10-01 12:00:00 +0000 UTC} <nil>}
	// Create result: map[created_at:{2023-10-01 12:00:00 +0000 UTC} name:Fourth]
	// Selected person: {First {2023-10-01 12:00:00 +0000 UTC} <nil>}
	// Selected person: {Second {2023-10-01 12:00:00 +0000 UTC} <nil>}
	// Selected person: {Third {2023-10-01 12:00:00 +0000 UTC} <nil>}
	// Selected person: {Fourth {2023-10-01 12:00:00 +0000 UTC} <nil>}
}
```


================================================
FILE: src/content/doc-sdk-golang/methods/delete.mdx
================================================
---
sidebar_position: 1
sidebar_label: Delete
title: Golang | SDK | Methods | Delete
description: The Delete method deletes all records, or a specific record, in the database.
---

import Label from "@components/shared/Label.astro";

# `.Delete()` {#delete}


```go title="Method Syntax"
db.Delete[T any, R any](resource)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to delete.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
	// Delete an entry by ID
	if err = surrealdb.Delete[models.RecordID](db, *person2.ID); err != nil {
		panic(err)
	}

	// Delete all entries
	if err = surrealdb.Delete[models.Table](db, models.Table("persons")); err != nil {
		panic(err)
	}
```



================================================
FILE: src/content/doc-sdk-golang/methods/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: SDK methods
title: Golang SDK methods | SDKs | Integration
description: The Golang SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

# SDK methods

The Golang SDK for SurrealDB has a single SurrealDB class that provides methods for querying a remote SurrealDB database.

The class is designed to be simple to use and easy to understand for developers who are new to Golang or SurrealDB.

This page lists out the methods that are available in the SurrealDB class.

## Initialization methods

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/new"> <code> db.New() </code></a></td>
			<td scope="row" data-label="Description">Connects the client to the underlying endpoint, also improving performance to avoid cold starts</td>
		</tr>
		<tr>
			<td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/use"> <code> db.Use(namespace, database)</code></a></td>
			<td scope="row" data-label="Description">Switch to a specific namespace and database</td>
		</tr>
		<tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/let"> <code>db.Let(key, value)</code></a></td>
            <td scope="row" data-label="Description">Assigns a value as a parameter for this connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/unset"> <code>db.Unset(key)</code></a></td>
            <td scope="row" data-label="Description">Removes a parameter for this connection</td>
        </tr>
	</tbody>
</table>

## Query methods

<table>
    <thead>
        <tr>
            <th scope="col">Method</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/query"> <code>db.Query&#91;T&#93;(sql string, vars ...interface{})</code></a></td>
            <td scope="row" data-label="Description">Runs a set of [SurrealQL statements](/docs/surrealql) against the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/raw-query"> <code>db.RawQuery&#91;T&#93;(sql, vars)</code></a></td>
            <td scope="row" data-label="Description">Runs a set of [SurrealQL statements](/docs/surrealql) against the database, based on a raw SurrealQL query</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/select"> <code>db.Select&#91;T,R&#93;(resource)</code></a></td>
            <td scope="row" data-label="Description">Selects all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/live"> <code>db.Live&#91;T&#93;(table, diff)</code></a></td>
            <td scope="row" data-label="Description">Initiate a live query from a [SurrealQL statement](/docs/surrealql)</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/live-notification"> <code>db.LiveNotifications&#91;T&#93;(queryUuid)</code></a></td>
            <td scope="row" data-label="Description"> Get notifications from a live query </td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/kill"> <code>db.Kill(queryUuid)</code></a></td>
            <td scope="row" data-label="Description">Kill a running live query</td>
        </tr>
    </tbody>
</table>

## Mutation methods

<table>
    <thead>
        <tr>
            <th scope="col">Method</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/create"> <code>db.Create&#91;T&#93;(table, data)</code></a></td>
            <td scope="row" data-label="Description">Creates a record in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/insert"> <code>db.Insert&#91;T&#93;(table, data)</code></a></td>
            <td scope="row" data-label="Description">Inserts one or multiple records in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/insert-relation"> <code>db.InsertRelation&#91;T&#93;(table, data)</code></a></td>
            <td scope="row" data-label="Description">Inserts one or multiple records in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/update"> <code>db.Update&#91;T&#93;(table, data)</code></a></td>
            <td scope="row" data-label="Description">Updates all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/upsert"> <code>db.Upsert&#91;T&#93;(table, data)</code></a></td>
            <td scope="row" data-label="Description">Creates or updates a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/merge"> <code>db.Merge&#91;T&#93;(what, data)</code></a></td>
            <td scope="row" data-label="Description">Modifies all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/patch"> <code>db.Patch&#91;T&#93;(table, data)</code></a></td>
            <td scope="row" data-label="Description">Applies JSON Patch changes to all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/delete"> <code>db.Delete(data)</code></a></td>
            <td scope="row" data-label="Description">Deletes all records, or a specific record</td>
        </tr>
    </tbody>
</table>

## Authentication methods

<table>
    <thead>
        <tr>
            <th scope="col">Method</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/signup"> <code>db.SignUp(credentials)</code></a></td>
            <td scope="row" data-label="Description">Signs this connection up to a specific authentication scope</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/signin"> <code>db.SignIn(credentials)</code></a></td>
            <td scope="row" data-label="Description">Signs this connection in to a specific authentication scope</td>
        </tr>
		<tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/invalidate"> <code>db.Invalidate()</code></a></td>
            <td scope="row" data-label="Description">Invalidates the authentication for the current connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/authenticate"> <code>db.Authenticate(token)</code></a></td>
            <td scope="row" data-label="Description">Authenticates the current connection with a JWT token</td>
        </tr>
		<tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/golang/methods/info"> <code>db.Info&#91;T&#93;()</code></a></td>
            <td scope="row" data-label="Description">Returns the record of an authenticated scope user</td>
        </tr>
    </tbody>
</table>


================================================
FILE: src/content/doc-sdk-golang/methods/info.mdx
================================================
---
sidebar_position: 1
sidebar_label: Info
title: Golang | SDK | Methods | Info
description: The Golang SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Info<T>()`

This method returns the record of an authenticated scope user.

```go title="Method Syntax"
db.Info<T>()
```

### Example usage

```go
var currentUser = db.Info<User>();
```



================================================
FILE: src/content/doc-sdk-golang/methods/insert-relation.mdx
================================================
---
sidebar_position: 1
sidebar_label: InsertRelation
title: Golang | SDK | Methods | InsertRelation
description: The InsertRelation method inserts a relation between two records.
---

import Label from "@components/shared/Label.astro";

# .InsertRelation[T](table, data)

Inserts one or multiple relations in the database.

```go title="Method Syntax"
db.InsertRelation[T](table, data)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Optionally pass along a table to insert into.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Either a single document/record or an array of documents/records to insert
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
package main

import (
	"fmt"
	"time"

	surrealdb "github.com/surrealdb/surrealdb.go"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)

//nolint:funlen
func ExampleInsertRelation() {
	
	db, err := surrealdb.New("ws://localhost:8000")
	if err != nil {
		panic(err)
	}
	if err = db.Use("test", "test"); err != nil { // set your namespace/database
		panic(err)
	}
	token, err := db.SignIn(&surrealdb.Auth{ // replace with your auth
		Username: "root",
		Password: "root",
	})
	if err != nil {
		panic(err)
	}
	if err = db.Authenticate(token); err != nil {
		panic(err)
	}

	type Person struct {
		ID models.RecordID `json:"id,omitempty"`
	}

	type Follow struct {
		In    *models.RecordID      `json:"in,omitempty"`
		Out   *models.RecordID      `json:"out,omitempty"`
		Since models.CustomDateTime `json:"since"`
	}

	first, err := surrealdb.Create[Person](
		db,
		"person",
		map[string]any{
			"id": models.NewRecordID("person", "first"),
		})
	if err != nil {
		panic(err)
	}

	second, err := surrealdb.Create[Person](
		db,
		"person",
		map[string]any{
			"id": models.NewRecordID("person", "second"),
		})
	if err != nil {
		panic(err)
	}

	since, err := time.Parse(time.RFC3339, "2023-10-01T12:00:00Z")
	if err != nil {
		panic(err)
	}

	persons, err := surrealdb.Query[[]Person](
		db,
		"SELECT * FROM person ORDER BY id.id",
		nil,
	)
	if err != nil {
		panic(err)
	}
	for _, person := range (*persons)[0].Result {
		fmt.Printf("Person: %+v\n", person)
	}

	if relateErr := surrealdb.InsertRelation(
		db,
		&surrealdb.Relationship{
			ID:       &models.RecordID{Table: "follow", ID: "first_second"},
			In:       first.ID,
			Out:      second.ID,
			Relation: "follow",
			Data: map[string]any{
				"since": models.CustomDateTime{
					Time: since,
				},
			},
		},
	); relateErr != nil {
		panic(relateErr)
	}

	//nolint:lll
	/// Here's an alternative way to insert a relation using a query.
	//
	// if res, err := surrealdb.Query[any](
	// 	db,
	// 	"INSERT RELATION INTO follow $content",
	// 	map[string]any{
	// 		"content": map[string]any{
	// 			"id":    "first_second",
	// 			"in":    first.ID,
	// 			"out":   second.ID,
	// 			"since": models.CustomDateTime{Time: since},
	// 		},
	// 	},
	// ); err != nil {
	// 	panic(err)
	// } else {
	// 	fmt.Printf("Relation: %+v\n", (*res)[0].Result)
	// }
	// The output will be:
	// Relation: [map[id:{Table:follow ID:first_second} in:{Table:person ID:first} out:{Table:person ID:second} since:{Time:2023-10-01 12:00:00 +0000 UTC}]]

	type PersonWithFollows struct {
		Person
		Follows []models.RecordID `json:"follows,omitempty"`
	}
	selected, err := surrealdb.Query[[]PersonWithFollows](
		db,
		"SELECT id, name, ->follow->person AS follows FROM $id",
		map[string]any{
			"id": first.ID,
		},
	)
	if err != nil {
		panic(err)
	}

	for _, person := range (*selected)[0].Result {
		fmt.Printf("PersonWithFollows: %+v\n", person)
	}

	// Note we can select the relationships themselves because
	// RELATE creates a record in the relation table.
	follows, err := surrealdb.Query[[]Follow](
		db,
		"SELECT * from follow",
		nil,
	)
	if err != nil {
		panic(err)
	}

	for _, follow := range (*follows)[0].Result {
		fmt.Printf("Follow: %+v\n", follow)
	}

	//nolint:lll
	// Output:
	// Person: {ID:{Table:person ID:first}}
	// Person: {ID:{Table:person ID:second}}
	// PersonWithFollows: {Person:{ID:{Table:person ID:first}} Follows:[{Table:person ID:second}]}
	// Follow: {In:person:first Out:person:second Since:{Time:2023-10-01 12:00:00 +0000 UTC}}
}
```



================================================
FILE: src/content/doc-sdk-golang/methods/insert.mdx
================================================
---
sidebar_position: 1
sidebar_label: Insert
title: Golang | SDK | Methods | Insert
description: The Insert method inserts one or multiple records in the database.
---

import Label from "@components/shared/Label.astro";

# `.Insert[T](table, data)` {#insert}

Inserts one or multiple records in the database.

```go title="Method Syntax"
db.Insert[T](table, data)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Optionally pass along a table to insert into.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Either a single document/record or an array of documents/records to insert
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
// Insert an entry

package main

import (
	"fmt"
	"time"

	surrealdb "github.com/surrealdb/surrealdb.go"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)

//nolint:funlen
func ExampleInsert() {
	
	db, err := surrealdb.New("ws://localhost:8000")
	if err != nil {
		panic(err)
	}
	if err = db.Use("test", "test"); err != nil { // set your namespace/database
		panic(err)
	}
	token, err := db.SignIn(&surrealdb.Auth{ // replace with your auth
		Username: "root",
		Password: "root",
	})
	if err != nil {
		panic(err)
	}
	if err = db.Authenticate(token); err != nil {
		panic(err)
	}

	type Person struct {
		Name string `json:"name"`
		// Note that you must use CustomDateTime instead of time.Time.
		CreatedAt models.CustomDateTime  `json:"created_at,omitempty"`
		UpdatedAt *models.CustomDateTime `json:"updated_at,omitempty"`
	}

	createdAt, err := time.Parse(time.RFC3339, "2023-10-01T12:00:00Z")
	if err != nil {
		panic(err)
	}

		// Unlike Create which returns a pointer to the record itself,
	// Insert returns a pointer to the array of inserted records.
	var inserted *[]Person
	inserted, err = surrealdb.Insert[Person](
		db,
		"persons",
		map[string]any{
			"name":       "First",
			"created_at": createdAt,
		})
	if err != nil {
		panic(err)
	}
	fmt.Printf("Insert result: %+s\n", *inserted)

	_, err = surrealdb.Insert[struct{}](
		db,
		"persons",
		map[string]any{
			"name":       "Second",
			"created_at": createdAt,
		},
	)
	if err != nil {
		panic(err)
	}

	_, err = surrealdb.Insert[struct{}](
		db,
		"persons",
		Person{
			Name: "Third",
			CreatedAt: models.CustomDateTime{
				Time: createdAt,
			},
		},
	)
	if err != nil {
		panic(err)
	}

	fourthAsMap, err := surrealdb.Insert[map[string]any](
		db,
		"persons",
		Person{
			Name: "Fourth",
			CreatedAt: models.CustomDateTime{
				Time: createdAt,
			},
		},
	)
	if err != nil {
		panic(err)
	}
	if _, ok := (*fourthAsMap)[0]["id"].(models.RecordID); ok {
		delete((*fourthAsMap)[0], "id")
	}
	fmt.Printf("Insert result: %+s\n", *fourthAsMap)

	selected, err := surrealdb.Select[[]Person](
		db,
		"persons",
	)
	if err != nil {
		panic(err)
	}
	for _, person := range *selected {
		fmt.Printf("Selected person: %+s\n", person)
	}

	//nolint:lll
	// Unordered output:
	// Insert result: [{First {2023-10-01 12:00:00 +0000 UTC} <nil>}]
	// Insert result: [map[created_at:{2023-10-01 12:00:00 +0000 UTC} name:Fourth]]
	// Selected person: {First {2023-10-01 12:00:00 +0000 UTC} <nil>}
	// Selected person: {Second {2023-10-01 12:00:00 +0000 UTC} <nil>}
	// Selected person: {Third {2023-10-01 12:00:00 +0000 UTC} <nil>}
	// Selected person: {Fourth {2023-10-01 12:00:00 +0000 UTC} <nil>}
}

```


================================================
FILE: src/content/doc-sdk-golang/methods/invalidate.mdx
================================================
---
sidebar_position: 1
sidebar_label: Invalidate
title: Golang | SDK | Methods | Invalidate
description: This method invalidates the authentication for the current connection.
---

import Label from "@components/shared/Label.astro";

# `.Invalidate()` {#invalidate}

Invalidates the authentication for the current connection.

```go title="Method Syntax"
db.Invalidate()
```

### Example usage

```go
// And we can later on invalidate the token if desired
	defer func(token string) {
		if err := db.Invalidate(); err != nil {
			panic(err)
		}
	}(token)
```


================================================
FILE: src/content/doc-sdk-golang/methods/kill.mdx
================================================
---
sidebar_position: 1
sidebar_label: Kill
title: Golang | SDK | Methods | Kill
description: This method kills a running live query by it's UUID.
---

import Label from "@components/shared/Label.astro";

# `.Kill()` {#kill}

Kills a running live query by it's UUID.

```go title="Method Syntax"
db.Kill(queryUuid string)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>queryUuid</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The UUID of the live query you wish to kill.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
package main

import (
    "fmt"
    surreal "github.com/surrealdb/surrealdb.go"
)

func main() {
    // Assuming db is an instance of your database connection
    // and uuid is a string containing the query UUID you want to kill
    queryUuid := "your-query-uuid-here"

    err := surreal.Kill(queryUuid)
    if err != nil {
        fmt.Println("Error killing query:", err)
        return
    }

    fmt.Println("Successfully killed query")
}


================================================
FILE: src/content/doc-sdk-golang/methods/let.mdx
================================================
---
sidebar_position: 11
sidebar_label: Let
title: Golang | SDK | Methods | Let
description: The let method assigns a value as a parameter for this connection.
---

import Label from "@components/shared/Label.astro";

# `.Let()` {#let}

Assigns a value as a parameter for this connection.

```go title="Method Syntax"
db.Let(key string, value interface{})
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>value</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Assigns the value to the variable name.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
// Assign the variable on the connection
db.Let("name", new Name { FirstName = "Tobie", LastName = "Morgan Hitchcock" });

// Use the variable in a subsequent query
db.Query("CREATE person SET name = $name");

// Use the variable in a subsequent query
db.Query("SELECT * FROM person WHERE name.first_name = $name.first_name");
```

You can remove the variable from the connection using the [`Unset()` method](/docs/sdk/golang/methods/unset).



================================================
FILE: src/content/doc-sdk-golang/methods/live-notification.mdx
================================================
---
sidebar_position: 1
sidebar_label: LiveNotification
title: Golang | SDK | Methods | LiveNotification
description: The Golang SDK enables you to listen for changes to records in a table.
---

import Label from "@components/shared/Label.astro";

# `.LiveNotifications<T>(queryUuid)` {#live-notifications}

Listen responses from an existing live query.

```go title="Method Syntax"
db.LiveNotifications[UUID string](queryUuid)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>queryUuid</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The UUID of the live query to consume.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go title="Example"
package main

package main

import (
	"fmt"
	"os"
	"os/signal"
	"syscall"
)

// Assume db is your database connection with a LiveNotifications method.
func main() {
	// Assuming queryUuid is obtained from a previous Live() call.
	queryUuid := "your-query-uuid-here"

	notifications, err := db.LiveNotifications(queryUuid)
	if err != nil {
		fmt.Println("Error setting up notifications:", err)
		return
	}

	// Listen for notifications in a goroutine.
	go func() {
		for notification := range notifications {
			// Process each notification as it arrives.
			fmt.Printf("Received notification: %+v\n", notification)
		}
	}()

	// Wait for a ctrl-C (SIGINT) or termination signal (SIGTERM) before exiting.
	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
	<-sigs

	fmt.Println("Exiting...")
}



================================================
FILE: src/content/doc-sdk-golang/methods/live.mdx
================================================
---
sidebar_position: 1
sidebar_label: LiveQuery
title: Golang | SDK | Methods | LiveQuery
description: The Golang SDK enables you to listen for changes to records in a table.
---

import Label from "@components/shared/Label.astro";

# `.Live[T](table, diff)` {#live-query}

Initiate a live query from a SurrealQL statement.

```go title="Method Syntax"
db.Live[UUID](table, diff)

```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
package main

import (
	"context"
	"fmt"
	"sort"
	"strings"
	"time"

	surrealdb "github.com/surrealdb/surrealdb.go"
	"github.com/surrealdb/surrealdb.go/contrib/testenv"
	"github.com/surrealdb/surrealdb.go/pkg/connection"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)

// formatRecordResult formats a record result (map[string]any) for testing.
// This is used for regular live query results (without diff) and DELETE operations.
// It handles the id field specially, formatting RecordID as table:`UUID`.
func formatRecordResult(record map[string]any) string {
	keys := make([]string, 0, len(record))
	for k := range record {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	var parts []string
	for _, k := range keys {
		val := record[k]
		if k == "id" {
			// The id field must be a models.RecordID
			recordID := val.(models.RecordID)
			parts = append(parts, fmt.Sprintf("id=%s:`UUID`", recordID.Table))
		} else {
			parts = append(parts, fmt.Sprintf("%s=%v", k, val))
		}
	}
	return "{" + strings.Join(parts, " ") + "}"
}

// formatDiffResult formats a diff result ([]any) for testing.
// Each item in the array is a diff operation (map[string]any).
func formatDiffResult(diffs []any) string {
	var items []string
	for _, item := range diffs {
		diffOp, ok := item.(map[string]any)
		if !ok {
			panic(fmt.Sprintf("Expected diff operation to be map[string]any, got %T", item))
		}
		items = append(items, formatDiffOperation(diffOp))
	}
	return "[" + strings.Join(items, " ") + "]"
}

// formatPatchDataMap formats a map representation of PatchData.
// This is the data contained in the "value" field of a diff operation.
func formatPatchDataMap(data map[string]any) string {
	keys := make([]string, 0, len(data))
	for k := range data {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	var parts []string
	for _, k := range keys {
		val := data[k]
		if k == "id" {
			// The id field in patch data is also a models.RecordID
			recordID := val.(models.RecordID)
			parts = append(parts, fmt.Sprintf("id=%s:`UUID`", recordID.Table))
		} else {
			parts = append(parts, fmt.Sprintf("%s=%v", k, val))
		}
	}
	return "{" + strings.Join(parts, " ") + "}"
}

// formatDiffOperation formats a single diff operation.
// A diff operation contains fields like "op", "path", and optionally "value".
func formatDiffOperation(op map[string]any) string {
	keys := make([]string, 0, len(op))
	for k := range op {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	var parts []string
	for _, k := range keys {
		val := op[k]
		if k == "value" {
			// The value field contains patch data (not a regular record)
			if patchData, ok := val.(map[string]any); ok {
				parts = append(parts, fmt.Sprintf("value=%s", formatPatchDataMap(patchData)))
			} else {
				// For non-map values (like simple value replacements)
				parts = append(parts, fmt.Sprintf("value=%v", val))
			}
		} else {
			parts = append(parts, fmt.Sprintf("%s=%v", k, val))
		}
	}
	return "{" + strings.Join(parts, " ") + "}"
}

// ExampleLive demonstrates using the Live RPC method to receive notifications.
// Live queries without diff return the full record as map[string]any in notification.Result.
// The notification channel is automatically closed when Kill is called.
//
//nolint:gocyclo
func ExampleLive() {
	config := testenv.MustNewConfig("surrealdbexamples", "livequery_rpc", "users")
	config.Endpoint = testenv.GetSurrealDBWSURL()

	db := config.MustNew()

	type User struct {
		ID       *models.RecordID `json:"id,omitempty"`
		Username string           `json:"username"`
		Email    string           `json:"email"`
	}

	ctx := context.Background()

	live, err := surrealdb.Live(ctx, db, "users", false)
	if err != nil {
		panic(fmt.Sprintf("Failed to start live query: %v", err))
	}

	fmt.Println("Started live query")

	notifications, err := db.LiveNotifications(live.String())
	if err != nil {
		panic(fmt.Sprintf("Failed to get live notifications channel: %v", err))
	}

	received := make(chan struct{})
	done := make(chan bool)
	go func() {
		for notification := range notifications {
			// Live queries without diff return the record as map[string]any
			record, ok := notification.Result.(map[string]any)
			if !ok {
				panic(fmt.Sprintf("Expected map[string]any, got %T", notification.Result))
			}

			fmt.Printf("Received notification - Action: %s, Result: %s\n", notification.Action, formatRecordResult(record))

			switch notification.Action {
			case connection.CreateAction:
				fmt.Println("New user created")
			case connection.UpdateAction:
				fmt.Println("User updated")
			case connection.DeleteAction:
				fmt.Println("User deleted")
				close(received)
			}
		}
		// Channel was closed
		fmt.Println("Notification channel closed")
		done <- true
	}()

	createdUser, err := surrealdb.Create[User](ctx, db, "users", map[string]any{
		"username": "alice",
		"email":    "alice@example.com",
	})
	if err != nil {
		panic(fmt.Sprintf("Failed to create user: %v", err))
	}

	_, err = surrealdb.Update[User](ctx, db, *createdUser.ID, map[string]any{
		"email": "alice.updated@example.com",
	})
	if err != nil {
		panic(fmt.Sprintf("Failed to update user: %v", err))
	}

	_, err = surrealdb.Delete[User](ctx, db, *createdUser.ID)
	if err != nil {
		panic(fmt.Sprintf("Failed to delete user: %v", err))
	}

	// Wait for all expected notifications to be received
	select {
	case <-received:
		// All notifications received
	case <-time.After(2 * time.Second):
		panic("Timeout waiting for all notifications")
	}

	err = surrealdb.Kill(ctx, db, live.String())
	if err != nil {
		panic(fmt.Sprintf("Failed to kill live query: %v", err))
	}

	fmt.Println("Live query terminated")

	select {
	case <-done:
		fmt.Println("Goroutine exited after channel closed")
	case <-time.After(2 * time.Second):
		panic("Timeout: notification channel was not closed after Kill")
	}

	// Output:
	// Started live query
	// Received notification - Action: CREATE, Result: {email=alice@example.com id=users:`UUID` username=alice}
	// New user created
	// Received notification - Action: UPDATE, Result: {email=alice.updated@example.com id=users:`UUID`}
	// User updated
	// Received notification - Action: DELETE, Result: {email=alice.updated@example.com id=users:`UUID`}
	// User deleted
	// Live query terminated
	// Notification channel closed
	// Goroutine exited after channel closed
}

// ExampleQuery_live demonstrates using LIVE SELECT via the Query RPC.
// LIVE SELECT returns matching records as map[string]any in notification.Result.
// The notification channel is automatically closed when Kill is called.
func ExampleQuery_live() {
	config := testenv.MustNewConfig("surrealdbexamples", "livequery_query", "products")
	config.Endpoint = testenv.GetSurrealDBWSURL()

	db := config.MustNew()

	type Product struct {
		ID    *models.RecordID `json:"id,omitempty"`
		Name  string           `json:"name"`
		Price float64          `json:"price"`
		Stock int              `json:"stock"`
	}

	ctx := context.Background()

	result, err := surrealdb.Query[models.UUID](ctx, db, "LIVE SELECT * FROM products WHERE stock < 10", map[string]any{})
	if err != nil {
		panic(fmt.Sprintf("Failed to start live query: %v", err))
	}

	liveID := (*result)[0].Result.String()
	fmt.Println("Started live query")

	notifications, err := db.LiveNotifications(liveID)
	if err != nil {
		panic(fmt.Sprintf("Failed to get live notifications channel: %v", err))
	}

	received := make(chan struct{})
	done := make(chan bool)
	notificationCount := 0
	go func() {
		for notification := range notifications {
			notificationCount++

			// LIVE SELECT returns matching records as map[string]any
			record, ok := notification.Result.(map[string]any)
			if !ok {
				panic(fmt.Sprintf("Expected map[string]any for LIVE SELECT result, got %T", notification.Result))
			}

			fmt.Printf("Notification %d - Action: %s, Result: %s\n", notificationCount, notification.Action, formatRecordResult(record))

			if notificationCount >= 3 {
				close(received)
			}
		}
		// Channel was closed
		fmt.Println("Notification channel closed")
		done <- true
	}()

	_, err = surrealdb.Create[Product](ctx, db, "products", map[string]any{
		"name":  "Widget",
		"price": 9.99,
		"stock": 5,
	})
	if err != nil {
		panic(fmt.Sprintf("Failed to create product: %v", err))
	}

	_, err = surrealdb.Create[Product](ctx, db, "products", map[string]any{
		"name":  "Gadget",
		"price": 19.99,
		"stock": 3,
	})
	if err != nil {
		panic(fmt.Sprintf("Failed to create second product: %v", err))
	}

	_, err = surrealdb.Create[Product](ctx, db, "products", map[string]any{
		"name":  "Abundant Item",
		"price": 5.99,
		"stock": 100,
	})
	if err != nil {
		panic(fmt.Sprintf("Failed to create third product: %v", err))
	}

	_, err = surrealdb.Create[Product](ctx, db, "products", map[string]any{
		"name":  "Rare Item",
		"price": 99.99,
		"stock": 1,
	})
	if err != nil {
		panic(fmt.Sprintf("Failed to create fourth product: %v", err))
	}

	// Wait for all expected notifications to be received
	select {
	case <-received:
		// All notifications received
	case <-time.After(2 * time.Second):
		panic("Timeout waiting for all notifications")
	}

	err = surrealdb.Kill(ctx, db, liveID)
	if err != nil {
		panic(fmt.Sprintf("Failed to kill live query: %v", err))
	}

	fmt.Println("Live query terminated")

	select {
	case <-done:
		fmt.Println("Goroutine exited after channel closed")
	case <-time.After(2 * time.Second):
		panic("Timeout: notification channel was not closed after Kill")
	}

	// Output:
	// Started live query
	// Notification 1 - Action: CREATE, Result: {id=products:`UUID` name=Widget price=9.99 stock=5}
	// Notification 2 - Action: CREATE, Result: {id=products:`UUID` name=Gadget price=19.99 stock=3}
	// Notification 3 - Action: CREATE, Result: {id=products:`UUID` name=Rare Item price=99.99 stock=1}
	// Live query terminated
	// Notification channel closed
	// Goroutine exited after channel closed
}

// ExampleLive_withDiff demonstrates using live queries with diff enabled.
// With diff=true, CREATE and UPDATE return diff operations as []any,
// while DELETE still returns the deleted record as map[string]any.
// The notification channel is automatically closed when Kill is called.
func ExampleLive_withDiff() {
	config := testenv.MustNewConfig("surrealdbexamples", "livequery_diff", "inventory")
	config.Endpoint = testenv.GetSurrealDBWSURL()

	db := config.MustNew()

	type Item struct {
		ID       *models.RecordID `json:"id,omitempty"`
		Name     string           `json:"name"`
		Quantity int              `json:"quantity"`
	}

	ctx := context.Background()

	live, err := surrealdb.Live(ctx, db, "inventory", true)
	if err != nil {
		panic(fmt.Sprintf("Failed to start live query with diff: %v", err))
	}

	fmt.Println("Started live query with diff enabled")

	notifications, err := db.LiveNotifications(live.String())
	if err != nil {
		panic(fmt.Sprintf("Failed to get live notifications channel: %v", err))
	}

	received := make(chan struct{})
	done := make(chan bool)
	go func() {
		for notification := range notifications {
			var resultStr string

			// With diff=true:
			// - CREATE and UPDATE return diff operations as []any
			// - DELETE returns the full deleted record as map[string]any (same as without diff)
			if notification.Action == connection.DeleteAction {
				// DELETE always returns a regular record, even with diff=true
				record, ok := notification.Result.(map[string]any)
				if !ok {
					panic(fmt.Sprintf("Expected map[string]any for DELETE result, got %T", notification.Result))
				}
				resultStr = formatRecordResult(record)
				close(received)
			} else {
				// CREATE and UPDATE return an array of diff operations
				diffs, ok := notification.Result.([]any)
				if !ok {
					panic(fmt.Sprintf("Expected []any for diff result, got %T", notification.Result))
				}
				resultStr = formatDiffResult(diffs)
			}

			fmt.Printf("Action: %s, Result: %s\n", notification.Action, resultStr)
		}
		// Channel was closed
		fmt.Println("Notification channel closed")
		done <- true
	}()

	item, err := surrealdb.Create[Item](ctx, db, "inventory", map[string]any{
		"name":     "Screwdriver",
		"quantity": 50,
	})
	if err != nil {
		panic(fmt.Sprintf("Failed to create item: %v", err))
	}

	_, err = surrealdb.Update[Item](ctx, db, *item.ID, map[string]any{
		"quantity": 45,
	})
	if err != nil {
		panic(fmt.Sprintf("Failed to update item: %v", err))
	}

	_, err = surrealdb.Delete[Item](ctx, db, *item.ID)
	if err != nil {
		panic(fmt.Sprintf("Failed to delete item: %v", err))
	}

	// Wait for all expected notifications to be received
	select {
	case <-received:
		// All notifications received
	case <-time.After(2 * time.Second):
		panic("Timeout waiting for all notifications")
	}

	err = surrealdb.Kill(ctx, db, live.String())
	if err != nil {
		panic(fmt.Sprintf("Failed to kill live query: %v", err))
	}

	fmt.Println("Live query with diff terminated")

	select {
	case <-done:
		fmt.Println("Goroutine exited after channel closed")
	case <-time.After(2 * time.Second):
		panic("Timeout: notification channel was not closed after Kill")
	}

	// Output:
	// Started live query with diff enabled
	// Action: CREATE, Result: [{op=replace path=/ value={id=inventory:`UUID` name=Screwdriver quantity=50}}]
	// Action: UPDATE, Result: [{op=remove path=/name} {op=replace path=/quantity value=45}]
	// Action: DELETE, Result: {id=inventory:`UUID` quantity=45}
	// Live query with diff terminated
	// Notification channel closed
	// Goroutine exited after channel closed
}

```


================================================
FILE: src/content/doc-sdk-golang/methods/merge.mdx
================================================
---
sidebar_position: 1
sidebar_label: Merge
title: Golang | SDK | Methods | Merge
description: The Merge method modifies all records in a table, or a specific record.
---

import Label from "@components/shared/Label.astro";

# `.Merge[T](what, data)` {#merge}

Modifies all records in a table, or a specific record.

```go title="Method Syntax"
db.Merge[T](what, data)
```

> [!NOTE]
> This function merges the current document / record data with the specified data.

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to merge.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The data with which to modify the records.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go title="Merging data within a single record"
type PersonMerge struct {
	ID       models.RecordID `json:"id"`
	Settings struct {
		Active    bool `json:"active"`
		Marketing bool `json:"marketing"`
	} `json:"settings"`
}

// Define the partial update data using a struct
mergeData := PersonMerge{
	ID: models.NewRecordID("person", "tobie"),
	Settings: struct {
		Active    bool `json:"active"`
		Marketing bool `json:"marketing"`
	}{
		Active:    true,
		Marketing: false,
	},
}

// Perform the merge operation
updatedPerson, err := surrealdb.Merge[Person, models.RecordID](db, mergeData.ID, mergeData)
if err != nil {
	panic(err)
}
fmt.Printf("Merged person record with struct: %+v\n", updatedPerson)

```


================================================
FILE: src/content/doc-sdk-golang/methods/new.mdx
================================================
---
sidebar_position: 2
sidebar_label: New
title: Golang | SDK | Methods | New
description: The Golang SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.New()` {#new}

Connects to a remote database endpoint.

```go title="Method Syntax"
surrealdb.New(url, options...)()
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>url</code>
                <Label label="required" />
            </td>
            <td colspan="2">
                The URL of the database endpoint to connect to. Examples may include http://hostname:8000 or ws://hostname:8000/rpc .
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>options</code>
               <Label label="optional" />
            </td>
            <td colspan="2">
                Set SurrealDB clients options such as Timeout etc.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```go
// Connect to a local endpoint
surrealdb.New("ws://localhost:8000");
// Connect to a remote endpoint
surrealdb.New("ws://cloud.surrealdb.com");
```

```go
db, err := surrealdb.New("ws://localhost:8000")
	if err != nil {
		panic(err)
}
```



================================================
FILE: src/content/doc-sdk-golang/methods/patch.mdx
================================================
---
sidebar_position: 1
sidebar_label: Patch
title: Golang | SDK | Methods | Patch
description: The Patch method applies JSON Patch changes to all records, or a specific record, in the database.
---

import Label from "@components/shared/Label.astro";

# `.Patch[T](what, patches)` {#patch}

Applies JSON Patch changes to all records, or a specific record, in the database.

```go title="Method Syntax"
db.Patch[T](what, patches)
```

> [!NOTE]
> This function patches document / record data with the specified <a href="https://jsonpatch.com/">JSON Patch</a> data.

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to patch.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The JSON Patch data with which to patch the records.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
type PatchData struct {
	Op    string      `json:"op"`    // Operation type: "add", "remove", "replace", etc.
	Path  string      `json:"path"`  // Path to the field to modify
	Value interface{} `json:"value"` // New value for the field (only for "add" or "replace")
}

// Define the patch operations
patches := []PatchData{
	{Op: "replace", Path: "/name", Value: "John Smith"},
	{Op: "add", Path: "/tags", Value: []string{"developer", "engineer"}},
	{Op: "remove", Path: "/oldField"},
}

// Specify the target record
recordID := models.NewRecordID("person", "tobie")

// Perform the patch operation
updatedPatches, err := surrealdb.Patch(db, recordID, patches)
if err != nil {
	panic(err)
}
fmt.Printf("Patched person record with patches: %+v\n", updatedPatches)

```


================================================
FILE: src/content/doc-sdk-golang/methods/query.mdx
================================================
---
sidebar_position: 1
sidebar_label: Query
title: Golang | SDK | Methods | Query
description: This method runs a set of SurrealQL statements against the database.
---

import Label from "@components/shared/Label.astro";

# `.Query()` {#query}

Runs a set of SurrealQL statements against the database.

```go title="Method Syntax"
db.Query[TResult any](sql string, vars map[string]interface{}) (*[]QueryResult[TResult], error)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>vars</code>
                <Label label="optional" />
            </td>
            <td colspan="2">
                Assigns the value to the variable name.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
package main

import (
	"fmt"
	"time"

	surrealdb "github.com/surrealdb/surrealdb.go"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)

func ExampleQuery() {
	db := newSurrealDBConnection("examples", "query", "persons")

	type NestedStruct struct {
		City string `json:"city"`
	}

	type Person struct {
		ID           *models.RecordID `json:"id,omitempty"`
		Name         string           `json:"name"`
		NestedMap    map[string]any   `json:"nested_map,omitempty"`
		NestedStruct `json:"nested_struct,omitempty"`
		CreatedAt    models.CustomDateTime  `json:"created_at,omitempty"`
		UpdatedAt    *models.CustomDateTime `json:"updated_at,omitempty"`
	}

	createdAt, err := time.Parse(time.RFC3339, "2023-10-01T12:00:00Z")
	if err != nil {
		panic(err)
	}

	createQueryResults, err := surrealdb.Query[[]Person](
		db,
		`CREATE type::record($tb, $id) CONTENT $content`,
		map[string]any{
			"tb": "persons",
			"id": "yusuke",
			"content": map[string]any{
				"name": "Yusuke",
				"nested_struct": NestedStruct{
					City: "Tokyo",
				},
				"created_at": models.CustomDateTime{
					Time: createdAt,
				},
			},
		})
	if err != nil {
		panic(err)
	}
	fmt.Printf("Number of query results: %d\n", len(*createQueryResults))
	fmt.Printf("First query result's status: %+s\n", (*createQueryResults)[0].Status)
	fmt.Printf("Persons contained in the first query result: %+v\n", (*createQueryResults)[0].Result)

	//nolint:lll
	// Output:
	// Number of query results: 1
	// First query result's status: OK
	// Persons contained in the first query result: [{ID:persons:yusuke Name:Yusuke NestedMap:map[] NestedStruct:{City:Tokyo} CreatedAt:{Time:2023-10-01 12:00:00 +0000 UTC} UpdatedAt:<nil>}]
}

```

### Transaction example

```go 

package main

import (
	"fmt"

	surrealdb "github.com/surrealdb/surrealdb.go"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)

func ExampleQuery_transaction_let_return() {
	
	db, err := surrealdb.New("ws://localhost:8000")
	if err != nil {
		panic(err)
	}
	if err = db.Use("test", "test"); err != nil { // set your namespace/database
		panic(err)
	}
	token, err := db.SignIn(&surrealdb.Auth{ // replace with your auth
		Username: "root",
		Password: "root",
	})
	if err != nil {
		panic(err)
	}
	if err = db.Authenticate(token); err != nil {
		panic(err)
	}

	createQueryResults, err := surrealdb.Query[[]any](
		db,
		`BEGIN;
		 CREATE t:1 SET name = 'test';
		 LET $i = SELECT * FROM $id;
		 RETURN $i.name;
		 COMMIT
		`,
		map[string]any{
			"id": models.NewRecordID("t", 1),
		})
	if err != nil {
		panic(err)
	}
	fmt.Printf("Number of query results: %d\n", len(*createQueryResults))
	fmt.Printf("First query result's status: %+s\n", (*createQueryResults)[0].Status)
	fmt.Printf("Names contained in the first query result: %+v\n", (*createQueryResults)[0].Result)

	//nolint:lll
	// Output:
	// Number of query results: 1
	// First query result's status: OK
	// Names contained in the first query result: [test]
}
```



================================================
FILE: src/content/doc-sdk-golang/methods/raw-query.mdx
================================================
---
sidebar_position: 1
sidebar_label: QueryRaw
title: Golang | SDK | Methods | QueryRaw
description: This method runs a set of SurrealQL statements against the database, based on a raw SurrealQL query. 
---

import Label from "@components/shared/Label.astro";

# `.QueryRaw()` {#query}

Runs a set of SurrealQL statements against the database, based on a raw SurrealQL query.

```go title="Method Syntax"
func QueryRaw(db *DB, queries *[]QueryStmt) error
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>params</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
	package main

import (
	"fmt"
	"log"
)

// QueryStmt represents a database query.
type QueryStmt struct {
	SQL         string
	Vars        map[string]interface{}
	Result      QueryResult
	unmarshaler interface{}
}

// QueryResult is a simple type representing a query result.
type QueryResult struct {
	Data string
}

// DB simulates a database connection.
type DB struct {
	con Connection
}

// Connection simulates a connection that can send queries.
type Connection struct{}

// RPCResponse is a generic response wrapper.
type RPCResponse[T any] struct {
	Result *T
}

// Send simulates sending the combined query to the database.
// For this example, it returns a dummy result for each query.
func (c *Connection) Send(res *RPCResponse[[]QueryResult], method, query string, params map[string]interface{}) error {
	// For simplicity, we assume one result per query.
	dummyResults := []QueryResult{
		{Data: "Result for query: SELECT * FROM person WHERE id = 1"},
	}
	res.Result = &dummyResults
	return nil
}

// GetUnmarshaler returns a dummy unmarshaler.
func (c *Connection) GetUnmarshaler() interface{} {
	return nil
}

// QueryRaw executes the queries by concatenating them, sending them to the DB,
// and assigning each query its corresponding result.
func QueryRaw(db *DB, queries *[]QueryStmt) error {
	preparedQuery := ""
	parameters := map[string]interface{}{}

	for i := 0; i < len(*queries); i++ {
		preparedQuery += fmt.Sprintf("%s;", (*queries)[i].SQL)
		for k, v := range (*queries)[i].Vars {
			parameters[k] = v
		}
	}

	if preparedQuery == "" {
		return fmt.Errorf("no query to run")
	}

	var res RPCResponse[[]QueryResult]
	if err := db.con.Send(&res, "query", preparedQuery, parameters); err != nil {
		return err
	}

	for i := 0; i < len(*queries); i++ {
		(*queries)[i].Result = (*res.Result)[i]
		(*queries)[i].unmarshaler = db.con.GetUnmarshaler()
	}

	return nil
}

func main() {
	// Create a dummy database instance.
	db := &DB{
		con: Connection{},
	}

	// Define the query statement(s).
	queries := []QueryStmt{
		{
			SQL:  "SELECT * FROM person WHERE id = $id",
			Vars: map[string]interface{}{"id": 1},
		},
	}

	// Perform the query operation.
	if err := QueryRaw(db, &queries); err != nil {
		log.Fatalf("QueryRaw failed: %v", err)
	}

	// Print the query result.
	fmt.Printf("Query result: %+v\n", queries[0].Result)
}

```



================================================
FILE: src/content/doc-sdk-golang/methods/relate.mdx
================================================
---
sidebar_position: 1
sidebar_label: Relate
title: Golang | SDK | Methods | Relate
description: This method creates a relation between records.
---

import Label from "@components/shared/Label.astro";

# `.Relate()` {#relate}

Creates a relation between records.

```go title="Method Syntax"
surrealdb.Relate(db, relationship)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>@in</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The edge of the relation.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>@out</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The other edge of the relation.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
package main

import (
	"fmt"
	"time"

	surrealdb "github.com/surrealdb/surrealdb.go"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)

//nolint:funlen
func ExampleRelate() {
	
	db, err := surrealdb.New("ws://localhost:8000")
	if err != nil {
		panic(err)
	}
	if err = db.Use("test", "test"); err != nil { // set your namespace/database
		panic(err)
	}
	token, err := db.SignIn(&surrealdb.Auth{ // replace with your auth
		Username: "root",
		Password: "root",
	})
	if err != nil {
		panic(err)
	}
	if err = db.Authenticate(token); err != nil {
		panic(err)
	}

	type Person struct {
		ID models.RecordID `json:"id,omitempty"`
	}

	type Follow struct {
		In    *models.RecordID      `json:"in,omitempty"`
		Out   *models.RecordID      `json:"out,omitempty"`
		Since models.CustomDateTime `json:"since"`
	}

	first, err := surrealdb.Create[Person](
		db,
		"person",
		map[string]any{
			"id": models.NewRecordID("person", "first"),
		})
	if err != nil {
		panic(err)
	}

	second, err := surrealdb.Create[Person](
		db,
		"person",
		map[string]any{
			"id": models.NewRecordID("person", "second"),
		})
	if err != nil {
		panic(err)
	}

	since, err := time.Parse(time.RFC3339, "2023-10-01T12:00:00Z")
	if err != nil {
		panic(err)
	}

	persons, err := surrealdb.Query[[]Person](
		db,
		"SELECT * FROM person ORDER BY id.id",
		nil,
	)
	if err != nil {
		panic(err)
	}
	for _, person := range (*persons)[0].Result {
		fmt.Printf("Person: %+v\n", person)
	}

	if relateErr := surrealdb.Relate(
		db,
		&surrealdb.Relationship{
			ID:       &models.RecordID{Table: "follow", ID: "first_second"},
			In:       first.ID,
			Out:      second.ID,
			Relation: "follow",
			Data: map[string]any{
				"since": models.CustomDateTime{
					Time: since,
				},
			},
		},
	); relateErr != nil {
		panic(relateErr)
	}

	//nolint:lll
	/// Here's an alternative way to create a relation using a query.
	//
	// if res, err := surrealdb.Query[any](
	// 	db,
	// 	"RELATE $in->follow:first_second->$out SET since = $since",
	// 	map[string]any{
	// 		// `RELATE $in->follow->$out` with "id" below is ignored,
	// 		// and the id becomes a generated one.
	// 		// If you want to set the id, use `RELATE $in->follow:the_id->$out` like above.
	// 		// "id":    models.NewRecordID("follow", "first_second"),
	// 		"in":    first.ID,
	// 		"out":   second.ID,
	// 		"since": models.CustomDateTime{Time: since},
	// 	},
	// ); err != nil {
	// 	panic(err)
	// } else {
	// 	fmt.Printf("Relation: %+v\n", (*res)[0].Result)
	// }
	// The output will be:
	// Relation: [map[id:{Table:follow ID:first_second} in:{Table:person ID:first} out:{Table:person ID:second} since:{Time:2023-10-01 12:00:00 +0000 UTC}]]

	type PersonWithFollows struct {
		Person
		Follows []models.RecordID `json:"follows,omitempty"`
	}
	selected, err := surrealdb.Query[[]PersonWithFollows](
		db,
		"SELECT id, name, ->follow->person AS follows FROM $id",
		map[string]any{
			"id": first.ID,
		},
	)
	if err != nil {
		panic(err)
	}

	for _, person := range (*selected)[0].Result {
		fmt.Printf("PersonWithFollows: %+v\n", person)
	}

	// Note we can select the relationships themselves because
	// RELATE creates a record in the relation table.
	follows, err := surrealdb.Query[[]Follow](
		db,
		"SELECT * from follow",
		nil,
	)
	if err != nil {
		panic(err)
	}

	for _, follow := range (*follows)[0].Result {
		fmt.Printf("Follow: %+v\n", follow)
	}

	//nolint:lll
	// Output:
	// Person: {ID:{Table:person ID:first}}
	// Person: {ID:{Table:person ID:second}}
	// PersonWithFollows: {Person:{ID:{Table:person ID:first}} Follows:[{Table:person ID:second}]}
	// Follow: {In:person:first Out:person:second Since:{Time:2023-10-01 12:00:00 +0000 UTC}}
}
```


================================================
FILE: src/content/doc-sdk-golang/methods/select.mdx
================================================
---
sidebar_position: 1
sidebar_label: Select
title: Golang | SDK | Methods | Select
description: This method selects all records in a table, or a specific record, from the database.
---

import Label from "@components/shared/Label.astro";

# `.Select[T, R](resource)` {#select}

Selects all records in a table, or a specific record, from the database.

```go title="Method Syntax"
db.Select[T, R](resource)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>resource</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The table name (as <code>models.Table</code>) for selecting all records or a <code>RecordID</code> (as <code>models.RecordID</code>) to select a single record.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>T</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The type to deserialize the result into, such as <code>Person</code> for a single record or <code>[]Person</code> for an array of records.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>R</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The type of the <code>resource</code> parameter—use <code>models.RecordID</code> for a single record or <code>models.Table</code> for an entire table.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
package main

import (
	"context"
	"fmt"

	surrealdb "github.com/surrealdb/surrealdb.go"
	"github.com/surrealdb/surrealdb.go/contrib/testenv"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)

func ExampleSelect() {
	db := testenv.MustNew("surrealdbexamples", "update", "person")

	type Person struct {
		ID models.RecordID `json:"id,omitempty"`
	}

	a := Person{ID: models.NewRecordID("person", "a")}
	b := Person{ID: models.NewRecordID("person", "b")}

	for _, p := range []Person{a, b} {
		created, err := surrealdb.Create[Person](
			context.Background(),
			db,
			p.ID,
			map[string]any{},
		)
		if err != nil {
			panic(err)
		}
		fmt.Printf("Created person: %+v\n", *created)
	}

	selectedOneUsingSelect, err := surrealdb.Select[Person](
		context.Background(),
		db,
		a.ID,
	)
	if err != nil {
		panic(err)
	}
	fmt.Printf("selectedOneUsingSelect: %+v\n", *selectedOneUsingSelect)

	selectedMultiUsingSelect, err := surrealdb.Select[[]Person](
		context.Background(),
		db,
		"person",
	)
	if err != nil {
		panic(err)
	}
	for _, p := range *selectedMultiUsingSelect {
		fmt.Printf("selectedMultiUsingSelect: %+v\n", p)
	}

	// Output:
	// Created person: {ID:{Table:person ID:a}}
	// Created person: {ID:{Table:person ID:b}}
	// selectedOneUsingSelect: {ID:{Table:person ID:a}}
	// selectedMultiUsingSelect: {ID:{Table:person ID:a}}
	// selectedMultiUsingSelect: {ID:{Table:person ID:b}}
}
```



================================================
FILE: src/content/doc-sdk-golang/methods/signin.mdx
================================================
---
sidebar_position: 1
sidebar_label: SignIn
title: Golang | SDK | Methods | SignIn
description: This method signs in to a root, namespace, database or scope user.
---

import Label from "@components/shared/Label.astro";
import Since from "@components/shared/Since.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# `.SignIn()` {#signin}

Signs in to a root, namespace, database or scope user.

```go title="Method Syntax"
await db.SignIn(credentials)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>credentials</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Variables used in a signin query.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

<Tabs groupId="signin-example">
<TabItem value="root" label="Root user">

```go
// Sign in to authentication `db` using the root user
	authData := &surrealdb.Auth{
		Username: "root", // use your setup username
		Password: "secret", // use your setup password
	}
	token, err := db.SignIn(authData)
	if err != nil {
		panic(err)
	}
```

</TabItem>

<TabItem value="namespace" label="Namespace user">

```go
// Sign in to authentication `db` using the root user
	authData := &surrealdb.Auth{
		Username: "root", // use your setup username
		Password: "secret", // use your setup password
        Namespace = "test", 
	}
	token, err := db.SignIn(authData)
	if err != nil {
		panic(err)
	}
```

</TabItem>

<TabItem value="database" label="Database user">

```go
// Sign in to authentication `db` using the root user
	authData := &surrealdb.Auth{
		Username: "root", // use your setup username
		Password: "secret", // use your setup password
        Namespace = "test", 
        Database = "test", 
	}
	token, err := db.SignIn(authData)
	if err != nil {
		panic(err)
	}
```

</TabItem>

<TabItem value="record" label="Record Access">

```go
// Sign in to authentication `db` using the root user
	authData := &surrealdb.Auth{
		Username: "root", // use your setup username
		Password: "secret", // use your setup password
        Namespace = "test", 
        Database = "test", 
        Access = "user",
        Email = "info@surrealdb.com",
        Password = "123456"
	}
	token, err := db.SignIn(authData)
	if err != nil {
		panic(err)
	}
```

</TabItem>

<TabItem value="scope" label="Scopes">

```go
// Sign in to authentication `db` using the root user
	authData := &surrealdb.Auth{
		Username: "root", // use your setup username
		Password: "secret", // use your setup password
        Namespace = "test", 
        Database = "test", 
        Scope = "user",
        Email = "info@surrealdb.com",
        Password = "123456"
	}
	token, err := db.SignIn(authData)
	if err != nil {
		panic(err)
	}
```

</TabItem>
</Tabs>

You can invalidate the authentication for the current connection using the [`Invalidate()` method](/docs/sdk/dotnet/methods/invalidate).



================================================
FILE: src/content/doc-sdk-golang/methods/signup.mdx
================================================
---
sidebar_position: 1
sidebar_label: SignUp
title: Golang | SDK | Methods | SignUp
description: This method signs up to a specific authentication scope / access method.
---

import Label from "@components/shared/Label.astro";
import Since from "@components/shared/Since.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# `.SignUp()` {#signup}

Signs up to a specific authentication scope / access method.

```go title="Method Syntax"
await db.SignUp(credentials)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>credentials</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Credentials to sign up as a scoped user.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

<Tabs groupId="signup-example">
<TabItem value="V2" label="V2.x">

```go
// Sign in to authentication `db` using the root user
	authData := &surrealdb.Auth{
		Username: "root", // use your setup username
		Password: "secret", // use your setup password
        Namespace = "test", 
        Database = "test", 
        Access = "user",
        Email = "info@surrealdb.com",
        Password = "123456"
	}
	token, err := db.SignUp(authData)
	if err != nil {
		panic(err)
	}
```

</TabItem>
<TabItem value="V1" label="V1.x">

```go
// Sign in to authentication `db` using the root user
	authData := &surrealdb.Auth{
		Username: "root", // use your setup username
		Password: "secret", // use your setup password
        Namespace = "test", 
        Database = "test", 
        Scope = "user",
        Email = "info@surrealdb.com",
        Password = "123456"
	}
	token, err := db.SignUp(authData)
	if err != nil {
		panic(err)
	}
```

</TabItem>
</Tabs>

You can invalidate the authentication for the current connection using the [`Invalidate()` method](/docs/sdk/dotnet/methods/invalidate).



================================================
FILE: src/content/doc-sdk-golang/methods/unset.mdx
================================================
---
sidebar_position: 1
sidebar_label: Unset
title: Golang | SDK | Methods | Unset
description: This method removes a parameter for this connection.
---

import Label from "@components/shared/Label.astro";

# `.Unset()` {#unset}

Removes a parameter for this connection.

```go title="Method Syntax"
db.Unset(key string)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
db.Unset("name")
```


================================================
FILE: src/content/doc-sdk-golang/methods/update.mdx
================================================
---
sidebar_position: 1
sidebar_label: Update
title: Golang | SDK | Methods | Update
description: The Update method updates all records in a table, or a specific record, in the database.
---

import Label from "@components/shared/Label.astro";

# `.Update[T](table, data)` {#update}

Updates all records in a table, or a specific record, in the database.

```go title="Method Syntax"
db.Update[T](table, data)
```

> [!NOTE]
> This function replaces the current document / record data with the specified data.

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/dotnet/data-types#recordid) to update.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to update.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
package main

import (
	"fmt"
	"time"

	surrealdb "github.com/surrealdb/surrealdb.go"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)

//nolint:funlen // ExampleUpdate demonstrates how to update records in SurrealDB.
func ExampleUpdate() {
	db := newSurrealDBConnection("examples", "update", "persons")

	type NestedStruct struct {
		City string `json:"city"`
	}

	type Person struct {
		ID           *models.RecordID `json:"id,omitempty"`
		Name         string           `json:"name"`
		NestedMap    map[string]any   `json:"nested_map,omitempty"`
		NestedStruct `json:"nested_struct,omitempty"`
		CreatedAt    models.CustomDateTime  `json:"created_at,omitempty"`
		UpdatedAt    *models.CustomDateTime `json:"updated_at,omitempty"`
	}

	createdAt, err := time.Parse(time.RFC3339, "2023-10-01T12:00:00Z")
	if err != nil {
		panic(err)
	}

	recordID := models.NewRecordID("persons", "yusuke")
	created, err := surrealdb.Create[Person](db, recordID, map[string]any{
		"name": "Yusuke",
		"nested_struct": NestedStruct{
			City: "Tokyo",
		},
		"created_at": models.CustomDateTime{
			Time: createdAt,
		},
	})
	if err != nil {
		panic(err)
	}
	fmt.Printf("Created persons: %+v\n", *created)

	updatedAt, err := time.Parse(time.RFC3339, "2023-10-02T12:00:00Z")
	if err != nil {
		panic(err)
	}

	updated, err := surrealdb.Update[Person](db, recordID, map[string]any{
		"name": "Yusuke",
		"nested_map": map[string]any{
			"key1": "value1",
		},
		"nested_struct": NestedStruct{
			City: "Kagawa",
		},
		"updated_at": models.CustomDateTime{
			Time: updatedAt,
		},
	})
	if err != nil {
		panic(err)
	}

	fmt.Printf("Updated persons: %+v\n", *updated)

	//nolint:lll
	// Output:
	// Created persons: {ID:persons:yusuke Name:Yusuke NestedMap:map[] NestedStruct:{City:Tokyo} CreatedAt:{Time:2023-10-01 12:00:00 +0000 UTC} UpdatedAt:<nil>}
	// Updated persons: {ID:persons:yusuke Name:Yusuke NestedMap:map[key1:value1] NestedStruct:{City:Kagawa} CreatedAt:{Time:0001-01-01 00:00:00 +0000 UTC} UpdatedAt:2023-10-02T12:00:00Z}
}
```


================================================
FILE: src/content/doc-sdk-golang/methods/upsert.mdx
================================================
---
sidebar_position: 1
sidebar_label: Upsert
title: Golang | SDK | Methods | Upsert
description: The Upsert method creates or updates a specific record.
---

import Label from "@components/shared/Label.astro";

# `.Upsert[T](table, data)` {#upsert}

Creates or updates a specific record.

```go title="Method Syntax"
db.Upsert[T](table, data)
```

> [!NOTE]
> This function creates a new document / record or replaces the current one with the specified data.

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
            <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The table to upsert the record to.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The document / record data to upsert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
package main

import (
	"fmt"
	"time"

	surrealdb "github.com/surrealdb/surrealdb.go"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)

//nolint:funlen
func ExampleUpsert() {
	
	db, err := surrealdb.New("ws://localhost:8000")
	if err != nil {
		panic(err)
	}
	if err = db.Use("test", "test"); err != nil { // set your namespace/database
		panic(err)
	}
	token, err := db.SignIn(&surrealdb.Auth{ // replace with your auth
		Username: "root",
		Password: "root",
	})
	if err != nil {
		panic(err)
	}
	if err = db.Authenticate(token); err != nil {
		panic(err)
	}

	type Person struct {
		ID   *models.RecordID `json:"id,omitempty"`
		Name string           `json:"name"`
		// Note that you must use CustomDateTime instead of time.Time.
		// See
		CreatedAt models.CustomDateTime  `json:"created_at,omitempty"`
		UpdatedAt *models.CustomDateTime `json:"updated_at,omitempty"`
	}

	createdAt, err := time.Parse(time.RFC3339, "2023-10-01T12:00:00Z")
	if err != nil {
		panic(err)
	}

	inserted, err := surrealdb.Upsert[Person](
		db,
		models.NewRecordID("persons", "yusuke"),
		map[string]any{
			"name":       "Yusuke",
			"created_at": createdAt,
		})
	if err != nil {
		panic(err)
	}
	fmt.Printf("Insert via upsert result: %+s\n", *inserted)

	updated, err := surrealdb.Upsert[Person](
		db,
		models.NewRecordID("persons", "yusuke"),
		map[string]any{
			"name": "Yusuke Updated",
			// because the upsert RPC is like UPSERT ~ CONTENT rather than UPSERT ~ MERGE,
			// the created_at field becomes None, which results in the returned created_at field being zero value.
			"updated_at": createdAt,
		},
	)
	if err != nil {
		panic(err)
	}
	fmt.Printf("Update via upsert result: %+s\n", *updated)

	udpatedAt, err := time.Parse(time.RFC3339, "2023-10-02T12:00:00Z")
	if err != nil {
		panic(err)
	}
	updatedFurther, err := surrealdb.Upsert[Person](
		db,
		models.NewRecordID("persons", "yusuke"),
		map[string]any{
			"name":       "Yusuke Updated Further",
			"created_at": createdAt,
			"updated_at": models.CustomDateTime{
				Time: udpatedAt,
			},
		},
	)
	if err != nil {
		panic(err)
	}
	fmt.Printf("Update further via upsert result: %+s\n", *updatedFurther)

	_, err = surrealdb.Upsert[struct{}](
		db,
		models.NewRecordID("persons", "yusuke"),
		map[string]any{
			"name": "Yusuke Updated Last",
		},
	)
	if err != nil {
		panic(err)
	}

	selected, err := surrealdb.Select[Person](
		db,
		models.NewRecordID("persons", "yusuke"),
	)
	if err != nil {
		panic(err)
	}
	fmt.Printf("Selected person: %+s\n", *selected)

	//nolint:lll
	// Output:
	// Insert via upsert result: {persons:yusuke Yusuke {2023-10-01 12:00:00 +0000 UTC} <nil>}
	// Update via upsert result: {persons:yusuke Yusuke Updated {0001-01-01 00:00:00 +0000 UTC} 2023-10-01T12:00:00Z}
	// Update further via upsert result: {persons:yusuke Yusuke Updated Further {2023-10-01 12:00:00 +0000 UTC} 2023-10-02T12:00:00Z}
	// Selected person: {persons:yusuke Yusuke Updated Last {0001-01-01 00:00:00 +0000 UTC} <nil>}
}
```

### Bulk upsert example 

```go
package main

import (
	"fmt"
	"strings"

	surrealdb "github.com/surrealdb/surrealdb.go"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)

// This example demonstrates how you can batch insert and upsert records,
// with specifying RETURN NONE to avoid unnecessary data transfer and decoding.
//
//nolint:funlen
func ExampleQuery_bluk_insert_upsert() {
	
	db, err := surrealdb.New("ws://localhost:8000")
	if err != nil {
		panic(err)
	}
	if err = db.Use("test", "test"); err != nil { // set your namespace/database
		panic(err)
	}
	token, err := db.SignIn(&surrealdb.Auth{ // replace with your auth
		Username: "root",
		Password: "root",
	})
	if err != nil {
		panic(err)
	}
	if err = db.Authenticate(token); err != nil {
		panic(err)
	}

	/// You can make it a schemaful table by defining fields like this:
	//
	// _, err := surrealdb.Query[any](
	// 	db,
	// 	`DEFINE TABLE persons SCHEMAFULL;
	// 	DEFINE FIELD note ON persons TYPE string;
	// 	DEFINE FIELD num ON persons TYPE int;
	// 	DEFINE FIELD loc ON persons TYPE geometry<point>;
	// `,
	// 	nil,
	// )
	// if err != nil {
	// 	panic(err)
	// }
	//
	/// If you do that, ensure that fields do not have `omitempty` json tags!
	///
	/// Why?
	/// Our cbor library reuses `json` tags for CBOR encoding/decoding,
	/// and `omitempty` skips the encoding of the field if it is empty.
	///
	/// For example, if you define an `int` field with `omitempty` tag,
	/// a value of `0` will not be encoded, resulting in an query error due:
	///   Found NONE for field `num`, with record `persons:p0`, but expected a int

	type Person struct {
		ID   *models.RecordID `json:"id"`
		Note string           `json:"note"`
		// As writte nabove whether it is `json:"num,omitempty"` or `json:"num"` is important,.
		// depending on what you want to achieve.
		Num int                  `json:"num"`
		Loc models.GeometryPoint `json:"loc"`
	}

	nthPerson := func(i int) Person {
		return Person{
			ID:   &models.RecordID{Table: "persons", ID: fmt.Sprintf("p%d", i)},
			Note: fmt.Sprintf("inserted%d", i),
			Num:  i,
			Loc: models.GeometryPoint{
				Longitude: 12.34 + float64(i),
				Latitude:  45.65 + float64(i),
			},
		}
	}

	var persons []Person
	for i := 0; i < 2; i++ {
		persons = append(persons, nthPerson(i))
	}

	insert, err := surrealdb.Query[any](
		db,
		`INSERT INTO persons $persons RETURN NONE`,
		map[string]any{
			"persons": persons,
		})
	if err != nil {
		panic(err)
	}
	fmt.Println("# INSERT INTO")
	fmt.Printf("Count   : %d\n", len(*insert))
	fmt.Printf("Status  : %+s\n", (*insert)[0].Status)
	fmt.Printf("Result  : %+v\n", (*insert)[0].Result)

	select1, err := surrealdb.Query[[]Person](
		db,
		`SELECT * FROM persons ORDER BY id.id`,
		nil)
	if err != nil {
		panic(err)
	}
	fmt.Printf("Selected: %+v\n", (*select1)[0].Result)

	persons = append(persons, nthPerson(2))

	insertIgnore, err := surrealdb.Query[any](
		db,
		`INSERT IGNORE INTO persons $persons RETURN NONE`,
		map[string]any{
			"persons": persons,
		})
	if err != nil {
		panic(err)
	}
	fmt.Println("# INSERT IGNORE INTO")
	fmt.Printf("Count   : %d\n", len(*insertIgnore))
	fmt.Printf("Status  : %+s\n", (*insertIgnore)[0].Status)
	fmt.Printf("Result  : %+v\n", (*insertIgnore)[0].Result)

	select2, err := surrealdb.Query[[]Person](
		db,
		`SELECT * FROM persons ORDER BY id.id`,
		nil)
	if err != nil {
		panic(err)
	}
	fmt.Printf("Selected: %+v\n", (*select2)[0].Result)

	for i := 0; i < 3; i++ {
		persons[i].Note = fmt.Sprintf("updated%d", i)
	}
	persons = append(persons, nthPerson(3))
	var upsertQueries []string
	vars := make(map[string]any)
	for i, p := range persons {
		upsertQueries = append(upsertQueries,
			fmt.Sprintf(`UPSERT persons CONTENT $content%d RETURN NONE`, i),
		)
		vars[fmt.Sprintf("content%d", i)] = p
	}
	upsert, err := surrealdb.Query[any](
		db,
		strings.Join(upsertQueries, ";"),
		vars,
	)
	if err != nil {
		panic(err)
	}
	fmt.Println("# UPSERT CONTENT")
	fmt.Printf("Count   : %d\n", len(*upsert))
	fmt.Printf("Status  : %+s\n", (*upsert)[0].Status)
	fmt.Printf("Result  : %+v\n", (*upsert)[0].Result)

	select3, err := surrealdb.Query[[]Person](
		db,
		`SELECT * FROM persons ORDER BY id.id`,
		nil)
	if err != nil {
		panic(err)
	}
	fmt.Printf("Selected: %+v\n", (*select3)[0].Result)

	//nolint:lll
	// Output:
	// # INSERT INTO
	// Count   : 1
	// Status  : OK
	// Result  : []
	// Selected: [{ID:persons:p0 Note:inserted0 Num:0 Loc:{Latitude:45.65 Longitude:12.34}} {ID:persons:p1 Note:inserted1 Num:1 Loc:{Latitude:46.65 Longitude:13.34}}]
	// # INSERT IGNORE INTO
	// Count   : 1
	// Status  : OK
	// Result  : []
	// Selected: [{ID:persons:p0 Note:inserted0 Num:0 Loc:{Latitude:45.65 Longitude:12.34}} {ID:persons:p1 Note:inserted1 Num:1 Loc:{Latitude:46.65 Longitude:13.34}} {ID:persons:p2 Note:inserted2 Num:2 Loc:{Latitude:47.65 Longitude:14.34}}]
	// # UPSERT CONTENT
	// Count   : 4
	// Status  : OK
	// Result  : []
	// Selected: [{ID:persons:p0 Note:updated0 Num:0 Loc:{Latitude:45.65 Longitude:12.34}} {ID:persons:p1 Note:updated1 Num:1 Loc:{Latitude:46.65 Longitude:13.34}} {ID:persons:p2 Note:updated2 Num:2 Loc:{Latitude:47.65 Longitude:14.34}} {ID:persons:p3 Note:inserted3 Num:3 Loc:{Latitude:48.65 Longitude:15.34}}]
}

```


================================================
FILE: src/content/doc-sdk-golang/methods/use.mdx
================================================
---
sidebar_position: 3
sidebar_label: Use
title: Golang | SDK | Methods | Use
description: The use method switches to a specific namespace and database.
---

import Label from "@components/shared/Label.astro";

# `.Use()` {#use}

Switch to a specific namespace and database.

```go title="Method Syntax"
db.Use(namespace, database)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>namespace</code>
                <Label label="initially required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Switches to a specific namespace.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>database</code>
                <Label label="initially required" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                Switches to a specific database.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
db.Use("test", "test");
```



================================================
FILE: src/content/doc-sdk-golang/methods/version.mdx
================================================
---
sidebar_position: 1
sidebar_label: Version
title: Golang | SDK | Methods | Version
description: The Golang SDK for SurrealDB enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.Version()` {#version}

Retrieves the version of the SurrealDB instance.

```go title="Method Syntax"
db.Version()
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" scope="row" data-label="Arguments">
                <code>cancellationToken</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="col" scope="row" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```go
package main

import (
	"fmt"
)

//nolint:lll,govet
func ExampleVersion() {
	
	db, err := surrealdb.New("ws://localhost:8000")
	if err != nil {
		panic(err)
	}
	if err = db.Use("test", "test"); err != nil { // set your namespace/database
		panic(err)
	}
	token, err := db.SignIn(&surrealdb.Auth{ // replace with your auth
		Username: "root",
		Password: "root",
	})
	if err != nil {
		panic(err)
	}
	if err = db.Authenticate(token); err != nil {
		panic(err)
	}
	v, err := ws.Version()
	if err != nil {
		panic(err)
	}
	fmt.Printf("VersionData (WebSocket): %+v\n", v)

	http := newSurrealDBHTTPConnection("version")
	v, err = http.Version()
	if err != nil {
		panic(err)
	}
	fmt.Printf("VersionData (HTTP): %+v\n", v)

	// You get something like below depending on your SurrealDB version:
	//
	// VersionData (WebSocket): &{Version:2.3.7 Build: Timestamp:}
	// VersionData (HTTP): &{Version:2.3.7 Build: Timestamp:}
}
```



================================================
FILE: src/content/doc-sdk-java/api-documentation.mdx
================================================
---
sidebar_position: 5
sidebar_label: API Documentation
title: Java | SDKs | API Documentation
description: Where you can find the API documentation for the SurrealDB SDK for Java.
---

# API Documentation

You can find the full API documentation for the SurrealDB SDK for Java on the [JavaDoc](https://surrealdb.github.io/surrealdb.java/javadoc/) website. The documentation provides detailed information about the classes, methods, and properties available in the SDK, as well as examples of how to use them in your applications.

This documentation will also be available in your IDE when you import the SDK into your project, allowing you to access the documentation directly from your code editor.


================================================
FILE: src/content/doc-sdk-java/data-types.mdx
================================================
---
sidebar_position: 4
sidebar_label: Data types
title: Java | SDKs | Data types
description: Where you can find the API documentation for the SurrealDB SDK for Java.
---

# Data Types

The Java SDK translates all datatypes native to SurrealQL into either datatypes native to Java, or a custom implementation. This document describes all datatypes, and links to their respective documentation.

## Data Types overview
{/* 
<table>
    <thead>
        <tr>
            <th colspan="1" scope="col">Datatype</th>
            <th colspan="1" scope="col">Kind</th>
            <th colspan="2" scope="col">Documentation</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="1" scope="row">String</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/String.html">
                    <code>String</code> on Oracle docs
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Number</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Long.html">
                    <code>long</code> on Oracle docs
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Float</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Double.html">
                    <code>double</code> on Oracle docs
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Bool</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Boolean.html">
                    <code>boolean</code> on Oracle docs
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Null</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row"></td>
        </tr>
        <tr>
            <td colspan="1" scope="row">None</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
				<a href="https://surrealdb.github.io/surrealdb.java/javadoc/com/surrealdb/Value.html#isNone()">
                	<code>Value#isNone()</code>
				</a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Array</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <a href="https://surrealdb.github.io/surrealdb.java/javadoc/com/surrealdb/Array.html">
                    <code>Array</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Object</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <a href="https://surrealdb.github.io/surrealdb.java/javadoc/com/surrealdb/Object.html">
                    <code>Object</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Datetime</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/time/ZonedDateTime.html">
                    <code>ZonedDateTime</code> on Oracle docs
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Binary</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Byte.html">
                	<code>byte\[\]</code>
				</a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Uuid</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/UUID.html">
                    <code>UUID</code> on Oracle docs
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Duration</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/time/Duration.html">
                    <code>Duration</code> on Oracle docs
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Geometry</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
				<a href="https://surrealdb.github.io/surrealdb.java/javadoc/com/surrealdb/Geometry.html">
					<code>Geometry</code>
				</a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Decimal</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
				<a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/math/BigDecimal.html">
					<code>BigDecimal</code> on Oracle docs
				</a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Table</td>
            <td colspan="1" scope="row">-</td>
            <td colspan="2" scope="row"></td>
        </tr>
        <tr>
            <td colspan="1" scope="row">RecordId</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
				<a href="https://surrealdb.github.io/surrealdb.java/javadoc/com/surrealdb/RecordId.html">
					<code>RecordId</code>
				</a>
            </td>
        </tr>
    </tbody>
</table> */}


================================================
FILE: src/content/doc-sdk-java/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Overview
title: Java | SDKs | Integration
description: The SurrealDB SDK for Java enables simple and advanced querying of a remote or embedded database.
---

import Version from '@components/Version.astro';
import Boxes from "@components/boxes/Boxes.astro";
import IconBox from "@components/boxes/IconBox.astro";
import Image from "@components/Image.astro";

import LightLogo from "@img/icon/light/java.png";
import DarkLogo from "@img/icon/dark/java.png";

<div class="flag-title">
	<Image
		alt="Java"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Java SDK
</div>

The SurrealDB SDK for Java is the primary SDK for interacting with SurrealDB from client or server-side applications, systems, and APIs. You can use the Java SDK to interact with your SurrealDB database instances, or to run SurrealDB as an embedded database within your Java application, with functionality for executing queries, managing data, running database functions, and authenticating to the database. When connecting to remote database instances, connections automatically reconnect when terminated.

> [!IMPORTANT]
> The SDK requires Java JDK version `8` or greater, and is available as a [Maven package](https://mvnrepository.com/artifact/com.surrealdb/surrealdb).

> [!NOTE]
> The SDK works seamlessly with SurrealDB versions `v2.0.0` to <Version />, ensuring compatibility with the latest version.

> [!WARNING]
> This API is not yet fully stabilized and may be subject to change until the SDK reaches `1.0.0`.

To contribute to the SDK code, submit an Issue or Pull Request in the [surrealdb.java](https://github.com/surrealdb/surrealdb.java) repository. To contribute to this documentation, submit an Issue or Pull Request in the [docs.surrealdb.com](https://github.com/surrealdb/docs.surrealdb.com) repository.

## Example projects

You can find example repositories that demonstrate how to integrate SurrealDB in a number of different environments:

<Boxes>
    <IconBox
        title="Java Starter"
        description="A simple starter project demonstrating the power of the SurrealDB Java SDK"
        href="https://github.com/surrealdb/examples/tree/main/java-starter"
    />
</Boxes>

## Sources

- [GitHub repository](https://github.com/surrealdb/surrealdb.java)
- [JavaDoc](https://surrealdb.github.io/surrealdb.java/javadoc/)
- [Maven package](https://mvnrepository.com/artifact/com.surrealdb/surrealdb)


================================================
FILE: src/content/doc-sdk-java/installation.mdx
================================================
---
sidebar_position: 2
sidebar_label: Installation
title: Java | SDKs | Installation
description: In this section, you will learn how to install the Java SDK in your project.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Installation

In this section, you will learn how to install the Java SDK in your project. 

### Install the SDK

First, install the [SurrealDB SDK](https://mvnrepository.com/artifact/com.surrealdb/surrealdb) from the Maven Central repository using [Gradle](https://gradle.org/) or [Maven](https://maven.apache.org/).


<Tabs groupId="java-build-tool">
  <TabItem value="gradle-groovy" label="Gradle (Groovy)" default>
```groovy
ext {
    surrealdbVersion = "0.2.1"
}

dependencies {
    implementation "com.surrealdb:surrealdb:${surrealdbVersion}"
}
```
  </TabItem>
  
  <TabItem value="gradle-kotlin" label="Gradle (Kotlin)">

```groovy
val surrealdbVersion by extra("0.2.1")

dependencies {
    implementation("com.surrealdb:surrealdb:${surrealdbVersion}")
}
```
  </TabItem>
  <TabItem value="maven" label="Maven">
```xml
<dependency>
    <groupId>com.surrealdb</groupId>
    <artifactId>surrealdb</artifactId>
    <version>0.2.1</version>
</dependency>
```
  </TabItem>
</Tabs>

<br />

### Import the SDK to your project

After installing, you can access the SDK by importing from the `com.surrealdb` package.

```java
import com.surrealdb.Surreal;

...

Surreal surreal = new Surreal();
```

In the Quick Start guide, you will learn how to create a new connection and authenticate users using the SDK.

## Next Steps

After installing the SDK, check out the quick start guide to build your a simple application with the SDK. You can also learn more about carrying out common tasks with the SDK in the following sections:
- [Quick Start](/docs/sdk/java/start)
- [Creating a new connection](/docs/sdk/java/core/create-a-new-connection)
- [Authenticating users](/docs/sdk/java/core/handling-authentication)



================================================
FILE: src/content/doc-sdk-java/start.mdx
================================================
---
sidebar_position: 3
sidebar_label: Quick start
title: Java | SDK | Quick start
description: In this guide, we will walk you through setting up and querying your first project with the SurrealDB SDK for Java.
---
import Image from "@components/Image.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

import QuickStartUI from "@img/quickstart-ui.png";

# Quick start

This guide will teach you the basics of using the SurrealDB SDK for Java to interact with a SurrealDB instance. We will cover topics such as installing the SDK, connecting to an in-memory database, and performing basic queries.
For demonstration purposes, the presented queries follow the example of a library database.

> [!IMPORTANT]
> You can find a working example project implementing the queries described in the guide in our [surrealdb-examples](https://github.com/surrealdb/examples/tree/main/java-starter) repository

## Prerequisites

This guide assumes the following:
- You have a basic understanding of Java and the Java Runtime Environment.
- You have Java 8 or higher installed on your machine.
- You have a suitable IDE installed, such as [IntelliJ IDEA](https://www.jetbrains.com/idea/) or [Eclipse](https://www.eclipse.org/).

## Setup

### Install the SDK

The SurrealDB Java SDK is available on the Maven Central repository. You can install it using [Gradle](https://gradle.org/) or [Maven](https://maven.apache.org/).
Copy the relevant code snippet into your `build.gradle` or `pom.xml` file to add the SDK as a dependency.

{/* The latest version of the SDK is currently <JavaVersion /> */}

<Tabs groupId="java-build-tool">
  <TabItem value="gradle-groovy" label="Gradle (Groovy)" default>
```groovy
ext {
    surrealdbVersion = "0.2.1"
}

dependencies {
    implementation "com.surrealdb:surrealdb:${surrealdbVersion}"
}
```
  </TabItem>
  <TabItem value="gradle-kotlin" label="Gradle (Kotlin)">
```groovy
val surrealdbVersion by extra("0.2.1")

dependencies {
    implementation("com.surrealdb:surrealdb:${surrealdbVersion}")
}
```
  </TabItem>
  <TabItem value="maven" label="Maven">
```xml
<dependency>
    <groupId>com.surrealdb</groupId>
    <artifactId>surrealdb</artifactId>
    <version>0.2.1</version>
</dependency>
```
  </TabItem>
</Tabs>

### Initialize the SDK

The first step towards sending queries is instantiating the driver. In the following example we use a try-with-resources block to ensure the driver is properly closed after use.
After instantiating the driver, we will connect to an in-memory database, and select our namespace and database.

```java title="SurrealDB.java"
package me.yourname.example;

import com.surrealdb.Surreal;

public class SurrealDB {

    public static void main(String[] args) {

		// Instantiate the driver
		try (final Surreal driver = new Surreal()) {
			// Connect to an in-memory database
			driver.connect("memory");

			// Select a namespace and database
			driver.useNs("example").useDb("example");

			// ...
		}
    }

}
```

### Defining model classes

In order to represent database records within your application, you need to define [POJO](https://wikipedia.org/wiki/Plain_old_Java_object) classes that match the tables in your database.
Additionally, model classes require a public no-argument constructor to be used with the SDK.

For this example, we will create a `Book` class representing book records in our database.

```java title="Book.java"
package me.yourname.surrealdb;

import com.surrealdb.RecordId;

import java.time.ZonedDateTime;

public class Book {
    public RecordId id;
    public String title;
    public String author;
    public ZonedDateTime publishedAt;
    public boolean available;

    //  A default constructor is required
    public Book() {
    }

    public Book(String title, String author, ZonedDateTime publishedAt, boolean available) {
        this.title = title;
        this.author = author;
        this.publishedAt = publishedAt;
        this.available = available;
    }

    @Override
    public String toString() {
        return "Book{" +
                "id=" + id +
                ", title='" + title + '\'' +
                ", author='" + author + '\'' +
                ", publishedAt=" + publishedAt +
                ", available=" + available +
                '}';
    }
}
```

Model classes are extremely useful as they can be used to represent more than just tables, such as complex query responses, relations, and more.
Additionally, the fields in model classes can contain nested objects, arrays, and other SurrealDB data types.

You can learn more about supported SurrealDB data types on the [data types](/docs/sdk/java/data-types) page.

## Using SDK methods

### Creating new records

The first step towards querying data is to populate the database with records. This can be achieved using the `create` method, which allows you to pass model class instances to create new records.

In the following example, we instantiate a new `Book` object and pass it to the `create` method. This method will return a list of created `Book` records, each with a unique record id.

```java
 // Create a new book
Book book = new Book(
	"Aeon's Surreal Renaissance",
	"Dave MacLeod",
	ZonedDateTime.parse("2024-10-15T00:00:00Z"),
	true
);

// Create a book record
Book created = driver.create(Book.class, "book", book).get(0);

// Print the record id
System.out.println("Created a new book with id " + created.id);
```

Since `create` allows us to create multiple records at once, it returns a list of books. In this case, we only created one book, so we use `.get(0)` to retrieve it.

You might also want to create records with a specific ID. In this case, you can pass the `RecordId` as the second argument to the `create` method.
This approach will return the `Book` instance directly instead of a list.

```java
// Create a book record with a custom id
Book created = driver.create(Book.class, new RecordId("book", "aeon"), book);
```

### Selecting records

Now we have records in our database, we can query them using the `select` method. This method allows you to retrieve either all records from a table, or select a single record by its ID.

```java
// Select all books
Iterator<Book> books = driver.select(Book.class, "book");

while (books.hasNext()) {
	System.out.println("Found book: " + books.next().title);
}

 // Select a specific book
Optional<Book> aeon = driver.select(Book.class, new RecordId("book", "aeon"));

aeon.ifPresent(value -> {
	System.out.println("Found book: " + value.title);
});
```

While the `select` method is useful for retrieving all records or a single record by ID, you may want to perform filtering, ordering, and other operations on your select queries.
In these situations you can use the `query` method to execute custom SurrealQL queries. We will cover this in the [Complex queries](#complex-queries) section.

### Updating records

Records can be updated using the `update` and `upsert` methods. These methods allow you to update all records of a table, or a single record by its ID.

In the following example we update the availability status of a book record. We pass the id of the record we want to update, the type of update we want to perform, and the updated record.
The `UpType.MERGE` parameter tells the SDK to merge the updated record with the existing record, keeping any fields that are not present in the updated record.

After the update is applied, a new `Book` instance is returned with the updated fields.

```java
// Modify an existing book record
existing.available = false;

// Update the book record
Book updated = driver.update(Book.class, existing.id, UpType.MERGE, existing);

// Print the book status
System.out.println("New availability: " + updated.available);
```

You can pass a table name instead of a record ID to update all records in a table. This will return an iterator of updated records.

```java
// Create an empty book instance
Book update = new Book();

update.available = true;

// Update all book records
Iterator<Book> updated = driver.update(Book.class, "book", UpType.MERGE, update);
```

As you can see, we can instantiate an empty `Book` object and set only the fields we want to update. This allows us to conveniently update only specific fields.

### Deleting records

Existing records can be deleted using the `delete` method. You can either pass a table name to delete all records in a table, or a record ID to delete a specific record.

```java
// Delete a specific book
driver.delete(new RecordId("book", "aeon"));

// Delete all book records
driver.delete("book");
```

### Relating records

The Java SDK makes it easy to define relations between records using the `relate` method. This method takes two `RecordId` instances, an edge name, and an optional value model.

This next example demonstrates how to relate a book to a publisher.

```java
RecordId bookId = new RecordId("book", "aeon");
RecordId publisherId = new RecordId("publisher", "surrealdb");

// Relate a book to a publisher
driver.relate(bookId, "published_by", publisherId);
```

Much like other methods, you can also pass a class reference as a first argument to control the return and value type. This class must be a subclass of `Relation`, or simply `Relation` itself.
This class holds the `id`, `in`, and `out` of a relation.

```java
Relation relation = driver.relate(Relation.class, bookId, "published_by", publisherId);
            
System.out.println("Related " + relation.in + " to " + relation.out + " with relation " + relation.id);
```

### Custom queries

While the previously mentioned methods are useful for basic operations, you may want to perform more complex queries. This can be achieved using the `query` method, which allows you to execute custom SurrealQL queries.

You can pass a query string to the `query` method and it will return a `Response` object containing the query results.

```java
Response response = driver.query("SELECT * FROM book WHERE available = true");

// Take the result of the first statement
Value result = response.take(0);
```

You can optionally pass parameters to the query by using the `queryBind` method, which takes a map of values to bind to the query.

```java
Response response = driver.queryBind(
	"SELECT * FROM book WHERE available = $status",
	Map.of("status", true)
);

// Take the result of the first statement
Value result = response.take(0);
```

## Using values

While we can represent object data using model classes, we can also use the `Value` class to represent SurrealDB data types directly.

In all previous examples we can omit the model class reference arguments to make methods return a `Value` instance instead of a model class instance.
This class provides useful functions to check and convert data types, as well as access nested objects and arrays.

```java
Value result = driver.query("RETURN 123").take(0);

// Check if the result is a long before casting
if (result.isLong()) {
	System.out.println("Long value: " + result.getLong());
}
```

## Next steps

Now that you have learned the basics of the SurrealDB SDK for Java, you can learn more about the API in the [API documentation](/docs/sdk/java/api-documentation) or explore the [data types](/docs/sdk/java/data-types) supported by the SDK.


================================================
FILE: src/content/doc-sdk-java/core/create-a-new-connection.mdx
================================================
---
sidebar_position: 1
sidebar_label: Create a new connection
title: Java | SDK | Create a new connection
description: The SurrealDB SDK for Java enables simple and advanced querying of a remote or embedded database.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";
import Label from "@components/shared/Label.astro";

# Create a new connection

The first step towards interacting with SurrealDB is to create a new connection to a database instance. This involves initializing a new instance of the `Surreal` class and connecting it to a database endpoint. You can then switch to a specific namespace and database, and pass required authentication credentials.

This guide will walk you through the process of creating a new connection to a SurrealDB instance using the Java SDK.

## Related Methods

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method">
				<a href="https://surrealdb.github.io/surrealdb.java/javadoc/com/surrealdb/Surreal.html#connect(java.lang.String)">
					<code> driver.connect(String url) </code>
				</a>
			</td>
			<td scope="row" data-label="Description">Connects to a local, remote, or embedded database endpoint</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method">
				<a href="https://surrealdb.github.io/surrealdb.java/javadoc/com/surrealdb/Surreal.html#close()">
					<code> driver.close() </code>
				</a>
			</td>
            <td scope="row" data-label="Description">Closes the persistent connection to the database</td>
        </tr>
		<tr>
			<td scope="row" data-label="Method">
				<a href="https://surrealdb.github.io/surrealdb.java/javadoc/com/surrealdb/Surreal.html#useNs(java.lang.String)">
					<code> driver.useNs(String namespace) </code>
				</a>
			</td>
			<td scope="row" data-label="Description">Switch to a specific namespace</td>
		</tr>
		<tr>
			<td scope="row" data-label="Method">
				<a href="https://surrealdb.github.io/surrealdb.java/javadoc/com/surrealdb/Surreal.html#useDb(java.lang.String)">
					<code> driver.useDb(String database) </code>
				</a>
			</td>
			<td scope="row" data-label="Description">Switch to a specific database</td>
		</tr>
	</tbody>
</table>

## Opening a connection

The `.connect()` method accepts a `String` pointing to the desired local or remote instance. Since the Java SDK supports running embedded databases, you can also specify an embedded endpoint such as `memory://` and `surrealkv://`.

### Supported protocols
This is the complete list of supported connection protocols

- `http://` - Plain HTTP
- `https://` - Secure HTTP
- `ws://` - Plain WebSocket
- `wss://` - Secure WebSocket
- `memory://` - In-memory database
- `surrealkv://` - Disk-based database
- `surrealkv+versioned://` - Disk-based database (with temporal data)

<br />

## Selecting a namespace and database

Depending on the complexity of your use case, you can switch to a specific namespace and database using the `.useNs()` and `.useDb()` methods. This is particularly useful if you want to switch to a different setup after connecting. You can also stay in the same namespace but switch to a different database. 

### Example usage
```java
driver.useNs("surrealdb").useDb("docs");
```

<br />

## Closing the connection

The `.close()` method closes the persistent connection to the database. You should always call this method when you are done with the connection to free up resources. You can use a try-with-resources block to ensure that the connection is closed automatically when the block is exited.

```java
// Close the connection manually
driver.close();

// Using try-with-resources
try (Surreal driver = new Surreal()) {
	// ...
}
```

<br />

## Example

Here is an example of the `.connect()`, `.useNs()`, `.useDb()`, and `.close()` methods in action.

```java title="Example.java"
package com.surrealdb.example;

import com.surrealdb.Surreal;

public class Example {

    public static void main(String[] args) {
        try (final Surreal driver = new Surreal()) {
            // Connect to an in-memory database
            driver.connect("memory");

            // Select a namespace and database
            driver.useNs("surrealdb").useDb("docs");
		}
	}

}
```


================================================
FILE: src/content/doc-sdk-java/core/handling-authentication.mdx
================================================
---
sidebar_position: 2
sidebar_label: Handle authentication
title: Java | SDK | Handle authentication
description: SurrealDB supports a number of methods for authenticating users and securing the database.
---

import Label from "@components/shared/Label.astro";
import Since from "@components/shared/Since.astro";
import Version from '@components/Version.astro';
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Handle authentication

Since SurrealDB is a database that is designed to be used in a distributed environment, it is important to secure the database and the data that is stored in it. SurrealDB provides a number of methods for authenticating users and securing the database.

In your SurrealDB database, you can configure authentication using the [`DEFINE USER`](/docs/surrealql/statements/define/user) or [`DEFINE ACCESS`](/docs/surrealql/statements/define/access) statements.

## Related Methods

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method">
				<a href="https://surrealdb.github.io/surrealdb.java/javadoc/com/surrealdb/Surreal.html#signin(com.surrealdb.signin.Signin)">
					<code> db.signin(Signin credentials) </code>
				</a>
			</td>
			<td scope="row" data-label="Description">Authenticate with provided credentials</td>
		</tr>
	</tbody>
</table>

## Authenticating a connection

You can call the `.signin()` method on a `Surreal` instance to authenticate with the database. The `signin` method takes any valid `Signin` implementation as an argument, which contains the credentials required to authenticate with the database.

The following `Signin` implementations are available:
- `new Root(String username, String password)`
- `new Namespace(String username, String password, String namespace)`
- `new Database(String username, String password, String namespace, String database)`

## Example

Here is an example of the `.signin()` methods in action.

```java title="Example.java"
package com.surrealdb.example;

import com.surrealdb.Surreal;
import com.surrealdb.signin.Database;
import com.surrealdb.signin.Namespace;
import com.surrealdb.signin.Root;

public class Example {

    public static void main(String[] args) {
        try (final Surreal driver = new Surreal()) {
          	driver.connect("wss://example.com");
            driver.useNs("example").useDb("example");

			// Authenticate as root user
			driver.signin(new Root("root", "secret"));

			// Authenticate as a namespace user
			driver.signin(new Namespace("root", "secret", "ns"));

			// Authenticate as a database user
            driver.signin(new Database("root", "secret", "ns", "db"));
		}
	}

}
```


================================================
FILE: src/content/doc-sdk-java/core/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: SDK Concepts
title: Java | SDK | Concepts
description: The SurrealDB SDK for Java enables simple and advanced querying of a remote or embedded database.
---

# Concepts 

In this section, we will go over the core concepts of the SurrealDB SDK for Java. You will learn how to connect to a SurrealDB instance, manage authentication, and interact with the database.

- [Create a new Connection](/docs/sdk/java/core/create-a-new-connection)
- [Handle authentication](/docs/sdk/java/core/handling-authentication)




================================================
FILE: src/content/doc-sdk-javascript/data-types.mdx
================================================
---
sidebar_position: 3
sidebar_label: Data Types
title:  Data Types | SDKs | Integration
description: The JavaScript SDK translates all datatypes native to SurrealQL into either datatypes native to JavaScript, or a custom implementation. This document describes all datatypes, and links to their respective documentation.
---

# Data Types

The JavaScript SDK translates all datatypes native to SurrealQL into either datatypes native to JavaScript, or a custom implementation. This document describes all datatypes, and links to their respective documentation.

## Data Types overview

<table>
    <thead>
        <tr>
            <th colspan="1" scope="col">Datatype</th>
            <th colspan="1" scope="col">Kind</th>
            <th colspan="2" scope="col">Documentation</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="1" scope="row">String</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">
                    <code>String</code> on MDN
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Number</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">
                    <code>Number</code> on MDN
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Float</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number">
                    <code>Number</code> on MDN
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Bool</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean">
                    <code>Boolean</code> on MDN
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Null</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null">
                    <code>null</code> on MDN
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">None</td>
            <td colspan="1" scope="row">
                Translated to `undefined`
            </td>
            <td colspan="2" scope="row">
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined">
                    <code>undefined</code> on MDN
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Array</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">
                    <code>Array</code> on MDN
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Object</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">
                    <code>Object</code> on MDN
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Datetime</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">
                    <code>Date</code> on MDN
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Binary</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">
                    <code>ArrayBuffer</code> on MDN
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Uuid</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[Uuid](#uuid)</code>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Duration</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[Duration](#duration)</code>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Geometry</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[Geometry](#geometry)</code>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Decimal</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[Decimal](#decimal)</code>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Table</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[Table](#table)</code>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">RecordId</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[RecordId](#recordid)</code>
            </td>
        </tr>
    </tbody>
</table>

<br /><br />

## `Uuid`

When you receive a uuid from SurrealDB, it will always be represented as a `Uuid` class.

```ts title="Signature"
new Uuid(uuid: string | ArrayBuffer | Uint8Array | Uuid)
```

### Create a `Uuid`

```ts
const uuid = new Uuid("159408af-2c23-4ac6-944d-75c3ed09e038");
```

### Generating a `Uuid`

```ts
const v4 = Uuid.v4();
const v7 = Uuid.v7();
```

### Convert to String or Binary

```ts
Uuid.v4().toString();
Uuid.v4().toUint8Array();
Uuid.v4().toArrayBuffer();
```



## `Duration`

When you receive a duration from SurrealDB, it will always be represented as a `Duration` class.

```ts title="Signature"
new Duration(duration: string | number)
```

### Create a `Duration`

```ts
// Parsed from a duration string
const dur = new Duration("1w2d");
// Input milliseconds
const dur = new Duration(1000);
// From a compact format ([ms, ns])
const dur = new Duration([10000, 300]);

// By a unit amount
const dur = Duration.nanoseconds(1000);
const dur = Duration.microseconds(1000);
const dur = Duration.milliseconds(1000);
const dur = Duration.seconds(1000);
const dur = Duration.minutes(1000);
const dur = Duration.hours(1000);
const dur = Duration.days(1000);
const dur = Duration.weeks(1000);
```

### Transform a `Duration`

```ts
const dur = new Duration("7d");

// Format as string, always as small as possible
dur.toString();     // 1w
// Get inner (float) milliseconds
dur._milliseconds;  // 604800000
// Get compact format
dur.toCompact();    // [604800]

// How many of a full unit fit into the duration
dur.nanoseconds;    // 604800000000000
dur.microseconds;   // 604800000000
dur.milliseconds;   // 604800000
dur.seconds;        // 604800
dur.minutes;        // 10080
dur.hours;          // 168
dur.days;           // 7
dur.weeks;          // 1
```

<br />

## `Geometry`

When I Geometry is sent back from SurrealDB, be it a `Point`, `LineString`, `Polygon`, `MultiPoint`, `MultiLineString`, `MultiPolygon` or `Collection`, it will be represented as a derivative of the `Geometry` class.

### Methods

Below, are all the methods implemented across all geometry derivatives.

#### `.toJSON()`

Used to convert a geometry to a GeoJSON representation

```ts title="Signature"
Geometry.toJSON()
```

```ts title="Example"
const line = new GeometryLine([
    new GeometryPoint([1, 2]),
    new GeometryPoint([3, 4]),
]);

line.toJSON();          // { type: "LineString", coordinates: [ [1, 2], [3, 4] ] }
JSON.stringify(line);   // '{ type: "LineString", coordinates: [ [1, 2], [3, 4] ] }'
```

#### `.is()`

Used to convert a check if geometry X is exactly equal to geometry Y

```ts title="Signature"
Geometry.is(geometry: Geometry)
```

```ts title="Example"
const point1 = new GeometryPoint([1, 2]);
const point2 = new GeometryPoint([3, 4]);
const line = new GeometryLine([point1, point2]);

point1.is(point1);      // true
point1.is(point2);      // false
point1.is(line);        // false

// Checks the inner values, does not need to be the same instance
const duplicate = new GeometryPoint([1, 2]);
point1.is(duplicate);   // true
```

#### `.clone()`

Used to deeply clone a geometry. Creates a new replica of the original instance, but changing the new instance won't affect the other.

```ts title="Signature"
Geometry.clone()
```

### Properties

#### `.coordinates`

A getter property, representing the coordinates as shown in GeoJSON format for X Geometry

```ts title="Signature"
Geometry.coordinates
```

### Derivatives

#### `GeometryPoint`

A [point](/docs/surrealql/datamodel/geometries#point) in space, made up of a long and lat coordinate, automatically converted to a float.

```ts title="Signature"
new GeometryPoint([long: number | Decimal, lat: number | Decimal]);
```

#### `GeometryLine`

A line, made up of two or more points

```ts title="Signature"
new GeometryLine([GeometryPoint, GeometryPoint, ...GeometryPoint[]]);
```

#### `GeometryPolygon`

A polygon, made up of self-closing lines

**Note**: The lines inside the polygon will automatically be closed if not already, meaning that the last point will be the same as the first.

```ts title="Signature"
new GeometryPolygon([GeometryLine, ...GeometryLine[]]);
```

#### `GeometryMultiPoint`

A collection of one or more points

```ts title="Signature"
new GeometryMultiPoint([GeometryPoint, ...GeometryPoint[]]);
```

#### `GeometryMultiLine`

A collection of one or more lines

```ts title="Signature"
new GeometryMultiLine([GeometryLine, ...GeometryLine[]]);
```

#### `GeometryMultiPolygon`

A collection of one or more polygons

```ts title="Signature"
new GeometryMultiPolygon([GeometryPolygon, ...GeometryPolygon[]]);
```

#### `GeometryCollection`

A collection of one or more `Geometry` derivatives

```ts title="Signature"
new GeometryCollection([Geometry, ...Geometry[]]);
```

<br />

## `Decimal`

Because Javascript does not support Decimals natively, our SDK represents them in a `Decimal` class as a string. This means if you want to work with Decimals, you will need to use an external library for this.

```ts title="Signature"
new Decimal(decimal: string | number | Decimal);
```

### Converting to string

```ts
const decimal = new Decimal("123.456");
decimal.toString(); // "123.456"
```

### Converting to JSON

A `Decimal` will be represented as a string in JSON to perserve accuracy

```ts
const decimal = new Decimal("123.456");
decimal.toJSON();        // "123.456"
JSON.stringify(decimal); // "123.456"
```

<br />

## `Table`

When you get a table name sent back from SurrealDB, it will be represented as a `Table` class.

```ts title="Signature"
new Table(table: string);
```

### Converting to string

```ts
const table = new Table("table");
table.toString();    // "table"
```

### Converting to JSON

A `Table` will be represented as a string in JSON

```ts
const table = new Table("table");
table.toJSON();        // "table"
JSON.stringify(table); // "table"
```

<br />

##  `RecordId`

When you receive a RecordId back from SurrealDB, it will always be represented as a `RecordId`. The class holds `tb` and `id` fields, representing the table name, and a unique identifier for the record on that table. A `RecordId` can be converted into a string, and will be represented as such when it's converted to JSON.

```ts title="Signature"
new RecordId<Tb extends string>(tb: Tb, id: RecordIdValue)
```

### Working with a `RecordId`

```ts title="Constructing"
// table is "person"
// unique identifier on the table is "john"
const rid = new RecordId("person", "john");
```

```ts title="Extracting data"
// Simple
const rid = new RecordId("person", "john");
rid.tb // "person"
rid.id // "john"

// Complex
const rid = new RecordId("recording", { city: "London", data: 123 });
rid.id      // { city: "London", data: 123 }
rid.id.city // "London"
rid.id.data // 123
```

### Convert to String

The JS SDK flawlessly and efficiently handles escaping the TB and ID parts in Record Id's into their string counterparts. Below are some examples

```ts title="Simple"
new RecordId('table', 123).toString();
// 'table:123'
new RecordId('table', 'abc').toString();
// 'table:abc'
```

```ts title="Complex characters"
new RecordId('table', '123').toString();
// 'table:`123`'
new RecordId('table', '123withletters').toString();
// 'table:123withletters'
new RecordId('table', 'complex-string').toString();
// 'table:`complex-string`'
new RecordId('table-name', 123).toString();
// '`table-name`:123'
```

```ts title="Objects and Arrays"
new RecordId('table', { city: "London" }).toString();
// 'table:{ city: "London" }'
new RecordId('table', ["London"]).toString();
// 'table:["London"]'
```

### Send back string

If you need to send back a Record Id in string format, you can do so with the `StringRecordId` class.

We do not implement the parsing of Record Ids in the JS SDK, as that would mean that we need to be able to parse any SurrealQL value, which comes with a cost. Instead you can send it over as a string with `StringRecordId`, allowing the server to handle the parsing.

```ts
new StringRecordId("person:john");
```


================================================
FILE: src/content/doc-sdk-javascript/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Overview
title: JavaScript | SDK | Overview
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Boxes from "@components/boxes/Boxes.astro";
import IconBox from "@components/boxes/IconBox.astro";
import Image from "@components/Image.astro";

import LightJavaScript from "@img/icon/light/javascript.png";
import LightNodejs from "@img/icon/light/nodejs.png";
import LightWasm from "@img/icon/light/webassembly.png";
import LightReact from "@img/icon/light/reactjs.png";
import LightNext from "@img/icon/light/nextjs.png";
import LightVue from "@img/icon/light/vuejs.png";
import LightAngular from "@img/icon/light/angular.png";
import LightSolid from "@img/icon/light/solidjs.png";
import LightSvelte from "@img/icon/light/svelte.png";

import DarkJavaScript from "@img/icon/dark/javascript.png";
import DarkNodejs from "@img/icon/dark/nodejs.png";
import DarkWasm from "@img/icon/dark/webassembly.png";
import DarkReact from "@img/icon/dark/reactjs.png";
import DarkNext from "@img/icon/dark/nextjs.png";
import DarkVue from "@img/icon/dark/vuejs.png";
import DarkAngular from "@img/icon/dark/angular.png";
import DarkSolid from "@img/icon/dark/solidjs.png";
import DarkSvelte from "@img/icon/dark/sveltejs.png";
import Version from '@components/Version.astro';

<div class="flag-title">
	<Image
		alt="JavaScript"
		width={42}
		height={42}
		src={{
			light: LightJavaScript,
			dark: DarkJavaScript,
		}}
	/>
	# JavaScript SDK
</div>

The SurrealDB SDK for JavaScript and TypeScript is the primary SDK for interacting with SurrealDB from frontend and server-side applications, systems, and APIs. It is designed to be used in a number of environments, including browser-based applications, server-side applications, and serverless functions. You can use the JavaScript SDK to interact with your SurrealDB database instances, or to run SurrealDB as an embedded database within your JavaScript based application, with functionality for executing queries, managing data, running database functions, authenticating to the database, building user signup and authentication functionality, and subscribing to data changes with live queries.

> [!IMPORTANT]
> The SDK is available as a [NPM](https://npmjs.com/package/surrealdb) and a [JSR](https://jsr.io/@surrealdb/surrealdb) package, with full support for TypeScript types.

> [!NOTE]
> The SDK works seamlessly with SurrealDB versions `v2.0.0` to <Version />, ensuring compatibility with the latest version.

To contribute to the SDK code, submit an Issue or Pull Request in the [surrealdb.js](https://github.com/surrealdb/surrealdb.js) repository. To contribute to this documentation, submit an Issue or Pull Request in the [docs.surrealdb.com](https://github.com/surrealdb/docs.surrealdb.com) repository.

## Language and Engines

<Boxes>
    <IconBox
        title="JavaScript"
        status="available"
        href="/docs/sdk/javascript/core/create-a-new-connection"
        icon={{
                light: LightJavaScript,
                dark: DarkJavaScript,
        }}
    />
    {/* <IconBox
        title="TypeScript"
        status="available"
        href="/docs/sdk/javascript/core/create-a-new-connection"
        icon={{
                light: LightTypescript,
                dark: DarkTypescript,
        }}
    /> */}
    <IconBox
        title="Node.js"
        status="available"
        href="/docs/sdk/javascript/engines/node"
        icon={{
                light: LightNodejs,
                dark: DarkNodejs,
        }}
    />
    <IconBox
        title="WebAssembly"
        status="available"
        href="/docs/sdk/javascript/engines/wasm"
        icon={{
                light: LightWasm,
                dark: DarkWasm,
        }}
    />
</Boxes>

## Frameworks

<Boxes>
    <IconBox
        title="React"
        href="/docs/sdk/javascript/frameworks/react"
        status="available"
        icon={{
            light: LightReact,
            dark: DarkReact,
        }}
    />
    <IconBox
        title="Solid.js"
        href="/docs/sdk/javascript/frameworks/solidjs"
        status="available"
        icon={{
            light: LightSolid,
            dark: DarkSolid,
        }}
    />
    <IconBox
        title="Next.js"
        status="coming soon"
        icon={{
            light: LightNext,
            dark: DarkNext,
        }}
    />
    <IconBox
        title="Vue.js"
        status="coming soon"
        icon={{
            light: LightVue,
            dark: DarkVue,
        }}
    />
    <IconBox
        title="Angular"
        status="coming soon"
        icon={{
            light: LightAngular,
            dark: DarkAngular,
        }}
    />
    <IconBox
        title="Svelte"
        status="coming soon"
        icon={{
            light: LightSvelte,
            dark: DarkSvelte,
        }}
    />
</Boxes>

## Example projects

You can find example repositories that demonstrate how to integrate SurrealDB in a number of different environments:

<Boxes>
    <IconBox
        title="Surreal Stickies (React)"
        description="A simple note-taking application built with SurrealDB, React, and Vite."
        href="https://github.com/surrealdb/examples/tree/main/notes-v2"
    />

     <IconBox
        title="Surreal Stickies (SvelteKit)"
        description="A simple note-taking application built with SurrealDB, SvelteKit, and Vite."
        href="https://github.com/surrealdb/examples/tree/main/notes-kit"
    />

    <IconBox
        title="Surreal Presence (React)"
        description="A demo project on how to create a realtime presence web application using SurrealDB Live Queries."
        href="https://github.com/Odonno/surrealdb-presence-demo"
    />

    <IconBox
        title="TypeScript Starter"
        description="A simple TypeScript starter project using Bun."
        href="https://github.com/surrealdb/examples/tree/main/ts-bun-starter"
    />
</Boxes>

## Sources

- [GitHub repository](https://github.com/surrealdb/surrealdb.js)
- [NPM package](https://npmjs.com/package/surrealdb)
- [JSR package](https://jsr.io/@surrealdb/surrealdb)



================================================
FILE: src/content/doc-sdk-javascript/installation.mdx
================================================
---
sidebar_position: 2
sidebar_label: Installation
title: JavaScript SDK Installation | SDKs | Installation
description: In this section, you will learn how to install the JavaScript SDK in your project.
---

# Installation

In this section, you will learn how to install the JavaScript SDK in your project. 

### Install the SDK

First, install the [SurrealDB SDK](https://npmjs.com/package/surrealdb) using your favorite package manager:

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

<Tabs groupId="node-package-manager">
  <TabItem value="bun" label="bun">
    ```bash
    bun install surrealdb
    ```
  </TabItem>
  <TabItem value="npm" label="npm" default>
    ```bash
    npm install --save surrealdb
    ```
  </TabItem>
  <TabItem value="yarn" label="yarn">
    ```bash
    yarn add surrealdb
    ```
  </TabItem>
  <TabItem value="pnpm" label="pnpm">
    ```bash
    pnpm install surrealdb
    ```
  </TabItem>
</Tabs>

> [!IMPORTANT]
> The SurrealDB SDK for JavaScript is also available in the JSR registry as [`@surrealdb/surrealdb`](https://jsr.io/@surrealdb/surrealdb).

<br />

### Import the SDK to your project

After installing, you can then import the SDK into your project. Depending on your setup and environment, we supported multiple options.

<Tabs groupId="node-package-manager">
<TabItem value="es6" label="ES6" default>

```ts
import Surreal from 'surrealdb';
```

</TabItem>
<TabItem value="bun" label="CommonJS" >

```ts
const { Surreal } = require('surrealdb');
```

</TabItem>
<TabItem value="deno" label="Deno">

```ts
//Importing from Deno
import Surreal from "https://deno.land/x/surrealdb/mod.ts";

// Import with version 
import Surreal from "https://deno.land/x/surrealdb@1.0.0/mod.ts";
```

</TabItem>
  <TabItem value="CDN" label="CDN">

```ts
import Surreal from "https://unpkg.com/surrealdb";
// or
import Surreal from "https://cdn.jsdelivr.net/npm/surrealdb";
```

  </TabItem>
</Tabs>

> [!NOTE]
> It is recommended to import this in a utility file or a file that is shared across your application.


## Next Steps

After installing the SDK, check out the quick start guide to build your a simple application with the SDK. You can also learn more about carrying out common tasks with the SDK in the following sections:
- [Quick Start](/docs/sdk/javascript/start)
- [Creating a new connection](/docs/sdk/javascript/core/create-a-new-connection)
- [Authenticating users](/docs/sdk/javascript/core/handling-authentication)



================================================
FILE: src/content/doc-sdk-javascript/properties.mdx
================================================
---
sidebar_position: 4
sidebar_label: Properties
title: JavaScript | SDKs | Properties
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

# SDK methods

The SurrealDB SDK for JavaScript has a single SurrealDB class that provides methods for querying a remote SurrealDB database.
The class is designed to be simple to use and easy to understand for developers who are new to JavaScript or SurrealDB.
This page lists out the methods that are available in the SurrealDB class.

## Available properties

<table>
	<thead>
		<tr>
			<th scope="col">Property</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#ready"> <code> db.ready </code></a></td>
			<td scope="row" data-label="Description">A promise which can be awaited, resolves when the connection is established</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#status"> <code> db.status </code></a></td>
            <td scope="row" data-label="Description">Reports the current connection status</td>
        </tr>
		<tr>
			<td scope="row" data-label="Method"><a href="#emitter"> <code> db.emitter </code></a></td>
			<td scope="row" data-label="Description">Stores the event emitter used for communication within the SDK</td>
		</tr>
	</tbody>
</table>

## `db.ready` {#ready}

A promise which can be awaited, resolves when the connection is established. 

> [!NOTE]
> This property is available once you call the `.connect()` method.

```ts
const db = new Surreal();

// These two promises are the same
const promise1 = db.connect();
const promise2 = db.ready;
```



## `db.status` {#status}

Reports the current connection status. Can be any of the following in string format:
- `disconnected`
- `connecting`
- `connected`
- `error`

```ts
db.status; // "disconnected"

db.connect();
db.status; // "connecting"

await db.ready;
db.status; // "connected"

// Once an error in the connection occurs
db.status; // "error"
```



## `db.emitter` {#emitter}

Stores the event emitter used for communication within the SDK.
The following general events can occur:
- `disconnected` - No arguments passed
- `connecting` - No arguments passed
- `connected` - No arguments passed
- `error` - An `Error` instance will be passed

The following events are intended for internal use only:
- `rpc-${string | number}` - An `RcpResponse` or `EngineDisconnected` instance will be passed
- `live-${string}` - Returns either of the following arguments
  - A `LiveAction`, being `"CREATE" | "UPDATE" | "DELETE"`, and a `Result` - being an object or patch
  - Or `"CLOSE"`, and a reason being `"killed" | "disconnected"` 

```ts title="Subscribe to events continuesly"
function listener(error: Error) {
    console.error("An error occurred:", error);
}

// Listen for the event
db.emitter.subscribe("error", listener);
// Check if the listener is subscribed
db.emitter.isSubscribed("error", listener);
// Unsubscribe the listener
db.emitter.unSubscribe("error", listener);
```

```ts title="Subscribe to an event once"
const disconnectedPromise = db.emitter.subscribeOnce("disconnected");
const connectingPromise = db.emitter.subscribeOnce("connecting");
const connectedPromise = db.emitter.subscribeOnce("connected");
const errorPromise = db.emitter.subscribeOnce("error");
```


================================================
FILE: src/content/doc-sdk-javascript/start.mdx
================================================
---
sidebar_position: 2
sidebar_label: Quick start
title: JavaScript | SDK | Quick start
description: In this guide, we will walk you through setting up and querying your first project with the SurrealDB SDK for JavaScript.
---
import Image from "@components/Image.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";
import QuickStartUI from "@img/quickstart-ui.png";

# Quick start

In this guide, we will walk you through setting up and querying your first project with the SDK. You will learn how to install, import, and initialize the SDK, as well as perform some queries. 
This guide is written in TypeScript, but the SDK is also compatible with JavaScript. 


> [!IMPORTANT]
> If you want to see the final project for this guide, you can find it in the [surrealdb-examples](https://github.com/surrealdb/examples/tree/main/ts-bun-starter) repository and follow the instructions in the `README.md` file to get the project running.

Here is the final folder structure:

```bash
my-surrealdb-project/
├── src/
│   ├── start-db.ts
│   ├── create-user.ts
│   ├── query-user.ts
│   ├── update-user.ts
│   ├── delete-user.ts
│   ├── index.ts
└── utils/
    └── surreal.ts
```

## Prerequisites

This guide assumes the following:
- You have a basic understanding of TypeScript or JavaScript.
- You have an install version of SurrealDB `>1.4.2` installed on your machine.

## Setup your project

In your terminal, create a new directory for your project and navigate into it:

```bash
# Make a new directory
mkdir my-surrealdb-project
# Navigate into the directory
cd my-surrealdb-project
```

Next, initialize a new project. This creates a `package.json` file within your project directory without prompting for input.

You can initialize a new project with any package manager. For this guide, we will use [Bun](https://bun.sh/).



<Tabs groupId="node-package-manager">
<TabItem value="bun" label="Bun" default>

```bash
bun init -y
```

</TabItem>
  <TabItem value="npm" label="NPM">

```bash
npm init -y
```

  </TabItem>
  <TabItem value="yarn" label="Yarn">

```bash
yarn init -y
```

  </TabItem>
  <TabItem value="pnpm" label="PNPM">

```bash
pnpm init -y
```
  </TabItem>
</Tabs>

Next, open your project in your IDE. For this guide, we will use [Visual Studio Code](https://code.visualstudio.com/).

### Install the SDK

Now that you have initialized your project, you can install and import the SDK into your created project. 

From your terminal, in your project directory, install the [SDK](https://npmjs.com/package/surrealdb) using any of the following package managers (we recommend using bun for this guide):

<Tabs groupId="node-package-manager">
<TabItem value="bun" label="Bun" default>

```bash
bun add surrealdb
```

  </TabItem>
  <TabItem value="npm" label="NPM">

```bash
npm install --save surrealdb
```

  </TabItem>
  <TabItem value="yarn" label="Yarn">

```bash
yarn add surrealdb
```

  </TabItem>
  <TabItem value="pnpm" label="PNPM">

```bash
pnpm install surrealdb
```

  </TabItem>
</Tabs>

> [!IMPORTANT]
> The SurrealDB SDK for JavaScript is also available in the JSR registry as [`@surrealdb/surrealdb`](https://jsr.io/@surrealdb/surrealdb).


<br />

### Initialize the SDK

After installing, you can then import the SDK into your project. Depending on your setup and environment, we support multiple options. For the sake of this guide, we will use ES6 syntax.


<Tabs groupId="node-package-manager">
<TabItem value="es6" label="ES6" default>

```ts
import Surreal from 'surrealdb';
```

</TabItem>
<TabItem value="bun" label="CommonJS" >

```ts
const { Surreal } = require('surrealdb');
```

</TabItem>
<TabItem value="deno" label="Deno">

```ts
//Importing from Deno
import Surreal from "https://deno.land/x/surrealdb/mod.ts";

// Import with version 
import Surreal from "https://deno.land/x/surrealdb@1.0.0/mod.ts";
```

</TabItem>
  <TabItem value="CDN" label="CDN">

```ts
import Surreal from "https://unpkg.com/surrealdb";
// or
import Surreal from "https://cdn.jsdelivr.net/npm/surrealdb";
```

  </TabItem>
</Tabs>

> [!NOTE]
> It is recommended to import this in a utility file or a file that is shared across your application.


In the root of your project, create a `utils` folder and create a `surreal.ts` file. This file will contain the SDK initialization logic which manages the connection to the database using the [`connect`](/docs/sdk/javascript/methods/connect), [`use`](/docs/sdk/javascript/methods/use), and [`close`](/docs/sdk/javascript/methods/close) methods.

In the created `surreal.ts` utility file, you can initialize the SDK as follows:

```ts title="utils/surreal.ts"
import Surreal from "surrealdb";

// Define the database configuration interface
interface DbConfig {
  url: string;
  namespace: string;
  database: string;
}

// Define the default database configuration
const DEFAULT_CONFIG: DbConfig = {
  url: "http://127.0.0.1:8000/rpc",
  namespace: "test",
  database: "test",
};

// Define the function to get the database instance
export async function getDb(config: DbConfig = DEFAULT_CONFIG): Promise<Surreal> {
  const db = new Surreal();

  try {
    await db.connect(config.url);
    await db.use({ namespace: config.namespace, database: config.database });
    return db;
  } catch (err) {
    console.error("Failed to connect to SurrealDB:", err instanceof Error ? err.message : String(err));
    await db.close();
    throw err;
  }
}
```

### Start the Database

Next, create a `src` folder in the root of your project and add a `start-db.ts` file. This file will contain the logic to start the database.

Usually, you can start a new instance of SurrealDB using the `surreal start` command. However, for the sake of this guide, we will use a function to start the database so that we can interact with the database in the browser.

This function uses the `spawn` method to start the database. Learn more about the `spawn` method [in the Node.js documentation](https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options).

In the created `start-db.ts` file, add the following code:

```ts title="src/start-db.ts"
import { spawn } from "child_process";

console.log("Starting SurrealDB...");

const surrealProcess = spawn("surreal", ["start", "--unauthenticated"], {
  stdio: "inherit",
});

surrealProcess.on("error", (error) => {
  console.error("Failed to start SurrealDB:", error.message);
});

surrealProcess.on("exit", (code) => {
  if (code === 0) {
    console.log("SurrealDB process exited successfully");
  } else {
    console.error(`SurrealDB process exited with code ${code}`);
  }
});

// Keep the script running
process.stdin.resume();
```
> [!IMPORTANT]
> We are starting the database in unauthenticated mode for the sake of this guide. In a production environment, you should start the database in authenticated mode.

You can still choose to start the database in your terminal and skip this step. See the [Surreal start command documentation](/docs/surrealdb/cli/start) for more information.


## Using SDK methods

Now that you have initialized the SDK, you can use it to connect to the database, using the specified [namespace](/docs/surrealdb/introduction/concepts/namespace) and [database](/docs/surrealdb/introduction/concepts/database), to perform queries anywhere in your application by calling the `getDb` function. 


### Create a new user
Create a new `src` folder and add `create-user.ts` file. This file will contain the logic to create a new user in the database. We will use the [`create`](/docs/sdk/javascript/methods/create) method to make a new user in the database. 

First, import the `getDb` function from the `surreal.ts` utility file. You can also import the `jsonify` class from the SDK to format the output. Next, create a new user record in the database. See the code below:

```ts title="src/create-user.ts"
import { getDb } from "../utils/surreal";
import { jsonify } from "surrealdb";

interface User {
  username: string;
  email: string;
  password: string;
}

async function createUser(): Promise<void> {
  const db = await getDb();
  // Check if the database is initialized
  if (!db) {
    console.error("Database not initialized");
    return;
  }
  // Create a new user
  try {
    const user = await db.create<User>("User", {
      // User details
      username: "newUser",
      email: "user@example.com",
      password: "securePassword", // Note: Store hashed passwords, not plain text
    });
    // Log the created user
    console.log("User created:", jsonify(user));
  } catch (err: unknown) {
    console.error("Failed to create user:", err instanceof Error ? err.message : String(err));
  } finally {
    // Close the database connection
    await db.close();
  }
}

createUser();
```

### Select user

In the `src` folder, add `query-user.ts` file. This file will contain the logic to query a user in the database. We will use the [`select`](/docs/sdk/javascript/methods/select) method to get all users in the database.

```ts title="src/query-user.ts"
import { getDb } from "../utils/surreal";
import { jsonify } from "surrealdb";

interface User {
  id: string;
  // Add other user properties here
}

export async function getAllUsers(): Promise<User[] | undefined> {
  const db = await getDb();
  if (!db) {
    console.error("Database not initialized");
    return undefined;
  }
  try {
    const users = await db.select<User>("User");
    console.log("All users:", jsonify(users));
    return users;
  } catch (err) {
    console.error("Failed to get users:", err);
    return undefined;
  } finally {
    await db.close();
  }
}

getAllUsers();
```
> [!NOTE]
> You can also specify a specific user to query by using the [`RecordId`](/docs/sdk/javascript/data-types#recordid) datatype. Learn more about the [`select`](/docs/sdk/javascript/methods/select) method [in the Data Types section](/docs/sdk/javascript/data-types).


### Update a user

In the `src` folder, add `update-user.ts` file. This file will contain the logic to update a user in the database. We will use the [`update`](/docs/sdk/javascript/methods/update) method to update a user in the database. 

In the example below, we will update the username and email of a user with the RecordId `nsg3k2he7mhxa8hk5qdu`. You may notice that we use a `RecordId` to specify the user information. 

Learn more about the [`RecordId`](/docs/sdk/javascript/data-types#recordid) datatype [in the Data Types section](/docs/sdk/javascript/data-types).

```ts title="src/update-user.ts"
import { getDb } from "../utils/surreal";
import { jsonify, RecordId } from "surrealdb";

// Type definition (you may want to move this to a separate types file)
interface User {
    id: RecordId;
    username: string;
    password: string;
    email: string;
}

export async function updateUser() {
  const db = await getDb();
  if (!db) {
    console.error("Database not initialized");
    return;
  }
  try {
    // Assuming the record id is nsg3k2he7mhxa8hk5qdu
    const updatedUser = await db.update(new RecordId("User", "nsg3k2he7mhxa8hk5qdu"), {
        username: "John Doe",
        email: "john@example.com",
    });
    console.log("Updated user:", jsonify(updatedUser));
    return updatedUser;
  } catch (err) {
    console.error("Failed to update user:", err);
  } finally {
    await db.close();
  }
}

// Example usage for specific user

updateUser();
```

### Delete a user

In the `src` folder, add `delete-user.ts` file. This file will contain the logic to delete a user in the database. We will use the [`delete`](/docs/sdk/javascript/methods/delete) method to delete the user. 

Since we are working with a single user, we will pass the `User` type as the parameter. For a more specific use case, you can use the `RecordId` datatype to delete a specific user.

Learn more about the [`RecordId`](/docs/sdk/javascript/data-types#recordid) datatype [in the Data Types section](/docs/sdk/javascript/data-types).

```ts title="src/delete-user.ts"
import { jsonify } from "surrealdb";
import { getDb } from "../utils/surreal";

export async function deleteUser() {
  const db = await getDb();
  if (!db) {
    console.error("Database not initialized");
    return;
  }
  try {
    const deletedUser = await db.delete('User');
    console.log("Deleted user:", jsonify(deletedUser));
    return deletedUser;
  } catch (err) {
    console.error("Failed to delete user:", err);
  } finally {
    await db.close();
  }
}

deleteUser();
```

## Interact with the Scripts

Finally, we will simulate a simple UI to interact with the scripts we created above. Usually this can be replaced with any framework of your choice. In the created `src` folder, add `index.ts` file and add the following code:

```ts title="src/index.ts"
import { serve, spawnSync } from "bun";
// biome-ignore lint/style/useNodejsImportProtocol: <explanation>
import { join } from "path";
import { cwd } from "process";
import { existsSync } from "fs";

// Helper function to run the script
function executeScript(scriptName: string) {
  // Get the current working directory and resolve the script path
  const scriptPath = join(cwd(), "src", `${scriptName}-user.ts`);

  // Check if the script file exists
  if (!existsSync(scriptPath)) {
    return `Error: Script file "${scriptName}-user.ts" not found in the src directory.`;
  }

  const result = spawnSync(["bun", scriptPath], {
    stdout: "pipe",
    stderr: "pipe",
  });

  if (result.success) {
    return result.stdout.toString();
  }
  return `Error executing script: ${result.stderr.toString()}`;
}

// Start the server
serve({
  port: 3000,
  fetch(req) {
    const url = new URL(req.url);
    const script = url.searchParams.get("script");

    if (script) {
      const output = executeScript(script);
      return new Response(output, {
        headers: { "Content-Type": "text/plain" },
      });
    }

    // Serve HTML UI with buttons
    return new Response(
      `
   <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Script Runner</title>
        <style>
          body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
          }
          .container {
            background-color: #ffffff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
          }
          h1 {
            color: #333;
          }
          .button {
            background-color: #ff00a0;
            color: #ffffff;
            border: none;
            padding: 10px 20px;
            margin: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
          }
          .button:hover {
            background-color: #007bff;
          }
          #output {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin-top: 20px;
            text-align: left;
            white-space: pre-wrap;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <h1>Interact with Scripts</h1>
          <button class="button" onclick="runScript('surreal')">Start Database</button>
          <button class="button" onclick="runScript('create')">Run Create Script</button>
          <button class="button" onclick="runScript('delete')">Run Delete Script</button>
          <button class="button" onclick="runScript('select')">Run Select Script</button>
          <button class="button" onclick="runScript('update')">Run Update Script</button>
          <pre id="output"></pre>
        </div>
        <script>
          function runScript(script) {
            fetch(\`/?script=\${script}\`)
              .then(response => response.text())
              .then(text => {
                document.getElementById('output').textContent = text;
              })
              .catch(error => {
                document.getElementById('output').textContent = 'Error: ' + error;
              });
          }
        </script>
      </body>
      </html>
      `,
      { headers: { "Content-Type": "text/html" } }
    );
  },
});
```

To initialize the server, run the following command:

```bash
bun run src/index.ts
```

You can now interact with the scripts by navigating to `http://localhost:3000` in your browser. 

<Image
  alt="SurrealDB SDK for JavaScript"
  src={QuickStartUI}
/>

## Next steps

Now that you have learned the basics of the SurrealDB SDK for JavaScript, you can learn more about the SDK and its methods [in the methods section](/docs/sdk/javascript/methods) and [data types section](/docs/sdk/javascript/data-types).


================================================
FILE: src/content/doc-sdk-javascript/core/create-a-new-connection.mdx
================================================
---
sidebar_position: 1
sidebar_label: Create a new connection
title: JavaScript | SDK | Create a new connection
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";
import Label from "@components/shared/Label.astro";

# Create a new connection

When creating a new connection to a SurrealDB instance, you can choose to connect to a local or remote endpoint, specify a namespace and database pair to use, authenticate with an existing token, authenticate using a pair of credentials, or use advanced custom logic to prepare the connection to the database.

First, you need to initialize a new instance of the Surreal class and connect it to a database endpoint using the `.connect()` method. Then you can specify the connection details such as the URL, namespace, and database. 


## Related Methods and Properties

While the `.connect()` method is the primary method to connect to a SurrealDB instance, there are other methods that you can use while managing your connection.

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/connect"> <code> db.connect(url, options) </code></a></td>
			<td scope="row" data-label="Description">Connects to a local or remote database endpoint</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/core/create-a-new-connection#close"> <code> db.close() </code></a></td>
            <td scope="row" data-label="Description">Closes the persistent connection to the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/core/create-a-new-connection#ready"> <code> db.ready </code></a></td>
			<td scope="row" data-label="Description">Waits for the connection to the database to succeed</td>
		</tr>
		<tr>
			<td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/use"> <code> db.use(namespace,database)</code></a></td>
			<td scope="row" data-label="Description">Switch to a specific namespace and database</td>
		</tr>
	</tbody>
</table>

## `.connect()` {#connect}

The `.connect()` method accepts a `url` and an `options` object. In the `options` object, you can specify the `namespace` and `database` to use, as well as the `auth` details which can be a token or a pair of credentials. 

This means that the `.use()` method is not required if you specify the [`namespace`](/docs/surrealdb/introduction/concepts/namespace) and [`database`](/docs/surrealdb/introduction/concepts/database) in the `options` object.  However, if you want to switch to a different namespace or database, you should use the [`.use()`](/docs/sdk/javascript/methods/use) method. Depending on the use case, you can also specify advanced custom logic for the connection.

### Connection options

You can specify your connection protocol either as `http`, `https`, `ws`, or `wss`. Since SurrealDB also supports RPC over WebSocket, by default, it is specified with a `/rpc` suffix. 

<Tabs groupId="connection-options">
<TabItem value="local" label="Local endpoint" default>
  ```ts
  // Connect to a local endpoint with http protocol
await db.connect('http://127.0.0.1:8000/rpc');

 // Connect to a local endpoint with ws protocol
await db.connect('ws://127.0.0.1:8000/rpc');
```
</TabItem>
<TabItem value="remote" label="Remote endpoint">
  ```ts
  // Connect to a remote endpoint with http protocol
await db.connect('https://cloud.surrealdb.com/rpc');

 // Connect to a remote endpoint with ws protocol
await db.connect('wss://cloud.surrealdb.com/rpc');
```
</TabItem>
<TabItem value="ns-db" label="Namespace and database">
```ts
// Specify a namespace and database pair to use with https protocol
await db.connect('https://cloud.surrealdb.com/rpc', {
	namespace: 'surrealdb',
	database: 'docs',
});

// Specify a namespace and database pair to use with wss protocol
await db.connect('wss://cloud.surrealdb.com/rpc', {
	namespace: 'surrealdb',
	database: 'docs',
});
```
</TabItem>
<TabItem value="token" label="Token">
```ts
// Authenticate with an existing token
// The .authenticate() function is used under the hood.
await db.connect('https://cloud.surrealdb.com/rpc', {
	auth: '.....',
});
```
</TabItem>
<TabItem value="credentials" label="Credentials">
```ts
// Authenticate using a pair of credentials
await db.connect('https://cloud.surrealdb.com/rpc', {
	auth: {
		username: 'root',
		password: 'surrealdb',
	},
});
```
</TabItem>
<TabItem value="custom" label="Custom logic">
```ts
// Use advanced custom logic to prepare the connection to the database
await db.connect('https://cloud.surrealdb.com/rpc', {
	prepare: async (db) => {
		await db.use({ namespace: 'surrealdb', database: 'docs' });

		const token = await retrieveToken();
		if (token) await db.authenticate(token);

		// Any queries executed before the .prepare() function finishes will be forced to wait
		// Please note that this is also the case for queries executed within the prepare function
		// Doing so can cause the connection to stay in a initializing state
	},
});
```
</TabItem>
</Tabs>

### Effect of connection protocol on token & session duration

The connection protocol you choose affects how authentication tokens and sessions work:

With websockets connections (`ws://`, `wss://`) you open a single long-lived stateful connection where after the initial authentication, the session duration applies and if not specified, defaults to `NONE` meaning that the session never expires unless otherwise specified. 

When you connect with a HTTP connection (`http://`, `https://`), every request you make is short-lived and stateless, requiring you to authenticate every request individually for which the token is used, creating a short lived session. Hence, the token duration which defaults to 1 hour applies.

You can extend the session duration of a token or a session by setting the `DURATION` clause when creating a new access method with the [`DEFINE ACCESS METHOD`](/docs/surrealql/statements/define/access) statement or when defining a new user with the [`DEFINE USER`](/docs/surrealql/statements/define/user) statement. 

Learn more about token and session duration in our [security best practices](/docs/surrealdb/reference-guide/security-best-practices#expiration) documentation.

<br />

## `.use()` {#use}

Depending on the complexity of your use case, you can switch to a specific namespace and database using the `.use()` method. This is particularly useful if you want to switch to a different setup after connecting. You can also stay in the same namespace but switch to a different database. 

Learn more about the `.use()` method [in the methods section](/docs/sdk/javascript/methods/use).

### Example usage
```ts
await db.use({ namespace: 'surrealdb', database: 'docs' });
```

<br />

## `.ready` property {#ready}

The `.ready` propery is used to wait for the connection to the database to succeed. This is particularly useful if you want to ensure that the connection is established before executing any queries.

> [!IMPORTANT]
> Use this property after `.connect()` to ensure that the connection is established before executing any queries.
```ts
await db.ready;
```

<br />

## `.close()` {#close}

The `.close()` method closes the persistent connection to the database. You should always call this method when you are done with the connection to free up resources.

```ts
await db.close();
```


## Example

Here is an example of the `.connect()`, `.use()`, `.ready`, and `.close()` methods in action.

```ts title="Example"
import Surreal from "surrealdb";

// Define the database configuration interface
interface DbConfig {
  url: string;
  namespace: string;
  database: string;
}

// Define the default database configuration
const DEFAULT_CONFIG: DbConfig = {
  url: "http://127.0.0.1:8000/rpc",
  namespace: "test",
  database: "test",
};

// Define the function to get the database instance
export async function getDb(config: DbConfig = DEFAULT_CONFIG): Promise<Surreal> {
  const db = new Surreal();

  try {
    await db.connect(config.url);
    await db.use({ namespace: config.namespace, database: config.database });
    return db;
  } catch (err) {
    console.error("Failed to connect to SurrealDB:", err instanceof Error ? err.message : String(err));
    await db.close();
    throw err;
  }
}
```



================================================
FILE: src/content/doc-sdk-javascript/core/data-maniplulation.mdx
================================================
---
sidebar_position: 4
sidebar_label: Data manipulation
title: JavaScript | SDK | Data manipulation
description: SurrealDB supports a number of methods for interacting with the database and performing CRUD operations.
---

import Label from "@components/shared/Label.astro";

# Data manipulation

SurrealDB supports a number of methods for interacting with the database and performing CRUD operations.

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#select"> <code> db.select() </code></a></td>
			<td scope="row" data-label="Description">Selects all records in a table, or a specific record, from the database</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#create"> <code> db.create() </code></a></td>
            <td scope="row" data-label="Description">Creates a record in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#insert"> <code> db.insert() </code></a></td>
            <td scope="row" data-label="Description">Inserts one or multiple records in the database</td>
		</tr>
		<tr>
			<td scope="row" data-label="Method"><a href="#insert_relation"> <code> db.insert_relation() </code></a></td>
			<td scope="row" data-label="Description">Inserts one or multiple relations in the database</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#update"> <code> db.update() </code></a></td>
            <td scope="row" data-label="Description">Updates all records in a table, or a specific record, in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#merge"> <code> db.merge() </code></a></td>
            <td scope="row" data-label="Description">Modifies all records in a table, or a specific record, in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#patch"> <code> db.patch() </code></a></td>
            <td scope="row" data-label="Description">Applies JSON Patch changes to all records, or a specific record, in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#delete"> <code> db.delete() </code></a></td>
            <td scope="row" data-label="Description">Deletes all records in a table, or a specific record, from the database</td>
        </tr>
	</tbody>
</table>

## `.select()` {#select}

Selects all records in a table, or a specific record, from the database.

```ts title="Method Syntax"
async db.select<T>(thing)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/javascript/data-types#recordid) to select.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
type Person = {
	id: string;
	name: string;
};

// Select all records from a table
const people = await db.select<Person>('person');

// Select a specific record from a table
const person = await db.select<Person>(new RecordId('person', 'h5wxrf2ewk8xjxosxtyc'));
const person = await db.select<Person>(new StringRecordId('person:h5wxrf2ewk8xjxosxtyc'));
```

### Translated query
This function will run the following query in the database.

```surql
SELECT * FROM $thing;
```

<br />

## `.create()` {#create}

Creates a record in the database.

```ts title="Method Syntax"
async db.create<T>(thing, data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/javascript/data-types#recordid) to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to create.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
type Person = {
	id: string;
	name: string;
	settings: {
		active: boolean;
		marketing: boolean;
	};
};

// Create a record with a random ID
const [person] = await db.create<Person>('person');

// Create a record with a specific ID
const person = await db.create<Person>(new RecordId('person', 'tobie'), {
	name: 'Tobie',
	settings: {
		active: true,
		marketing: true,
	},
});

// The content you are creating the record with might differ from the return type
const [record] = await db.create<
	Person,
	Pick<Person, 'name'>
>(
    new RecordId('person', 'tobie'),
    {
        name: 'Tobie',
    }
);
```

### Translated query
This function will run the following query in the database.

```surql
CREATE $thing CONTENT $data;
```

<br />

## `.insert()` {#insert}

Inserts one or multiple records in the database.

```ts title="Method Syntax"
async db.insert<T>(table, data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Optionally pass along a table to insert into.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Either a single document/record or an array of documents/records to insert
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
type Person = {
	id: string;
	name: string;
	settings: {
		active: boolean;
		marketing: boolean;
	};
};

// Insert a single record
const [person] = await db.insert<Person>('person', {
	name: 'Tobie',
	settings: {
		active: true,
		marketing: true,
	},
});

// Insert multiple records
const people = await db.insert<Person>('person', [
	{
		name: 'Tobie',
		settings: {
			active: true,
			marketing: true,
		},
	},
	{
		name: 'Jaime',
		settings: {
			active: true,
			marketing: true,
		},
	},
]);

// The content you are creating the record with might differ from the return type
const people = await db.insert<
	Person,
	Pick<Person, 'name'>
>('person', [
	{ name: 'Tobie' },
	{ name: 'Jaime' },
]);
```

### Translated query
This function will run the following query in the database.

```surql
INSERT INTO $table $data;
```

<br />

## `.insert_relation()` {#insert_relation}

Inserts one or multiple relations in the database.

```ts title="Method Syntax"
async db.insert_relation<T>(table, data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Optionally pass along a table to insert into.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Either a single document/record or an array of documents/records to insert
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
type Likes = {
	id: RecordId<"likes">;
	in: RecordId<"person">;
	out: RecordId<"post">;
};

// Insert a single record
const [person] = await db.insert_relation<Likes>('likes', {
	in: new RecordId('person', 'tobie'),
	out: new RecordId('post', 123),
});

// Insert multiple records across tables
const people = await db.insert<Likes>('likes', [
	{
    	in: new RecordId('person', 'tobie'),
    	out: new RecordId('post', 123),
	},
	{
    	in: new RecordId('person', 'jaime'),
    	out: new RecordId('post', 456),
	},
]);
```

### Translated query
This function will run the following query in the database.

```surql
INSERT RELATION INTO $table $data;
```

<br />

## `.update()` {#update}

Updates all records in a table, or a specific record, in the database.

```ts title="Method Syntax"
async db.update<T>(thing, data)
```


> [!NOTE]
> This function replaces the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/javascript/data-types#recordid) to update.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to update.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
type Person = {
	id: string;
	name: string;
	settings: {
		active: boolean;
		marketing: boolean;
	};
};

// Update all records in a table
const people = await db.update<Person>('person');

// Update a record with a specific ID
const person = await db.update<Person>(new RecordId('person', 'tobie'), {
	name: 'Tobie',
	settings: {
		active: true,
		marketing: true,
	},
});

// The content you are updating the record with might differ from the return type
const record = await db.update<
	Person,
	Pick<Person, 'name'>
>(new RecordId('person', 'tobie'), {
	name: 'Tobie',
});
```

### Translated query
This function will run the following query in the database.

```surql
UPDATE $thing CONTENT $data;
```

<br />

## `.merge()` {#merge}

Modifies all records in a table, or a specific record, in the database.

```ts title="Method Syntax"
async db.merge<T>(thing, data)
```

> [!NOTE]
> This function merges the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/javascript/data-types#recordid) to merge.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to merge.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
type Person = {
	id: string;
	name: string;
	updated_at: Date;
	settings: {
		active: boolean;
		marketing: boolean;
	};
};

// Update all records in a table
const people = await db.merge<Person>('person', {
	updated_at: new Date(),
});

// Update a record with a specific ID
const person = await db.merge<Person>(new RecordId('person', 'tobie'), {
	updated_at: new Date(),
	settings: {
		active: true,
	},
});

// The content you are merging the record with might differ from the return type
const record = await db.merge<
	Person,
	Pick<Person, 'name'>
>(new RecordId('person', 'tobie'), {
	name: 'Tobie',
});
```

### Translated query
This function will run the following query in the database.

```surql
UPDATE $thing MERGE $data;
```

<br />

## `.patch()` {#patch}

Applies JSON Patch changes to all records, or a specific record, in the database.

```ts title="Method Syntax"
async db.patch(thing, data)
```

> [!NOTE]
> This function patches the current document / record data with the specified JSON Patch data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/javascript/data-types#recordid) to patch.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The JSON Patch data with which to patch the records.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
// Update all records in a table
const people = await db.patch('person', [
	{ op: 'replace', path: '/created_at', value: new Date() },
]);

// Update a record with a specific ID
const person = await db.patch(new RecordId('person', 'tobie'), [
	{ op: 'replace', path: '/settings/active', value: false },
	{ op: 'add', path: '/tags', value: ['developer', 'engineer'] },
	{ op: 'remove', path: '/temp' },
]);
```

### Translated query
This function will run the following query in the database.

```surql
UPDATE $thing PATCH $data;
```

<br />

## `.delete()` {#delete}

Deletes all records in a table, or a specific record, from the database.

```ts title="Method Syntax"
async db.delete<T>(thing)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/javascript/data-types#recordid) to delete.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
// Delete all records from a table
await db.delete('person');

// Delete a specific record from a table
await db.delete(new RecordId('person', 'h5wxrf2ewk8xjxosxtyc'));
```

### Translated query
This function will run the following query in the database.

```surql
DELETE $thing;
```



================================================
FILE: src/content/doc-sdk-javascript/core/handling-authentication.mdx
================================================
---
sidebar_position: 2
sidebar_label: Handle authentication
title: JavaScript | SDK | Handle authentication
description: SurrealDB supports a number of methods for authenticating users and securing the database.
---

import Label from "@components/shared/Label.astro";
import Since from "@components/shared/Since.astro";
import Version from '@components/Version.astro';
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Handle authentication

Since SurrealDB is a database that is designed to be used in a distributed environment, it is important to secure the database and the data that is stored in it. SurrealDB provides a number of methods for authenticating users and securing the database.

In your SurrealDB database, you can create authentication login using the [`DEFINE ACCESS`](/docs/surrealql/statements/define/access) statement which supports [JWT](/docs/surrealql/statements/define/access/jwt) and [Record](/docs/surrealql/statements/define/access/record) Access methods.

The access method used will inform the input for `access` in the `.signup()` and `.signin()` methods.

> [!IMPORTANT]
> If you are not on Version <Version /> of SurrealDB, you will use the `scope` property instead of `access`. 

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#signup"> <code> db.signup() </code></a></td>
			<td scope="row" data-label="Description">Connects to a local or remote database endpoint</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#signin"> <code> db.signin() </code></a></td>
            <td scope="row" data-label="Description">Signs in to a root, namespace, database or scope user</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#invalidate"> <code> db.invalidate() </code></a></td>
            <td scope="row" data-label="Description">Invalidates the current session</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#authenticate"> <code> db.authenticate() </code></a></td>
            <td scope="row" data-label="Description">Authenticates a user with a token</td>
        </tr>
	</tbody>
</table>

## Defining access in your application

The JavaScript SDK has a [`.query()` method](/docs/sdk/javascript/core/writing-surrealql) which allows you to write secure SurrealQL statements from within your application. Using this method, you can define access for your users and securely manage authentication. See the code example below:

<Tabs groupId="define-access">
<TabItem value="V2" label="V2.x" >
```ts
...
// Assign the variable on the connection
const authentication = await db.query(
" DEFINE ACCESS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 15m, FOR SESSION 12h; "
);
...
```
</TabItem>
<TabItem value="V1" label="V1.x" >

```ts
...
// Assign the variable on the connection
const authentication = await db.query(
" DEFINE SCOPE user SESSION 24h
	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) ); "
);
...
```
</TabItem>
</Tabs>

> [!NOTE]
> Depending on the connection protocol you choose, authentication tokens and sessions lifetime work differently. Refer to the [connection options](/docs/sdk/javascript/core/create-a-new-connection#connection-options) documentation for more information.


## User authentication

After you have defined your authentication login, you can use the following methods to authenticate users:


## `.signup()` {#signup}

Signs up to a specific authentication scope / access method.

```ts title="Method Syntax"
async db.signup({`{ namespace, database, [ scope | access ], [...] }`})
```

### Arguments

<Tabs groupId="signup">
<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>namespace</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign up to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>database</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign up to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>access  </code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The access to sign up to. Also pass any variables used in the access under the `variables` key. Only supported from SurrealDB 2.x onwards
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>variables</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The variables to pass to the access definition
            </td>
        </tr>
    </tbody>
</table>

</TabItem>

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>namespace</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign up to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>database</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign up to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>scope</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The scope to sign up to. Also pass any variables used in the scope. Only supported in SurrealDB 1.x
            </td>
        </tr>
    </tbody>
</table>
</TabItem>
</Tabs>

### Example usage

<Tabs groupId="signup-example">

<TabItem value="V2" label="V2.x" >

```ts
// With Record Access
const token = await db.signup({
	namespace: 'surrealdb',
	database: 'docs',
	access: 'account',

    // Also pass any properties required by the access definition
	variables: {
    	email: 'info@surrealdb.com',
    	pass: '123456',
    },
});
```
</TabItem>

<TabItem value="V1" label="V1.x" >
```ts

// With Scopes
const token = await db.signup({
	namespace: 'surrealdb',
	database: 'docs',
	scope: 'user',

	// Also pass any properties required by the scope definition
	email: 'info@surrealdb.com',
	pass: '123456',
});
```
</TabItem>
</Tabs>

<br />

## `.signin()` {#signin}

Signs in to a root, namespace, database or scope user.

```ts title="Method Syntax"
async db.signin({`{ ... }`})
```

### Arguments


<Tabs groupId="http-sql">
<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Properties</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>username</code>
                <Label label="REQUIRED FOR ROOT, NAMESPACE & DATABASE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The username of the database user
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>password</code>
                <Label label="REQUIRED FOR ROOT, NAMESPACE & DATABASE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The password of the database user
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>namespace</code>
                <Label label="REQUIRED FOR DATABASE & ACCESS" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign in to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>database</code>
                <Label label="REQUIRED FOR ACCESS" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign in to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>access</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The access to sign in to. Also pass any variables used in the access under the `variables` key. Only supported from SurrealDB 2.x onwards
            </td>
        </tr>
    </tbody>
</table>

</TabItem>

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Properties</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>username</code>
                <Label label="REQUIRED FOR ROOT, NAMESPACE & DATABASE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The username of the database user
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>password</code>
                <Label label="REQUIRED FOR ROOT, NAMESPACE & DATABASE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The password of the database user
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>namespace</code>
                <Label label="REQUIRED FOR DATABASE & SCOPE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign in to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>database</code>
                <Label label="REQUIRED FOR SCOPE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign in to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>scope</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The scope to sign in to. Also pass any variables used in the scope. Only supported in SurrealDB 1.x
            </td>
        </tr>
    </tbody>
</table>
</TabItem>
</Tabs>

### Example usage

<Tabs groupId="signin-example">

<TabItem value="root" label="Root user" >
```ts
// Authenticate with a root user
const token = await db.signin({
	username: 'root',
	password: 'surrealdb',
});
```
</TabItem>

<TabItem value="namespace" label="Namespace user" >
```ts
// Authenticate with a Namespace user
const token = await db.signin({
	namespace: 'surrealdb',
	username: 'tobie',
	password: 'surrealdb',
});
```
</TabItem>

<TabItem value="database" label="Database user" >
```ts
// Authenticate with a Database user
const token = await db.signin({
	namespace: 'surrealdb',
	database: 'docs',
	username: 'tobie',
	password: 'surrealdb',
});
```
</TabItem>
<TabItem value="record" label="Record Access" >
```ts
// Authenticate with Record Access
const token = await db.signin({
	namespace: 'surrealdb',
	database: 'docs',
	access: 'account',

    // Also pass any properties required by the access definition
	variables: {
    	email: 'info@surrealdb.com',
    	pass: '123456',
    },
});
```
</TabItem>
<TabItem value="scope" label="Scopes" >
```ts
// Authenticate with Scopes
const token = await db.signin({
	namespace: 'surrealdb',
	database: 'docs',
	scope: 'user',

	// Also pass any properties required by the scope definition
	email: 'info@surrealdb.com',
	pass: '123456',
});
```
</TabItem>
</Tabs>


<br />

## `.invalidate()` {#invalidate}

Invalidates the authentication for the current connection.

```ts title="Method Syntax"
async db.invalidate()
```

### Example usage
```ts
await db.invalidate();
```

<br />

## `.authenticate()` {#authenticate}

Authenticates the current connection with a JWT token.

```ts title="Method Syntax"
async db.authenticate(token)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>token</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The JWT authentication token.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
await db.authenticate('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJTdXJyZWFsREIiLCJpYXQiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwiZXhwIjoxODM2NDM5MDIyLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJTQyI6InVzZXIiLCJJRCI6InVzZXI6dG9iaWUifQ.N22Gp9ze0rdR06McGj1G-h2vu6a6n9IVqUbMFJlOxxA');
```

## Learn more

Learn more about authentication in SurrealDB in our [security best practices](/docs/surrealdb/reference-guide/security-best-practices#authentication) documentation and in the [security](/docs/surrealdb/security/authentication#expiration) section of the SurrealDB documentation.  


================================================
FILE: src/content/doc-sdk-javascript/core/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: SDK Concepts
title: JavaScript SDK Concepts | SDKs | Integration
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

# Concepts 

In this section, we will go over the core concepts of the SurrealDB SDK for JavaScript. You will learn how to connect to a SurrealDB instance, manage authentication, and interact with the database.

- [Create a new Connection](/docs/sdk/javascript/core/create-a-new-connection)
- [Handle authentication](/docs/sdk/javascript/core/handling-authentication)
- [Set parameters](/docs/sdk/javascript/core/parameters)
- [Data manipulation](/docs/sdk/javascript/core/data-maniplulation)
- [Real-Time Streaming](/docs/sdk/javascript/core/streaming)
- [Run SurrealQL queries](/docs/sdk/javascript/core/writing-surrealql)
- [Utilities methods](/docs/sdk/javascript/core/utilities)




================================================
FILE: src/content/doc-sdk-javascript/core/parameters.mdx
================================================
---
sidebar_position: 3
sidebar_label: Set parameters
title: JavaScript | SDK | Set parameters
description: In this section, you will learn how to set parameters in the SurrealDB JavaScript SDK.
---

import Label from "@components/shared/Label.astro";

# Set parameters

Within your application, you can define parameters that can be used to store and retrieve data from SurrealDB. Parameters are used to store data in a structured format, and can be used to store data in a key-value pair format.

>[!IMPORTANT]
> Parameters allow you to define global (database-wide) parameters that are available to every client.

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#let"> <code> db.let(key, val) </code></a></td>
			<td scope="row" data-label="Description">Assigns a value as a parameter for this connection</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#unset"> <code> db.unset(key) </code></a></td>
            <td scope="row" data-label="Description">Removes a parameter for this connection</td>
        </tr>
	</tbody>
</table>

## `.let()` {#let}

Assigns a value as a parameter for this connection.

```ts title="Method Syntax"
async db.let(key, val)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>val</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns the value to the variable name.
            </td>
        </tr>
    </tbody>
</table>

### Example Usage
```ts
// Assign the variable on the connection
await db.let('name', {
	first: 'Tobie',
	last: 'Morgan Hitchcock',
});

// Use the variable in a subsequent query
await db.query('CREATE person SET name = $name');

// Use the variable in a subsequent query
await db.query('SELECT * FROM person WHERE name.first = $name.first');
```

<br />

## `.unset()` {#unset}

Removes a parameter for this connection.

```ts title="Method Syntax"
async db.unset(key)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
// Remove the variable from the connection
await db.unset('name');
```



================================================
FILE: src/content/doc-sdk-javascript/core/streaming.mdx
================================================
---
sidebar_position: 4
sidebar_label: Real-Time data streaming
title: JavaScript | SDK | Real-Time data streaming
description: The SurrealDB SDK for JavaScript allows you to create live queries that listen for changes in the database and automatically update your application when changes occur.
---

import Label from "@components/shared/Label.astro";

# Real-Time data streaming

You can use the SurrealDB JavaScript SDK to create live queries that listen for changes in the database and automatically update your application when changes occur. This feature is useful for building real-time applications that need to respond to changes in the database.

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#live"> <code> db.live(table, callback, diff) </code></a></td>
			<td scope="row" data-label="Description">Initiates a live query</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#subscribeLive"> <code> db.subscribeLive(queryUuid, callback) </code></a></td>
            <td scope="row" data-label="Description">Registers a callback function for a running live query</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#kill"> <code> db.kill(queryUuid) </code></a></td>
			<td scope="row" data-label="Description">Kills a running live query by it's UUID</td>
		</tr>
	</tbody>
</table>

## `.live()` {#live}

Initiates a live query.

```ts title="Method Syntax"
async db.live<T>(table, callback, diff)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name to listen for changes for
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>callback</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                A callback function that processes live notifications. Consult the [Live Actions](#live-actions) for a list of all possible values being returned.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>diff</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                If set to true, live notifications will include an array of JSON Patch objects, rather than the entire record for each notification.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
// The uuid of the live query will be returned
const queryUuid = await db.live(
	"person",
	// The callback function takes two arguments: the 'action' and 'result' properties
	( action, result ) => {
		// action can be: 'CREATE', 'UPDATE', 'DELETE' or 'CLOSE'
	    if (action === 'CLOSE') return;

		// result contains either the entire record, or a set of JSON patches when diff mode is enabled
		processSomeLiveQueryUpdate(result);
	}
)
```

<br />

## `.subscribeLive()` {#subscribeLive}

Registers a callback function for a running live query.

```ts title="Method Syntax"
async db.subscribeLive<T>(queryUuid, callback)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>queryUuid</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The UUID of a running live query
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>callback</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                A callback function that processes live notifications. Consult the [Live Actions](#live-actions) for a list of all possible values being returned.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
await db.subscribeLive(
	queryUuid,
	// The callback function takes an object with the "action" and "result" properties
	( action, result ) => {
		// action can be: "CREATE", "UPDATE", "DELETE" or "CLOSE"
	    if (action === 'CLOSE') return;

		// result contains either the entire record, or a set of JSON patches when diff mode is enabled
		processSomeLiveQueryUpdate(result);
	}
)
```

<br />

## `.kill()` {#kill}

Kills a running live query by it's UUID

```ts title="Method Syntax"
async db.kill(queryUuid)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>queryUuid</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The UUID of the live query you wish to kill
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
await db.kill(queryUuid)
```

<br />

## Live Actions

For `CREATE`, `UPDATE` and `DELETE`, the type `Result` is the generic argument passed to [`.live()`](#live) or [`.subscribeLive()`](#subscribeLive). <br />
It extends either `Record<string, unknown>` or `Patch`.

It's generally recommended to handle the `CLOSE` action first, as that clears out the type for the result parameter.

<table>
    <thead>
        <tr>
            <th colspan="1" scope="col">Action</th>
            <th colspan="1" scope="col">Result</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `CLOSE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `killed` or `disconnected`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when the live query is closed due to it either being killed or the connection being disconnected.
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `CREATE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `Result`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when a record within your subscription gets created
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `UPDATE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `Result`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when a record within your subscription gets updated
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `DELETE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `Result`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when a record within your subscription gets deleted
            </td>
        </tr>
    </tbody>
</table>



================================================
FILE: src/content/doc-sdk-javascript/core/utilities.mdx
================================================
---
sidebar_position: 7
sidebar_label: Utilities methods
title: JavaScript | SDK | Utilities methods
description: The SurrealDB SDK for JavaScript provides some built-in utilities to work with responses.
---

# Utilities methods

The JavaScript SDK provides some built-in utilities to work with responses.

## Utilities overview

<table>
    <thead>
        <tr>
            <th colspan="1" scope="col">Utility</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="1" scope="row">
                [`.jsonify()`](#jsonify)
            </td>
            <td colspan="2" scope="row">
                Convert a response into a type-preserving JSON representation, in the same manner as SurrealDB would.
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">
                [`PreparedQuery`](#preparedquery)
            </td>
            <td colspan="2" scope="row">
                A class containing a query and it's variables, which can be passed to the [`.query()`](/docs/sdk/javascript/core/data-maniplulation#query) method.
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">
                [Tagged Template](#tagged-template)
            </td>
            <td colspan="2" scope="row">
                A method allowing you to write a tagged template string, automatically escaping any variables passed.
            </td>
        </tr>
    </tbody>
</table>

<br /><br />

##  `.jsonify()`

In certain scenario's, it's useful to be able to get a JSON representation of returned data, when working with tools like GraphQL for example. For this, the JavaScript SDK publishes a `jsonify()` utility.

It takes in a value of type `unknown`, and converts it into a JSON representation in the same manner that SurrealDB would. The utility **only affects SurrealQL values**, leaving all other sort of classes, including derivatives of Objects, Arrays, Maps and Sets, untouched.

Additionally, it is fully type-safe, transforming only the types for SurrealQL values.

```ts title="Signature"
jsonify<T>(value: T): Jsonify<T>;
```

### Example

```ts
jsonify({
    rid: new RecordId("person", "tobie"),
	dec: new Decimal("3.333333"),
	dur: new Duration("1d2h"),
	geo: new GeometryLine([
		new GeometryPoint([1, 2]),
		new GeometryPoint([3, 4]),
	]),

	tb: new Table("table_name"),
	uuid: new Uuid("92b84bde-39c8-4b4b-92f7-626096d6c4d9"),
	date: new Date("2024-05-06T17:44:57.085Z"),
	undef: undefined,
	null: null,
	num: 123,
	float: 123.456,
	true: true,
	false: false,
	string: "I am a string",
});
```

```json title="Output"
{
    rid: "person:tobie",
    dec: "3.333333",
    dur: "1d2h",
    geo: {
        type: "GeometryLine",
        coordinates: [
            [1, 2],
            [2, 3],
        ],
    },
    tb: "table_name",
    uuid: "92b84bde-39c8-4b4b-92f7-626096d6c4d9",
    date: "2024-05-06T17:44:57.085Z",
    null: null,
    num: 123,
    float: 123.456,
    true: true,
    false: false,
    string: "I am a string"
}
```

<br />

## `PreparedQuery`

A class containing a query and it's bindings, which can be passed to the [`.query()`](/docs/sdk/javascript/core/data-maniplulation#query) method.

> [!NOTE]
>The additional benefit of using this method over the `.query()` method is that it encodes the query and its variables into CBOR upfront, which can be helpful when writing large queries often. 


```ts title="Signature"
new PreparedQuery(query: string, bindings: Record<string, unknown>)
```

### Example

```ts
const query = new PreparedQuery(
    /* surql */ `CREATE person CONTENT $content`,
    { content: {} }
);

await surreal.query(query);
```

### Dynamically building queries using `.append()`

`PreparedQuery` also provides an append method that lets you conditionally add SurrealQL fragments and additional bound parameters. This is especially handy for optional filters:

```ts
// Start with a simple SELECT query
const query = new PreparedQuery("SELECT * FROM person");

// Conditionally add a WHERE clause if needed
const filterName = "Alice";
if (filterName) {
  query.append` WHERE name = ${filterName}`;
}

// The final query SurrealDB sees:
// SELECT * FROM person WHERE name = $bind___0
// ...with { "bind___0": "Alice" } as the binding.

const results = await surreal.query(query);
```

By reusing an existing `PreparedQuery` and appending only the parts you need, you keep your code maintainable and avoid manual string manipulation.

### Gap

You can set a value to be a `Gap` instance to later set or override it when sending the query.

```ts
const name = new Gap<string>();
const enabled = new Gap(true);
const query = new PreparedQuery(
    /* surql */ `CREATE person SET name = $name, enabled = $enabled`,
    { name, enabled }
);

// All gaps without a default value must be passed
await surreal.query(
    query,
    [name.fill("John Doe")]
);

// You can also override gap default values
await surreal.query(
    query,
    [
        name.fill("John Doe"),
        enabled.fill(false),
    ]
);
```

### Updating Record Links

Handling record links in queries can be tricky, as JavaScript's default array syntax formats [record links](/docs/surrealql/datamodel/records) like in strings: `["person:tobie", "person:jamie"]`. However, SurrealDB expects the input to be in this form: `[person:tobie, person:jamie]`.

To simplify this process, you can use the `PreparedQuery` method, which allows you to map JavaScript strings to the appropriate SurrealDB record link format:

```ts
const people = ["person:tobie", "person:jamie"];

const query = new PreparedQuery(
  /* surql */`UPDATE person:john SET $content`,
  { content: { friends: people.map(p => new StringRecordId(p)) } }
);
```

This approach makes it easy to handle and update record links dynamically while adhering to SurrealDB's expected syntax.

<br />

## Tagged Template

A method allowing you to write a [tagged template literal string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals), automatically escaping any variables passed. You can also use `Gap` instances like described above. Returns a [`PreparedQuery`](#preparedquery).

> [!NOTE]
> [Template literal strings](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) in JavaScript only work with backticks, and not with single or double quoted strings.

### Example

```ts
// Optionally, `surrealql` is an alias export of `surql`
import { surql, surrealql } from 'surrealdb';

const content = { name: "Tobie" };
const query = surql`CREATE person CONTENT ${content}`;
await surreal.query(query);

// Or use gaps
const name = new Gap("Tobie");
const query = surql`CREATE person CONTENT ${{ name }}`;
await surreal.query(query);
await surreal.query(
    query,
    // Or override a Gap's default value
    [name.fill("Jaime")]
);
```

<br />

## String Prefixes

These methods are also based on [tagged template literal strings](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals), but they replicate SurrealQLs string prefixes in JS.

> [!NOTE]
> [Template literal strings](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) in JavaScript only work with backticks, and not with single or double quoted strings.

### Example

```ts
// Optionally, `surrealql` is an alias export of `surql`
import { s, d, r, u } from 'surrealdb';

const string = s`I am a string`;
const date = d`2024-05-06T17:44:57.085Z`;
const record = r`person:tobie`;
const uuid = u`92b84bde-39c8-4b4b-92f7-626096d6c4d9`;
```



================================================
FILE: src/content/doc-sdk-javascript/core/writing-surrealql.mdx
================================================
---
sidebar_position: 5
sidebar_label: Run SurrealQL queries
title: JavaScript | SDK | Run SurrealQL queries
description: SurrealDB supports a number of methods for interacting with the database and performing CRUD operations.
---
import Label from "@components/shared/Label.astro";

# Run SurrealQL queries

The methods below are used to interact with the database and perform CRUD operations. You can also use the `query` method to run [SurrealQL statements](/docs/surrealql/statements) against the database.

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#query"> <code> db.query() </code></a></td>
			<td scope="row" data-label="Description">Runs a set of SurrealQL statements against the database</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#query_raw"> <code> db.query_raw() </code></a></td>
            <td scope="row" data-label="Description">Runs a set of SurrealQL statements against the database and returns the raw RPC response</td>
        </tr>
	</tbody>
</table>

## `.query()` {#query}

Runs a set of SurrealQL statements against the database.

```ts title="Method Syntax"
async db.query<T>(query, vars)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>query</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>vars</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
type Person = {
	id: string;
	name: string;
};

// Assign the variable on the connection
const result = await db.query<[Person[], Person[]]>(
	'CREATE person SET name = "John"; SELECT * FROM type::table($tb);',
	{ tb: 'person' }
);

// Get the first result from the first query
const created = result[0].result[0];

// Get all of the results from the second query
const people = result[1].result;
```

### `.query_raw()`

With `.query_raw()`, you will get back the raw RPC response. This contrast to the `.query()` method, this will not throw for errors that occur in individual queries, but will rather give those back as a string, and this will include the time it took to execute the individual queries.


<br />

# Built-in methods

The JavaScript SDK also provides easy to use methods for data selection and altering.

## `Table` vs `RecordId`

These methods all accept either a [`Table`](/docs/sdk/javascript/data-types#table) vs [`RecordId`](/docs/sdk/javascript/data-types#recordid) vs [`StringRecordId`](/docs/sdk/javascript/data-types#recordid), or a "thing", as their first argument.
Passing a [`Table`](/docs/sdk/javascript/data-types#table) instance, or a `string`, will make the method return an array of objects of generic type `T`.
If you instead pass a [`RecordId`](/docs/sdk/javascript/data-types#recordid) or [`StringRecordId`](/docs/sdk/javascript/data-types#recordid) instance, the method will return a single object of generic type `T` back.

<br />



================================================
FILE: src/content/doc-sdk-javascript/engines/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Overview
title: JavaScript | SDK | Engines | Overview
description: The SurrealDB SDK for JavaScript can run in memory using the Node.js engine or in a browser using the WebAssembly engine.
---

# Engines 

The SurrealDB JavaScript SDK supports two engines for running in embedded mode. 

- [Node.js](/docs/sdk/javascript/engines/node) : Run SurrealDB as an embedded database within a server-side environment, backed by either an in-memory engine or SurrealKV.

- [WebAssembly](/docs/sdk/javascript/engines/wasm) : Run SurrealDB as an embedded database within a browser environment it enables SurrealDB to be run in-memory, or to persist data by running on top of IndexedDB. 

Learn more about the [Node.js engine](/docs/sdk/javascript/engines/node) and the [WebAssembly engine](/docs/sdk/javascript/engines/wasm) in the following sections.




================================================
FILE: src/content/doc-sdk-javascript/engines/node.mdx
================================================
---
sidebar_position: 1
sidebar_label: Node.js
title: JavaScript | SDK | Engines | Node
description: The SurrealDB SDK for JavaScript using the Node.js engine.
---

import Image from "@components/Image.astro";

import LightNodejs from "@img/icon/light/nodejs.png";
import DarkNodejs from "@img/icon/dark/nodejs.png";

<div class="flag-title">
	<Image
		alt="Node.js"
		width={42}
		height={42}
		src={{
			light: LightNodejs,
			dark: DarkNodejs,
		}}
	/>
	# Node.js engine
</div>

This library is a plugin for the SurrealDB JavaScript SDK, which can be used to run SurrealDB as an embedded database within a Node.js server-side environment.

It enables SurrealDB to be run in-memory, or to persist data by running on top of SurrealKV. It allows for a consistent JavaScript and TypeScript API when using the surrealdb.js library by adding support for embedded storage engines (`memory`, `surrealkv`) alongside the remote connection protocols (`http`, `https`, `ws`, `wss`).

The WebAssembly engine is available on NPM as [`@surrealdb/node`](https://npmjs.com/package/@surrealdb/node) and is required to be used as a plugin within the [JavaScript SDK](https://npmjs.com/package/surrealdb).

> [!IMPORTANT]
> This library works with ES modules (`import`), not CommonJS (`require`).

## Installation

Before installing the Node.js engine, you need to install the JavaScript SDK using the instructions in the [installation](/docs/sdk/javascript/installation) documentation. 

After installing the SDK, install the Node.js engine using the following command:

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

<Tabs groupId="installation">
  <TabItem value="npm" label="npm" default>
    ```bash
    npm install --save @surrealdb/node
    ```
  </TabItem>
  <TabItem value="yarn" label="yarn">
    ```bash
    yarn add @surrealdb/node
    ```
  </TabItem>
  <TabItem value="pnpm" label="pnpm">
    ```bash
    pnpm install @surrealdb/node
    ```
  </TabItem>
</Tabs>

## Configuration

To use the Node.js engine, you need to import the `surrealdbNodeEngines` function from the `@surrealdb/node` package, and pass it as an option to the `Surreal` constructor.

```js
import { Surreal } from 'surrealdb';
import { surrealdbNodeEngines } from '@surrealdb/node';
```

After importing the `surrealdbNodeEngines` function, you can pass it as an option to the `Surreal` constructor. 

```js
const db = new Surreal({
    engines: surrealdbNodeEngines(),
});
```

## Connecting 

Using the [`.connect()`](/docs/sdk/javascript/methods/connect) method, you can connect to a SurrealDB instance. The connection string specifies whether to connect to the Wasm engine, in memory or persisted with the `mem://` or `surrealkv://` prefixes respectively.

## Example

```js
import { Surreal } from 'surrealdb';
import { surrealdbNodeEngines } from '@surrealdb/node';

// Enable the WebAssembly engines
const db = new Surreal({
    engines: surrealdbNodeEngines(),
});

// Now we can start SurrealDB as an in-memory database
await db.connect("mem://");
// Or we can start a persisted SurrealKV database
await db.connect("surrealkv://demo");
// Or a persisted SurrealKV database with versioning (temoral queries)
await db.connect("surrealkv+versioned://demo");

// Now use the JavaScript SDK as normal.

// Close the database connection
await db.close();
```

> [!NOTE]
> You must close the connection to the database with the `.close()` method to prevent console warnings.

## Next steps

After setting up the Wasm engine, you can continue with the rest of the [SDK documentation](/docs/sdk/javascript/core). You can refer to the [methods](/docs/sdk/javascript/methods) documentation for more information on using SurrealDB with the Wasm engine also see the [data types](/docs/sdk/javascript/data-types) documentation for more information on how to use the data types supported by SurrealDB.

## Sources

- [`@surrealdb/node` on NPM](https://npmjs.com/package/@surrealdb/node)
- [GitHub repository](https://github.com/surrealdb/surrealdb.node)



================================================
FILE: src/content/doc-sdk-javascript/engines/wasm.mdx
================================================
---
sidebar_position: 2
sidebar_label: WebAssembly
title: JavaScript | SDK | Engines | WebAssembly
description: The SurrealDB SDK for JavaScript using the WebAssembly engine.
---

import Image from "@components/Image.astro";

import LightWasm from "@img/icon/light/webassembly.png";
import DarkWasm from "@img/icon/dark/webassembly.png";

<div class="flag-title">
	<Image
		alt="WebAssembly"
		width={42}
		height={42}
		src={{
			light: LightWasm,
			dark: DarkWasm,
		}}
	/>
	# WebAssembly engine
</div>

This library is a plugin for the SurrealDB JavaScript SDK, which can be used to run SurrealDB as an embedded database within a frontend or client-side web browser environment.

It enables SurrealDB to be run in-memory, or to persist data by running on top of IndexedDB. It allows for a consistent JavaScript and TypeScript API when using the surrealdb.js library by adding support for embedded storage engines (`memory`, `indxdb`) alongside the remote connection protocols (`http`, `https`, `ws`, `wss`).

The WebAssembly engine is available on NPM as [`@surrealdb/wasm`](https://npmjs.com/package/@surrealdb/wasm) and is required to be used as a plugin within the [JavaScript SDK](https://npmjs.com/package/surrealdb).

> [!IMPORTANT]
> This library works with ES modules (`import`), not CommonJS (`require`).

## Installation

Before installing the WebAssembly engine, you need to install the JavaScript SDK using the instructions in the [installation](/docs/sdk/javascript/installation) documentation. 

After installing the SDK, install the Wasm engine using the following command:

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

<Tabs groupId="installation">
  <TabItem value="npm" label="npm" default>
    ```bash
    npm install --save @surrealdb/wasm
    ```
  </TabItem>
  <TabItem value="yarn" label="yarn">
    ```bash
    yarn add @surrealdb/wasm
    ```
  </TabItem>
  <TabItem value="pnpm" label="pnpm">
    ```bash
    pnpm install @surrealdb/wasm
    ```
  </TabItem>
</Tabs>

## Configuration

To use the Wasm engine, you need to import the `surrealdbWasmEngines` function from the `@surrealdb/wasm` package, and pass it as an option to the `Surreal` constructor.

```js
import { Surreal } from 'surrealdb';
import { surrealdbWasmEngines } from '@surrealdb/wasm';
```

After importing the `surrealdbWasmEngines` function, you can pass it as an option to the `Surreal` constructor. 

```js
const db = new Surreal({
    engines: surrealdbWasmEngines(),
});
```

If you are using a bundler like Vite, Webpack, or Parcel, you can import the `surrealdbWasmEngines` function directly. For example, using Vite, place the following in your `vite.config.js` file:

```js title="vite.config.js"
optimizeDeps: {
    exclude: ["@surrealdb/wasm"],
    esbuildOptions: {
        target: "esnext",
    },
},
esbuild: {
    supported: {
        "top-level-await": true
    },
}
```

## Connecting 

Using the [`.connect()`](/docs/sdk/javascript/methods/connect) method, you can connect to a SurrealDB instance. The connection string specifies whether to connect to the Wasm engine, in memory or persisted with the `mem://` or `indxdb://` prefixes respectively.

## Example

```js title="index.js"
import { Surreal } from 'surrealdb';
import { surrealdbWasmEngines } from '@surrealdb/wasm';

// Enable the WebAssembly engines
const db = new Surreal({
    engines: surrealdbWasmEngines(),
});

// Now we can start SurrealDB as an in-memory database

await db.connect("mem://");

// Or we can start a persisted IndexedDB database

await db.connect("indxdb://demo");

// Now use the JavaScript SDK as normal.
```

## Next steps

After setting up the Wasm engine, you can continue with the rest of the [SDK documentation](/docs/sdk/javascript/core). You can refer to the [methods](/docs/sdk/javascript/methods) documentation for more information on using SurrealDB with the Wasm engine also see the [data types](/docs/sdk/javascript/data-types) documentation for more information on how to use the data types supported by SurrealDB.

## Sources

- [`@surrealdb/wasm` on NPM](https://npmjs.com/package/@surrealdb/wasm)
- [GitHub repository](https://github.com/surrealdb/surrealdb.wasm)



================================================
FILE: src/content/doc-sdk-javascript/frameworks/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Frameworks
title: JavaScript | SDK | Frameworks
description: The SurrealDB SDK for JavaScript can run in memory using the Node.js engine or in a browser using the WebAssembly engine.
---
import Boxes from "@components/boxes/Boxes.astro";
import IconBox from "@components/boxes/IconBox.astro";
import LightReact from "@img/icon/light/reactjs.png";
import LightNext from "@img/icon/light/nextjs.png";
import LightVue from "@img/icon/light/vuejs.png";
import LightAngular from "@img/icon/light/angular.png";
import LightSolid from "@img/icon/light/solidjs.png";
import LightSvelte from "@img/icon/light/svelte.png";
import DarkReact from "@img/icon/dark/reactjs.png";
import DarkNext from "@img/icon/dark/nextjs.png";
import DarkVue from "@img/icon/dark/vuejs.png";
import DarkAngular from "@img/icon/dark/angular.png";
import DarkSolid from "@img/icon/dark/solidjs.png";
import DarkSvelte from "@img/icon/dark/sveltejs.png";
import Version from '@components/Version.astro';

# Frameworks 

The SurrealDB JavaScript SDK can be used with your favorite frameworks depending on your use case.  Utilising support from TanStack Query, with support for data caching and syncing, and authentication.

<Boxes>
    <IconBox
        title="React"
        href="/docs/sdk/javascript/frameworks/react"
        status="available"
        icon={{
            light: LightReact,
            dark: DarkReact,
        }}
    />
    <IconBox
        title="Solid.js"
        href="/docs/sdk/javascript/frameworks/solidjs"
        status="available"
        icon={{
            light: LightSolid,
            dark: DarkSolid,
        }}
    />
    <IconBox
        title="Next.js"
        status="coming soon"
        icon={{
            light: LightNext,
            dark: DarkNext,
        }}
    />
    <IconBox
        title="Vue.js"
        status="coming soon"
        icon={{
            light: LightVue,
            dark: DarkVue,
        }}
    />
    <IconBox
        title="Angular"
        status="coming soon"
        icon={{
            light: LightAngular,
            dark: DarkAngular,
        }}
    />
    <IconBox
        title="Svelte"
        status="coming soon"
        icon={{
            light: LightSvelte,
            dark: DarkSvelte,
        }}
    />
</Boxes>


================================================
FILE: src/content/doc-sdk-javascript/frameworks/react.mdx
================================================
---
sidebar_position: 1
sidebar_label: React
title: React | JavaScript | SDK | Frameworks 
description: The SurrealDB SDK for JavaScript can also be used in your React applications to interact with your SurrealDB instance.
---

import LightReact from "@img/icon/light/reactjs.png";
import DarkReact from "@img/icon/dark/reactjs.png";

import Image from "@components/Image.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

<div class="flag-title">
	<Image
		alt="React"
		width={42}
		height={42}
		src={{
			light: LightReact,
			dark: DarkReact,
		}}
	/>
	# React
</div>

[React](https://react.dev/) is a popular JavaScript library for building user interfaces. The SurrealDB SDK for JavaScript can also be used in your React applications to interact with your SurrealDB instance.

In this guide, we will walk you through setting up and querying your first project with the SurrealDB SDK for React.

## Prerequisites

This guide assumes the following:
- You have a basic understanding of React.
- You have installed SurrealDB on your machine

## Setup

### Install the SDK

First, install the [SurrealDB SDK](https://npmjs.com/package/surrealdb) using your favorite package manager:

<Tabs groupId="node-package-manager">
  <TabItem value="Bun" label="Bun">
    ```bash
    bun install surrealdb
    ```
  </TabItem>
  <TabItem value="NPM" label="NPM" default>
    ```bash
    npm install --save surrealdb
    ```
  </TabItem>
  <TabItem value="Yarn" label="Yarn">
    ```bash
    yarn add surrealdb
    ```
  </TabItem>
  <TabItem value="Pnpm" label="Pnpm">
    ```bash
    pnpm install surrealdb
    ```
  </TabItem>
</Tabs>

> [!IMPORTANT]
> The SurrealDB SDK for JavaScript is also available in the JSR registry as [`@surrealdb/surrealdb`](https://jsr.io/@surrealdb/surrealdb).

## Initialize the SDK

After installing the SDK, import it into your project. We recommend initializing the SDK in a [Context Provider](https://react.dev/learn/passing-data-deeply-with-context) in order to expose it throughout your application. This makes the client accessible anywhere in your component tree, simplifies cleanup, and provides built-in state management for connection success or failure.

### 1. Install Required Packages

In addition to `surrealdb`, we recommend using [@tanstack/react-query](https://tanstack.com/query/latest) for managing the connection state:

<Tabs groupId="node-package-manager">
  <TabItem value="Bun" label="Bun">
    ```bash
    bun install @tanstack/react-query
    ```
  </TabItem>
  <TabItem value="NPM" label="NPM" default>
    ```bash
    npm install --save @tanstack/react-query
    ```
  </TabItem>
  <TabItem value="Yarn" label="Yarn">
    ```bash
    yarn add @tanstack/react-query
    ```
  </TabItem>
  <TabItem value="Pnpm" label="Pnpm">
    ```bash
    pnpm install @tanstack/react-query
    ```
  </TabItem>
</Tabs>

### 2. Creating the Context Provider

Create a new file, e.g., `SurrealProvider.tsx`, which will contain the context provider and hooks for accessing the SurrealDB client. You can copy the following code, which takes care of managing the connection.

Feel free to make any changes to fit your project structure and coding style.

```tsx title= "src/contexts/SurrealProvider.tsx"
import { Surreal } from "surrealdb";
import { useMutation } from "@tanstack/react-query";
import React, { createContext, useContext, useEffect, useMemo, useCallback, useState } from "react";

interface SurrealProviderProps {
	children: React.ReactNode;
	/** The database endpoint URL */
	endpoint: string;
	/** Optional existing Surreal client */
	client?: Surreal;
	/* Optional connection parameters */
	params?: Parameters<Surreal["connect"]>[1];
	/** Auto connect on component mount, defaults to true */
	autoConnect?: boolean;
}

interface SurrealProviderState {
	/** The Surreal instance */
	client: Surreal;
	/** Whether the connection is pending */
	isConnecting: boolean;
	/** Whether the connection was successfully established */
	isSuccess: boolean;
	/** Whether the connection rejected in an error */
	isError: boolean;
	/** The connection error, if present */
	error: unknown;
	/** Connect to the Surreal instance */
	connect: () => Promise<true>;
	/** Close the Surreal instance */
	close: () => Promise<true>;
}

const SurrealContext = createContext<SurrealProviderState | undefined>(undefined);

export function SurrealProvider({
	children,
	client,
	endpoint,
	params,
	autoConnect = true,
}: SurrealProviderProps) {
	// Surreal instance remains stable across re-renders
	const [surrealInstance] = useState(() => client ?? new Surreal());

	// React Query mutation for connecting to Surreal
	const {
		mutateAsync: connectMutation,
		isPending,
		isSuccess,
		isError,
		error,
		reset,
	} = useMutation({
		mutationFn: () => surrealInstance.connect(endpoint, params),
	});

	// Wrap mutateAsync in a stable callback
	const connect = useCallback(() => connectMutation(), [connectMutation]);

	// Wrap close() in a stable callback
	const close = useCallback(() => surrealInstance.close(), [surrealInstance]);

	// Auto-connect on mount (if enabled) and cleanup on unmount
	useEffect(() => {
		if (autoConnect) {
			connect();
		}

		return () => {
			reset();
			surrealInstance.close();
		};
	}, [autoConnect, connect, reset, surrealInstance]);

	// Memoize the context value
	const value: SurrealProviderState = useMemo(
		() => ({
			client: surrealInstance,
			isConnecting: isPending,
			isSuccess,
			isError,
			error,
			connect,
			close,
		}),
		[surrealInstance, isPending, isSuccess, isError, error, connect, close],
	);

	return <SurrealContext.Provider value={value}>{children}</SurrealContext.Provider>;
}

/**
 * Access the Surreal connection state from the context.
 */
export function useSurreal() {
	const context = useContext(SurrealContext);
	if (!context) {
		throw new Error("useSurreal must be used within a SurrealProvider");
	}
	return context;
}

/**
 * Access the Surreal client from the context.
 */
export function useSurrealClient() {
	const { client } = useSurreal();
	return client;
}
```

### 3. Wrap Your Application with the Provider

In your top level component (usually `index.tsx`), wrap your root component with `SurrealProvider`:

```tsx title="src/index.tsx"
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { SurrealProvider } from "./SurrealProvider";

const root = ReactDOM.createRoot(document.getElementById("root")!);

root.render(
  <React.StrictMode>
    <SurrealProvider endpoint="http://127.0.0.1:8000" autoConnect>
      <App />
    </SurrealProvider>
  </React.StrictMode>
);
```

### 4. Use the Hooks in Your Components

Anywhere inside the provider component tree, you can now access the Surreal client or check the connection status:

```tsx
import { useEffect } from "react";
import { useSurreal, useSurrealClient } from "./SurrealProvider";

export function ExampleComponent() {
  const { client, isConnecting, isSuccess, isError, error, connect } = useSurreal();
  // or if you only need the client:
  // const client = useSurrealClient();

  useEffect(() => {
    if (isSuccess) {
      // Example: run a query once the connection is successful
      client.query("SELECT * FROM users").then(console.log).catch(console.error);
    }
  }, [isSuccess, client]);

  if (isConnecting) return <p>Connecting to SurrealDB...</p>;
  if (isError) return <p>Failed to connect: {String(error)}</p>;

  return (
    <div>
      <h1>Users</h1>
      {/* Example button to manually reconnect */}
      <button onClick={connect}>Reconnect</button>
    </div>
  );
}
```

### 5. Customizing the Connection Logic

If you need custom logic (e.g., calling `db.use(...)`, providing authentication tokens, etc.), you can:

1. Use the `params` prop:
	```tsx
	<SurrealProvider
		endpoint="http://127.0.0.1:8000"
		params={{ namespace: "myNs", database: "myDb" }}
	>
		<App />
	</SurrealProvider>
	```

2. Supply your own **preconfigured Surreal instance**:
	```tsx
	import Surreal from "surrealdb";

	const customClient = new Surreal();
	await customClient.connect("http://127.0.0.1:8000/rpc");
	await customClient.use({ namespace: "myNs", database: "myDb" });

	<SurrealProvider
		client={customClient}
		endpoint="http://127.0.0.1:8000"
	>
		<App />
	</SurrealProvider>
	```

#### Why Use a Provider?

- **Shared Connection**: A single Surreal client instance is accessible to all your components.
- **Managed Lifecycle**: Auto-connect on mount, reset on unmount, and handle errors gracefully.
- **Connection State**: React Query simplifies loading, success, and error handling.


## Using the SDK methods

If you are only interested in accessing [SDK methods](/docs/sdk/javascript/methods), you can use `useSurrealClient()` to directly obtain a reference to the `Surreal` client instance. In the example below, we use the `.query()` method which allows you write raw SurrealQL queries:

```tsx
import { useState, useEffect } from "react";
import { useSurrealClient } from "./SurrealProvider";

export function ExampleComponent() {
  const client = useSurrealClient();
  const [users, setUsers] = useState([]);

  const fetchUsers = async () => {
    try {
      const result = await client.query("SELECT * FROM users");
      setUsers(result[0] || []); 
    } catch (err) { 
      console.error(err);
    }
  };

  useEffect(() => {
    fetchUsers();
  }, []);

  return (
    <div>
      {users.map((user) => (
        <div key={user?.id}>
          <h3>{user?.name}</h3>
          <p>Email: {user?.email}</p>
        </div>
      ))}

      {users.length === 0 && <p>No users found</p>}
    </div>
  );
}
```

## Next steps 

Now that you have SurrealDB integrated into your React project, you're ready to start building! To learn more about interacting with your database:

- Explore the [JavaScript SDK reference](/docs/sdk/javascript/methods) for a complete list of available methods and features
- See SurrealDB in action by checking out our React example projects in the [examples section](/docs/sdk/javascript#example-projects)
- Join our [Discord community](https://discord.com/invite/surrealdb) to connect with other developers building with React and SurrealDB


================================================
FILE: src/content/doc-sdk-javascript/frameworks/solidjs.mdx
================================================
---
sidebar_position: 1
sidebar_label: SolidJS
title: SolidJS | JavaScript | SDK | Frameworks 
description: The SurrealDB SDK for JavaScript can also be used in your SolidJS applications to interact with your SurrealDB Instance.
---

import LightSolid from "@img/icon/light/solidjs.png";
import DarkSolid from "@img/icon/dark/solidjs.png";

import Image from "@components/Image.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

<div class="flag-title">
	<Image
		alt="SolidJS"
		width={42}
		height={42}
		src={{
			light: LightSolid,
			dark: DarkSolid,
		}}
	/>
	# SolidJS
</div>

[SolidJS](https://docs.solidjs.com/) is a modern JavaScript framework designed to build responsive and high-performing user interfaces (UI). It prioritizes a simple and predictable development experience, making it a great choice for developers of all skill levels. 

The SurrealDB SDK for JavaScript can also be used in your SolidJS applications to interact with your SurrealDB Instance.

In this guide, we will walk you through setting up and querying your first project with the SurrealDB SDK for SolidJS.

## Prerequisites

This guide assumes the following:
- You have a basic understanding of SolidJS.
- You have installed SurrealDB on your machine

## Setup

### Install the SDK

First, install the [SurrealDB SDK](https://npmjs.com/package/surrealdb) using your favorite package manager:

<Tabs groupId="node-package-manager">
  <TabItem value="Bun" label="Bun">
    ```bash
    bun install surrealdb
    ```
  </TabItem>
  <TabItem value="NPM" label="NPM" default>
    ```bash
    npm install --save surrealdb
    ```
  </TabItem>
  <TabItem value="Yarn" label="Yarn">
    ```bash
    yarn add surrealdb
    ```
  </TabItem>
  <TabItem value="Pnpm" label="Pnpm">
    ```bash
    pnpm install surrealdb
    ```
  </TabItem>
</Tabs>

> [!IMPORTANT]
> The SurrealDB SDK for JavaScript is also available in the JSR registry as [`@surrealdb/surrealdb`](https://jsr.io/@surrealdb/surrealdb).

## Initialize the SDK

After installing the SDK, import it into your project. We recommend initializing the SDK in a [Context Provider](https://solidjs.com/docs/components/context) in order to expose it throughout your application. This makes the client accessible anywhere in your component tree, simplifies cleanup, and provides built-in state management for connection success or failure.

### 1. Install Required Packages

In addition to `surrealdb`, we recommend using [@tanstack/solid-query](https://tanstack.com/query/latest) for managing manage the asynchronous connection state to the SurrealDB database. 

Specifically, `createMutation` to create a managed mutation that handles the connection lifecycle. It provides built-in state management for the async operation, automatically tracking loading states (isError, error), and provides utilities like reset to handle errors and retry operations if needed.

You can install the package using your favorite package manager:

<Tabs groupId="node-package-manager">
  <TabItem value="Bun" label="Bun">
    ```bash
    bun install @tanstack/solid-query
    ```
  </TabItem>
  <TabItem value="NPM" label="NPM" default>
    ```bash
    npm install --save @tanstack/solid-query
    ```
  </TabItem>
  <TabItem value="Yarn" label="Yarn">
    ```bash
    yarn add @tanstack/solid-query
    ```
  </TabItem>
  <TabItem value="Pnpm" label="Pnpm">
    ```bash
    pnpm install @tanstack/solid-query
    ```
  </TabItem>
</Tabs>

### 2. Creating the Context Provider 

The best way to manage the connection state is to create a context provider that will handle the connection and provide the client to the rest of the application. In SolidJS, we can use the `createContext` function to create a context and the `createStore` function to manage the state.

First, create a new file, e.g., `SurrealProvider.tsx`, which will contain the context provider and hooks for accessing the SurrealDB client. You can copy the following code, which takes care of managing the connection.

Feel free to make any changes to fit your project structure and coding style. 

> [!NOTE]
> We do recommend adding this in a `lib/providers` directory, but you can place it wherever you see fit.

```ts title= "src/lib/providers/SurrealProvider.tsx"
import { 
    useContext,
    createContext, 
    JSX, 
    createSignal,
    createEffect, 
    onCleanup, 
    Accessor, 
    onMount 
} from "solid-js";
import Surreal from "surrealdb";
import { createMutation } from "@tanstack/solid-query";
import { createStore } from "solid-js/store";

interface SurrealProviderProps {
	children: JSX.Element;
	/** The database endpoint URL */
	endpoint: string;
	/** Optional existing Surreal client */
	client?: Surreal;
	/* Optional connection parameters */
	params?: Parameters<Surreal["connect"]>[1];
	/** Auto connect on component mount, defaults to true */
	autoConnect?: boolean;
}

interface SurrealProviderState {
	/** The Surreal instance */
	client: Accessor<Surreal>;
	/** Whether the connection is pending */
	isConnecting: Accessor<boolean>;
	/** Whether the connection was successfully established */
	isSuccess: Accessor<boolean>;
	/** Whether the connection rejected in an error */
	isError: Accessor<boolean>;
	/** The connection error, if present */
	error: Accessor<unknown|null>;
	/** Connect to the Surreal instance */
	connect: () => Promise<void>;
	/** Close the Surreal instance */
	close: () => Promise<true>;
}

// Store interface to track the Surreal instance and connection status
interface SurrealProviderStore {
	instance: Surreal;
	status: "connecting" | "connected" | "disconnected";
}

const SurrealContext = createContext<SurrealProviderState>();

export function SurrealProvider(props: SurrealProviderProps) {
	// Initialize store with either provided client or new instance
	const [store, setStore] = createStore<SurrealProviderStore>({ 
		instance: props.client ?? new Surreal(),
		status: "disconnected"
	});

	// Use TanStack Query's mutation hook to manage the async connection state
	const { 
		mutateAsync,
		isError,
		error,
		reset
	} = createMutation(() => ({
		mutationFn: async () => {
			setStore("status", "connecting");
			await store.instance.connect(props.endpoint, props.params);
		}
	}));

	// Effect to handle auto-connection and cleanup
	createEffect(() => {
		// Connect automatically if autoConnect is true
		if(props.autoConnect) {
			mutateAsync();
		}

		// Cleanup function to reset mutation state and close connection
		onCleanup(() => {
			reset();
			store.instance.close();
		});
	});

	// Subscribe to connection events when component mounts
	onMount(() => {
		// Update store status when connection is established
		store.instance.emitter.subscribe("connected", () => {
			setStore("status", "connected");
		});

		// Update store status when connection is lost
		store.instance.emitter.subscribe("disconnected", () => {
			setStore("status", "disconnected");
		});
	});

	// Create the value object that will be provided through context
	const providerValue: SurrealProviderState = {
		client: () => store.instance,
		close: () => store.instance.close(),
		connect: mutateAsync,
		error: () => error,
		isConnecting: () => store.status === "connecting",
		isError: () => isError,
		isSuccess: () => store.status === "connected"
	};

	return (
		<SurrealContext.Provider value={providerValue}>
			{props.children}
		</SurrealContext.Provider>
	);
}

// Custom hook to access the SurrealDB context
export function useSurreal(): SurrealProviderState {
	const context = useContext(SurrealContext);
	
	// Ensure the hook is used within a provider
	if(!context) {
		throw new Error("useSurreal must be used within a SurrealProvider");
	}

	return context;
}
```

### 3. Wrap Your Application with the Provider

After creating the SurrealProvider, you'll need to wrap your application's root component with it. Here's an example of how to set up your `App.tsx` component with the necessary providers. We're using both the `QueryClientProvider` for managing async state and our custom `SurrealProvider` for database connectivity, along with routing and authentication setup:
 
```tsx title="src/App.tsx"
import type { Component } from 'solid-js';
import { Router, Route } from "@solidjs/router";
import { SurrealProvider } from './lib/providers/SurrealProvider';
import { QueryClientProvider } from '@tanstack/solid-query';
import { tanstackClient } from './lib/query-client';
import { AuthProvider } from './lib/providers/auth';
import { AppLayout } from './components/layout/app';


const App: Component = () => {
	return (
		<QueryClientProvider client={tanstackClient}>
			<SurrealProvider
				endpoint={import.meta.env.VITE_DB_HOST}
				autoConnect
				params={{
					namespace: "surrealdb",
					database: "pollwebapp",
				}}
			>
				<AuthProvider>
					<Router>
						<Route path="/" component={AppLayout}>
							... your routes here
						</Route>
					</Router>
				</AuthProvider>
			</SurrealProvider>
		</QueryClientProvider>
	);
};

export default App;
```

### 4. Use the `useSurreal` Hook in Your Components

Now you can use the `useSurreal` hook in your components to access the SurrealDB client. For example, you can create an `AuthProvider` to handle authentication and user management.

```ts title="src/lib/providers/AuthProvider.tsx"
import { Accessor, createContext, ParentProps, useContext } from "solid-js";
import { createStore } from "solid-js/store";
import { useSurreal } from "../lib/providers/SurrealProvider";

interface AuthProviderState {
	user: Accessor<UserRecord | undefined>;
	login: (email: string, password: string) => Promise<void>;
	register: (data: Omit<UserRecord, "id">) => Promise<void>;
	logout: () => Promise<void>;
}

interface AuthProviderStore {
	user: UserRecord | undefined;
	status: "idle" | "signing-in" | "signing-up" | "signing-out" | "signed-in" | "signed-up";
}

const AuthContext = createContext<AuthProviderState>();

export function AuthProvider(props: ParentProps) {

	const { 
		client, 
		close, 
		connect 
	} = useSurreal();

	const [store, setStore] = createStore<AuthProviderStore>({
		user: undefined,
		status: "idle"
	});

	const login = async (email: string, password: string) => {
		const db = client();
		
		setStore("status", "signing-in");

		await db.signin({ 
			access: "user",
			namespace: "surrealdb",
			database: "pollwebapp",
			variables: {
				email: email,
				pass: password
			}
		});

		setStore("status", "signed-up");
	};

	const register = async (data: Omit<UserRecord, "id">) => {
		const db = client();

		setStore("status", "signing-up");

		await db.signup({
			access: "user",
			namespace: "surrealdb",
			database: "pollwebapp",
			variables: data
		}); 

		setStore("status", "signed-up");
	};

	const logout = async () => {

		setStore("status", "signing-out");

		await close();
		await connect();

		setStore("status", "idle");
	};

	const providerValue: AuthProviderState = {
		user: () => store.user,
		login,
		register,
		logout
	};

	return (
		<AuthContext.Provider value={providerValue}>
			{props.children}
		</AuthContext.Provider>
	);
}

export function useAuth(): AuthProviderState {
	const ctx = useContext(AuthContext);

	if(!ctx) {
		throw new Error("useAuth must be used within an AuthProvider");
	}

	return ctx;
}
```

## Next steps 

Now that you have SurrealDB integrated into your SolidJS project, you're ready to start building! To learn more about interacting with your database:

- Explore the [JavaScript SDK reference](/docs/sdk/javascript/methods) for a complete list of available methods and features
- See SurrealDB in action by checking out our SolidJS example projects in the [examples section](/docs/sdk/javascript#example-projects)
- Join our [Discord community](https://discord.com/invite/surrealdb) to connect with other developers building with SolidJS and SurrealDB


================================================
FILE: src/content/doc-sdk-javascript/methods/authenticate.mdx
================================================
---
sidebar_position: 1
sidebar_label: authenticate
title: JavaScript | SDK | Methods | authenticate
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.authenticate()` {#authenticate}

Authenticates the current connection with a JWT token.

```ts title="Method Syntax"
db.authenticate(token: string)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody> 
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>token</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The JWT authentication token.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```javascript
await db.authenticate('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJTdXJyZWFsREIiLCJpYXQiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwiZXhwIjoxODM2NDM5MDIyLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJTQyI6InVzZXIiLCJJRCI6InVzZXI6dG9iaWUifQ.N22Gp9ze0rdR06McGj1G-h2vu6a6n9IVqUbMFJlOxxA');
```

You can invalidate the authentication for the current connection using the [`invalidate()` method](/docs/sdk/javascript/methods/invalidate).


================================================
FILE: src/content/doc-sdk-javascript/methods/close.mdx
================================================
---
sidebar_position: 1
sidebar_label: close
title: JavaScript | SDK | Methods | close
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

# `.close()` {#close}

Closes the persistent connection to the database.

```javascript title="Method Syntax"
db.close()
```

### Example usage
```javascript
await db.close();
```


================================================
FILE: src/content/doc-sdk-javascript/methods/connect.mdx
================================================
---
sidebar_position: 1
sidebar_label: connect
title: JavaScript | SDK | Methods | connect
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

# `.connect()` {#connect}

Connects to a local or remote database endpoint.

```javascript title="Method Syntax"
db.connect(url, options)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>url</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The url of the database endpoint to connect to.
            </td>
        </tr>
                <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>options</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                An object with options to initiate the connection to SurrealDB.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

There are several ways to connect to a database endpoint. You can connect to a local or remote endpoint, specify a namespace and database pair to use, authenticate with an existing token, authenticate using a pair of credentials, or use advanced custom logic to prepare the connection to the database.

```ts
// Connect to a local endpoint
await db.connect('http://127.0.0.1:8000/rpc');

// Connect to a remote endpoint
await db.connect('https://cloud.surrealdb.com/rpc');

// Specify a namespace and database pair to use
await db.connect('https://cloud.surrealdb.com/rpc', {
	namespace: 'surrealdb',
	database: 'docs',
});

// Authenticate with an existing token
// The .authenticate() function is used under the hood.
await db.connect('https://cloud.surrealdb.com/rpc', {
	auth: '.....',
});

// Authenticate using a pair of credentials
await db.connect('https://cloud.surrealdb.com/rpc', {
	auth: {
		username: 'root',
		password: 'surrealdb',
	},
});

// Use advanced custom logic to prepare the connection to the database
await db.connect('https://cloud.surrealdb.com/rpc', {
	prepare: async (db) => {
		await db.use({ namespace: 'surrealdb', database: 'docs' });

		const token = await retrieveToken();
		if (token) await db.authenticate(token);

		// Any queries executed before the .prepare() function finishes will be forced to wait
		// Please note that this is also the case for queries executed within the prepare function
		// Doing so can cause the connection to stay in a initializing state
	},
});
```


================================================
FILE: src/content/doc-sdk-javascript/methods/create.mdx
================================================
---
sidebar_position: 1
sidebar_label: create
title: JavaScript | SDK | Methods | create
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.create()` {#create}

Creates a record in the database.

```ts title="Method Syntax"
db.create<T,U>(thing, data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/javascript/data-types#recordid) to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to create.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
type Person = {
	id: string;
	name: string;
	settings: {
		active: boolean;
		marketing: boolean;
	};
};

// Create a record with a random ID
const [person] = await db.create<Person>('person');

// Create a record with a specific ID
const person = await db.create<Person>(new RecordId('person', 'tobie'), {
	name: 'Tobie',
	settings: {
		active: true,
		marketing: true,
	},
});

// The content you are creating the record with might differ from the return type
const [record] = await db.create<
	Person,
	Pick<Person, 'name'>
>(
    new RecordId('person', 'tobie'),
    {
        name: 'Tobie',
    }
);
```

### Translated query
This function will run the following query in the database.

```surql
CREATE $thing CONTENT $data;
```


================================================
FILE: src/content/doc-sdk-javascript/methods/delete.mdx
================================================
---
sidebar_position: 1
sidebar_label: delete 
title: JavaScript | SDK | Methods | delete
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.delete()` {#delete}

Deletes all records in a table, or a specific record, from the database.

```ts title="Method Syntax"
db.delete<T,U>(thing)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/javascript/data-types#recordid) to delete.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```javascript
// Delete all records from a table
await db.delete('person');

// Delete a specific record from a table
await db.delete(new RecordId('person', 'h5wxrf2ewk8xjxosxtyc'));
```

### Translated query
This function will run the following query in the database.

```surql
DELETE $thing;
```


================================================
FILE: src/content/doc-sdk-javascript/methods/export.mdx
================================================
---
sidebar_position: 1
sidebar_label: export
title: JavaScript | SDK | Methods | export
description: The export method allows you to export the database to a file.
---

# `.export()`

This method exports data for a specific Namespace and Database. To use this method, you need to be connected to a SurrealDB instance that is version `>= 2.1.0`. 

It returns a promise that resolves to a string containing the exported SurrealQL statements that can be used to recreate the database state.

```ts title="Method Syntax"
db.export(options?: {
  tables?: string[] | boolean;
  functions?: boolean;
})
```

### Example usage

```ts
// Export everything
const result = await db.export();

// Export specific tables only
const specificTables = await db.export({
  tables: ["foo", "bar"]
});

// Export functions only
const functionsOnly = await db.export({
  functions: true,
  tables: false
});
```

```surql title="Example SurrealQL"
// Create some data
db.query(`
    DEFINE TABLE foo SCHEMALESS;
    DEFINE TABLE bar SCHEMALESS;
    CREATE foo:1 CONTENT { hello: "world" };
    CREATE bar:1 CONTENT { hello: "world" };
    DEFINE FUNCTION fn::foo() {
      RETURN "bar";
    };
`)

// Export specific tables only
db.export({
  tables: ["foo", "bar"],
  functions: true
})

// Export functions only
db.export({
  tables: false,
  functions: true
})

// Export nothing
db.export({
  tables: false,
  functions: false
})

// Export everything
db.export()
```




================================================
FILE: src/content/doc-sdk-javascript/methods/import.mdx
================================================
---
sidebar_position: 1
sidebar_label: import
title: JavaScript | SDK | Methods | import
description: The import method allows you to import data into a SurrealDB database.
---

# `.import()`

This method imports data into a SurrealDB database. To use this method, you need to be connected to a SurrealDB instance that is version `>= 2.0.0`.

```ts title="Method Syntax"
db.import(data: string)
```

### Example usage

```ts
const data = await db.import(
    `
    DEFINE TABLE foo SCHEMALESS;
    DEFINE TABLE bar SCHEMALESS;
    CREATE foo:1 CONTENT { hello: "world" };
    CREATE bar:1 CONTENT { hello: "world" };
    DEFINE FUNCTION fn::foo() {
      RETURN "bar";
    };
`)

const result = await db.query(`
    SELECT * FROM foo;
    SELECT * FROM bar;
`)

console.log(result)
```




================================================
FILE: src/content/doc-sdk-javascript/methods/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: SDK methods
title: JavaScript | SDKs | Integration
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

# SDK methods

The SurrealDB SDK for JavaScript has a single SurrealDB class that provides methods for querying a remote SurrealDB database.
The class is designed to be simple to use and easy to understand for developers who are new to JavaScript or SurrealDB.
This page lists out the methods that are available in the SurrealDB class.

## Initialization methods

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/connect"> <code> db.connect(url, options) </code></a></td>
			<td scope="row" data-label="Description">Connects to a local or remote database endpoint</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/core/create-a-new-connection#close"> <code> db.close() </code></a></td>
            <td scope="row" data-label="Description">Closes the persistent connection to the database</td>
        </tr>
		<tr>
			<td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/use"> <code> db.use(namespace,database)</code></a></td>
			<td scope="row" data-label="Description">Switch to a specific namespace and database</td>
		</tr>
		<tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/let"> <code>db.let(key,val)</code></a></td>
            <td scope="row" data-label="Description">Assigns a value as a parameter for this connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/unset"> <code>db.unset(key)</code></a></td>
            <td scope="row" data-label="Description">Removes a parameter for this connection</td>
        </tr>
	</tbody>
</table>

## Query methods

<table>
    <thead>
        <tr>
            <th scope="col">Method</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/query"> <code>db.query&lt;T&gt;(sql,vars)</code></a></td>
            <td scope="row" data-label="Description">Runs a set of [SurrealQL statements](/docs/surrealql) against the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/select"> <code>db.select&lt;T&gt;(thing)</code></a></td>
            <td scope="row" data-label="Description">Selects all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/core/streaming#live"> <code>db.live&lt;T&gt;(table, callback,diff)</code></a></td>
            <td scope="row" data-label="Description">Initiate a live query</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/core/streaming#subscribeLive"> <code> db.subscribeLive&lt;T&gt;(queryUuid,callback)</code></a></td>
            <td scope="row" data-label="Description">Register a callback for a running live query</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/core/streaming#kill"> <code>db.kill(queryUuid)</code></a></td>
            <td scope="row" data-label="Description">Kill a running live query</td>
        </tr>
    </tbody>
</table>

## Export and Import methods

<table>
    <thead>
        <tr>
            <th scope="col">Method</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/export"> <code>db.export()</code></a></td>
            <td scope="row" data-label="Description">Exports data from a Namespace and Database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/import"> <code>db.import()</code></a></td>
            <td scope="row" data-label="Description">Imports data into a Namespace and Database</td>
        </tr>
        
    </tbody>
</table>

## Mutation methods

<table>
    <thead>
        <tr>
            <th scope="col">Method</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/create"> <code>db.create&lt;T,U&gt;(thing,data)</code></a></td>
            <td scope="row" data-label="Description">Creates a record in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/insert"> <code>db.insert&lt;T,U&gt;(thing,data)</code></a></td>
            <td scope="row" data-label="Description">Inserts one or multiple records in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/insertrelation"> <code>db.insertRelation&lt;T,U&gt;(thing,data)</code></a></td>
            <td scope="row" data-label="Description">Inserts one or multiple relations in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/update"> <code>db.update&lt;T,U&gt;(thing,data)</code></a></td>
            <td scope="row" data-label="Description">Updates all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/upsert"> <code>db.upsert&lt;T,U&gt;(thing,data)</code></a></td>
            <td scope="row" data-label="Description">Inserts records into the database, or updates them if they exist.</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/merge"> <code>db.merge&lt;T,U&gt;(thing,data)</code></a></td>
            <td scope="row" data-label="Description">Modifies all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/patch"> <code>db.patch&lt;T,U&gt;(thing,data)</code></a></td>
            <td scope="row" data-label="Description">Applies JSON Patch changes to all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/delete"> <code>db.delete&lt;T,U&gt;(thing)</code></a></td>
            <td scope="row" data-label="Description">Deletes all records, or a specific record</td>
        </tr>
    </tbody>
</table>

## Authentication methods

<table>
    <thead>
        <tr>
            <th scope="col">Method</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/signup"> <code>db.signup(vars)</code></a></td>
            <td scope="row" data-label="Description">Signs this connection up to a specific authentication scope</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/signin"> <code>db.signin(vars)</code></a></td>
            <td scope="row" data-label="Description">Signs this connection in to a specific authentication scope</td>
        </tr>
		<tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/invalidate"> <code>db.invalidate()</code></a></td>
            <td scope="row" data-label="Description">Invalidates the authentication for the current connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/authenticate"> <code>db.authenticate(token)</code></a></td>
            <td scope="row" data-label="Description">Authenticates the current connection with a JWT token</td>
        </tr>
		<tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/javascript/methods/info"> <code>db.info&lt;T&gt;()</code></a></td>
            <td scope="row" data-label="Description">Returns the record of an authenticated scope user</td>
        </tr>
    </tbody>
</table>


================================================
FILE: src/content/doc-sdk-javascript/methods/info.mdx
================================================
---
sidebar_position: 1
sidebar_label: info
title: JavaScript | SDK | Methods | info
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

# `.info()`

This method returns the record of an authenticated scope user.

```ts title="Method Syntax"
db.info<T>()
```

### Example usage
```ts
const user = await db.info();
```


================================================
FILE: src/content/doc-sdk-javascript/methods/insert.mdx
================================================
---
sidebar_position: 1
sidebar_label: insert
title: JavaScript | SDK | Methods | insert
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.insert()` {#insert}

Inserts one or multiple records in the database.

```ts title="Method Syntax"
db.insert<T,U>(thing, data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or [`RecordId`](/docs/sdk/javascript/data-types#recordid) to insert to.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Either a single document/record or an array of documents/records to insert
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts

type Person = {
	id: string;
	name: string;
	settings: {
		active: boolean;
		marketing: boolean;
	};
};

// Insert a single record
const [person] = await db.insert<Person>('person', {
	name: 'Tobie',
	settings: {
		active: true,
		marketing: true,
	},
});

// Insert multiple records
const people = await db.insert<Person>('person', [
	{
		name: 'Tobie',
		settings: {
			active: true,
			marketing: true,
		},
	},
	{
		name: 'Jaime',
		settings: {
			active: true,
			marketing: true,
		},
	},
]);

// The content you are creating the record with might differ from the return type
const people = await db.insert<
	Person,
	Pick<Person, 'name'>
>('person', [
	{ name: 'Tobie' },
	{ name: 'Jaime' },
]);
```

### Translated query
This function will run the following query in the database.

```surql
INSERT INTO $thing $data;
```


================================================
FILE: src/content/doc-sdk-javascript/methods/insertrelation.mdx
================================================
---
sidebar_position: 1
sidebar_label: insertRelation
title: JavaScript | SDK | Methods | insertRelation
description: The SurrealDB SDK for JavaScript enables you to insert a relation between two records.
---

import Label from "@components/shared/Label.astro";

# `.insertRelation()` {#insertRelation}

Inserts one or multiple relations in the database.

```ts title="Method Syntax"
db.insertRelation<T>(table, data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Optionally pass along a table to insert into.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Either a single document/record or an array of documents/records to insert
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
type Likes = {
	id: RecordId<"likes">;
	in: RecordId<"person">;
	out: RecordId<"post">;
};

// Insert a single record
const [person] = await db.insertRelation<Likes>('likes', {
	in: new RecordId('person', 'tobie'),
	out: new RecordId('post', 123),
});

// Insert multiple records across tables
const people = await db.insertRelation<Likes>('likes', [
	{
    	in: new RecordId('person', 'tobie'),
    	out: new RecordId('post', 123),
	},
	{
    	in: new RecordId('person', 'jaime'),
    	out: new RecordId('post', 456),
	},
]);
```

### Translated query
This function will run the following query in the database.

```surql
INSERT RELATION INTO $table $data;
```


================================================
FILE: src/content/doc-sdk-javascript/methods/invalidate.mdx
================================================
---
sidebar_position: 1
sidebar_label: invalidate
title: JavaScript | SDK | Methods | invalidate
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

# `.invalidate()` {#invalidate}

Invalidates the authentication for the current connection.

```ts title="Method Syntax"
db.invalidate()
```

### Example usage
```ts
await db.invalidate();
```


================================================
FILE: src/content/doc-sdk-javascript/methods/kill.mdx
================================================
---
sidebar_position: 1
sidebar_label: kill
title: JavaScript | SDK | Methods | kill
description: The SurrealDB SDK for JavaScript enables you to kill a running live query.
---

import Label from "@components/shared/Label.astro";

# `.kill()` {#kill}

Kills a running live query by it's UUID

```ts title="Method Syntax"
db.kill(queryUuid)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>queryUuid</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The UUID of the live query you wish to kill
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
await db.kill(queryUuid)
```

<br />


================================================
FILE: src/content/doc-sdk-javascript/methods/let.mdx
================================================
---
sidebar_position: 1
sidebar_label: let
title: JavaScript | SDK | Methods | let
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.let()` {#let}

Assigns a value as a parameter for this connection.

```ts title="Method Syntax"
db.let(key: string, val: any)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>val</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns the value to the variable name.
            </td>
        </tr>
    </tbody>
</table>

### Example Usage
```javascript
// Assign the variable on the connection
await db.let('name', {
	first: 'Tobie',
	last: 'Morgan Hitchcock',
});

// Use the variable in a subsequent query
await db.query('CREATE person SET name = $name');

// Use the variable in a subsequent query
await db.query('SELECT * FROM person WHERE name.first = $name.first');
```

You can remove the variable from the connection using the [`unset()` method](/docs/sdk/javascript/methods/unset).


================================================
FILE: src/content/doc-sdk-javascript/methods/live.mdx
================================================
---
sidebar_position: 1
sidebar_label: live
title: JavaScript | SDK | Methods | live
description: The SurrealDB SDK for JavaScript enables you to listen for changes to records in a table.
---
import Label from "@components/shared/Label.astro";

# `.live()` {#live}

Initiates a live query. 

```ts
db.live<T>(table: string, callback: (action: string, result: T) => void, diff?: boolean)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name to listen for changes for
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>callback</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                A callback function that processes live notifications. Consult the [Live Actions](#live-actions) for a list of all possible values being returned.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>diff</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                If set to true, live notifications will include an array of JSON Patch objects, rather than the entire record for each notification.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```ts
// The uuid of the live query will be returned
const queryUuid = await db.live(
	"person",
	// The callback function takes two arguments: the 'action' and 'result' properties
	( action, result ) => {
		// action can be: 'CREATE', 'UPDATE', 'DELETE' or 'CLOSE'
	    if (action === 'CLOSE') return;

		// result contains either the entire record, or a set of JSON patches when diff mode is enabled
		processSomeLiveQueryUpdate(result);
	}
)
```

## Live Actions

For `CREATE`, `UPDATE` and `DELETE`, the type `Result` is the generic argument passed to [`.live()`](#live) or [`.subscribeLive()`](#subscribeLive). <br />
It extends either `Record<string, unknown>` or `Patch`.

It's generally recommended to handle the `CLOSE` action first, as that clears out the type for the result parameter.

<table>
    <thead>
        <tr>
            <th colspan="1" scope="col">Action</th>
            <th colspan="1" scope="col">Result</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `CLOSE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `killed` or `disconnected`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when the live query is closed due to it either being killed or the connection being disconnected.
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `CREATE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `Result`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when a record within your subscription gets created
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `UPDATE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `Result`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when a record within your subscription gets updated
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `DELETE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `Result`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when a record within your subscription gets deleted
            </td>
        </tr>
    </tbody>
</table>




================================================
FILE: src/content/doc-sdk-javascript/methods/merge.mdx
================================================
---
sidebar_position: 1
sidebar_label: merge
title: JavaScript | SDK | Methods | merge
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.merge()` {#merge}

Modifies all records in a table, or a specific record, in the database.

```javascript title="Method Syntax"
db.merge<T,U>(thing, data)
```

> [!NOTE]
> This function merges the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/javascript/data-types#recordid) to merge.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to merge.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts

type Person = {
	id: string;
	name: string;
	updated_at: Date;
	settings: {
		active: boolean;
		marketing: boolean;
	};
};

// Update all records in a table
const people = await db.merge<Person>('person', {
	updated_at: new Date(),
});

// Update a record with a specific ID
const person = await db.merge<Person>(new RecordId('person', 'tobie'), {
	updated_at: new Date(),
	settings: {
		active: true,
	},
});

// The content you are merging the record with might differ from the return type
const record = await db.merge<
	Person,
	Pick<Person, 'name'>
>(new RecordId('person', 'tobie'), {
	name: 'Tobie',
});
```

### Translated query
This function will run the following query in the database.

```surql
UPDATE $thing MERGE $data;
```


================================================
FILE: src/content/doc-sdk-javascript/methods/patch.mdx
================================================
---
sidebar_position: 1
sidebar_label: patch
title: JavaScript | SDK | Methods | patch
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.patch()` {#patch}

Applies JSON Patch changes to all records, or a specific record, in the database.

```ts title="Method Syntax"
db.patch<T,U>(thing, data)
```

> [!NOTE]
> This function patches the current document / record data with the specified JSON Patch data.


### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/javascript/data-types#recordid) to patch.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The JSON Patch data with which to patch the records.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
// Update all records in a table
const people = await db.patch('person', [
	{ op: 'replace', path: '/created_at', value: new Date() },
]);

// Update a record with a specific ID
const person = await db.patch(new RecordId('person', 'tobie'), [
	{ op: 'replace', path: '/settings/active', value: false },
	{ op: 'add', path: '/tags', value: ['developer', 'engineer'] },
	{ op: 'remove', path: '/temp' },
]);
```

### Translated query
This function will run the following query in the database.

```surql
UPDATE $thing PATCH $data;
```


================================================
FILE: src/content/doc-sdk-javascript/methods/query.mdx
================================================
---
sidebar_position: 1
sidebar_label: query
title: JavaScript | SDK | Methods | query
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.query()` {#query}

Runs a set of [SurrealQL statements](/docs/surrealql) against the database.

```ts title="Method Syntax"
db.query<T>(query, vars)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>query</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>vars</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
type Person = {
	id: string;
	name: string;
};

// Assign the variable on the connection
const result = await db.query<[Person[], Person[]]>(
	'CREATE person SET name = "John"; SELECT * FROM type::table($tb);',
	{ tb: 'person' }
);

// Get the first result from the first query
const created = result[0].result[0];

// Get all of the results from the second query
const people = result[1].result;
```

### `.query_raw()`

With `.query_raw()`, you will get back the raw RPC response. This contrast to the `.query()` method, this will not throw for errors that occur in individual queries, but will rather give those back as a string, and this will include the time it took to execute the individual queries.


================================================
FILE: src/content/doc-sdk-javascript/methods/select.mdx
================================================
---
sidebar_position: 1
sidebar_label: select
title: JavaScript | SDK | Methods | select
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.select()` {#select}

Selects all records in a table, or a specific record, from the database.

```ts title="Method Syntax"
db.select<T>(thing)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/javascript/data-types#recordid) to select.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
type Person = {
	id: string;
	name: string;
};

// Select all records from a table
const people = await db.select<Person>('person');

// Select a specific record from a table
const person = await db.select<Person>(new RecordId('person', 'h5wxrf2ewk8xjxosxtyc'));
const person = await db.select<Person>(new StringRecordId('person:h5wxrf2ewk8xjxosxtyc'));
```

### Translated query
This function will run the following query in the database.

```surql
SELECT * FROM $thing;
```


================================================
FILE: src/content/doc-sdk-javascript/methods/signin.mdx
================================================
---
sidebar_position: 1
sidebar_label: signin
title: JavaScript | SDK | Methods | signin
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";
import Since from "@components/shared/Since.astro";

# `.signin()` {#signin}

Signs in to a root, namespace, database or scope user.

```javascript title="Method Syntax"
db.signin({`{ ... }`})
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Properties</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>username</code>
                <Label label="REQUIRED FOR ROOT, NAMESPACE & DATABASE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The username of the database user
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>password</code>
                <Label label="REQUIRED FOR ROOT, NAMESPACE & DATABASE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The password of the database user
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>namespace</code>
                <Label label="REQUIRED FOR DATABASE & SCOPE/ACCESS" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign in to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>database</code>
                <Label label="REQUIRED FOR SCOPE/ACCESS" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign in to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>scope</code>
                <Since v="1.x" prefix={false} />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The scope to sign in to. Also pass any variables used in the scope. Only supported in SurrealDB 1.x
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>access</code>
                <Since v="2.x" prefix=">=" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The access to sign in to. Also pass any variables used in the access. Only supported from SurrealDB 2.x onwards
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```javascript
// Authenticate with a root user
const token = await db.signin({
	username: 'root',
	password: 'surrealdb',
});

// Authenticate with a Namespace user
const token = await db.signin({
	namespace: 'surrealdb',
	username: 'tobie',
	password: 'surrealdb',
});

// Authenticate with a Database user
const token = await db.signin({
	namespace: 'surrealdb',
	database: 'docs',
	username: 'tobie',
	password: 'surrealdb',
});

// Authenticate with Record Access
const token = await db.signin({
	namespace: 'surrealdb',
	database: 'docs',
	access: 'user',

    // Also pass any properties required by the access definition
	variables: {
    	email: 'info@surrealdb.com',
    	pass: '123456',
    },
});

// Authenticate with Scopes
const token = await db.signin({
	namespace: 'surrealdb',
	database: 'docs',
	scope: 'user',

	// Also pass any properties required by the scope definition
	email: 'info@surrealdb.com',
	pass: '123456',
});
```

You can invalidate the authentication for the current connection using the [`invalidate()` method](/docs/sdk/javascript/methods/invalidate). Learn more about [handling authentication](/docs/sdk/javascript/core/handling-authentication).  


================================================
FILE: src/content/doc-sdk-javascript/methods/signup.mdx
================================================
---
sidebar_position: 1
sidebar_label: signup
title: JavaScript | SDK | Methods | signup
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";
import Since from "@components/shared/Since.astro";

# `.signup()` {#signup}

Signs up to a specific authentication scope.

```javascript title="Method Syntax"
db.signup({`{ namespace, database, [ scope | access ], [...] }`})
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>namespace</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign up to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>database</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign up to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>scope</code>
                <Label label="required" />
                <Since v="1.x" prefix={false} />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The scope to sign up to. Also pass any variables used in the scope. Only supported in SurrealDB 1.x
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>access</code>
                <Label label="required" />
                <Since v="2.x" prefix=">=" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The access to sign in to. Also pass any variables used in the access. Only supported from SurrealDB 2.x onwards
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
// With Record Access
const token = await db.signup({
	namespace: 'surrealdb',
	database: 'docs',
	access: 'user',

    // Also pass any properties required by the scope definition
	variables: {
    	email: 'info@surrealdb.com',
    	pass: '123456',
    },
});

// With Scopes
const token = await db.signup({
	namespace: 'surrealdb',
	database: 'docs',
	scope: 'user',

	// Also pass any properties required by the scope definition
	email: 'info@surrealdb.com',
	pass: '123456',
});
```

You can invalidate the authentication for the current connection using the [`invalidate()` method](/docs/sdk/javascript/methods/invalidate). Learn more about [handling authentication](/docs/sdk/javascript/core/handling-authentication). 


================================================
FILE: src/content/doc-sdk-javascript/methods/subscribelive.mdx
================================================
---
sidebar_position: 1
sidebar_label: subscribeLive
title: JavaScript | SDK | Methods | subscribeLive
description: The SurrealDB SDK for JavaScript enables you to listen for changes to records in a table.
---
import Label from "@components/shared/Label.astro";


# `.subscribeLive()` {#subscribeLive}

Registers a callback function for a running live query.

```ts title="Method Syntax"
db.subscribeLive<T>(queryUuid, callback)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>queryUuid</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The UUID of a running live query
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>callback</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                A callback function that processes live notifications. Consult the [Live Actions](#live-actions) for a list of all possible values being returned.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
await db.subscribeLive(
	queryUuid,
	// The callback function takes an object with the "action" and "result" properties
	( action, result ) => {
		// action can be: "CREATE", "UPDATE", "DELETE" or "CLOSE"
	    if (action === 'CLOSE') return;

		// result contains either the entire record, or a set of JSON patches when diff mode is enabled
		processSomeLiveQueryUpdate(result);
	}
)
```


## Live Actions

For `CREATE`, `UPDATE` and `DELETE`, the type `Result` is the generic argument passed to [`.live()`](/docs/sdk/javascript/methods/live) or [`.subscribeLive()`](/docs/sdk/javascript/methods/subscribelive). <br />
It extends either `Record<string, unknown>` or `Patch`.

It's generally recommended to handle the `CLOSE` action first, as that clears out the type for the result parameter.

<table>
    <thead>
        <tr>
            <th colspan="1" scope="col">Action</th>
            <th colspan="1" scope="col">Result</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `CLOSE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `killed` or `disconnected`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when the live query is closed due to it either being killed or the connection being disconnected.
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `CREATE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `Result`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when a record within your subscription gets created
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `UPDATE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `Result`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when a record within your subscription gets updated
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Action">
                `DELETE`
            </td>
            <td colspan="1" scope="row" data-label="Result">
                `Result`
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Emitted when a record within your subscription gets deleted
            </td>
        </tr>
    </tbody>
</table>




================================================
FILE: src/content/doc-sdk-javascript/methods/unset.mdx
================================================
---
sidebar_position: 1
sidebar_label: unset
title: JavaScript | SDK | Methods | unset
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.unset()` {#unset}

Removes a parameter for this connection.

```ts title="Method Syntax"
db.unset(key: string)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```javascript
// Remove the variable from the connection
await db.unset('name');
```



================================================
FILE: src/content/doc-sdk-javascript/methods/update.mdx
================================================
---
sidebar_position: 1
sidebar_label: update
title: JavaScript | SDK | Methods | update
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.update()` {#update}

Updates all records in a table, or a specific record, in the database.

```ts title="Method Syntax"
db.update<T,U>(thing, data)
```

> [!NOTE]
> This function replaces the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/javascript/data-types#recordid) to update.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to update.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```ts
type Person = {
	id: string;
	name: string;
	settings: {
		active: boolean;
		marketing: boolean;
	};
};

// Update all records in a table
const people = await db.update<Person>('person');

// Update a record with a specific ID
const person = await db.update<Person>(new RecordId('person', 'tobie'), {
	name: 'Tobie',
	settings: {
		active: true,
		marketing: true,
	},
});

// The content you are updating the record with might differ from the return type
const record = await db.update<
	Person,
	Pick<Person, 'name'>
>(new RecordId('person', 'tobie'), {
	name: 'Tobie',
});
```

### Translated query
This function will run the following query in the database.

```surql
UPDATE $thing CONTENT $data;
```


================================================
FILE: src/content/doc-sdk-javascript/methods/upsert.mdx
================================================
---
sidebar_position: 1
sidebar_label: upsert
title: JavaScript | SDK | Methods | upsert
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.upsert()` {#upsert}

This method can be used to insert records into the database, or to update them if they exist.

```ts title="Method Syntax"
db.upsert<T,U>(thing, data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/javascript/data-types#recordid) to upsert.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to update.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```ts
type Person = {
	id: string;
	name: string;
	settings: {
		active: boolean;
		marketing: boolean;
	};
};

// Upsert all records in a table
const multiple = await db.upsert<Person>(
	'person',
	{
		name: 'Mary Doe',
		settings: {
			active: true,
			marketing: false,
		},
	}
);

// Upsert a record with a specific ID
const single = await db.upsert<Person>(
	new RecordId('person', 'john-doe'),
	{
		name: 'John Doe',
		settings: {
			active: true,
			marketing: true,
		},
	}
);

// The content you upsert might differ from the return type
const partial = await db.upsert<
	Person,
	Pick<Person, 'name'>
>(
	new RecordId('person', 'jane-doe'),
	{
		name: 'Jane Doe',
	}
);

```


================================================
FILE: src/content/doc-sdk-javascript/methods/use.mdx
================================================
---
sidebar_position: 1
sidebar_label: use
title: JavaScript | SDK | Methods | use
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.use()` {#use}

Switch to a specific namespace and database. If only the ns or db property is specified, the current connection details will be used to fill the other property.

```javascript title="Method Syntax"
db.use({ namespace: 'surrealdb', database: 'docs' });
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>namespace</code>
                <Label label="initially required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Switches to a specific namespace.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>database</code>
                <Label label="initially required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Switches to a specific database.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```javascript
await db.use({ namespace: 'surrealdb', database: 'docs' });
```



================================================
FILE: src/content/doc-sdk-php/data-types.mdx
================================================
---
sidebar_position: 2
sidebar_label: Data Types
title: PHP Data Types | PHP SDK | Integration | SurrealDB
description: The SurrealDB SDK for PHP enables simple and advanced querying of a remote database.
---

# Data Types

The PHP SDK translates all SurrealQL datatypes into native PHP types, or a custom implementation. This document describes all datatypes, and links to their respective documentation.

## Data Types overview

<table>
    <thead>
        <tr>
            <th colspan="1" scope="col">Datatype</th>
            <th colspan="1" scope="col">Kind</th>
            <th colspan="2" scope="col">Documentation</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="1" scope="row">String</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://www.php.net/manual/en/language.types.string.php">
                    <code>string</code> on php.net
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Int</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://www.php.net/manual/en/language.types.integer.php">
                    <code>integer</code> on php.net
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Float</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://www.php.net/manual/en/language.types.float.php">
                    <code>float</code> on php.net
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Bool</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://www.php.net/manual/en/language.types.boolean.php">
                    <code>bool</code> on php.net
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">null</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://www.php.net/manual/en/language.types.null.php">
                    <code>null</code> on php.net
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Array / Associative</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://www.php.net/manual/en/language.types.array.php">
                    <code>array</code> on php.net
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Datetime</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://www.php.net/manual/en/class.datetime">
                    <code>DateTime</code> on php.net
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Binary</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <a href="https://github.com/welpie21/cbor.php/blob/main/src/utils/CborByteString.php">
                    <code>CborByteString</code>
                </a>
            </td>
        </tr>
		<tr>
            <td colspan="1" scope="row">None</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <a href="https://github.com/surrealdb/surrealdb.php/blob/main/src/Cbor/Types/None.php">
                    <code>[None](#none)</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">RecordId</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[RecordId](#recordid)</code>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Uuid</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[Uuid](#uuid)</code>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Duration</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[Duration](#duration)</code>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Geometry</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[Geometry](#geometry)</code>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Decimal</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[Decimal](#decimal)</code>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Table</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[Table](#table)</code>
            </td>
        </tr>
    </tbody>
</table>

<br /><br />

##  `RecordId`

When you receive a RecordId from SurrealDB, it will always be represented as a `RecordId` class.
This class holds a `tb` and `id` field, representing the table name, and a unique identifier for the record on that table.
A `RecordId` can be converted into a string, and will be represented as such when it's converted to JSON.

```php title="Signature"
new RecordId(string $tb, string|int|array $id)
```

### Working with a `RecordId`

```php title="Constructing"
// table is "person"
// unique identifier on the table is "john"
$rid = new RecordId("person", "john");
```

```php title="Extracting data"
// Simple
$rid = new RecordId("person", "john");
$rid->tb // "person"
$rid->id // "john"

// Complex
$rid = new RecordId("recording", ["city" => "London", "data" => 123 ]);

$rid->id         // [ "city" => "London", "data" => 123 ]
$rid->id["city"] // "London"
$rid->id["data"] // 123
```

### Convert to String

The PHP SDK flawlessly and efficiently handles escaping the `tb` and `id` parts in Record Id's into their string counterparts.
Below are some examples

```php title="Simple"
$rid = (new RecordId("table", 123))->toString();
// 'table:123'
$rid = (new RecordId("table", "abc"))->toString();
// 'table:abc'
```

```php title="Complex characters"
$rid = (new RecordId("table", "123"))->toString();
// 'table:`123`'
$rid = (new RecordId("table", "123withletters"))->toString();
// 'table:123withletters'
$rid = (new RecordId("table", "complex-string"))->toString();
// 'table:`complex-string`'
$rid = (new RecordId("table-name", 123))->toString();
// '`table-name`:123'
```

```php title="Objects and Arrays"
$rid = (new RecordId("table", ["city" => "London"]))->toString();
// 'table:{ city: "London" }'
$rid = (new RecordId("table", ["London"]))->toString();
// 'table:["London"]'
```

### Send back string

If you need to send back a Record Id in string format, you can do so with the `StringRecordId` class.

We do not implement the parsing of Record Ids in the PHP SDK, as that would mean that we need to be able to parse any SurrealQL value, 
which comes with a cost. Instead you can send it over as a string with `StringRecordId`, allowing the server to handle the parsing.

```php
new StringRecordId("person:john");
```

<br />

## `Geometry`

When a Geometry is sent back from SurrealDB, be it a `Point`, `Line`, `Polygon`, `MultiPoint`, `MultiLine`, `MultiPolygon` or `Collection`, it will be represented as a derivative of the `Geometry` class.

### Methods

Below, are all the methods implemented across all geometry derivatives.

#### `->toJSON()`

Used to convert a geometry to a GeoJSON representation

```php title="Signature"
Geometry->toJson();
```

```php title="Example"
$line = new GeometryLine([
    new GeometryPoint([1, 2]),
    new GeometryPoint([3, 4]),
]);

$line->toJson();                    // '{ type: "LineString", coordinates: [ [1, 2], [3, 4] ] }'
json_encode($line);                 // '{ type: "LineString", coordinates: [ [1, 2], [3, 4] ] }'
```

#### `->is()`

Used to convert a check if geometry X is exactly equal to geometry Y

```php title="Signature"
Geometry->is(Geometry $geometry)
```

```php title="Example"
$point1 = new GeometryPoint([1, 2]);
$point2 = new GeometryPoint([3, 4]);
$line = new GeometryLine([$point1, $point2]);

$point1->is($point1);      // true
$point1->is($point2);      // false
$point1->is($line);        // false

// Checks the inner values, does not need to be the same instance
$duplicate = new GeometryPoint([1, 2]);
$point1->is($duplicate);   // true
```

#### `->clone()`

Used to deeply clone a geometry. Creates a new replica of the original instance, but changing the new instance won't affect the other.

```php title="Signature"
Geometry->clone()
```

### Properties

#### `->coordinates`

A getter property, representing the coordinates as shown in GeoJSON format for X Geometry

```php title="Signature"
Geometry.coordinates
```

### Derivatives

#### `GeometryPoint`

A [point](/docs/surrealql/datamodel/geometries#point) in space, made up of a long and lat coordinate, automatically converted to a float.

```php title="Signature"
new GeometryPoint([int|float|Decimal $long, int|float|Decimal $lat]);
```

#### `GeometryLine`

A line, made up of two or more points

```php title="Signature"
new GeometryLine([GeometryPoint, GeometryPoint, ...GeometryPoint[]]);
```

#### `GeometryPolygon`

A polygon, made up of self-closing lines

**Note**: The lines inside the polygon will automatically be closed if not already, meaning that the last point will be the same as the first.

```php title="Signature"
new GeometryPolygon([GeometryLine, ...GeometryLine[]]);
```

#### `GeometryMultiPoint`

A collection of one or more points

```php title="Signature"
new GeometryMultiPoint([GeometryPoint, ...GeometryPoint[]]);
```

#### `GeometryMultiLine`

A collection of one or more lines

```php title="Signature"
new GeometryMultiLine([GeometryLine, ...GeometryLine[]]);
```

#### `GeometryMultiPolygon`

A collection of one or more polygons

```php title="Signature"
new GeometryMultiPolygon([GeometryPolygon, ...GeometryPolygon[]]);
```

#### `GeometryCollection`

A collection of one or more `Geometry` derivatives

```php title="Signature"
new GeometryCollection([Geometry, ...Geometry[]]);
```

<br />

## `Decimal`

Because PHP does not support Decimals natively, 
our SDK represents them in a `Decimal` class as a string. 
This means if you want to work with Decimals, you will need to use an external library for this.

```php title="Signature"
new Decimal(string|float|Decimal $decimal);
```

### Converting to string

```php
$decimal = new Decimal("123.456");
decimal->toString(); // "123.456"
```

### Converting to JSON

A `Decimal` will be represented as a string in JSON to perserve accuracy

```php
$decimal = new Decimal("123.456");
$decimal->toJson();                  // "123.456"
json_encode(decimal);                // "123.456"
```

<br />

## `Table`

When you get a table name sent back from SurrealDB, it will be represented as a `Table` class.

```php title="Signature"
new Table(string $table);
```

### Converting to string

```php
$table = new Table("table");
$table->toString();              // "table"
```Composer package

### Converting to JSON

A `Table` will be represented as a string in JSON

```php
$table = new Table("table");
$table->jsonSerializable();      // "table"
json_encode($table);             // "table"
```



================================================
FILE: src/content/doc-sdk-php/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Overview
title: PHP SDK | Integration | SurrealDB
description: The SurrealDB SDK for PHP enables simple and advanced querying of a remote database.
---

import Boxes from "@components/boxes/Boxes.astro";
import IconBox from "@components/boxes/IconBox.astro";
import Image from "@components/Image.astro";
import Version from '@components/Version.astro';

import LightPhp from "@img/icon/light/php.png";
import LightLaravel from "@img/icon/light/laravel.png";
import LightSymfony from "@img/icon/light/symfony.png";

import DarkPhp from "@img/icon/dark/php.png";
import DarkLaravel from "@img/icon/dark/laravel.png";
import DarkSymfony from "@img/icon/dark/symfony.png";

import LightLogo from "@img/icon/light/php.png";
import DarkLogo from "@img/icon/dark/php.png";

<div class="flag-title">
	<Image
		alt="PHP"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# PHP SDK
</div>

The SurrealDB SDK for PHP is the primary SDK for interacting with SurrealDB from server-side applications, systems, and APIs, allowing you to integrate SurrealDB into your website or application backend, and serve dynamic content to your users. You can use the PHP SDK to interact with your SurrealDB database instances, with functionality for executing queries, managing data, running database functions, authenticating to the database, building user signup and authentication functionality, and subscribing to data changes with live queries. When connecting to remote database instances, connections automatically reconnect when terminated.

> [!IMPORTANT]
> The SDK requires PHP version `8.2` or greater, and is available as a [Composer package](https://packagist.org/packages/surrealdb/surrealdb.php).

> [!NOTE]
> The SDK works seamlessly with SurrealDB versions `v2.0.0` to <Version />, ensuring compatibility with the latest version.

To contribute to the SDK code, submit an Issue or Pull Request in the [surrealdb.php](https://github.com/surrealdb/surrealdb.php) repository. To contribute to this documentation, submit an Issue or Pull Request in the [docs.surrealdb.com](https://github.com/surrealdb/docs.surrealdb.com) repository.

## Language

<Boxes>
    <IconBox
        title="PHP"
        status="available"
        href="/docs/sdk/php"
        icon={{
            light: LightPhp,
            dark: DarkPhp,
        }}
    />
</Boxes>

## Frameworks

<Boxes>
    <IconBox
        title="Laravel"
        status="coming soon"
        icon={{
            light: LightLaravel,
            dark: DarkLaravel,
        }}
    />
    <IconBox
        title="Symfony"
        status="coming soon"
        icon={{
            light: LightSymfony,
            dark: DarkSymfony,
        }}
    />
</Boxes>

## Sources

- [GitHub repository](https://github.com/surrealdb/surrealdb.php)
- [Composer package](https://packagist.org/packages/surrealdb/surrealdb.php)



================================================
FILE: src/content/doc-sdk-php/setup.mdx
================================================
---
sidebar_position: 3
sidebar_label: Getting Started
title: PHP | SDKs | Integration | SurrealDB Docs
description: The SurrealDB SDK for PHP enables simple and advanced querying of a remote database.
---

# Getting Started

Before you can use this SDK in PHP, you need to install the SDK via the [Composer package](https://getcomposer.org/download/) manager.
This guide will walk you through the process of installing the SDK into your project.

### Install the SDK

Within your Compose project, run the following command to install the SDK:

```bash
composer require surrealdb/surrealdb.php
```

### Using the SDK

Once you have installed the SDK, make sure to include the [Composer autoloader](https://getcomposer.org/doc/01-basic-usage.md#autoloading) in your PHP script:

```php
require __DIR__ . '/vendor/autoload.php';
```

You can now use the SDK in your PHP script by importing it:

```php
use Surreal\Surreal;
```

Now that you have the SDK installed and imported, you can start using the SDK to interact with SurrealDB.

Check out the [initialization guide](/docs/sdk/php/core/initialization) to learn more.



================================================
FILE: src/content/doc-sdk-php/core/authentication.mdx
================================================
---
sidebar_position: 2
sidebar_label: Authentication
title: Authentication | PHP SDK | Integration | SurrealDB
description: Learn how to authenticate users and secure the database with the SurrealDB PHP SDK.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Authentication

Since SurrealDB is a database that is designed to be used in a distributed environment, it is important to secure the database and the data that is stored in it.
SurrealDB provides a number of methods for authenticating users and securing the database.

## Define scope

If you haven't defined a scope for your database, you can define a scope by quering to the database using the [`query`](/docs/sdk/php/methods/query) method.

```php
$db->query('
	DEFINE SCOPE user SESSION 24h
	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) );
');
```

In `2.0` and above, the `DEFINE SCOPE` Statement has been replaced with the `DEFINE ACCESS ... TYPE RECORD` Statement so the above query would be:

```php
$db->query('
DEFINE ACCESS user ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 15m, FOR SESSION 12h
;
');
```


## Signup with credentials

To signup a new scoped user, you can use the [`signup`](/docs/sdk/php/methods/signup) method from the `Surreal` class. This method takes an associative array
with the `namespace`, `database`, and `scope` keys as arguments. The `email` and `pass` keys are also required for this example, but it can be different
depending on the required parameters you have defined for the scope.

```php
$db->signup([
	"namespace" => "surrealdb",
	"database" => "surrealdb",
	"scope" => "user",
	"email" => "user@email.com",
	"pass" => "password-123"
]);
```

```php
// 2.0 and above
$db->signup([
	"namespace" => "surrealdb",
	"database" => "surrealdb",
	"access" => "user",
	"email" => "user@email.com",
	"pass" => "password-123"
]);
```

## Signin with credentials

To signin with credentials, you can use the [`signin`](/docs/sdk/php/methods/signin) method.

<Tabs groupId="php-signin">
  <TabItem value="root" label="Root" default>
		Root authentication gives you access to all namespaces and databases within the SurrealDB instance.
		```php
		$token = $db->signin([
			"username" => "root",
			"password" => "secret"
		]);
		```
	</TabItem>
	<TabItem value="namespace" label="Namespace">
		Namespace authentication gives you access to all databases within a particular namespace.
		```php
		$token = $db->signin([
			"username" => "root",
			"password" => "secret",
			"namespace" => "surrealdb"
		]);
		```
	</TabItem>
	<TabItem value="database" label="Database">
		Database authentication gives you access to all data within a single database.
		```php
		$token = $db->signin([
			"username" => "root",
			"password" => "secret",
			"namespace" => "surrealdb",
			"database" => "surrealdb"
		]);
		```
	</TabItem>
	<TabItem value="scope" label="Scope">
		Authenticate using a specific [Scope](/docs/surrealql/statements/define/scope) within a database.
		```php
		$token = $db->signin([
			"email" => "user@email.com",
			"pass" => "secret",
			"namespace" => "surrealdb",
			"database" => "surrealdb",
			"scope" => "user"
		]);
		```
	</TabItem>
		<TabItem value="access" label="Access">
		Authenticate using a specific [access method](/docs/surrealql/statements/define/access) within a database.
		```php
		$token = $db->signin([
			"email" => "user@email.com",
			"pass" => "secret",
			"namespace" => "surrealdb",
			"database" => "surrealdb",
			"access" => "user"
		]);
		```
	</TabItem>
</Tabs>

## Signin with auth token

If you already have signed in and have an auth token stored somewhere, you can authenticate using the [`authenticate`](/docs/sdk/php/methods/authenticate) method.
This method takes one argument, the auth token.

```php
$db->authenticate($token);
```

## User information

When you signed in successfully, you can get the user information by using the [`info`](/docs/sdk/php/methods/info) method.
This returns the user information as an associative array.

```php
$user = $db->info();
```

## Invalidate user session

To invalidate a user session, you can use the [`invalidate`](/docs/sdk/php/methods/invalidate) method. When executed, the user
session will be invalidated and the user will be signed out.

```php
$db->invalidate();
```

In the next article we will cover how to query to the database.



================================================
FILE: src/content/doc-sdk-php/core/data-querying.mdx
================================================
---
sidebar_position: 5
sidebar_label: Data Querying
title: Data Querying | PHP SDK | Integration | SurrealDB
description: Learn how to interact with the database and perform CRUD operations using the SurrealDB SDK for PHP.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Data Querying

The methods below are used to interact with the database and perform CRUD operations.
You can also use the [`query`](/docs/sdk/php/methods/query) method to run [SurrealQL statements](/docs/surrealql/statements) against the database.

## Creating records

If we wish to create a new record in the database, we can use the [`create`](/docs/sdk/php/methods/create) method. The first argument
is the table name and the second argument is an associative array with the column names and values.

```php
$person = $db->create("person:tobie", [
	"name" => "Tobie",
	"lastname" => "Morgan Hitchcock",
	"age" => 30,
	"hobbies" => ["reading", "coding"]
]);
```

## Selecting records

After when you created a record, you can now use the [`select`](/docs/sdk/php/methods/select) method to fetch the newly created person.
The first argument is the newly created person's ID or a string which is the table name.

```php
$person = $db->select($person->id);
```

Or you can fetch it manually by using the RecordID or RecordStringId.

```php
// using the StringRecordId
$id = StringRecordId::create("person:tobie");
$person = $db->select($id);

// using the RecordId
$id = RecordId::create("person", "tobie");
$person = $db->select($id);
```

## Updating records

To update a record, you can use the [`update`](/docs/sdk/php/methods/update) method. The first argument is the RecordID or a StringRecordId,
and the second argument is an associative array with the column names and values. Updating a record can be done if 3 ways:

<Tabs groupId="update-statements" defaultValue="update">
	<TabItem label="update" value="update">
		The [`update`](/docs/sdk/php/methods/update) method will replace the entire record with the new values. So make sure you include all the columns in the associative array.
		```php
		$person = $db->update($person->id, [
			"name" => "Tobie",
			"lastname" => "Morgan Hitchcock",
			"age" => 31
		]);
		```
		You can find more information about updating a record using the update method [here](/docs/surrealql/statements/update).
	</TabItem>
	<TabItem label="merge" value="merge">
		The [`merge`](/docs/surrealql/statements/update#merge-clause) method will merge the new values with the existing record. If the column already exists, it will be replaced with the new value.
		```php
		$person = $db->merge($person->id, [
			"age" => 31
		]);
		```
		You can find more information about updating a record using the merge method [here](/docs/surrealdb/integration/rpc#merge).
	</TabItem>
	<TabItem label="patch" value="patch">
		The [`patch`](/docs/sdk/php/methods/patch) method will update a field in a single or multiple record(s) based on the path provided.
		```php
		$person = $db->patch($person->id, [
			"path" => "/hobbies/0",
			"op" => "replace",
			"value" => "writing"
		]);
		```
		You can find more information about updating a record using the patch method [here](/docs/surrealql/statements/update).
	</TabItem>
</Tabs>

## Deleting records

To delete a record, you can use the [`delete`](/docs/sdk/php/methods/delete) method. The first argument is the RecordID or a StringRecordId.

```php
$db->delete($person->id);
```

or we can use the RecordId or StringRecordId to delete the record.

```php
$id = StringRecordId::create("person:tobie");
$db->delete($id);

$id = RecordId::create("person", "tobie");
$db->delete($id);
```



================================================
FILE: src/content/doc-sdk-php/core/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: SDK Concepts
title: PHP SDK Concepts | SDKs | Integration
description: Learn the core concepts of the SurrealDB SDK for PHP. Understand how to connect to a SurrealDB instance, manage authentication, and interact with the database.
---

# Concepts 

In this section, we will go over the core concepts of the SurrealDB SDK for PHP. You will learn how to connect to a SurrealDB instance, manage authentication, and interact with the database.

- [Initialize SurrealDB](/docs/sdk/php/core/initialization)
- [Handle authentication](/docs/sdk/php/core/authentication)
- [Data Quering](/docs/sdk/php/core/data-querying)


================================================
FILE: src/content/doc-sdk-php/core/initialization.mdx
================================================
---
sidebar_position: 1
sidebar_label: Initialization
title: Initialization | PHP SDK | Integration | SurrealDB
description: Learn how to initialize the SurrealDB SDK for PHP. Understand how to connect to a SurrealDB instance, manage authentication, and interact with the database.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Initialization

This is a guide on how to initialize the SurrealDB SDK for PHP. If you haven't installed the SDK yet in your PHP project, You can go to [getting started](/docs/sdk/php/setup) to learn how to install the SDK.

<Tabs groupId="php-include-or-use">
	<TabItem value="composer" label="Composer" default>
		Before we can make use of any of the packages we have installed for our project, we need to include the `autoload.php` file in our project.
		This file is generated by Composer and it contains all the classes and dependencies that we have installed in our project.
		```php
		include_once __DIR__ . '/vendor/autoload.php';
		```
	</TabItem>
</Tabs>

When we have imported the `Surreal` class, we can initialize a new instance of SurrealDB.
After this is done we can make use of certain methods to interact with the database.

```php
$db = new Surreal();
```

Then we connect to the database. The `connect` method takes the URL of
the database as an argument. The URL can be either `http` or `ws` protocol.

<Tabs groupId="php-protocol">
  <TabItem value="http" label="HTTP" default>
		```php
		$db->connect("http://127.0.0.1:8000/rpc");
		```
	</TabItem>
	<TabItem value="ws" label="WebSocket">
		```php
		$db->connect("ws://127.0.0.1:8000/rpc");
		```
	</TabItem>
</Tabs>

In order to send queries to the database,
we need to set the `namespace` and `database` for the current connection you want
to interact with.

```php
$db->use([
	"namespace" => "test",
	"database" => "test"
]);
```

We should now be successfully connected to the database. In the next article we will cover authenticating our connection.



================================================
FILE: src/content/doc-sdk-php/methods/authenticate.mdx
================================================
---
sidebar_position: 1
sidebar_label: authenticate
title: Authenticate Method in PHP | PHP SDK | Integration | SurrealDB
description: Authenticate the current connection with a JWT token using the authenticate method in the SurrealDB PHP SDK.
---

import Label from "@components/shared/Label.astro";

# `->authenticate()` {#authenticate}

Authenticates the current connection with a JWT token.

```php title="Method Syntax"
$db->authenticate($token)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>token</code>
                <Label label="required" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>string</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                The JWT authentication token.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```php
$db->authenticate('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJTdXJyZWFsREIiLCJpYXQiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwiZXhwIjoxODM2NDM5MDIyLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJTQyI6InVzZXIiLCJJRCI6InVzZXI6dG9iaWUifQ.N22Gp9ze0rdR06McGj1G-h2vu6a6n9IVqUbMFJlOxxA');
```

You can invalidate the authentication for the current connection using the [`invalidate()` method](/docs/sdk/php/methods/invalidate).


================================================
FILE: src/content/doc-sdk-php/methods/close.mdx
================================================
---
sidebar_position: 1
sidebar_label: close
title: Close Method in PHP | PHP SDK | Integration | SurrealDB
description: Close the persistent connection to the database using the close method in the SurrealDB PHP SDK.
---

# `->close()` {#close}

Closes the persistent connection to the database.

```php title="Method Syntax"
$db->close()
```

### Example usage
```php
$db->close();
```


================================================
FILE: src/content/doc-sdk-php/methods/connect.mdx
================================================
---
sidebar_position: 1
sidebar_label: connect
title: Connect Method in PHP | PHP SDK | Integration | SurrealDB
description: Connect to a local or remote database endpoint using the connect method in the SurrealDB PHP SDK.
---

# `->connect()` {#connect}

Connects to a local or remote database endpoint.

```php title="Method Syntax"
$db->connect($host, $options)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>host</code>
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>string</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                The url of the database endpoint to connect to.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>options</code>
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>associative array</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                An object with options to initiate the connection to SurrealDB.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

There are several ways to connect to a database endpoint. You can connect to a local or remote endpoint, specify a namespace and database pair to use, authenticate with an existing token, authenticate using a pair of credentials, or use advanced custom logic to prepare the connection to the database.

```php
// Connect to a local endpoint
$db->connect('http://127.0.0.1:8000/rpc');

// Connect to a remote endpoint
$db->connect('https://cloud.surrealdb.com/rpc');

// Specify a namespace and database pair to use
$db->connect('https://cloud.surrealdb.com/rpc', [
	"namespace" => "surrealdb",
	"database" => "docs",
]);
```


================================================
FILE: src/content/doc-sdk-php/methods/create.mdx
================================================
---
sidebar_position: 1
sidebar_label: create
title: Create Method in PHP | PHP SDK | Integration | SurrealDB
description: Create a record in the database using the create method with the SurrealDB PHP SDK.
---

import Label from "@components/shared/Label.astro";

# `->create()` {#create}

Creates a record in the database.

```php title="Method Syntax"
$db->create($thing, $data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>string</code>, <code>RecordId</code> or <code>StringRecordId</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/php/data-types#recordid) to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>mixed</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to create.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```php
// Create a record with a random ID
[$person] = $db->create('person');

// Create a record with a specific ID
$person = $db->create(new RecordId('person', 'tobie'), [
	"name" => 'Tobie',
	"settings" => [
		"active" => true,
		"marketing" => true,
	],
]);

// The content you are creating the record with might differ from the return type
[$record] = $db->create(
    new RecordId('person', 'tobie'),
    ["name" => "Tobie"]
);
```

### Translated query
This function will run the following query in the database.

```surql
CREATE $thing CONTENT $data;
```


================================================
FILE: src/content/doc-sdk-php/methods/delete.mdx
================================================
---
sidebar_position: 1
sidebar_label: delete 
title: Delete Method in PHP | PHP SDK | Integration | SurrealDB
description: Delete records from a table in the database using the delete method with the SurrealDB PHP SDK.
---

import Label from "@components/shared/Label.astro";

# `->delete()` {#delete}

Deletes all records in a table, or a specific record, from the database.

```php title="Method Syntax"
$db->delete($thing)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>string</code>, <code>RecordId</code> or <code>StringRecordId</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/php/data-types#recordid) to delete.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```php
// Delete all records from a table
$db->delete('person');

// Delete a specific record from a table
$db->delete(new RecordId('person', 'h5wxrf2ewk8xjxosxtyc'));
```

### Translated query
This function will run the following query in the database.

```surql
DELETE $thing;
```


================================================
FILE: src/content/doc-sdk-php/methods/export.mdx
================================================
---
sidebar_position: 1
sidebar_label: export
title: Export Method in PHP | PHP SDK | Integration | SurrealDB
description: Export data from a local or remote database using the export method with the SurrealDB PHP SDK.
---

import Label from "@components/shared/Label.astro";

# `->export()` {#export}

Exports data from a table.

> [!NOTE]
> This method is only available on a remote database targeted with the http protocol.


```php title="Method Syntax"
$db->export($username, $password);
```

### Arguments

<table>
	<thead>
		<tr>
			<th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
			<th colspan="2" scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td colspan="2" scope="row" data-label="Arguments">
				<code>username</code>
				<Label label="required" />
			</td>
			<td colspan="2" scope="row" data-label="Type">
				`string`
			</td>
			<td colspan="2" scope="row" data-label="Description">
				The username to authenticate with.
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row" data-label="Arguments">
				<code>password</code>
				<Label label="required" />
			</td>
			<td colspan="2" scope="row" data-label="Type">
				`string`
			</td>
			<td colspan="2" scope="row" data-label="Description">
				The password to authenticate with.
			</td>
		</tr>
	</tbody>
</table>

### Example

```php title="Example"

// connect to the remote database. For the export to work, the database must exists with also existing data.
$db->connect('http://localhost:8080', [
	'namespace' => 'example',
	'database' => 'example',
]);

// Export data
$response = $db->export('admin', 'password');

// Create a file and write the response to it
$fp = fopen('exported_data.json', 'w');

// Write the response to the file
fwrite($fp, $response);

// Close the file
fclose($fp);
```


================================================
FILE: src/content/doc-sdk-php/methods/health.mdx
================================================
---
sidebar_position: 1
sidebar_label: health
title: Health Method in PHP | PHP SDK | Integration | SurrealDB
description: Check the storage layer health of a local or remote database using the health method with the SurrealDB PHP SDK.
---

import Label from "@components/shared/Label.astro";

# `->health()` {#health}

This method checks wether the database is running and the storage engine is running.

> [!NOTE]
> This method is only available on a remote database targeted with the http protocol.

```php title="Method Syntax"
$db->health();
```

### Example usage
```php
$health = $db->health();
echo "The health status is: $health."; // 200 or 500
```

The health function returns `200` if the database is running and is in good shape. `500` if a failure occurred.


================================================
FILE: src/content/doc-sdk-php/methods/import.mdx
================================================
---
sidebar_position: 1
sidebar_label: import
title: Import Method in PHP | PHP SDK | Integration | SurrealDB
description: Import data into an existing database using the import method with the SurrealDB PHP SDK.
---

import Label from "@components/shared/Label.astro";

# `->import()` {#import}

Imports data into a table.

> [!NOTE]
> This method is only available on a remote database targeted with the http protocol.

```php title="Method Syntax"
$db->import($content, $username, $password);
```

### Arguments

<table>
	<thead>
		<tr>
			<th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
			<th colspan="2" scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td colspan="2" scope="row" data-label="Arguments">
				<code>content</code>
				<Label label="required" />
			</td>
			<td colspan="2" scope="row" data-label="Type">
				`string`
			</td>
			<td colspan="2" scope="row" data-label="Description">
				The content to import.
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row" data-label="Arguments">
				<code>username</code>
				<Label label="required" />
			</td>
			<td colspan="2" scope="row" data-label="Type">
				`string`
			</td>
			<td colspan="2" scope="row" data-label="Description">
				The username to authenticate with.
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row" data-label="Arguments">
				<code>password</code>
				<Label label="required" />
			</td>
			<td colspan="2" scope="row" data-label="Type">
				`string`
			</td>
			<td colspan="2" scope="row" data-label="Description">
				The password to authenticate with.
			</td>
		</tr>
	</tbody>
</table>

### Example

```php title="Example"

// connect and select the namespace + database that the import function will use to import the data
$db->connect('http://localhost:8080', [
	'namespace' => 'example',
	'database' => 'example',
]);

// grab file contents and import the data
$import = file_get_contents('data.surql');
$db->import($import, 'admin', 'password');
```


================================================
FILE: src/content/doc-sdk-php/methods/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: SDK methods
title: PHP Methods | PHP SDK | Integration | SurrealDB
description: List of methods available in the SurrealDB SDK for PHP. Learn how to connect to a database, query data, and manage authentication.
---

# SDK methods

The SurrealDB SDK for PHP has a single SurrealDB class that provides methods for querying a remote SurrealDB database.
The class is designed to be simple to use and easy to understand for developers who are new to PHP or SurrealDB.
This page lists out the methods that are available in the SurrealDB class.

## Initialization methods

<table>
	<thead>
		<tr>
			<th scope="col">Function</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/connect"> <code> $db->connect($url, $options) </code></a></td>
			<td scope="row" data-label="Description">Connects to a local or remote database endpoint</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/close"> <code> $db->close() </code></a></td>
			<td scope="row" data-label="Description">Closes the persistent connection to the database</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/use"> <code> $db->use($options)</code></a></td>
			<td scope="row" data-label="Description">Switch to a specific namespace and database</td>
		</tr>
		<tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/let"> <code>$db->let($key,$val)</code></a></td>
            <td scope="row" data-label="Description">Assigns a value as a parameter for this connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/unset"> <code>$db->unset($key)</code></a></td>
            <td scope="row" data-label="Description">Removes a parameter for this connection</td>
        </tr>
	</tbody>
</table>

## Query methods

<table>
    <thead>
        <tr>
            <th scope="col">Function</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/query"> <code>$db->query($sql,$vars)</code></a></td>
            <td scope="row" data-label="Description">Runs a set of [SurrealQL statements](/docs/surrealql) against the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/select"> <code>$db->select($thing)</code></a></td>
            <td scope="row" data-label="Description">Selects all records in a table, or a specific record</td>
        </tr>
    </tbody>
</table>

## Mutation methods

<table>
    <thead>
        <tr>
            <th scope="col">Function</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/create"> <code>$db->create($thing,$data)</code></a></td>
            <td scope="row" data-label="Description">Creates a record in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/insert"> <code>$db->insert($thing,$data)</code></a></td>
            <td scope="row" data-label="Description">Inserts one or multiple records in the database</td>
        </tr>
		<tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/insertrelation"> <code>$db->insertRelation($thing,$data)</code></a></td>
            <td scope="row" data-label="Description">Inserts one or multiple records in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/update"> <code>$db->update($thing,$data)</code></a></td>
            <td scope="row" data-label="Description">Updates all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/merge"> <code>$db->merge($thing,$data)</code></a></td>
            <td scope="row" data-label="Description">Modifies all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/patch"> <code>$db->patch($thing,$data)</code></a></td>
            <td scope="row" data-label="Description">Applies JSON Patch changes to all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/delete"> <code>$db->delete($thing,$data)</code></a></td>
            <td scope="row" data-label="Description">Deletes all records, or a specific record</td>
        </tr>
    </tbody>
</table>

## Authentication methods

<table>
    <thead>
        <tr>
            <th scope="col">Function</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/signup"> <code>$db->signup($vars)</code></a></td>
            <td scope="row" data-label="Description">Signs this connection up to a specific authentication scope</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/signin"> <code>$db->signin($vars)</code></a></td>
            <td scope="row" data-label="Description">Signs this connection in to a specific authentication scope</td>
        </tr>
		<tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/invalidate"> <code>$db->invalidate()</code></a></td>
            <td scope="row" data-label="Description">Invalidates the authentication for the current connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/authenticate"> <code>$db->authenticate(token)</code></a></td>
            <td scope="row" data-label="Description">Authenticates the current connection with a JWT token</td>
        </tr>
		<tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/info"> <code>$db->info()</code></a></td>
            <td scope="row" data-label="Description">Returns the record of an authenticated scope user</td>
        </tr>
    </tbody>
</table>

## Utility methods

<table>
	<thead>
		<tr>
			<th scope="col">Function</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/import"> <code>$db->import($content, $username, $password)</code></a></td>
			<td scope="row" data-label="Description">Imports data into the database</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/export"> <code>$db->export($username, $password)</code></a></td>
			<td scope="row" data-label="Description">Exports data from the database</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/health"> <code>$db->health()</code></a></td>
			<td scope="row" data-label="Description">Checks wether the database is running and the storage engine is healthy</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function"><a href="/docs/sdk/php/methods/status"> <code>$db->status()</code></a></td>
			<td scope="row" data-label="Description">Wether the database is running or is reachable</td>
		</tr>
	</tbody>
</table>


================================================
FILE: src/content/doc-sdk-php/methods/info.mdx
================================================
---
sidebar_position: 1
sidebar_label: info
title: Info Method in PHP | PHP SDK | Integration | SurrealDB
description: The info method returns information about the authenticated user in the SurrealDB PHP SDK.
---

# `->info()`

This method returns the authenticated record user.

```php title="Method Syntax"
$db->info()
```

### Example usage
```php
$user = $db->info();
```



================================================
FILE: src/content/doc-sdk-php/methods/insert.mdx
================================================
---
sidebar_position: 1
sidebar_label: insert
title: Insert Method in PHP | PHP SDK | Integration | SurrealDB
description: Insert one or multiple records in the database using the insert method with the SurrealDB PHP SDK.	
---

import Label from "@components/shared/Label.astro";

# `->insert()` {#insert}

Inserts one or multiple records in the database.

```php title="Method Syntax"
$db->insert($thing, $data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>string</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or [`RecordId`](/docs/sdk/php/data-types#recordid) to insert to.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>associative array</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                Either a single document/record or an array of documents/records to insert
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```php

// Insert a single record
[$person] = $db->insert('person', [
	"name" => 'Tobie',
	"settings" => [
		"active" => true,
		"marketing" => true,
	],
]);

$person = $db->insert(new RecordId('person', 'tobie'), [
	"name" => 'Tobie',
	"settings" => [
		"active" => true,
		"marketing" => true,
	],
]);

// Insert multiple records
$people = $db->insert('person', [
	[
		"name" => 'Tobie',
		"settings" => [
			"active" => true,
			"marketing" => true,
		],
	],
	[
		"name" => 'Jaime',
		"settings" => [
			"active" => true,
			"marketing" => true,
		],
	],
]);

// The content you are creating the record with might differ from the return type
$people = $db->insert('person', [
	[ "name" => 'Tobie' ],
	[ "name" => 'Jaime' ],
]);
```

### Translated query
This function will run the following query in the database.

```surql
INSERT INTO $thing $data;
```


================================================
FILE: src/content/doc-sdk-php/methods/insertRelation.mdx
================================================
---
sidebar_position: 1
sidebar_label: insertRelation
title: Insert Method in PHP | PHP SDK | Integration | SurrealDB
description: Insert one or multiple relations in the database using the insertRelation method with the SurrealDB PHP SDK.
---

import Label from "@components/shared/Label.astro";

# `->insertRelation()` {#insertRelation}

Inserts one or multiple relations in the database.

```php title="Method Syntax"
$db->insertRelation($thing, $data)
```

### Arguments

<table>
	<thead>
		<tr>
			<th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
			<th colspan="2" scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td colspan="2" scope="row" data-label="Arguments">
				<code>thing</code>
				<Label label="required" />
			</td>
			<td colspan="2" scope="row" data-label="Description">
				`string` or `Table`
			</td>
			<td colspan="2" scope="row" data-label="Description">
				Target table to insert the relation to.
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row" data-label="Arguments">
				<code>data</code>
			   <Label label="optional" />
			</td>
			<td colspan="2" scope="row" data-label="Type">
				`array`
			</td>
			<td colspan="2" scope="row" data-label="Description">
				An array of relations to insert.
			</td>
		</tr>
	</tbody>
</table>

### Example usage
```php

// Insert a single relation
$relation = $db->insertRelation('person', [
	"id" => new RecordId('person', 'tobie'),
	"in" => new RecordId('company', 'surreal'),
	"out" => new RecordId('role', 'founder'),
]);

// Insert multiple relations
$relations = $db->insertRelation('person', [
	[
		"id" => new RecordId('person', 'tobie'),
		"in" => new RecordId('company', 'surreal'),
		"out" => new RecordId('role', 'founder'),
	],
	[
		"id" => new RecordId('person', 'jaime'),
		"in" => new RecordId('company', 'surreal'),
		"out" => new RecordId('role', 'cofounder'),
	],
]);
```


================================================
FILE: src/content/doc-sdk-php/methods/invalidate.mdx
================================================
---
sidebar_position: 1
sidebar_label: invalidate
title: Invalidate Method in PHP | PHP SDK | Integration | SurrealDB
description: Invalidate the authentication for the current connection using the invalidate method in the SurrealDB PHP SDK.
---

# `->invalidate()` {#invalidate}

Invalidates the authentication for the current connection.

```php title="Method Syntax"
$db->invalidate()
```

### Example usage
```php
$db->invalidate();
```


================================================
FILE: src/content/doc-sdk-php/methods/let.mdx
================================================
---
sidebar_position: 1
sidebar_label: let
title: Let Method in PHP | PHP SDK | Integration | SurrealDB
description: Assign parameters to a query using the let method in the SurrealDB PHP SDK.
---

import Label from "@components/shared/Label.astro";

# `->let()` {#let}

Assigns a value as a parameter for this connection.

```php title="Method Syntax"
$db->let($name, $value)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>name</code>
                <Label label="required" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>string</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>value</code>
                <Label label="required" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>mixed</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns the value to the variable name.
            </td>
        </tr>
    </tbody>
</table>

### Example Usage
```php
// Assign the variable on the connection
$db->let('name', [
	"first" => "Tobie",
	"last" => "Morgan Hitchcock",
]);

// Use the variable in a subsequent query
$db->query('CREATE person SET name = $name');

// Use the variable in a subsequent query
$db->query('SELECT * FROM person WHERE name.first = $name.first');
```

You can remove the variable from the connection using the [`unset()` method](/docs/sdk/php/methods/unset).


================================================
FILE: src/content/doc-sdk-php/methods/merge.mdx
================================================
---
sidebar_position: 1
sidebar_label: merge
title: Merge Method in PHP | PHP SDK | Integration | SurrealDB
description: The ->merge() method for the SurrealDB SDK for PHP merges record data with the specified data.
---

import Label from "@components/shared/Label.astro";

# `->merge()` {#merge}

Modifies all records in a table, or a specific record, in the database.

```php title="Method Syntax"
$db->merge($thing, $data)
```

> [!NOTE]
> This function merges the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>string</code>, <code>RecordId</code> or <code>StringRecordId</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/php/data-types#recordid) to merge.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>mixed</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to merge.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```php

// Update all records in a table
$people = $db->merge('person', [
	"updated_at" => new Date(),
]);

// Update a record with a specific ID
$person = $db->merge(new RecordId('person', 'tobie'), [
	"updated_at" => new Date(),
	"settings" => [
		"active" => true,
	],
]);

// The content you are merging the record with might differ from the return type
$record = $db->merge(new RecordId('person', 'tobie'), [
	"name" => 'Tobie',
]);
```

### Translated query
This function will run the following query in the database.

```surql
UPDATE $thing MERGE $data;
```


================================================
FILE: src/content/doc-sdk-php/methods/patch.mdx
================================================
---
sidebar_position: 1
sidebar_label: patch
title: Patch Method in PHP | PHP SDK | Integration | SurrealDB
description: The ->patch() method for the SurrealDB SDK for PHP applies JSON patch changes to records in the database.
---

import Label from "@components/shared/Label.astro";

# `->patch()` {#patch}

Applies JSON Patch changes to all records, or a specific record, in the database.

```php title="Method Syntax"
$db->patch($thing, $data, $diff)
```

> [!NOTE]
> This function patches the current document / record data with the specified JSON Patch data.


### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>string</code>, <code>RecordId</code> or <code>StringRecordId</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/php/data-types#recordid) to patch.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>associative array</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                The JSON Patch data with which to patch the records.
            </td>
        </tr>
		<tr>
			<td colspan="2" scope="row" data-label="Arguments">
				<code>diff</code>
			   <Label label="optional" />
			</td>
			<td colspan="2" scope="row" data-label="Type">
				<code>boolean</code>
			</td>
			<td colspan="2" scope="row" data-label="Description">
				Whether to return the diff of the patched record.
			</td>
		</tr>
    </tbody>
</table>

### Example usage
```php
// Update all records in a table
$people = $db->patch('person', [
	[ "op" => 'replace', "path" => '/created_at', "value" => new Date() ],
]);

// Update a record with a specific ID
$person = $db->patch(new RecordId('person', 'tobie'), [
	[ "op" => 'replace', "path" => '/settings/active', "value" => false ],
	[ "op" => 'add', "path" => '/tags', "value" => ['developer', 'engineer'] ],
	[ "op" => 'remove', "path" => '/temp' ],
]);
```

### Translated query
This function will run the following query in the database.

```surql
UPDATE $thing PATCH $data;
```


================================================
FILE: src/content/doc-sdk-php/methods/query.mdx
================================================
---
sidebar_position: 1
sidebar_label: query
title: Query Method in PHP | PHP SDK | Integration | SurrealDB
description: The ->query() method for the SurrealDB SDK for PHP runs a set of SurrealQL statements against the database.
---

import Label from "@components/shared/Label.astro";

# `->query()` {#query}

Runs a set of [SurrealQL statements](/docs/surrealql) against the database.

```php title="Method Syntax"
$db->query($query, $vars)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>$query</code>
                <Label label="required" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>string</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>$vars</code>
               <Label label="optional" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>associative array</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```php
// Assign the variable on the connection
$result = db->query(
	'CREATE person SET name = "John"; SELECT * FROM type::table($tb);',
	[ "tb" => "person" ]
);

// Get the first result from the first query
$created = $result[0]->result[0];

// Get all of the results from the second query
$people = $result[1]->result;
```


================================================
FILE: src/content/doc-sdk-php/methods/queryRaw.mdx
================================================
---
sidebar_position: 1
sidebar_label: queryRaw
title: QueryRaw Method in PHP | PHP SDK | Integration | SurrealDB
description: The queryRaw method in the SurrealDB PHP SDK allows you to execute raw SQL queries and return the raw RPC response.
---

import Label from "@components/shared/Label.astro";

# `->queryRaw()` {#queryRaw}

With queryRaw, you will get back the raw RPC response. 
This contrast to the .query() method, this will not throw for errors that occur in individual queries, 
but will rather give those back as a string, and this will include the time it took to execute the individual queries.

```php title="Method Syntax"
$db->queryRaw($query, $params);
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>$query</code>
                <Label label="required" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>string</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                The query to execute
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>$params</code>
               <Label label="optional" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>associative array</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                An associative array of parameters to bind to the query.
            </td>
        </tr>
    </tbody>
</table>

### Example

```php title="Example"

// Query the database for all users with the firstname "Tobie" with parameters.
$response = $db->queryRaw(
	'SELECT * FROM users WHERE firstname = $firstname',
	['firstname' => 'Tobie']
);

// Query the database for all users with the firstname "Tobie" without parameters.
$response = $db->queryRaw('SELECT * FROM users WHERE firstname = "Tobie"');
```


================================================
FILE: src/content/doc-sdk-php/methods/run.mdx
================================================
---
sidebar_position: 1
sidebar_label: run
title: Run Method in PHP | PHP SDK | Integration | SurrealDB
description: The run method in the SurrealDB PHP SDK allows you to execute a defined SurrealQL function on the remote database.
---

import Label from "@components/shared/Label.astro";

# `->run()` {#run}

Runs a defined SurrealQL function on the remote database.

```php title="Method Syntax"
$db->run($function, $version, $params);
```

### Arguments

<table>
	<thead>
		<tr>
			<th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
			<th colspan="2" scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td colspan="2" scope="row" data-label="Arguments">
				<code>$function</code>
				<Label label="required" />
			</td>
			<td colspan="2" scope="row" data-label="Description">
				<code>string</code>
			</td>
			<td colspan="2" scope="row" data-label="Description">
				The name of the function to run.
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row" data-label="Arguments">
				<code>$version</code>
				<Label label="optional" />
			</td>
			<td colspan="2" scope="row" data-label="Type">
				`string` or `null`
			</td>
			<td colspan="2" scope="row" data-label="Description">
				The version of the function to run.
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row" data-label="Arguments">
				<code>$params</code>
				<Label label="optional" />
			</td>
			<td colspan="2" scope="row" data-label="Type">
				`array` or `null`
			</td>
			<td colspan="2" scope="row" data-label="Description">
				An array of parameters to pass to the function.
			</td>
		</tr>
	</tbody>
</table>

### Example

```php title="Example"
$functionA = $db->run("fn::hello_world", null, ["Tobie"]);
$functionB = $db->run("fn::hello_world", "v1", ["Tobie"]);

// or with named arguments
$functionA = $db->run("fn::hello_world", params: ["Tobie"]);
$functionB = $db->run("fn::hello_world", version: "v1", params: ["Tobie"]);
```


================================================
FILE: src/content/doc-sdk-php/methods/select.mdx
================================================
---
sidebar_position: 1
sidebar_label: select
title: Select Method in PHP | PHP SDK | Integration | SurrealDB
description: The ->select() method for the SurrealDB SDK for PHP selects all or specific records from the database.
---

import Label from "@components/shared/Label.astro";

# `->select()` {#select}

Selects all records in a table, or a specific record, from the database.

```php title="Method Syntax"
$db->select($thing)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>string</code>, <code>RecordId</code> or <code>StringRecordId</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordId`](/docs/sdk/php/data-types#recordid) to select.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```php
// Select all records from a table
$people = $db->select('person');

// Select a specific record from a table
$person = $db->select(new RecordId('person', 'h5wxrf2ewk8xjxosxtyc'));
$person = $db->select(new StringRecordId('person:h5wxrf2ewk8xjxosxtyc'));
```

### Translated query
This function will run the following query in the database.

```surql
SELECT * FROM $thing;
```


================================================
FILE: src/content/doc-sdk-php/methods/signin.mdx
================================================
---
sidebar_position: 1
sidebar_label: signin
title: Signin Method in PHP | PHP SDK | Integration | SurrealDB
description: The ->signin() method for the SurrealDB SDK for PHP signs in to a specific access method.
---

import Label from "@components/shared/Label.astro";
import Since from "@components/shared/Since.astro";

# `->signin()` {#signin}

Signs in to a root, namespace, database or record/scope user.

```php title="Method Syntax"
$db->signin([
    "namespace" => "test",
    "database" => "db",
    "scope" => "scope",
    // ... other variables
]);
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Properties</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>username</code>
                <Label label="REQUIRED FOR ROOT, NAMESPACE & DATABASE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The username of the database user
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>password</code>
                <Label label="REQUIRED FOR ROOT, NAMESPACE & DATABASE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The password of the database user
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>namespace</code>
                <Label label="REQUIRED FOR DATABASE & SCOPE/ACCESS" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign in to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>database</code>
                <Label label="REQUIRED FOR SCOPE/ACCESS" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign in to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>scope</code>
                <Since v="1.x" prefix={false} />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The scope to sign in to. Also pass any variables used in the scope. Only supported in SurrealDB 1.x
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>access</code>
                <Since v="2.x" prefix=">=" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The access to sign in to. Also pass any variables used in the access. Only supported from SurrealDB 2.x onwards
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```php
// Authenticate with a root user
$token = $db->signin([
	"username" => "root",
	"password" => "surrealdb",
]);

// Authenticate with a Namespace user
$token = $db->signin([
	"namespace" => "surrealdb",
	"username" => "tobie",
	"password" => "surrealdb",
]);

// Authenticate with a Database user
$token = $db->signin([
	"namespace" => "surrealdb",
	"database" => "docs",
	"username" => "tobie",
	"password" => "surrealdb",
]);

// Authenticate with a Scope user
$token = $db->signin([
	"namespace" => "surrealdb",
	"database" => "docs",
	"scope" => "user",

	// Also pass any properties required by the scope definition
	"email" => "info@surrealdb.com",
	"pass" => "123456",
]);
```

You can invalidate the authentication for the current connection using the [`invalidate()` method](/docs/sdk/php/methods/invalidate).



================================================
FILE: src/content/doc-sdk-php/methods/signup.mdx
================================================
---
sidebar_position: 1
sidebar_label: signup
title: Signup Method in PHP | PHP SDK | Integration | SurrealDB
description: The ->signup() method for the SurrealDB SDK for PHP signs up to a specific access method.
---

import Label from "@components/shared/Label.astro";
import Since from "@components/shared/Since.astro";

# `->signup()` {#signup}

Signs up to a specific authentication scope.

```php title="Method Syntax"
$db->signup([
    "namespace" => "test",
    "database" => "db",
    "scope" => "scope",
    // ... other variables
]);
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>namespace</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign up to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>database</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign up to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>scope</code>
                <Label label="required" />
                <Since v="1.x" prefix={false} />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The scope to sign up to. Also pass any variables used in the scope. Only supported in SurrealDB 1.x
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>access</code>
                <Label label="required" />
                <Since v="2.x" prefix=">=" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The access to sign in to. Also pass any variables used in the access. Only supported from SurrealDB 2.x onwards
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```php
$token = $db->signup([
	"namespace" => "surrealdb",
	"database" => "docs",
	"scope" => "user",

	// Also pass any properties required by the scope definition
	"email" => "info@surrealdb.com",
	"pass" => "123456",
]);
```

You can invalidate the authentication for the current connection using the [`invalidate()` method](/docs/sdk/php/methods/invalidate).



================================================
FILE: src/content/doc-sdk-php/methods/status.mdx
================================================
---
sidebar_position: 1
sidebar_label: status
title: Status Method in PHP | PHP SDK | Integration | SurrealDB
description: The status method in the SurrealDB PHP SDK retrieves the current status of a remote database.
---

import Label from "@components/shared/Label.astro";

# `->status()` {#status}

This method retrieves the current status of a remote database.

```php title="Method Syntax"
$db->status();
```

### Example usage
```php
$status = $db->status();
echo "The status code is: $status."; // 200 or 500
```

The status function returns `200` if the database is running and `500` if the database is down or cannot be reached.



================================================
FILE: src/content/doc-sdk-php/methods/unset.mdx
================================================
---
sidebar_position: 1
sidebar_label: unset
title: Unset Method in PHP | PHP SDK | Integration | SurrealDB
description: The ->unset() method for the SurrealDB SDK for PHP removes a parameter from the connection.
---

import Label from "@components/shared/Label.astro";

# `->unset()` {#unset}

Removes a parameter for this connection.

```php title="Method Syntax"
$db->unset($key)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>string</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```php
// Remove the variable from the connection
$db->unset('name');
```


================================================
FILE: src/content/doc-sdk-php/methods/update.mdx
================================================
---
sidebar_position: 1
sidebar_label: update
title: Update Method in PHP | PHP SDK | Integration | SurrealDB
description: The ->update() method for the SurrealDB SDK for Rust updates all or specific records in the database if they exist.
---

import Label from "@components/shared/Label.astro";

# `->update()` {#update}

Updates all records in a table, or a specific record, in the database.

```php title="Method Syntax"
$db->update($thing, $data)
```

> [!NOTE]
> This function replaces the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>string</code>, <code>RecordId</code> or <code>StringRecordId</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordId`](/docs/sdk/php/data-types#recordid) to update.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
			<td colspan="2" scope="row" data-label="Type">
				<code>mixed</code>
			</td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to update.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```php
// Update all records in a table
$people = $db->update('person');

// Update a record with a specific ID
$person = $db->update(new RecordId('person', 'tobie'), [
	"name" => 'Tobie',
	"settings" => [
		"active" => true,
		"marketing" => true,
	],
]);

// The content you are updating the record with might differ from the return type
$record = $db->update(new RecordId('person', 'tobie'), [
	"name" => 'Tobie',
]);
```

### Translated query
This function will run the following query in the database.

```surql
UPDATE $thing CONTENT $data;
```


================================================
FILE: src/content/doc-sdk-php/methods/upsert.mdx
================================================
---
sidebar_position: 1
sidebar_label: upsert
title: Upsert Method in PHP | PHP SDK | Integration | SurrealDB
description: The upsert method in the SurrealDB PHP SDK allows you to create or update a record in a table.
---

import Label from "@components/shared/Label.astro";

# `->upsert()` {#upsert}

Creates or updates a record in a table.

```php title="Method Syntax"
$db->upsert($thing, $data);
```

### Arguments

<table>
	<thead>
		<tr>
			<th colspan="2" scope="col">Arguments</th>
			<th colspan="2" scope="col">Type</th>
			<th colspan="2" scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td colspan="2" scope="row" data-label="Arguments">
				<code>$thing</code>
				<Label label="required" />
			</td>
			<td colspan="2" scope="row" data-label="Type">
				`RecordId`. `StringRecordId` or `string`
			</td>
			<td colspan="2" scope="row" data-label="Description">
				The collection to upsert the record to.
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row" data-label="Arguments">
				<code>$data</code>
				<Label label="required" />
			</td>
			<td colspan="2" scope="row" data-label="Type">
				`mixed`
			</td>
			<td colspan="2" scope="row" data-label="Description">
				The record to upsert.
			</td>
		</tr>
	</tbody>
</table>

### Example

```php title="Example"

$id = new RecordId('users', 'tobie');

// Upsert a record to the "users" collection.
$response = $db->upsert($id, [
	'firstname' => 'Tobie',
	'lastname' => 'Hitchcock',
]);
```


================================================
FILE: src/content/doc-sdk-php/methods/use.mdx
================================================
---
sidebar_position: 1
sidebar_label: use
title: Use Method in PHP | PHP SDK | Integration | SurrealDB
description: The ->use() method for the SurrealDB SDK for PHP switches to a specific namespace and database.
---

import Label from "@components/shared/Label.astro";

# `->use()` {#use}

Switch to a specific namespace and database. If only the ns or db property is specified, the current connection details will be used to fill the other property.

```php title="Method Syntax"
$db->use([ "namespace" => "...", "database" => "..." ]);
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>namespace</code>
                <Label label="initially required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Switches to a specific namespace.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>database</code>
                <Label label="initially required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Switches to a specific database.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```php
$db->use([
    "namespace" => "surrealdb",
    "database" => "docs"
]);
```



================================================
FILE: src/content/doc-sdk-php/methods/version.mdx
================================================
---
sidebar_position: 1
sidebar_label: version
title: Version Method in PHP | PHP SDK | Integration | SurrealDB
description: The version method in the SurrealDB PHP SDK retrieves the current version of a remote database.
---

# `->version()` {#version}

This method retrieves the current version of a remote database.

```php title="Method Syntax"
$db->version();
```

### Example usage
```php
try {
	$version = $db->version();
	echo "The remote database is running version $version.";
} catch (Exception $e) {
	echo "An error occurred while retrieving the version: " . $e->getMessage();
}

```


================================================
FILE: src/content/doc-sdk-python/data-types.mdx
================================================
---
sidebar_position: 3
sidebar_label: Data Types
title:  Data Types | SDKs | Integration
description: The Python SDK translates all datatypes native to SurrealQL into either datatypes native to Python, or a custom implementation. This document describes all datatypes, and links to their respective documentation.
---

# Data Types

The Python SDK translates all datatypes native to SurrealQL into either datatypes native to Python, or a custom implementation. This document describes all datatypes, and links to their respective documentation.

## Data Types overview

<table>
    <thead>
        <tr>
            <th colspan="1" scope="col">Datatype</th>
            <th colspan="1" scope="col">Kind</th>
            <th colspan="2" scope="col">Documentation</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="1" scope="row">String</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str">
                    <code>str</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Number</td>
            <td colspan="1" scope="row">Translated to `int`, `float` or `complex`</td>
            <td colspan="2" scope="row">
                <a href="https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex">
                    <code>int, float or complex</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Float</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex">
                    <code>float</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Decimal</td>
            <td colspan="1" scope="row">via `decimal.Decimal`</td>
            <td colspan="2" scope="row">
                <a href="https://docs.python.org/3/library/decimal.html">
                    <code>Decimal</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Bool</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://docs.python.org/3/library/stdtypes.html#boolean-type-bool">
                    <code>bool</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">None</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://docs.python.org/3/library/stdtypes.html#the-null-object">
                    <code>None</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Array</td>
            <td colspan="1" scope="row">Translated to `list`</td>
            <td colspan="2" scope="row">
                <a href="https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range">
                    <code>list</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Object</td>
            <td colspan="1" scope="row">Translated to `dict`</td>
            <td colspan="2" scope="row">
                <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict">
                    <code>dict</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Datetime</td>
            <td colspan="1" scope="row">Via `datetime.datetime`</td>
            <td colspan="2" scope="row">
                <a href="https://docs.python.org/3/library/datetime.html#datetime-objects">
                    <code>datetime</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Binary</td>
            <td colspan="1" scope="row">Native</td>
            <td colspan="2" scope="row">
                <a href="https://docs.python.org/3/library/stdtypes.html#binary-sequence-types-bytes-bytearray-memoryview">
                    <code>bytes</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">UUID</td>
            <td colspan="1" scope="row">via `uuid.UUID`</td>
            <td colspan="2" scope="row">
                <a href="https://docs.python.org/3/library/uuid.html">
                <code>UUID</code>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Duration</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[Duration](#duration)</code>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Geometry</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[Geometry](#geometry)</code>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">Table</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[Table](#table)</code>
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row">RecordID</td>
            <td colspan="1" scope="row">Custom</td>
            <td colspan="2" scope="row">
                <code>[RecordID](#RecordID)</code>
            </td>
        </tr>
    </tbody>
</table>

<br /><br />

## `Duration`

When you receive a duration from SurrealDB, it will always be represented as a `Duration` class.

```python title="Signature"
from surrealdb import Duration

Duration(duration: str | int | list[int, int])
```

### Create a `Duration`

```python
from surrealdb import Duration

# Parsed from a duration string
Duration("1w2d")
# Input milliseconds
Duration(1000)
# From a compact format ([ms, ns])
Duration([10000, 300])

# By a unit amount
Duration.nanoseconds(1000)
Duration.microseconds(1000)
Duration.milliseconds(1000)
Duration.seconds(1000)
Duration.minutes(1000)
Duration.hours(1000)
Duration.days(1000)
Duration.weeks(1000)
```

### Transform a `Duration`

```python
from surrealdb import Duration

dur = Duration("7d")

# Format as string, always as small as possible
dur.to_string()     # 1w
# Get inner milliseconds
dur._milliseconds  # 604800000
# Get compact format
dur.to_compact()    # [604800]

# How many of a full unit fit into the duration
dur.nanoseconds    # 604800000000000
dur.microseconds   # 604800000000
dur.milliseconds   # 604800000
dur.seconds        # 604800
dur.minutes        # 10080
dur.hours          # 168
dur.days           # 7
dur.weeks          # 1
```

<br />

## `Geometry`

When a Geometry is sent back from SurrealDB, be it a `Point`, `LineString`, `Polygon`, `MultiPoint`, `MultiLineString`, `MultiPolygon` or `Collection`, it will be represented as a derivative of the `Geometry` class.

### Methods

Below, are all the methods implemented across all geometry derivatives.

#### `.to_json()`

Used to convert a geometry to a GeoJSON representation

```python title="Signature"
from surrealdb import Geometry

Geometry.to_json()
```

```python title="Example"
from surrealdb import GeometryLine, GeometryPoint
import json

line = GeometryLine([
    GeometryPoint([1, 2]),
    GeometryPoint([3, 4]),
])

line.to_json()     # { type: "LineString", coordinates: [ [1, 2], [3, 4] ] }
json.dumps(line)   # '{ type: "LineString", coordinates: [ [1, 2], [3, 4] ] }'
```

#### `.is()`

Used to convert a check if geometry X is exactly equal to geometry Y

```python title="Signature"
from surrealdb import Geometry

Geometry.is(geometry: Geometry)
```

```python title="Example"
from surrealdb import GeometryLine, GeometryPoint

point1 = GeometryPoint([1, 2])
point2 = GeometryPoint([3, 4])
line = GeometryLine([point1, point2])

point1.is(point1)      # true
point1.is(point2)      # false
point1.is(line)        # false

# Checks the inner values, does not need to be the same instance
duplicate = GeometryPoint([1, 2])
point1.is(duplicate)   # true
```

#### `.clone()`

Used to deeply clone a geometry. Creates a replica of the original instance, but changing the instance won't affect the other.

```python title="Signature"
from surrealdb import Geometry

Geometry.clone()
```

### Properties

#### `.coordinates`

A getter property, representing the coordinates as shown in GeoJSON format for X Geometry

```python title="Signature"
from surrealdb import Geometry

Geometry.coordinates
```

### Derivatives

#### `GeometryPoint`

A [point](/docs/surrealql/datamodel/geometries#point) in space, made up of a long and lat coordinate, automatically converted to a float.

```python title="Signature"
from surrealdb import GeometryPoint

GeometryPoint([long: int | Decimal, lat: int | Decimal])
```

#### `GeometryLine`

A line, made up of two or more points

```python title="Signature"
from surrealdb import GeometryLine, GeometryPoint

GeometryLine([GeometryPoint, GeometryPoint, ...])
```

#### `GeometryPolygon`

A polygon, made up of self-closing lines

**Note**: The lines inside the polygon will automatically be closed if not already, meaning that the last point will be the same as the first.

```python title="Signature"
from surrealdb import GeometryPolygon, GeometryLine

GeometryPolygon([GeometryLine, ...])
```

#### `GeometryMultiPoint`

A collection of one or more points

```python title="Signature"
from surrealdb import GeometryMultiPoint, GeometryPoint

GeometryMultiPoint([GeometryPoint, ...])
```

#### `GeometryMultiLine`

A collection of one or more lines

```python title="Signature"
from surrealdb import GeometryMultiLine, GeometryLine

GeometryMultiLine([GeometryLine, ...])
```

#### `GeometryMultiPolygon`

A collection of one or more polygons

```python title="Signature"
from surrealdb import GeometryMultiPolygon, GeometryPolygon

GeometryMultiPolygon([GeometryPolygon, ...])
```

#### `GeometryCollection`

A collection of one or more `Geometry` derivatives

```python title="Signature"
from surrealdb import GeometryCollection, Geometry

GeometryCollection([Geometry, ...])
```

<br />

## `Table`

When you get a table name sent back from SurrealDB, it will be represented as a `Table` class.

```python title="Signature"
from surrealdb import Table

Table(table: str)
```

### Converting to string

```python
from surrealdb import Table

table = Table("table")
str(table)    # "table"
```

### Converting to JSON

A `Table` will be represented as a string in JSON

```python
from surrealdb import Table
import json

table = Table("table")
json.dumps(table) # "table"
```

<br />

##  `RecordID`

When you receive a RecordID back from SurrealDB, it will always be represented as a `RecordID`. The class holds `tb` and `id` fields, representing the table name, and a unique identifier for the record on that table. A `RecordID` can be converted into a string, and will be represented as such when it's converted to JSON.

```python title="Signature"
from surrealdb import RecordID

RecordID(tb: str, id: Any)
```

### Working with a `RecordID`

```python title="Constructing"
from surrealdb import RecordID

# table is "person"
# unique identifier on the table is "john"
rid = RecordID("person", "john")
```

```python title="Extracting data"
from surrealdb import RecordID

# Simple
rid = RecordID("person", "john")
rid.table_name # "person"
rid.id # "john"

# Complex
rid = RecordID("recording", {"city": "London", "data": 123})
rid.id      # {"city": "London", "data": 123}
rid.id["city"] # "London"
rid.id["data"] # 123
```

### Convert to String

```python title="Simple"
from surrealdb import RecordID

str(RecordID('table', 123))
# 'table:123'
str(RecordID('table', 'abc'))
# 'table:abc'
```

```python title="Complex characters"
from surrealdb import RecordID

str(RecordID('table', '123'))
# 'table:`123`'
str(RecordID('table', '123withletters'))
# 'table:123withletters'
str(RecordID('table', 'complex-string'))
# 'table:`complex-string`'
str(RecordID('table-name', 123))
# '`table-name`:123'
```

```python title="Objects and Arrays"
from surrealdb import RecordID

str(RecordID('table', {"city": "London"}))
# 'table:{ city: "London" }'
str(RecordID('table', ["London"]))
# 'table:["London"]'
```

### Parse a string to RecordID

The `RecordID.parse` method allows you to convert a string representation of a RecordID back into a `RecordID` object.

```python title="Basic parsing"
from surrealdb import RecordID

# Parse a simple RecordID string
record_id = RecordID.parse("user:john")
print(record_id.table_name)  # "user"
print(record_id.id)  # "john"
```

```python title="Parsing special formats"
from surrealdb import RecordID

# Parse RecordID with special characters in the ID
record_id = RecordID.parse("item:`complex-id`")
print(record_id.table_name)  # "item"
print(record_id.id)  # "complex-id"
```

```python title="Advanced parsing examples"
from surrealdb import RecordID

# Parse a RecordID from a query result
result_id = "weather:['London', '2025-05-07']"
record_id = RecordID.parse(result_id)
print(record_id.table_name)  # "weather"
# The ID will be parsed as a string representation
print(record_id.id)  # "['London', '2025-05-07']"

# Using parse with error handling
try:
    record_id = RecordID.parse("invalid-format")
    # Handle the parsed record ID
except ValueError:
    print("Invalid RecordID format")
```


================================================
FILE: src/content/doc-sdk-python/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Overview
title: Python SDKs | Integration
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/python.png";
import DarkLogo from "@img/icon/dark/python.png";
import Version from "@components/Version.astro";

<div class="flag-title">
	<Image
		alt="Python"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Python SDK
</div>

The SurrealDB SDK for Python is the primary SDK for interacting with SurrealDB from server-side applications, systems, and APIs, and data analysis and engineering tools. You can use the Python SDK to interact with your SurrealDB database instances, or to run SurrealDB as an embedded database within your Python application, with functionality for executing queries, managing data, running database functions, authenticating to the database, building user signup and authentication functionality, and subscribing to data changes with live queries. When connecting to remote database instances, connections automatically reconnect when terminated.

> [!IMPORTANT]
> The SDK requires Python version `3.10` or greater, and is available as a [PyPI package](https://pypi.org/project/surrealdb/).

> [!NOTE]
> The SDK works seamlessly with SurrealDB versions `v2.0.0` to <Version />, ensuring compatibility with the latest version.

To contribute to the SDK code, submit an Issue or Pull Request in the [surrealdb.py](https://github.com/surrealdb/surrealdb.py) repository. To contribute to this documentation, submit an Issue or Pull Request in the [SurrealDB documentation](https://github.com/surrealdb/docs.surrealdb.com) repository.

## Sources

- [GitHub repository](https://github.com/surrealdb/surrealdb.py)
- [PyPI package](https://pypi.org/project/surrealdb/)



================================================
FILE: src/content/doc-sdk-python/installation.mdx
================================================
---
sidebar_position: 2
sidebar_label: Installation
title: Python SDK Installation | SDKs | Installation
description: In this section, you will learn how to install the Python SDK in your project.
---

# Installation

In this section, you will learn how to install the Python SDK in your project. 

### Install the SDK

First, install the [Python SDK from PyPI](https://pypi.org/project/surrealdb/):

```sh
pip install surrealdb
```

<br />

### Import the SDK to your project

After installing, you can then import the SDK into your project.

Sync API

```python
from surrealdb import Surreal
```

Async API
```python
from surrealdb import AsyncSurreal
```

## Next Steps

After installing the SDK, check out the quick start guide to build your a simple application with the SDK. You can also learn more about carrying out common tasks with the SDK in the following sections:
- [Quick Start](/docs/sdk/python/start)
- [Creating a new connection](/docs/sdk/python/concepts/create-a-new-connection)
- [Authenticating users](/docs/sdk/python/concepts/handling-authentication)



================================================
FILE: src/content/doc-sdk-python/start.mdx
================================================
---
sidebar_position: 2
sidebar_label: Quick start
title: Python | SDK | Quick start
description: In this guide, we will walk you through setting up and querying your first project with the SurrealDB SDK for Python.
---
import Image from "@components/Image.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";
import LabsPreview from "@components/LabsPreview.astro";
import QuickStartUI from "@img/quickstart-ui.png";

# Quick start

In this short guide, you will learn how to install, import, and initialize the SDK, as well as perform the basic data manipulation queries. 
This guide uses the `Surreal` class, but this example would also work with `AsyncSurreal` class, with the addition of `await` in front of the class methods.


## Install

```sh
pip install surrealdb
```

## Learn the basics



```python

# Import the Surreal class
from surrealdb import Surreal

# Using a context manger to automatically connect and disconnect
with Surreal("ws://localhost:8000/rpc") as db:
    db.signin({"username": 'root', "password": 'root'})
    db.use("namepace_test", "database_test")

    # Create a record in the person table
    db.create(
        "person",
        {
            "user": "me",
            "password": "safe",
            "marketing": True,
            "tags": ["python", "documentation"],
        },
    )

    # Read all the records in the table
    print(db.select("person"))

    # Update all records in the table
    print(db.update("person", {
        "user":"you",
        "password":"very_safe",
        "marketing": False,
        "tags": ["Awesome"]
    }))

    # Delete all records in the table
    print(db.delete("person"))

    # You can also use the query method 
    # doing all of the above and more in SurrealQl
    
    # In SurrealQL you can do a direct insert 
    # and the table will be created if it doesn't exist
    
    # Create
    db.query("""
    insert into person {
        user: 'me',
        password: 'very_safe',
        tags: ['python', 'documentation']
    };
    """)

    # Read
    print(db.query("select * from person"))
    
    # Update
    print(db.query("""
    update person content {
        user: 'you',
        password: 'more_safe',
        tags: ['awesome']
    };
    """))

    # Delete
    print(db.query("delete person"))
```

## Examples from our labs

<LabsPreview languages={["python"]} limit={4} showAuthor showTopics />

## Next steps

Now that you have learned the basics of the SurrealDB SDK for Python, you can learn more about the SDK and its methods [in the methods section](/docs/sdk/python/methods) and [data types section](/docs/sdk/python/data-types).



================================================
FILE: src/content/doc-sdk-python/concepts/create-a-new-connection.mdx
================================================
---
sidebar_position: 1
sidebar_label: Create a new connection
title: Python | SDK | Create a new connection
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Tabs from "@components/Tabs/Tabs.astro"
import TabItem from "@components/Tabs/TabItem.astro"
import Label from "@components/shared/Label.astro"

# Create a new connection

When creating a new connection to SurrealDB, you can choose to connect to a local or remote endpoint, specify a namespace and database pair to use, authenticate with an existing token, authenticate using a pair of credentials, or use advanced custom logic to prepare the connection to the database.

First, you need to initialize a new instance of the `Surreal` or `AsyncSurreal` class and connect it to a database endpoint.


## Related Methods and Properties

While the `Surreal` class is the primary method to connect to SurrealDB, there are other methods that you can use while managing your connection.

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#connect"> <code> Surreal / AsyncSurreal </code></a></td>
			<td scope="row" data-label="Description">Establishes a persistent connection to the database</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#close"> <code> db.close() </code></a></td>
            <td scope="row" data-label="Description">Closes the persistent connection to the database</td>
        </tr>
		<tr>
			<td scope="row" data-label="Method"><a href="#use"> <code> db.use()</code></a></td>
			<td scope="row" data-label="Description">Switch to a specific namespace and database</td>
		</tr>
	</tbody>
</table>

## `Surreal / AsyncSurreal`

You can specify your connection protocol either as `http`, `https`, `ws`, or `wss`.

### Example usage
```python
# Connect to a local endpoint with http protocol
db = Surreal('http://127.0.0.1:8000')

# Connect to a remote endpoint with ws protocol
db = AsyncSurreal('wss://cloud.surrealdb.com')
```

### Effect of connection protocol on token & session duration

The connection protocol you choose affects how authentication tokens and sessions work:

With websockets connections (`ws://`, `wss://`) you open a single long-lived stateful connection where after the initial authentication, the session duration applies and if not specified, defaults to `NONE` meaning that the session never expires unless otherwise specified. 

When you connect with a HTTP connection (`http://`, `https://`), every request you make is short-lived and stateless, requiring you to authenticate every request individually for which the token is used, creating a short lived session. Hence, the token duration which defaults to 1 hour applies.

You can extend the session duration of a token or a session by setting the `DURATION` clause when creating a new access method with the [`DEFINE ACCESS METHOD`](/docs/surrealql/statements/define/access) statement or when defining a new user with the [`DEFINE USER`](/docs/surrealql/statements/define/user) statement. 

Learn more about token and session duration in our [security best practices](/docs/surrealdb/reference-guide/security-best-practices#expiration) documentation.

<br />

## `.use()`

Depending on the complexity of your use case, you can switch to a specific namespace and database using the `.use()` method. This is particularly useful if you want to switch to a different setup after connecting. You can also stay in the same namespace but switch to a different database. 

Learn more about the `.use()` method [in the methods section](/docs/sdk/python/methods/use).

### Example usage
```python
db.use(namespace='surrealdb', database='docs')
```

<br />

## `.close()`

The `.close()` method closes the persistent connection to the database. You should call this method when you are done with the connection to free up resources.


### Example usage

```python
db.close()
```

## Context manager

You can also use Python's context manger to automatically open and close a connection when exiting the context.

## Putting it all together

```python
from surrealdb import Surreal

# Without using a context manager
db = Surreal('ws://localhost:8000')
db.use('namespace', 'database')
# Sign in and your code...
db.close()

# Using a context manager
with Surreal('ws://localhost:8000') as db:
    db.use('namespace', 'database')
	# Sign in and your code...
```

The same applies when using Async

```python
from surrealdb import AsyncSurreal

# Without using a context manager
db = AsyncSurreal('ws://localhost:8000')
await db.use('namespace', 'database')
# Sign in and your code...
await db.close()

# Using a context manager
async with AsyncSurreal('ws://localhost:8000') as db:
    await db.use('namespace', 'database')
	# Sign in and your code...
```


================================================
FILE: src/content/doc-sdk-python/concepts/data-maniplulation.mdx
================================================
---
sidebar_position: 4
sidebar_label: Data manipulation
title: Python | SDK | Data manipulation
description: SurrealDB supports a number of methods for interacting with the database and performing CRUD operations.
---

import Label from "@components/shared/Label.astro";

# Data manipulation

SurrealDB supports a number of methods for interacting with the database and performing CRUD operations.

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#select"> <code> db.select() </code></a></td>
			<td scope="row" data-label="Description">Selects all records in a table, or a specific record, from the database</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#create"> <code> db.create() </code></a></td>
            <td scope="row" data-label="Description">Creates a record in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#insert"> <code> db.insert() </code></a></td>
            <td scope="row" data-label="Description">Inserts one or multiple records in the database</td>
		</tr>
		<tr>
			<td scope="row" data-label="Method"><a href="#insert_relation"> <code> db.insert_relation() </code></a></td>
			<td scope="row" data-label="Description">Inserts one or multiple relations in the database</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#update"> <code> db.update() </code></a></td>
            <td scope="row" data-label="Description">Updates all records in a table, or a specific record, in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#merge"> <code> db.merge() </code></a></td>
            <td scope="row" data-label="Description">Modifies all records in a table, or a specific record, in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#patch"> <code> db.patch() </code></a></td>
            <td scope="row" data-label="Description">Applies JSON Patch changes to all records, or a specific record, in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#delete"> <code> db.delete() </code></a></td>
            <td scope="row" data-label="Description">Deletes all records in a table, or a specific record, from the database</td>
        </tr>
	</tbody>
</table>

## `.select()` 

Selects all records in a table, or a specific record, from the database.

```python title="Method Syntax"
db.select(thing)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordID`](/docs/sdk/python/data-types#recordid) to select.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
# Select all records from a table
people = db.select('person')

# Select a specific record from a table
person = db.select(RecordID('person', 'h5wxrf2ewk8xjxosxtyc'))
```

### Translated query
This function will run the following query in the database.

```surql
SELECT * FROM $thing;
```

<br />

## `.create()` 

Creates a record in the database.

```python title="Method Syntax"
db.create(thing, data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordID`](/docs/sdk/python/data-types#recordid) to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to create.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
# Create a record with a random ID
person = db.create('person')

# Create a record with a specific ID
person = db.create(RecordID('person', 'tobie'), {
	"name": 'Tobie',
	"settings": {
		"active": True,
		"marketing": True,
	}
})
```

### Translated query
This function will run the following query in the database.

```surql
CREATE $thing CONTENT $data;
```

<br />

## `.insert()` 

Inserts one or multiple records in the database.

```python title="Method Syntax"
db.insert(table, data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name to insert to.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
            	<Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Either a single document/record or an array of documents/records to insert
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python

# Insert a single record
db.insert('person', {
	"name": 'Tobie',
	"settings": {
		"active": True,
		"marketing": True,
	},
})

# Insert multiple records
db.insert('person', [
	{
		"name": 'Tobie',
		"settings": {
			"active": True,
			"marketing": True,
		},
	},
	{
		"name": 'Jaime',
		"settings": {
			"active": True,
			"marketing": True,
		},
	},
])
```

### Translated query
This function will run the following query in the database.

```surql
INSERT INTO $table $data;
```

<br />

## `.insert_relation()` 

Inserts one or multiple relations in the database.

```python title="Method Syntax"
db.insert_relation(table, data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name to insert to.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Either a single document/record or an array of documents/records to insert
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python


# Insert a single record
db.insert_relation('likes', {
	"in": RecordID('person', 'tobie'),
	"out": RecordID('post', 123)
})

# Insert multiple records across tables
people = db.insert_relation('likes', [
	{
    	"in": RecordID('person', 'tobie'),
    	"out": RecordID('post', 123),
	},
	{
    	"in": RecordID('person', 'jaime'),
    	"out": RecordID('post', 456),
	}
])
```

### Translated query
This function will run the following query in the database.

```surql
INSERT RELATION INTO $table $data;
```

<br />

## `.update()` 

Updates all records in a table, or a specific record, in the database.

```python title="Method Syntax"
db.update(thing, data)
```

> [!NOTE]
> This function replaces the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordID`](/docs/sdk/python/data-types#recordid) to update.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to update.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python

# Update all records in a table
db.update('person', {name: "Jaime"})

# Update a record with a specific ID
db.update(RecordID('person', 'tobie'), {
	"name": 'Tobie',
	"settings": {
		"active": True,
		"marketing": True,
	}
})
```

### Translated query
This function will run the following query in the database.

```surql
UPDATE $thing CONTENT $data;
```

<br />

## `.merge()` 

Modifies all records in a table, or a specific record, in the database.

```python title="Method Syntax"
db.merge(thing, data)
```

> [!NOTE]
> This function merges the current document / record data with the specified data. If no merge data is passed it will simply trigger an update.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordID`](/docs/sdk/python/data-types#recordid) to merge.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to merge.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python

# Update all records in a table
db.merge('person', {
	"updated_at": datetime.datetime.now().isoformat()
})

# Update a record with a specific ID
db.merge(RecordID('person', 'tobie'), {
	"updated_at": datetime.datetime.now().isoformat(),
	"settings": {
		"active": True,
	}
})
```

### Translated query
This function will run the following query in the database.

```surql
UPDATE $thing MERGE $data;
```

<br />

# `.patch()`

Applies JSON Patch changes to all records, or a specific record, in the database.

```python title="Method Syntax"
db.patch(thing, data)
```

> [!NOTE]
> This function patches the current document / record data with the specified JSON Patch data.


### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordID`](/docs/sdk/python/data-types#recordid) to patch.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The JSON Patch data with which to patch the records.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
# Update all records in a table
db.patch('person', [
	{ "op": 'replace', "path": '/created_at', "value": datetime.datetime.now().isoformat() },
])

# Update a record with a specific ID
db.patch(RecordID('person', 'tobie'), [
	{ "op": 'replace', "path": '/settings/active', "value": False },
	{ "op": 'add', "path": '/tags', "value": ['developer', 'engineer'] },
	{ "op": 'remove', "path": '/temp' },
])
```

### Translated query
This function will run the following query in the database.

```surql
UPDATE $thing PATCH $data;
```

<br />

## `.delete()`

Deletes all records in a table, or a specific record, from the database.

```python title="Method Syntax"
db.delete(thing,data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordID`](/docs/sdk/python/data-types#recordid) to delete.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
# Delete all records from a table
db.delete('person')

# Delete a specific record from a table
db.delete(RecordID('person', 'h5wxrf2ewk8xjxosxtyc'))
```

### Translated query
This function will run the following query in the database.

```surql
DELETE $thing;
```



================================================
FILE: src/content/doc-sdk-python/concepts/handling-authentication.mdx
================================================
---
sidebar_position: 2
sidebar_label: Handle authentication
title: Python | SDK | Handle authentication
description: SurrealDB supports a number of methods for authenticating users and securing the database.
---

import Label from "@components/shared/Label.astro";
import Since from "@components/shared/Since.astro";
import Version from '@components/Version.astro';
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Handle authentication

Since SurrealDB is a database that is designed to be used in a distributed environment, it is important to secure the database and the data that is stored in it. SurrealDB provides a number of methods for authenticating users and securing the database.

In your SurrealDB database, you can create authentication login using the [`DEFINE ACCESS`](/docs/surrealql/statements/define/access) statement which supports [JWT](/docs/surrealql/statements/define/access/jwt) and [Record](/docs/surrealql/statements/define/access/record) access methods.

The access method used will inform the input for `access` in the `.signup()` and `.signin()` methods.

> [!IMPORTANT]
> If you are not on Version <Version /> of SurrealDB, you will use the `scope` property instead of `access`. 

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#signup"> <code> db.signup() </code></a></td>
			<td scope="row" data-label="Description">Connects to a local or remote database endpoint</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#signin"> <code> db.signin() </code></a></td>
            <td scope="row" data-label="Description">Signs in to a root, namespace, database or scope user</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#invalidate"> <code> db.invalidate() </code></a></td>
            <td scope="row" data-label="Description">Invalidates the current session</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#authenticate"> <code> db.authenticate() </code></a></td>
            <td scope="row" data-label="Description">Authenticates a user with a token</td>
        </tr>
	</tbody>
</table>

## Defining access in your application

The Python SDK has a [`.query()` method](/docs/sdk/python/concepts/writing-surrealql) which allows you to write secure SurrealQL statements from within your application. Using this method, you can define access for your users and securely manage authentication. See the code example below:

<Tabs groupId="define-access">
<TabItem value="V2" label="V2.x" >
```python
...
# Assign the variable on the connection
db.query("""
    DEFINE ACCESS account ON DATABASE TYPE RECORD
        SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
    	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
        DURATION FOR TOKEN 15m, FOR SESSION 12h;
    """
)
...
```
</TabItem>
<TabItem value="V1" label="V1.x" >

```python
...
# Assign the variable on the connection
db.query("""
    DEFINE SCOPE user SESSION 24h
	    SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
	    SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) );
    """
)
...
```
</TabItem>
</Tabs>

> [!NOTE]
> Depending on the connection protocol you choose, authentication tokens and sessions lifetime work differently. Refer to the [connection options](/docs/sdk/python/concepts/create-a-new-connection#effect-of-connection-protocol-on-token--session-duration) documentation for more information.


## User authentication

After you have defined your authentication login, you can use the following methods to authenticate users:


## `.signup()`

Signs up to a specific authentication scope / access method.

```python title="Method Syntax"
db.signup({ ... })
```

### Arguments

<Tabs groupId="signup">
<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>namespace</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign up to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>database</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign up to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>access  </code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The access to sign up to. Also pass any variables used in the access under the `variables` key. Only supported from SurrealDB 2.x onwards
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>variables</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The variables to pass to the access definition
            </td>
        </tr>
    </tbody>
</table>

</TabItem>

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>namespace</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign up to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>database</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign up to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>scope</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The scope to sign up to. Also pass any variables used in the scope. Only supported in SurrealDB 1.x
            </td>
        </tr>
    </tbody>
</table>
</TabItem>
</Tabs>

### Example usage

<Tabs groupId="signup-example">

<TabItem value="V2" label="V2.x" >

```python
# With Record Access
db.signup({
	"namespace": 'surrealdb',
	"database": 'docs',
	"access": 'account',

    # Also pass any properties required by the access definition
	"variables": {
        "email": 'info@surrealdb.com',
        "password": '123456'
    }
})
```
</TabItem>

<TabItem value="V1" label="V1.x" >
```python

# With Scopes
db.signup({
	"namespace": 'surrealdb',
	"database": 'docs',
	"scope": 'user',

	# Also pass any properties required by the scope definition
	"email": 'info@surrealdb.com',
	"password": '123456'
})
```
</TabItem>
</Tabs>

<br />

## `.signin()`

Signs in to a root, namespace, database or scope user.

```python title="Method Syntax"
db.signin({ ... })
```

### Arguments


<Tabs groupId="http-sql">
<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Properties</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>username</code>
                <Label label="REQUIRED FOR ROOT, NAMESPACE & DATABASE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The username of the database user
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>password</code>
                <Label label="REQUIRED FOR ROOT, NAMESPACE & DATABASE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The password of the database user
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>namespace</code>
                <Label label="REQUIRED FOR DATABASE & ACCESS" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign in to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>database</code>
                <Label label="REQUIRED FOR ACCESS" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign in to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>access</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The access to sign in to. Also pass any variables used in the access under the `variables` key. Only supported from SurrealDB 2.x onwards
            </td>
        </tr>
    </tbody>
</table>

</TabItem>

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Properties</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>username</code>
                <Label label="REQUIRED FOR ROOT, NAMESPACE & DATABASE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The username of the database user
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>password</code>
                <Label label="REQUIRED FOR ROOT, NAMESPACE & DATABASE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The password of the database user
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>namespace</code>
                <Label label="REQUIRED FOR DATABASE & SCOPE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign in to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>database</code>
                <Label label="REQUIRED FOR SCOPE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign in to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>scope</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The scope to sign in to. Also pass any variables used in the scope. Only supported in SurrealDB 1.x
            </td>
        </tr>
    </tbody>
</table>
</TabItem>
</Tabs>

### Example usage

<Tabs groupId="signin-example">

<TabItem value="root" label="Root user" >
```python
# Authenticate with a root user
db.signin({
	"database": 'root',
	"password": 'surrealdb',
})
```
</TabItem>

<TabItem value="namespace" label="Namespace user" >
```python
# Authenticate with a Namespace user
db.signin({
	"namespace": 'surrealdb',
	"username": 'tobie',
	"password": '123456',
})
```
</TabItem>

<TabItem value="database" label="Database user" >
```python
# Authenticate with a Database user
db.signin({
	"namespace": 'surrealdb',
	"database": 'docs',
	"username": 'tobie',
	"password": '123456',
})
```
</TabItem>
<TabItem value="record" label="Record Access" >
```python
# Authenticate with Record Access
db.signin({
	"namespace": 'surrealdb',
	"database": 'docs',
	"access": 'account',

    # Also pass any properties required by the access definition
	"variables": {
        "email": 'info@surrealdb.com',
        "password": '123456',
    }
})
```
</TabItem>
<TabItem value="scope" label="Scopes" >
```python
# Authenticate with Scopes
db.signin({
	"namespace": 'surrealdb',
	"database": 'docs',
	"scope": 'user',

	# Also pass any properties required by the scope definition
	"email": 'info@surrealdb.com',
	"password": '123456'
})
```
</TabItem>
</Tabs>


<br />

## `.invalidate()`

Invalidates the authentication for the current connection.

```python title="Method Syntax"
db.invalidate()
```

### Example usage
```python
db.invalidate()
```

<br />

## `.authenticate()`

Authenticates the current connection with a JWT token.

```python title="Method Syntax"
db.authenticate(token)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>token</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The JWT authentication token.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
db.authenticate('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJTdXJyZWFsREIiLCJpYXQiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwiZXhwIjoxODM2NDM5MDIyLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJTQyI6InVzZXIiLCJJRCI6InVzZXI6dG9iaWUifQ.N22Gp9ze0rdR06McGj1G-h2vu6a6n9IVqUbMFJlOxxA')
```

## Learn more

Learn more about authentication in SurrealDB in our [security best practices](/docs/surrealdb/reference-guide/security-best-practices#authentication) documentation and in the [security](/docs/surrealdb/security/authentication#expiration) section of the SurrealDB documentation.  



================================================
FILE: src/content/doc-sdk-python/concepts/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: SDK Concepts
title: Python SDK Concepts | SDKs | Integration
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

# Concepts 

In this section, we will go over the core concepts of the SurrealDB SDK for Python. You will learn how to connect to a SurrealDB instance, manage authentication, and interact with the database.

- [Create a new Connection](/docs/sdk/python/concepts/create-a-new-connection)
- [Handle authentication](/docs/sdk/python/concepts/handling-authentication)
- [Set parameters](/docs/sdk/python/concepts/parameters)
- [Data manipulation](/docs/sdk/python/concepts/data-maniplulation)
- [Real-Time Streaming](/docs/sdk/python/concepts/streaming)
- [Run SurrealQL queries](/docs/sdk/python/concepts/writing-surrealql)


================================================
FILE: src/content/doc-sdk-python/concepts/parameters.mdx
================================================
---
sidebar_position: 3
sidebar_label: Set parameters
title: Python | SDK | Set parameters
description: In this section, you will learn how to set parameters in the SurrealDB Python SDK.
---

import Label from "@components/shared/Label.astro";

# Set parameters

Within your application, you can define parameters that can be used to store and retrieve data from SurrealDB. Parameters are used to store data in a structured format, and can be used to store data in a key-value pair format.

>[!IMPORTANT]
> Parameters allow you to define global (database-wide) parameters that are available to every client.

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#let"> <code> db.let(key, value) </code></a></td>
			<td scope="row" data-label="Description">Assigns a value as a parameter for this connection</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#unset"> <code> db.unset(key) </code></a></td>
            <td scope="row" data-label="Description">Removes a parameter for this connection</td>
        </tr>
	</tbody>
</table>

## `.let()`

Assigns a value as a parameter for this connection.

```python title="Method Syntax"
db.let(key, value)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>value</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns the value to the variable name.
            </td>
        </tr>
    </tbody>
</table>

### Example Usage
```python
# Assign the variable on the connection
db.let('name', {
	"first": 'Tobie',
	"last": 'Morgan Hitchcock',
})

# Use the variable in a subsequent query
db.query('CREATE person SET name = $name')

# Use the variable in a subsequent query
db.query('SELECT * FROM person WHERE name.first = $name.first')
```

<br />

## `.unset()`

Removes a parameter for this connection.

```python title="Method Syntax"
db.unset(key)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
# Remove the variable from the connection
db.unset('name')
```



================================================
FILE: src/content/doc-sdk-python/concepts/streaming.mdx
================================================
---
sidebar_position: 4
sidebar_label: Real-Time data streaming
title: Python | SDK | Real-Time data streaming
description: The SurrealDB SDK for Python allows you to create live queries that listen for changes in the database and automatically update your application when changes occur.
---

import Label from "@components/shared/Label.astro";

# Real-Time data streaming

You can use the SurrealDB Python SDK to create live queries that listen for changes in the database and automatically update your application when changes occur. This feature is useful for building real-time applications that need to respond to changes in the database.

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#live"> <code> db.live(table, diff) </code></a></td>
			<td scope="row" data-label="Description">Initiates a live query for a specified table name</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#subscribe_live"> <code> db.subscribe_live(query_uuid) </code></a></td>
            <td scope="row" data-label="Description">Returns a queue that receives notification messages from a running live query</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#kill"> <code> db.kill(query_uuid) </code></a></td>
			<td scope="row" data-label="Description">Kills a running live query by it's UUID</td>
		</tr>
	</tbody>
</table>

# `.live()`

Initiates a live query for a specified table name.

```python
db.live(table, diff)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name to listen for changes for
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>diff</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                If set to true, live notifications will include an array of JSON Patch objects, rather than the entire record for each notification.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```python
db.live('person')

# Async
await db.live('person')
```

<br />

# `.subscribe_live()`

Returns a queue that receives notification messages from a running live query.

```python title="Method Syntax"
db.subscribe_live(query_uuid)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>query_uuid</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The UUID of a running live query
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
db.subscribe_live(UUID)

# Async
await db.subscribe_live(UUID)
```

<br />

# `.kill()`

Kills a running live query by it's UUID

```python title="Method Syntax"
db.kill(query_uuid)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>queryUuid</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The UUID of the live query you wish to kill
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
db.kill(query_uuid)

# Async
await db.kill(query_uuid)
```


================================================
FILE: src/content/doc-sdk-python/concepts/writing-surrealql.mdx
================================================
---
sidebar_position: 5
sidebar_label: Run SurrealQL queries
title: Python | SDK | Run SurrealQL queries
description: SurrealDB supports a number of methods for interacting with the database and performing CRUD operations.
---
import Label from "@components/shared/Label.astro";

# Run SurrealQL queries

The methods below are used to interact with the database and perform CRUD operations. You can also use the `query` method to run [SurrealQL statements](/docs/surrealql/statements) against the database.

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="#query"> <code> db.query() </code></a></td>
			<td scope="row" data-label="Description">Runs a set of SurrealQL statements against the database</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="#query_raw"> <code> db.query_raw() </code></a></td>
            <td scope="row" data-label="Description">Runs a set of SurrealQL statements against the database and returns the raw RPC response</td>
        </tr>
	</tbody>
</table>

# `.query()`

Runs a set of [SurrealQL statements](/docs/surrealql) against the database.

```python title="Method Syntax"
db.query(query, vars)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>query</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>vars</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python

# Assign the variable on the connection
db.query(
	'CREATE person SET name = "John"; SELECT * FROM type::table($tb);',
	{ "tb": 'person' }
)
```

### `.query_raw()`

With `.query_raw()`, you will get back the raw RPC response. This contrast to the `.query()` method, this will not throw for errors that occur in individual queries, but will rather give those back as a string, and this will include the time it took to execute the individual queries.


================================================
FILE: src/content/doc-sdk-python/methods/authenticate.mdx
================================================
---
sidebar_position: 1
sidebar_label: authenticate
title: Python | SDK | Methods | authenticate
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.authenticate()`

Authenticates the current connection with a JWT token.

```python title="Method Syntax"
db.authenticate(token)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody> 
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>token</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The JWT authentication token.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
db.authenticate('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJTdXJyZWFsREIiLCJpYXQiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwiZXhwIjoxODM2NDM5MDIyLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJTQyI6InVzZXIiLCJJRCI6InVzZXI6dG9iaWUifQ.N22Gp9ze0rdR06McGj1G-h2vu6a6n9IVqUbMFJlOxxA')

# Async
await db.authenticate('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJTdXJyZWFsREIiLCJpYXQiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwiZXhwIjoxODM2NDM5MDIyLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJTQyI6InVzZXIiLCJJRCI6InVzZXI6dG9iaWUifQ.N22Gp9ze0rdR06McGj1G-h2vu6a6n9IVqUbMFJlOxxA')
```

You can invalidate the authentication for the current connection using the [`invalidate()` method](/docs/sdk/python/methods/invalidate).


================================================
FILE: src/content/doc-sdk-python/methods/close.mdx
================================================
---
sidebar_position: 1
sidebar_label: close
title: Python | SDK | Methods | close
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

# `.close()`

Closes the persistent connection to the database.

```python title="Method Syntax"
db.close()
```

### Example usage
```python
db.close()

# async
await db.close()
```

You can establish the connection using the [`connect()` method](/docs/sdk/python/methods/connect).


================================================
FILE: src/content/doc-sdk-python/methods/connect.mdx
================================================
---
sidebar_position: 1
sidebar_label: connect - Surreal
title: Python | SDK | Methods | connect
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---
import Label from "@components/shared/Label.astro";

# `Surreal / AsyncSurreal`

Establishes a persistent connection to the database.

```python title="Method Syntax"
Surreal(url)
AsyncSurreal(url)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>url</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The url of the database endpoint to connect to.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
Surreal('https://cloud.surrealdb.com')

# async
AsyncSurreal('https://cloud.surrealdb.com')
```

You can close the connection using the [`close()` method](/docs/sdk/python/methods/close).


================================================
FILE: src/content/doc-sdk-python/methods/create.mdx
================================================
---
sidebar_position: 1
sidebar_label: create
title: Python | SDK | Methods | create
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro"

# `.create()`

Creates a record in the database.

```python title="Method Syntax"
db.create(thing, data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordID`](/docs/sdk/python/data-types#recordid) to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to create.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
# Create a record with a random ID
person = db.create('person')

# Create a record with a specific ID
person = db.create(RecordID('person', 'tobie'), {
	"name": 'Tobie',
	"settings": {
		"active": True,
		"marketing": True,
	}
})
```

### Translated query
This function will run the following query in the database.

```surql
CREATE $thing CONTENT $data
```


================================================
FILE: src/content/doc-sdk-python/methods/delete.mdx
================================================
---
sidebar_position: 1
sidebar_label: delete 
title: Python | SDK | Methods | delete
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.delete()`

Deletes all records in a table, or a specific record, from the database.

```python title="Method Syntax"
db.delete(thing,data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordID`](/docs/sdk/python/data-types#recordid) to delete.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
# Delete all records from a table
await db.delete('person')

# Delete a specific record from a table
await db.delete(RecordID('person', 'h5wxrf2ewk8xjxosxtyc'))
```

### Translated query
This function will run the following query in the database.

```surql
DELETE $thing;
```


================================================
FILE: src/content/doc-sdk-python/methods/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: SDK methods
title: Python | SDKs | Integration
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

# SDK methods

The SurrealDB SDK for Python has a `SurrealDB` and `AsyncSurrealDB` class that provides methods for querying a remote SurrealDB database.

These classes are designed to be simple to use and easy to understand for developers who are new to Python or SurrealDB.

This page lists out the methods that are available. Both classes have the same methods, the only difference is the addition of the `async / await` keywords in the `AsyncSurrealDB` class.

## Initialization methods

<table>
	<thead>
		<tr>
			<th scope="col">Method</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/connect"> <code> Surreal / AsyncSurreal </code></a></td>
			<td scope="row" data-label="Description">Connects to a local or remote database endpoint</td>
		</tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/concepts/create-a-new-connection#close"> <code> db.close() </code></a></td>
            <td scope="row" data-label="Description">Closes the persistent connection to the database</td>
        </tr>
		<tr>
			<td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/use"> <code> db.use(namespace,database)</code></a></td>
			<td scope="row" data-label="Description">Switch to a specific namespace and database</td>
		</tr>
		<tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/let"> <code>db.let(key,value)</code></a></td>
            <td scope="row" data-label="Description">Assigns a value as a variable for this connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/unset"> <code>db.unset(key)</code></a></td>
            <td scope="row" data-label="Description">Removes a variable for this connection</td>
        </tr>
	</tbody>
</table>

## Query methods

<table>
    <thead>
        <tr>
            <th scope="col">Method</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/query"> <code>db.query(sql,vars)</code></a></td>
            <td scope="row" data-label="Description">Runs a set of [SurrealQL statements](/docs/surrealql) against the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/select"> <code>db.select(thing)</code></a></td>
            <td scope="row" data-label="Description">Selects all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/concepts/streaming#live"> <code>db.live(table, diff)</code></a></td>
            <td scope="row" data-label="Description">Initiates a live query for a specified table name.</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/concepts/streaming#subscribeLive"> <code>db.subscribe_Live(query_uuid)</code></a></td>
            <td scope="row" data-label="Description">Returns a queue that receives notification messages from a running live query.</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/concepts/streaming#kill"> <code>db.kill(query_uuid)</code></a></td>
            <td scope="row" data-label="Description">Kill a running live query</td>
        </tr>
    </tbody>
</table>

## Mutation methods

<table>
    <thead>
        <tr>
            <th scope="col">Method</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/create"> <code>db.create(thing,data)</code></a></td>
            <td scope="row" data-label="Description">Creates a record in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/insert"> <code>db.insert(thing,data)</code></a></td>
            <td scope="row" data-label="Description">Inserts one or multiple records in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/update"> <code>db.update(thing,data)</code></a></td>
            <td scope="row" data-label="Description">Updates all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/merge"> <code>db.merge(thing,data)</code></a></td>
            <td scope="row" data-label="Description">Modifies all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/patch"> <code>db.patch(thing,data)</code></a></td>
            <td scope="row" data-label="Description">Applies JSON Patch changes to all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/delete"> <code>db.delete(thing,data)</code></a></td>
            <td scope="row" data-label="Description">Deletes all records, or a specific record</td>
        </tr>
    </tbody>
</table>

## Authentication methods

<table>
    <thead>
        <tr>
            <th scope="col">Method</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/signup"> <code>db.signup(vars)</code></a></td>
            <td scope="row" data-label="Description">Signs this connection up to a specific authentication scope</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/signin"> <code>db.signin(vars)</code></a></td>
            <td scope="row" data-label="Description">Signs this connection in to a specific authentication scope</td>
        </tr>
		<tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/invalidate"> <code>db.invalidate()</code></a></td>
            <td scope="row" data-label="Description">Invalidates the authentication for the current connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/authenticate"> <code>db.authenticate(token)</code></a></td>
            <td scope="row" data-label="Description">Authenticates the current connection with a JWT token</td>
        </tr>
		<tr>
            <td scope="row" data-label="Method"><a href="/docs/sdk/python/methods/info"> <code>db.info()</code></a></td>
            <td scope="row" data-label="Description">Returns the record of an authenticated scope user</td>
        </tr>
    </tbody>
</table>



================================================
FILE: src/content/doc-sdk-python/methods/info.mdx
================================================
---
sidebar_position: 1
sidebar_label: info
title: Python | SDK | Methods | info
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

# `.info()`

This method returns the record of an authenticated scope user.

```python title="Method Syntax"
db.info()
```

### Example usage
```python
db.info()

# Async
await db.info()
```


================================================
FILE: src/content/doc-sdk-python/methods/insert-relation.mdx
================================================
---
sidebar_position: 1
sidebar_label: insert_relation
title: Python | SDK | Methods | insert_relation
description: The SurrealDB SDK for Python enables you to insert a relation between two records.
---

import Label from "@components/shared/Label.astro";

# `.insert_relation()`

Inserts one or multiple relations in the database.

```python title="Method Syntax"
db.insert_relation(table, data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name to insert to.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Either a single document/record or an array of documents/records to insert
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python


# Insert a single record
db.insert_relation('likes', {
	"in": RecordID('person', 'tobie'),
	"out": RecordID('post', 123)
})

# Insert multiple records across tables
people = db.insert_relation('likes', [
	{
    	"in": RecordID('person', 'tobie'),
    	"out": RecordID('post', 123),
	},
	{
    	"in": RecordID('person', 'jaime'),
    	"out": RecordID('post', 456),
	}
])
```

### Translated query
This function will run the following query in the database.

```surql
INSERT RELATION INTO $table $data;
```


================================================
FILE: src/content/doc-sdk-python/methods/insert.mdx
================================================
---
sidebar_position: 1
sidebar_label: insert
title: Python | SDK | Methods | insert
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.insert()`

Inserts one or multiple records in the database.

```python title="Method Syntax"
db.insert(thing, data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name to insert to.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
            	<Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Either a single document/record or an array of documents/records to insert
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python

# Insert a single record
db.insert('person', {
	"name": 'Tobie',
	"settings": {
		"active": True,
		"marketing": True,
	},
})

# Insert multiple records
db.insert('person', [
	{
		"name": 'Tobie',
		"settings": {
			"active": True,
			"marketing": True,
		},
	},
	{
		"name": 'Jaime',
		"settings": {
			"active": True,
			"marketing": True,
		},
	},
])
```

### Translated query
This function will run the following query in the database.

```surql
INSERT INTO $thing $data;
```

You can insert relations using the [`insert_relation()` method](/docs/sdk/python/methods/insert-relation).


================================================
FILE: src/content/doc-sdk-python/methods/invalidate.mdx
================================================
---
sidebar_position: 1
sidebar_label: invalidate
title: Python | SDK | Methods | invalidate
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

# `.invalidate()`

Invalidates the authentication for the current connection.

```python title="Method Syntax"
db.invalidate()
```

### Example usage
```python
db.invalidate()

# Async
await db.invalidate()
```


================================================
FILE: src/content/doc-sdk-python/methods/kill.mdx
================================================
---
sidebar_position: 1
sidebar_label: kill
title: Python | SDK | Methods | kill
description: The SurrealDB SDK for Python enables you to kill a running live query.
---

import Label from "@components/shared/Label.astro";

# `.kill()`

Kills a running live query by it's UUID

```python title="Method Syntax"
db.kill(query_uuid)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>queryUuid</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The UUID of the live query you wish to kill
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
db.kill(query_uuid)

# Async
await db.kill(query_uuid)
```


================================================
FILE: src/content/doc-sdk-python/methods/let.mdx
================================================
---
sidebar_position: 1
sidebar_label: let
title: Python | SDK | Methods | let
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.let()`

Assigns a value as a variable for this connection.

```python title="Method Syntax"
db.let(key, value)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>value</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns the value to the variable name.
            </td>
        </tr>
    </tbody>
</table>

### Example Usage
```python
# Assign the variable on the connection
await db.let('name', {
	"first": 'Tobie',
	"last": 'Morgan Hitchcock',
})

# Use the variable in a subsequent query
await db.query('CREATE person SET name = $name')

# Use the variable in a subsequent query
await db.query('SELECT * FROM person WHERE name.first = $name.first')
```

You can remove the variable from the connection using the [`unset()` method](/docs/sdk/python/methods/unset).


================================================
FILE: src/content/doc-sdk-python/methods/live.mdx
================================================
---
sidebar_position: 1
sidebar_label: live
title: Python | SDK | Methods | live
description: The SurrealDB SDK for Python enables you to listen for changes to records in a table.
---
import Label from "@components/shared/Label.astro";

# `.live()`

Initiates a live query for a specified table name.

```python
db.live(table, diff)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>table</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name to listen for changes for
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>diff</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                If set to true, live notifications will include an array of JSON Patch objects, rather than the entire record for each notification.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```python
db.live('person')

# Async
await db.live('person')
```


================================================
FILE: src/content/doc-sdk-python/methods/merge.mdx
================================================
---
sidebar_position: 1
sidebar_label: merge
title: Python | SDK | Methods | merge
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.merge()`

Modifies all records in a table, or a specific record, in the database.

```python title="Method Syntax"
db.merge(thing, data)
```

> [!NOTE]
> This function merges the current document / record data with the specified data. If no merge data is passed it will simply trigger an update.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordID`](/docs/sdk/python/data-types#recordid) to merge.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to merge.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python

# Update all records in a table
await db.merge('person', {
	updated_at: datetime.datetime.utcnow()
})

# Update a record with a specific ID
await db.merge(RecordID('person', 'tobie'), {
	"updated_at": datetime.datetime.utcnow(),
	"settings": {
		"active": true,
	}
})
```

### Translated query
This function will run the following query in the database.

```surql
UPDATE $thing MERGE $data;
```


================================================
FILE: src/content/doc-sdk-python/methods/patch.mdx
================================================
---
sidebar_position: 1
sidebar_label: patch
title: Python | SDK | Methods | patch
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.patch()`

Applies JSON Patch changes to all records, or a specific record, in the database.

```python title="Method Syntax"
db.patch(thing, data)
```

> [!NOTE]
> This function patches the current document / record data with the specified JSON Patch data.


### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordID`](/docs/sdk/python/data-types#recordid) to patch.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The JSON Patch data with which to patch the records.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
# Update all records in a table
await db.patch('person', [
	{ "op": 'replace', "path": '/created_at', "value": datetime.datetime.utcnow() },
])

# Update a record with a specific ID
await db.patch(RecordID('person', 'tobie'), [
	{ "op": 'replace', "path": '/settings/active', "value": false },
	{ "op": 'add', "path": '/tags', "value": ['developer', 'engineer'] },
	{ "op": 'remove', "path": '/temp' },
])
```

### Translated query
This function will run the following query in the database.

```surql
UPDATE $thing PATCH $data;
```


================================================
FILE: src/content/doc-sdk-python/methods/query.mdx
================================================
---
sidebar_position: 1
sidebar_label: query
title: Python | SDK | Methods | query
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.query()`

Runs a set of [SurrealQL statements](/docs/surrealql) against the database.

```python title="Method Syntax"
db.query(query, vars)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>query</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>vars</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python

# Assign the variable on the connection
await db.query(
	'CREATE person SET name = "John"; SELECT * FROM type::table($tb);',
	{ "tb": 'person' }
)
```

### `.query_raw()`

With `.query_raw()`, you will get back the raw RPC response. This contrast to the `.query()` method, this will not throw for errors that occur in individual queries, but will rather give those back as a string, and this will include the time it took to execute the individual queries.


================================================
FILE: src/content/doc-sdk-python/methods/select.mdx
================================================
---
sidebar_position: 1
sidebar_label: select
title: Python | SDK | Methods | select
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.select()`

Selects all records in a table, or a specific record, from the database.

```python title="Method Syntax"
db.select(thing)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a [`RecordID`](/docs/sdk/python/data-types#recordid) to select.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python

# Select all records from a table
db.select('person')

# Select a specific record from a table
await db.select(RecordID('person', 'h5wxrf2ewk8xjxosxtyc'))
```

### Translated query
This function will run the following query in the database.

```surql
SELECT * FROM $thing;
```


================================================
FILE: src/content/doc-sdk-python/methods/signin.mdx
================================================
---
sidebar_position: 1
sidebar_label: signin
title: Python | SDK | Methods | signin
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro"
import Since from "@components/shared/Since.astro"

# `.signin()`

Signs in to a root, namespace, database or scope user.

```python title="Method Syntax"
db.signin({ ... })
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Properties</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>username</code>
                <Label label="REQUIRED FOR ROOT, NAMESPACE & DATABASE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The username of the database user
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>password</code>
                <Label label="REQUIRED FOR ROOT, NAMESPACE & DATABASE" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The password of the database user
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>namespace</code>
                <Label label="REQUIRED FOR DATABASE & SCOPE/ACCESS" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign in to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>database</code>
                <Label label="REQUIRED FOR SCOPE/ACCESS" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign in to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>scope</code>
                <Since v="1.x" prefix={false} />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The scope to sign in to. Also pass any variables used in the scope. Only supported in SurrealDB 1.x
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>access</code>
                <Since v="2.x" prefix=">=" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The access to sign in to. Also pass any variables used in the access. Only supported from SurrealDB 2.x onwards
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
# Authenticate with a root user
await db.signin({
	"username": 'root',
	"password": 'surrealdb'
})

# Authenticate with a Namespace user
await db.signin({
	"namespace": 'surrealdb',
	"username": 'tobie',
	"password": 'surrealdb'
})

# Authenticate with a Database user
await db.signin({
	"namespace": 'surrealdb',
	"database": 'docs',
	"username": 'tobie',
	"password": 'surrealdb'
})

# Authenticate with Record Access
await db.signin({
	"namespace": 'surrealdb',
	"database": 'docs',
	"access": 'user',

    # Also pass any properties required by the access definition
	"variables": {
        "email": 'info@surrealdb.com',
        "password": '123456'
    }
})

# Authenticate with Scopes
await db.signin({
	"namespace": 'surrealdb',
	"database": 'docs',
	"scope": 'user',

	# Also pass any properties required by the scope definition
	"email": 'info@surrealdb.com',
	"pass": '123456'
})
```

You can invalidate the authentication for the current connection using the [`invalidate()` method](/docs/sdk/python/methods/invalidate). Learn more about [handling authentication](/docs/sdk/python/concepts/handling-authentication).  


================================================
FILE: src/content/doc-sdk-python/methods/signup.mdx
================================================
---
sidebar_position: 1
sidebar_label: signup
title: Python | SDK | Methods | signup
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";
import Since from "@components/shared/Since.astro";

# `.signup()`

Signs up to a specific authentication scope.

```python title="Method Syntax"
db.signup({ ... })
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>namespace</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign up to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>database</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign up to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>scope</code>
                <Label label="required" />
                <Since v="1.x" prefix={false} />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The scope to sign up to. Also pass any variables used in the scope. Only supported in SurrealDB 1.x
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Properties">
                <code>access</code>
                <Label label="required" />
                <Since v="2.x" prefix=">=" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The access to sign in to. Also pass any variables used in the access. Only supported from SurrealDB 2.x onwards
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
# With Record Access
db.signup({
	"namespace": 'surrealdb',
	"database": 'docs',
	"access": 'user',

    # Also pass any properties required by the scope definition
	"variables": {
        "email": 'info@surrealdb.com',
        "password": '123456',
    }
})

# With Scopes
await db.signup({
	"namespace": 'surrealdb',
	"database": 'docs',
	"scope": 'user',

	# Also pass any properties required by the scope definition
	"email": 'info@surrealdb.com',
	"password": '123456'
})
```

You can invalidate the authentication for the current connection using the [`invalidate()` method](/docs/sdk/python/methods/invalidate). Learn more about [handling authentication](/docs/sdk/python/concepts/handling-authentication). 


================================================
FILE: src/content/doc-sdk-python/methods/subscribelive.mdx
================================================
---
sidebar_position: 1
sidebar_label: subscribe_live
title: Python | SDK | Methods | subscribe_live
description: The SurrealDB SDK for Python enables you to listen for changes to records in a table.
---
import Label from "@components/shared/Label.astro";


# `.subscribe_live()`

Returns a queue that receives notification messages from a running live query.

```python title="Method Syntax"
db.subscribe_live(query_uuid)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>query_uuid</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The UUID of a running live query
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
await db.subscribe_live(UUID)
```


================================================
FILE: src/content/doc-sdk-python/methods/unset.mdx
================================================
---
sidebar_position: 1
sidebar_label: unset
title: Python | SDK | Methods | unset
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.unset()`

Removes a variable for this connection.

```python title="Method Syntax"
db.unset(key)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
# Remove the variable from the connection
await db.unset('name')
```



================================================
FILE: src/content/doc-sdk-python/methods/update.mdx
================================================
---
sidebar_position: 1
sidebar_label: update
title: Python | SDK | Methods | update
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.update()`

Updates all records in a table, or a specific record, in the database.

```python title="Method Syntax"
db.update(thing, data)
```

> [!NOTE]
> This function replaces the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordID`](/docs/sdk/python/data-types#recordid) to update.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to update.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python

# Update all records in a table
db.update('person', {name: "Jaime"})

# Update a record with a specific ID
db.update(RecordID('person', 'tobie'), {
	"name": 'Tobie',
	"settings": {
		"active": True,
		"marketing": True,
	}
})
```

### Translated query
This function will run the following query in the database.

```surql
UPDATE $thing CONTENT $data;
```


================================================
FILE: src/content/doc-sdk-python/methods/upsert.mdx
================================================
---
sidebar_position: 1
sidebar_label: upsert
title: Python | SDK | Methods | upsert
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.upsert()`

The `UPSERT` statement can be used to insert records into the database, or to update them if they exist.

```python title="Method Syntax"
db.upsert(thing, data)
```

> [!NOTE]
> This function replaces the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific [`RecordID`](/docs/sdk/python/data-types#recordid) to upsert.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to upsert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python

# Update all records in a table
db.upsert('person', {name: "Jaime"})

# Update a record with a specific ID
db.upsert(RecordID('person', 'tobie'), {
	"name": 'Tobie',
	"settings": {
		"active": True,
		"marketing": True,
	}
})
```

### Translated query
This function will run the following query in the database.

```surql
UPSERT $thing CONTENT $data;
```


================================================
FILE: src/content/doc-sdk-python/methods/use.mdx
================================================
---
sidebar_position: 1
sidebar_label: use
title: Python | SDK | Methods | use
description: The SurrealDB SDK for Python enables simple and advanced querying of a remote or embedded database.
---

import Label from "@components/shared/Label.astro";

# `.use()`

Switch to a specific namespace and database. If only the ns or db property is specified, the current connection details will be used to fill the other property.

```python title="Method Syntax"
db.use(namespace, database)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>namespace</code>
                <Label label="Required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Switches to a specific namespace.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>database</code>
                <Label label="Required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Switches to a specific database.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```python
db.use('surrealdb', 'docs')

# Async
await db.use('surrealdb', 'docs')
```


================================================
FILE: src/content/doc-sdk-rust/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Overview
title: Rust | SDKs | Integration
description: The SurrealDB SDK for Rust enables simple and advanced querying of a remote or embedded database.
---

import Boxes from "@components/boxes/Boxes.astro";
import IconBox from "@components/boxes/IconBox.astro";
import Image from "@components/Image.astro";

import Version from '@components/Version.astro';
import LightLogo from "@img/icon/light/rust.png";
import DarkLogo from "@img/icon/dark/rust.png";
import LightActixLogo from "@img/icon/light/actix.png";
import DarkActixLogo from "@img/icon/dark/actix.png";
import LightAxumLogo from "@img/icon/light/axum.png";
import DarkAxumLogo from "@img/icon/dark/axum.png";
import LightRerunLogo from "@img/icon/light/rerun.png";
import DarkRerunLogo from "@img/icon/dark/rerun.png";
import LightRocketLogo from "@img/icon/light/rocket.png";
import DarkRocketLogo from "@img/icon/dark/rocket.png";

<div class="flag-title">
	<Image
		alt="Rust"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Rust SDK
</div>

The SurrealDB SDK for Rust is the primary method of interacting with SurrealDB from client-side, server-side applications, systems, APIs, embedded systems, and IOT devices. The Rust SDK has support for robust error handling and type-safe operations, using an asynchronous API for efficient concurrent database interactions. You can use the Rust SDK to interact with your SurrealDB database instances, or to run SurrealDB as an embedded database within your Rust application, with functionality for executing queries, managing data, running database functions, authenticating to the database, building user signup and authentication functionality, and subscribing to data changes with live queries.

> [!IMPORTANT]
> The SDK requires Rust version `1.80.1` or greater, and is available as a [crate](https://crates.io/crates/surrealdb).

> [!NOTE]
> The SDK works seamlessly with SurrealDB versions `v2.0.0` to <Version />, ensuring compatibility with the latest version.

To contribute to the SDK code, submit an Issue or Pull Request in the [surrealdb.rust](https://github.com/surrealdb/surrealdb/tree/main/crates/sdk) repository. To contribute to this documentation, submit an Issue or Pull Request in the [docs.surrealdb.com](https://github.com/surrealdb/docs.surrealdb.com) repository.

## Frameworks

<Boxes>
    <IconBox
        title="Actix"
        href="/docs/sdk/rust/frameworks/actix"
        icon={{
                light: LightActixLogo,
                dark: DarkActixLogo,
        }}
    />
    <IconBox
        title="Axum"
        href="/docs/sdk/rust/frameworks/axum"
        icon={{
                light: LightAxumLogo,
                dark: DarkAxumLogo,
        }}
    />
    <IconBox
        title="Egui"
        href="/docs/sdk/rust/frameworks/egui"
        icon={{
                light: LightRerunLogo,
                dark: DarkRerunLogo,
        }}
    />
    <IconBox
        title="Rocket"
        href="/docs/sdk/rust/frameworks/rocket"
        icon={{
                light: LightRocketLogo,
                dark: DarkRocketLogo,
        }}
    />
</Boxes>

## Sources

- [GitHub repository](https://github.com/surrealdb/surrealdb/tree/main/crates/sdk)
- [Crates.io package](https://crates.io/crates/surrealdb)
- [Docs.rs documentation](https://docs.rs/surrealdb/latest/surrealdb/) 



================================================
FILE: src/content/doc-sdk-rust/setup.mdx
================================================
---
sidebar_position: 2
sidebar_label: Quick start
title: Quick Start | Rust SDK | Integration | SurrealDB
description: The SurrealDB SDK for Rust enables simple and advanced querying of a remote or embedded database.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/rust.png";
import DarkLogo from "@img/icon/dark/rust.png";
import Label from "@components/shared/Label.astro";

# Quick start

First, create a new project using `cargo new` and add the following dependencies:

* [`surrealdb`](https://crates.io/crates/surrealdb)
* [`tokio`](https://crates.io/crates/tokio), in order to to use the database inside `fn main()`. You will most likely want to enable the `macros` and `rt-multi-thread` features so that the `#[tokio::main]` attribute can be used on top of `fn main()`.
* [`serde`](https://crates.io/crates/serde) with the `derive` feature enabled in order to use the `Serialize` and `Deserialize` attribute macros on top of your Rust data types to match those sent to and returned from the database.

All together, that leads to the following commands to get started:

```sh
cargo new my_project
cd my_project
cargo add surrealdb
cargo add tokio --features macros,rt-multi-thread
cargo add serde --features derive
```

The examples inside this SDK manual assume that all of these crates and features are present.

To maximize performance when compiling in release mode, it is recommended to use the following profile inside `Cargo.toml`, the same as [the profile used by SurrealDB](https://github.com/surrealdb/surrealdb/blob/main/Cargo.toml#L45C1-L50C18) when building each version for release.

```toml
[profile.release]
lto = true
strip = true
opt-level = 3
panic = 'abort'
codegen-units = 1
```

### Start SurrealDB

Before using `cargo run` to try out your code, make sure that the SurrealDB server is running by using the [`surreal start`](/docs/surrealdb/cli/start) command. The following command will start an in-memory server with a single root user at the default address `127.0.0.1:8000`.

```bash
surreal start --user root --pass secret
```

If you prefer to do everything through Surrealist, you can also use the [`Start serving`](/docs/surrealist/concepts/local-database-serving) button to do the same as long as you have Surrealist installed locally on your computer.

### Connect to SurrealDB

Open `src/main.rs` and replace everything with the following code to try out some basic operations using the SurrealDB SDK.

```rust
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::Surreal;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {

    // Connect to the server
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;

    // Signin as a namespace, database, or root user
    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    // Select a specific namespace / database
    db.use_ns("test").use_db("test").await?;

    let some_queries = db.query("
        RETURN 9; 
        RETURN 10; 
        SELECT * FROM { is: 'Nice database' };
    ").await?;
    dbg!(some_queries);
    Ok(())
}
```

Note that the `.query()` method is able to hold more than one statement, in this case three statements; i.e. two [`RETURN`](/docs/surrealql/statements/return) statements and one [`SELECT`](/docs/surrealql/statements/return) statement. The `Response` struct returned contains a field called `results` which holds the output of each statement. Note that each result has its own index. This will become useful when using the `.take()` method in the example to follow, which can access a result by its index number.

```surql title="Example output"
    results: {
        0: (
            Stats {
                execution_time: Some(
                    64.125µs,
                ),
            },
            Ok(
                Number(
                    Int(
                        9,
                    ),
                ),
            ),
        ),
        1: (
            Stats {
                execution_time: Some(
                    19.791µs,
                ),
            },
            Ok(
                Number(
                    Int(
                        10,
                    ),
                ),
            ),
        ),
        2: (
            Stats {
                execution_time: Some(
                    97.75µs,
                ),
            },
            Ok(
                Array(
                    Array(
                        [
                            Object(
                                Object(
                                    {
                                        "is": Strand(
                                            Strand(
                                                "Nice database",
                                            ),
                                        ),
                                    },
                                ),
                            ),
                        ],
                    ),
                ),
            ),
        ),
    }
```

Now that we have the basics down, it is time to try out some other methods like [`CREATE`](/docs/surrealql/statements/create) and [`UPDATE`](/docs/surrealql/statements/update). The most ergonomic way to do this is to use a struct that implements `Serialize` for anything we want to pass in, and `Deserialize` for anything we have received from the database and want to turn back into a Rust type.

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::opt::Resource;
use surrealdb::RecordId;
use surrealdb::Surreal;
use surrealdb::Value;

#[derive(Debug, Serialize)]
struct Name<'a> {
    first: &'a str,
    last: &'a str,
}

#[derive(Debug, Serialize)]
struct Person<'a> {
    title: &'a str,
    name: Name<'a>,
    marketing: bool,
}

#[derive(Debug, Serialize)]
struct Responsibility {
    marketing: bool,
}

#[derive(Debug, Deserialize)]
struct Record {
    id: RecordId,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("test").use_db("test").await?;

    // Create a new person with a random id
    let created: Option<Record> = db
        .create("person")
        .content(Person {
            title: "Founder & CEO",
            name: Name {
                first: "Tobie",
                last: "Morgan Hitchcock",
            },
            marketing: true,
        })
        .await?;
    dbg!(created);

    // Update a person record with a specific id
    // We don't care about the response in this case
    // so we are just going to use `Resource::from`
    // to let the compiler return `surrealdb::Value`
    db.update(Resource::from(("person", "jaime")))
        .merge(Responsibility { marketing: true })
        .await?;

    // Select all people records
    let people: Vec<Record> = db.select("person").await?;
    dbg!(people);

    // Perform a custom advanced query
    let mut groups = db
        .query("SELECT marketing, count() FROM type::table($table) GROUP BY marketing")
        .bind(("table", "person"))
        .await?;
    // Use .take() to transform the first query result into
    // anything that can be deserialized, in this case
    // a Value
    dbg!(groups.take::<Value>(0).unwrap());

    Ok(())
}
```

### Using a static singleton

A static singleton can be used to ensure that a single database instance is available across very large or complicated applications. With the singleton, only one connection to the database is instantiated, and the database connection does not have to be shared across components or controllers. 

The `LazyLock` struct below has been available in stable Rust since version 1.80, making it usable without a single external crate.

```rust
use serde::{Deserialize, Serialize};
use std::sync::LazyLock;
use surrealdb::engine::remote::ws::{Client, Ws};
use surrealdb::opt::auth::Root;
use surrealdb::RecordId;
use surrealdb::Surreal;

#[derive(Debug, Deserialize)]
struct Record {
    id: RecordId,
}

#[derive(Debug, Serialize)]
struct Person<'a> {
    name: &'a str,
    marketing: bool,
}

static DB: LazyLock<Surreal<Client>> = LazyLock::new(Surreal::init);

async fn upsert_tobie() -> surrealdb::Result<()> {
    // Create or update a specific record
    let tobie: Option<Record> = DB
        .upsert(("person", "tobie"))
        .content(Person {
            name: "Tobie",
            marketing: true,
        })
        .await?;
    dbg!(tobie);
    Ok(())
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    // Connect to the database
    DB.connect::<Ws>("localhost:8000").await?;
    // Sign in to the server
    DB.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;
    // Select a namespace + database
    DB.use_ns("test").use_db("test").await?;
    upsert_tobie().await?;
    Ok(())
}
```

### Other ways to see the results

Besides printing out the results inside the Rust code above, you can sign in to the database using the CLI or Surrealist to view them.

```bash
surreal sql --user root --pass secret --namespace test --database test --pretty
```

Inside Surrealist, do the following:

* Hover over the current connection and click on "Change connection"
* Hover over "New connection" and click the pencil icon
* Change the "Method" to "root". Enter "root" for the username and "secret" for the password.
* You will now be connected as the root user, and can define and then select the namespace and databases called "test".

Here is the last query in the example above to get started:

```surql
SELECT marketing, count() FROM person GROUP BY marketing;
```

### Using capabilities and experimental capabilities

The Rust SDK has a single [`Capabilities`](https://docs.rs/surrealdb/latest/surrealdb/opt/capabilities/struct.Capabilities.html) struct that is used to allow or limit what users are allowed to do using queries. Each method on this struct is used to configure the capabilities for the database in the same way that [capabilities flags](/docs/surrealdb/security/capabilities#list) are passed in to the [`surreal start`](/docs/surrealdb/cli/start) command.

```bash
surreal start --allow-all --deny-funcs "http"
surreal sql --ns ns --db db
```

```rust
#[tokio::main]
async fn main() -> Result<(), Error> {
    let config = Config::default().capabilities(Capabilities::all().with_deny_function("http")?);
    let db = connect(("mem://", config)).await?;

    db.use_ns("ns").use_db("db").await?;

    println!("{:?}", db.query("http::get('http://www.surrealdb.com')").await);

    Ok(())
}
```

SurrealDB also has a number of experimental capabilities which need to be specifically opted into and are not included inside an `--allow-all` flag or struct created by the `Capabilities::all()` function. These can be passed in individually using a slice of the [`ExperimentalFeature`](https://docs.rs/surrealdb/latest/surrealdb/opt/capabilities/enum.ExperimentalFeature.html) enum inside the [`.with_experimental_features_allowed`](https://docs.rs/surrealdb/latest/surrealdb/opt/capabilities/struct.Capabilities.html#method.with_experimental_features_allowed) method, or all at once with [`.with_all_experimental_features_allowed()`](https://docs.rs/surrealdb/latest/surrealdb/opt/capabilities/struct.Capabilities.html#method.with_all_experimental_features_allowed).

```rust
#[tokio::main]
async fn main() -> Result<(), Error> {
    
    let config = Config::default().capabilities(Capabilities::all().with_all_experimental_features_allowed());
    let db = connect(("mem://", config)).await?;

    db.use_ns("ns").use_db("db").await?;

    println!("{:?}", db.query("DEFINE FIELD comics ON person TYPE option<array<record<comic_book>>> REFERENCE"));

    Ok(())
}
```

### Experimenting with an embedded instance

An embedded in-memory instance of SurrealDB does not expose any endpoints. To experiment with such an instance without having to recompile the Rust code, a server can be spun up with a single endpoint that accepts a query. The following example uses Axum to create a `localhost:8080/query` endpoint that feeds any input into the `.query()` method, deserializes it into a `Value` and returns this as a `String`.

```rust
use axum::{Router, routing::post};
use std::sync::OnceLock;
use surrealdb::{
    Surreal,
    engine::any::{Any, connect},
};
use tokio::net::TcpListener;

static DB: OnceLock<Surreal<Any>> = OnceLock::new();

use surrealdb::Value;

pub async fn query(query: String) -> Result<String, String> {
    let mut res = DB.get().unwrap().query(query.to_string()).await.map_err(|e| e.to_string())?;
    Ok(res.take::<Value>(0).map_err(|e| e.to_string())?.to_string())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    DB.set(connect("memory").await?).unwrap();

    DB.get().unwrap().use_ns("test").use_db("test").await?;

    let listener = TcpListener::bind("localhost:8080").await?;
    let router = Router::new().route("/query", post(query));
    axum::serve(listener, router).await?;
    Ok(())
}
```

Two examples of output:

```bash
curl -X POST http://localhost:8080/query \
  -H "Content-Type: application/json" \
  -d 'CREATE user SET name = "Billy"'

[{ id: user:oktnnywt6mj9f5oka7d6, name: 'Billy' }]

curl -X POST http://localhost:8080/query \
  -H "Content-Type: application/json" \
  -d 'LET $x: string = 9'            

Found 9 for param $x, but expected a string
```

For more on web frameworks using the Rust SDK, see the pages on [Actix](/docs/sdk/rust/frameworks/actix), [Axum](/docs/sdk/rust/frameworks/axum), and [Rocket](/docs/sdk/rust/frameworks/rocket).


================================================
FILE: src/content/doc-sdk-rust/concepts/authenticating-users.mdx
================================================
---
sidebar_position: 6
sidebar_label: Authenticating users
title: Authenticating Users in Rust | Rust SDK | SurrealDB
description: The Rust SDK for SurrealDB supports a number of methods for authenticating users and securing the database.
---

# Authenticating users

The [`.signup()`](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.signup) and [`.signin()`](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.signin) methods are used for both system users (users created with a [DEFINE USER](/docs/surrealql/statements/define/user) statement) and record users (users created with a [DEFINE ACCESS](/docs/surrealql/statements/define/access) statement). These two methods take any type that implements the [`Credentials`](https://docs.rs/surrealdb/latest/surrealdb/opt/auth/trait.Credentials.html) trait, namely the structs [`Root`](https://docs.rs/surrealdb/latest/surrealdb/opt/auth/struct.Root.html), [`Namespace`](https://docs.rs/surrealdb/latest/surrealdb/opt/auth/struct.Namespace.html), [`Database`](https://docs.rs/surrealdb/latest/surrealdb/opt/auth/struct.Database.html), and [`Record`](https://docs.rs/surrealdb/latest/surrealdb/opt/auth/struct.Record.html).

```rust
pub struct Root<'a> {
    pub username: &'a str,
    pub password: &'a str,
}

pub struct Namespace<'a> {
    pub namespace: &'a str,
    pub username: &'a str,
    pub password: &'a str,
}

pub struct Database<'a> {
    pub namespace: &'a str,
    pub database: &'a str,
    pub username: &'a str,
    pub password: &'a str,
}

// P: any type that implements Serialize
pub struct Record<'a, P> {
    pub namespace: &'a str,
    pub database: &'a str,
    pub access: &'a str,
    pub params: P,
}
```

The `access` and `params` fields of the `Record` struct are the only one of the four that requires extra explanation.

The `access` field comes from the name of the [access method](/docs/surrealql/statements/define/access/record) used to create a record user. In our case, we will use an access method called 'account'. An access method will generally create a record on signup, and select a record on signin, which is the case with our access method as well.

```surql
DEFINE ACCESS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 15m, FOR SESSION 12h;
```

Since the `params` of a `Record` struct used to sign up and sign can be any type that implements `Serialize`, we can put our own struct together and pass them into these methods. On signup, the database will CREATE a `user` record that holds the name and password, and on signin it will SELECT the user that has a matching name and password.



```rust
#[derive(Serialize, Deserialize)]
struct Params<'a> {
    name: &'a str,
    pass: &'a str,
}

db.signup(Record {
    access: "account",
    namespace: "namespace",
    database: "database",
    params: Params {
        name: "username",
        pass: "Str0ngpAASSword!",
    },
})
```

All of the definitions for this example are as follows.

```surql
DEFINE TABLE person SCHEMALESS
    PERMISSIONS FOR 
        CREATE, SELECT WHERE $auth,
        FOR UPDATE, DELETE WHERE created_by = $auth;
DEFINE FIELD name ON TABLE person TYPE string;
DEFINE FIELD created_by ON TABLE person VALUE $auth READONLY;

DEFINE INDEX unique_name ON TABLE user FIELDS name UNIQUE;
DEFINE ACCESS account ON DATABASE TYPE RECORD
SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
DURATION FOR TOKEN 15m, FOR SESSION 12h
```

Whenever a record user is signed into the database, the `$auth` parameter will be populated with its record ID. The `DEFINE TABLE` statement then uses this to give the record user permissions to `CREATE` and `SELECT` any `person` record, but to `UPDATE` and `DELETE` only when the `created_by` field matches the ID in `$auth`. This `created_by` field is automatically set and is `READONLY`. It will show up as `None` when a system user is signed in.

The `.signup()` and `.signin()` methods return a [`Jwt`](https://docs.rs/surrealdb/latest/surrealdb/opt/auth/struct.Jwt.html), which can be printed out if needed using the `.into_insecure_token()` or `.as_insecure_token()` methods. As the method names imply, great care should be taken care with them. The `Jwt` struct redacts the token so printing out a `Jwt` on its own will not display it.

The code uses a crate called [`faker_rand`](https://docs.rs/faker_rand/latest/faker_rand/index.html) to generate a random name and password to make it easy to rerun the code and experiment with the behaviour.

```rust
async fn make_new_user(db: &Surreal<Client>) -> Result<RecordUser, Error> {
    let name = rand::random::<FirstName>().to_string();
    let pass = rand::random::<FirstName>().to_string();
    println!("Signing in as user {name} and password {pass}");
    let jwt = db
        .signup(Record {
            access: "account",
            namespace: "namespace",
            database: "database",
            params: Params {
                name: &name,
                pass: &pass,
            },
        })
        .await?
        .into_insecure_token();
    println!("New user created!\n\nName: {name}\nPassword: {pass}\nToken: {jwt}\n\nTo log in, use this command:\n\nsurreal sql --namespace namespace --database database --pretty --token \"{jwt}\"\n");
    Ok(RecordUser { name, pass })
}

async fn get_new_token(db: &Surreal<Client>, user: &RecordUser) -> Result<(), Error> {
    let jwt = db
        .signin(Record {
            access: "account",
            namespace: "namespace",
            database: "database",
            params: Params {
                name: &user.name,
                pass: &user.pass,
            },
        })
        .await?
        .into_insecure_token();
    println!("New token! Sign in with surreal sql --namespace namespace --database database --pretty --token \"{jwt}\"\n");
    Ok(())
}
```

The entire code is as follows. Inside `main()`, the client first logs in as a root user to define the schema and create a `person` record. It then signs up as a new record user, and then signs in again to demonstrate that a new token is returned each time this method is called (as long as the name and password match). The record user then creates a `person` record - which it is permitted to do - and then tries to delete all of the `person` records in the database. However, the `person` record created by the root user will remain untouched.

```rust
use surrealdb::engine::remote::ws::Client;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::Surreal;

use faker_rand::en_us::names::FirstName;
use surrealdb::opt::auth::Record;

use serde::{Deserialize, Serialize};
use surrealdb::{Error, RecordId};

#[derive(Debug, Serialize, Deserialize)]
struct Person {
    name: String,
    id: RecordId,
    created_by: Option<RecordId>,
}

#[derive(Serialize, Deserialize)]
struct Params<'a> {
    name: &'a str,
    pass: &'a str,
}

#[derive(Serialize, Deserialize)]
struct RecordUser {
    name: String,
    pass: String,
}

async fn make_new_user(db: &Surreal<Client>) -> Result<RecordUser, Error> {
    let name = rand::random::<FirstName>().to_string();
    let pass = rand::random::<FirstName>().to_string();
    println!("Signing in as user {name} and password {pass}");
    let jwt = db
        .signup(Record {
            access: "account",
            namespace: "namespace",
            database: "database",
            params: Params {
                name: &name,
                pass: &pass,
            },
        })
        .await?
        .into_insecure_token();
    println!("New user created!\n\nName: {name}\nPassword: {pass}\nToken: {jwt}\n\nTo log in, use this command:\n\nsurreal sql --namespace namespace --database database --pretty --token \"{jwt}\"\n");
    Ok(RecordUser { name, pass })
}

async fn get_new_token(db: &Surreal<Client>, user: &RecordUser) -> Result<(), Error> {
    let jwt = db
        .signin(Record {
            access: "account",
            namespace: "namespace",
            database: "database",
            params: Params {
                name: &user.name,
                pass: &user.pass,
            },
        })
        .await?
        .into_insecure_token();
    println!("New token! Sign in with surreal sql --namespace namespace --database database --pretty --token \"{jwt}\"\n");
    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let db = Surreal::new::<Ws>("localhost:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("namespace").use_db("database").await?;

    db.query(
        "DEFINE TABLE person SCHEMALESS
        PERMISSIONS FOR 
            CREATE, SELECT WHERE $auth,
            FOR UPDATE, DELETE WHERE created_by = $auth;
    DEFINE FIELD name ON TABLE person TYPE string;
    DEFINE FIELD created_by ON TABLE person VALUE $auth READONLY;

    DEFINE INDEX unique_name ON TABLE user FIELDS name UNIQUE;
    DEFINE ACCESS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 15m, FOR SESSION 12h
;",
    )
    .await?;

    db.query("CREATE person SET name = 'Created by root'")
        .await?;

    let user = make_new_user(&db).await?;

    get_new_token(&db, &user).await?;

    db.query("CREATE person SET name = 'Created by record user'")
        .await?;

    println!(
        "Two `person` records: {:?}\n",
        db.select::<Vec<Person>>("person").await?
    );

    db.query("DELETE person").await?;

    println!(
        "`person` created by root is still there: {:?}\n",
        db.select::<Vec<Person>>("person").await?
    );

    Ok(())
}
```

Example output:

```
Signing in as user Emmett and password Izaiah
New user created!

Name: Emmett
Password: Izaiah
Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MzA4NjQ2NDAsIm5iZiI6MTczMDg2NDY0MCwiZXhwIjoxNzMwODY1NTQwLCJpc3MiOiJTdXJyZWFsREIiLCJqdGkiOiIwNmYwOGFhZi0zYzIyLTQ5N2UtYWRmNC0zNDMxMzA5YWYxOGEiLCJOUyI6Im5hbWVzcGFjZSIsIkRCIjoiZGF0YWJhc2UiLCJBQyI6ImFjY291bnQiLCJJRCI6InVzZXI6YW92bHN0dzBvN2R1Y2J4ZWpqZWsifQ.tHCVlubg3G2j05-LsEaE6jRHMwrBtccJcR6uC9Z6Lo-egrYlBybEEfOZh020OxWxKvUt8eA92-6TjwBvSpN5KA

To log in, use this command:

surreal sql --namespace namespace --database database --pretty --token "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MzA4NjQ2NDAsIm5iZiI6MTczMDg2NDY0MCwiZXhwIjoxNzMwODY1NTQwLCJpc3MiOiJTdXJyZWFsREIiLCJqdGkiOiIwNmYwOGFhZi0zYzIyLTQ5N2UtYWRmNC0zNDMxMzA5YWYxOGEiLCJOUyI6Im5hbWVzcGFjZSIsIkRCIjoiZGF0YWJhc2UiLCJBQyI6ImFjY291bnQiLCJJRCI6InVzZXI6YW92bHN0dzBvN2R1Y2J4ZWpqZWsifQ.tHCVlubg3G2j05-LsEaE6jRHMwrBtccJcR6uC9Z6Lo-egrYlBybEEfOZh020OxWxKvUt8eA92-6TjwBvSpN5KA"

New token! Sign in with surreal sql --namespace namespace --database database --pretty --token "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MzA4NjQ2NDAsIm5iZiI6MTczMDg2NDY0MCwiZXhwIjoxNzMwODY1NTQwLCJpc3MiOiJTdXJyZWFsREIiLCJqdGkiOiIyZjExZTQzZi04ODg1LTRmNzAtOGI2Zi0zNGZmZGZlZWY4MDUiLCJOUyI6Im5hbWVzcGFjZSIsIkRCIjoiZGF0YWJhc2UiLCJBQyI6ImFjY291bnQiLCJJRCI6InVzZXI6YW92bHN0dzBvN2R1Y2J4ZWpqZWsifQ.0GWwMiAjn5kKUoNAw2TxAdVLhWIHeJsVWvlAzw1QZ91qdIhkazygdG5uFl5DHVmmoYC-cLo-ko27jiRCid5xDg"

Two `person` records: [Person { name: "Created by record user", id: RecordId { table: "person", key: String("i2sv6bqk0mso0udgzmdx") }, created_by: Some(RecordId { table: "user", key: String("aovlstw0o7ducbxejjek") }) }, Person { name: "Created by root", id: RecordId { table: "person", key: String("u6mry7agmsmtbwl94yui") }, created_by: None }]

`person` created by root is still there: [Person { name: "Created by root", id: RecordId { table: "person", key: String("u6mry7agmsmtbwl94yui") }, created_by: None }]
```

## See also

Each of the crates featured in the Rust SDK also use the schema above. Three of them (Actix, Axum, Rocket) are web servers, while Egui is a visual UI. See the mini tutorials for each of these crates here:

* [Actix](/docs/sdk/rust/frameworks/actix)
* [Axum](/docs/sdk/rust/frameworks/axum)
* [Rocket](/docs/sdk/rust/frameworks/rocket)
* [Egui](/docs/sdk/rust/frameworks/egui)

Learn more about authentication in SurrealDB in our [security best practices](/docs/surrealdb/reference-guide/security-best-practices#authentication) documentation and in the [security](/docs/surrealdb/security/authentication#expiration) section of the SurrealDB documentation.


================================================
FILE: src/content/doc-sdk-rust/concepts/concurrency.mdx
================================================
---
sidebar_position: 7
sidebar_label: Concurrency
title: Concurrency in Rust | Rust SDK | SurrealDB
description: Multiple threads or asynchronous tasks can be used to speed up queries to a SurrealDB database
---

# Concurrency

While the Rust SDK for SurrealDB uses the tokio async runtime, the operation of the database itself will only take place concurrently if the code itself uses concurrency. The following example shows how to do this and a comparison of the performance between synchronous and asynchronous usage.

## Getting started

Start a running database using the following command:

```
surreal start --user root --pass secret 
```

To follow along interactively, connect [using Surrealist](/docs/surrealist/getting-started#creating-a-connection) or the following command to open up the CLI:

```
surrealdb % surreal sql --user root --pass secret --ns namespace --db database --pretty
```

Then use the `cargo add` command to add the `surrealdb` and `tokio` crates. The dependencies inside `Cargo.toml` should look something like this:

```toml
[dependencies]
surrealdb = "2.0.4"
tokio = "1.41.0"
```

## The code

The SurrealDB client by nature has no maximum capacity for the number of channels that can be made to perform queries. To change this setting, the [`.with_capacity()`](https://docs.rs/surrealdb/latest/surrealdb/struct.Connect.html#method.with_capacity) method can be used. As tokio's documentation notes, this method is useful if your client is running so many queries concurrently that the machine used to execute them is running out of memory.

> This is used to set bounds of the channels used internally as well set the capacity of the HashMap used for routing responses in case of the WebSocket client. Setting this capacity to 0 (the default) means that unbounded channels will be used. If your queries per second are so high that the client is running out of memory, it might be helpful to set this to a number that works best for you.

To experiment with this, we will create three clients: one with no maximum capacity, a second with a maximum capacity of 1, and a third with a maximum capacity of 1000. To avoid any code duplication, we'll use an enum to set these clients up.

```rust
enum DbType {
    Standard,
    With1,
    With1000,
}

impl DbType {
    async fn generate(self) -> Result<Surreal<Client>, Error> {
        let db = match self {
            DbType::Standard => Surreal::new::<Ws>("localhost:8000").await,
            DbType::With1 => Surreal::new::<Ws>("localhost:8000").with_capacity(1).await,
            DbType::With1000 => {
                Surreal::new::<Ws>("localhost:8000")
                    .with_capacity(1000)
                    .await
            }
        }?;
        db.use_ns("namespace").use_db("database").await?;
        db.signin(Root {
            username: "root",
            password: "secret",
        })
        .await?;
        Ok(db)
    }
}
```

Each of these clients will be put into a `for` loop 50000 times, in which they will simply return the index number of the current iteration of the loop. Note that the [`.take()`](https://docs.rs/surrealdb/latest/surrealdb/struct.Response.html#method.take) method returns a query response as anything that can be deserialized, including primitive types like `usize`. It will also take a `test_num` field so that we can see which test is running as the index numbers fly by on the terminal.

```rust
async fn select_index(db: &Surreal<Client>, idx: usize, test_num: &'static str) {
    let mut result = db
        .query("SELECT * FROM $idx")
        .bind(("idx", idx))
        .await
        .unwrap();

    let db_idx: Option<usize> = result.take(0).unwrap();
    if let Some(db_idx) = db_idx {
        println!("{test_num} - {idx}: {db_idx}");
    }
}
```

The first test inside main will be done synchronously, returning the `Duration` taken by the test once it is done.

```rust
let start = std::time::Instant::now();
for idx in 0..=MAX {
	select_index(&db, idx).await;
}
let res_1 = format!("Regular DB: {:?}", Instant::now() - start);
```

The other three tests will all be done asynchronously, so we'll put them into their own function. Each one will spawn a tokio task which will execute and return the result whenever it is finished. Each task will be put into a `Vec` of `JoinHandle`s that will be awaited on at the end to ensure that we don't exit the function before they have finished.

```rust
async fn async_test(db: Arc<Surreal<Client>>, test_num: &'static str) -> std::time::Duration {
    let start = std::time::Instant::now();
    let mut handles = vec![];
    for idx in 0..=MAX {
        let db = db.clone();
        handles.push(tokio::spawn(async move {
            select_index(&db, idx, test_num).await;
        }));
    }
    for h in handles {
        h.await.unwrap();
    }
    Instant::now() - start
}
```

We will then make a `String` variable from the output of each test, and print them out at the end when everything has run.

The entire code is as follows:

```rust
use std::sync::Arc;
use std::time::Instant;
use surrealdb::engine::remote::ws::{Client, Ws};
use surrealdb::opt::auth::Root;
use surrealdb::{Error, Surreal};

const MAX: usize = 50_000;

enum DbType {
    Standard,
    With1,
    With1000,
}

impl DbType {
    async fn generate(self) -> Result<Surreal<Client>, Error> {
        let db = match self {
            DbType::Standard => Surreal::new::<Ws>("localhost:8000").await,
            DbType::With1 => Surreal::new::<Ws>("localhost:8000").with_capacity(1).await,
            DbType::With1000 => {
                Surreal::new::<Ws>("localhost:8000")
                    .with_capacity(1000)
                    .await
            }
        }?;
        db.use_ns("namespace").use_db("database").await?;
        db.signin(Root {
            username: "root",
            password: "secret",
        })
        .await?;
        Ok(db)
    }
}

async fn select_index(db: &Surreal<Client>, idx: usize, test_num: &'static str) {
    let mut result = db
        .query("SELECT * FROM $idx")
        .bind(("idx", idx))
        .await
        .unwrap();

    let db_idx: Option<usize> = result.take(0).unwrap();
    if let Some(db_idx) = db_idx {
        println!("{test_num} - {idx}: {db_idx}");
    }
}

async fn async_test(db: Arc<Surreal<Client>>, test_num: &'static str) -> std::time::Duration {
    let start = std::time::Instant::now();
    let mut handles = vec![];
    for idx in 0..=MAX {
        let db = db.clone();
        handles.push(tokio::spawn(async move {
            select_index(&db, idx, test_num).await;
        }));
    }
    for h in handles {
        h.await.unwrap();
    }
    Instant::now() - start
}

#[tokio::main]
async fn main() -> Result<(), Error> {

    let db_standard = Arc::new(DbType::Standard.generate().await?);
    let db_with_1 = Arc::new(DbType::With1.generate().await?);
    let db_with_1000 = Arc::new(DbType::With1000.generate().await?);

    let start = std::time::Instant::now();
    for idx in 0..=MAX {
        select_index(&db_standard, idx, "Test1").await;
    }

    let res_1 = format!("Regular DB: {:?}", Instant::now() - start);
    let res_2 = format!("Async with capacity 1: {:?}", async_test(db_with_1, "Test2").await);
    let res_3 = format!(
        "Async with capacity 1000: {:?}",
        async_test(db_with_1000, "Test3").await
    );
    let res_4 = format!(
        "Async with unbounded capacity: {:?}",
        async_test(db_standard, "Test4").await
    );

    println!("{res_1}\n{res_2}\n{res_3}\n{res_4}");

    Ok(())
}
```

Running the code, you should see the following:

1) The first test runs one index and one query at a time, taking by far the longest time.
2) The second test will run much faster. Despite only having a capacity of 1, it still runs concurrently and does not need to wait for the output of the previous query to send in its own.
3) The third test with a capacity of 1000 will run even faster,
4) The last test using the first unbounded database should run fastest of all. If running the test on a particularly slow computer, however, you may see a slowdown compared to the other two async tests if the computer's memory capacity is reached during the test.

A sample of the output at the end:

```
Regular DB: 5.244320833s
Async with capacity 1: 1.523926416s
Async with capacity 1000: 1.441300833s
Async with unbounded capacity: 1.183820584s
```

## Using a channel instead of a JoinHandle

Besides the classic method of using a `JoinHandle` for each thread or task to wait until all have completed their operation, a [channel](https://docs.rs/tokio/latest/tokio/sync/mpsc/fn.channel.html) can also be used. A channel can be used in the following way:

* Create a channel with a buffer of 1 (the minimum size), as the channel will not be used to actually send data,
* Clone the sender and send it into each iteration of the `for` loop,
* Drop the cloned sender once the database query is done,
* Drop the original sender after the `for` loop,
* Call [`.recv()`](https://docs.rs/tokio/latest/tokio/sync/mpsc/struct.Receiver.html#method.recv) on the receiver at the very end.

As tokio's documentation shows, the `.recv()` method will cause the receiver to sleep as it waits for each task to complete, and at the end it will close once the last sender has been dropped.

```
This method returns None if the channel has been closed and there are no remaining messages in the channel’s buffer. This indicates that no further values can ever be received from this Receiver. The channel is closed when all senders have been dropped, or when close is called.

If there are no messages in the channel’s buffer, but the channel has not yet been closed, this method will sleep until a message is sent or the channel is closed.
```

Here is what the `async_test()` function looks like using this method.

```rust
async fn async_test(db: Arc<Surreal<Client>>, test_num: &'static str) -> std::time::Duration {
    let (tx, mut rx) = mpsc::channel::<()>(1);
    let start = std::time::Instant::now();

    for idx in 0..=MAX {
        let sender = tx.clone();
        let db = db.clone();
        tokio::spawn(async move {
            select_index(&db, idx, test_num).await;
            drop(sender);
        });
    }
    drop(tx);

	rx.recv().await;

    Instant::now() - start
}
```


================================================
FILE: src/content/doc-sdk-rust/concepts/fetch.mdx
================================================
---
sidebar_position: 2
sidebar_label: Fetching linked records
title: Fetching Records in Rust | Rust SDK | SurrealDB
description: All the fields of a SurrealDB linked record can be fetched and deserialized into a Rust type
---

# Fetching records

Start a running database using the following command:

```
surreal start --user root --pass secret 
```

To follow along interactively, connect [using Surrealist](/docs/surrealist/getting-started#creating-a-connection) or the following command to open up the CLI:

```
surrealdb % surreal sql --user root --pass secret --ns namespace --db database --pretty
```

Then use the `cargo add` command to add three crates: `surrealdb` and `tokio`, and with `serde` with the "serde_derive" feature (`cargo add serde --features serde_derive`). The dependencies inside `Cargo.toml` should look something like this:

cargo add serde --features serde_derive

```toml
[dependencies]
serde = { version = "1.0.214", features = ["serde_derive"] }
surrealdb = "2.0.4"
tokio = "1.41.0"
```

## When to use FETCH

The following example shows a classroom joined to a few students by [record links](/docs/surrealql/datamodel/records).

```surql
CREATE teacher:one SET name = id.id();
CREATE student:one, student:two, student:three SET name = id.id();

CREATE classroom SET
    location = (-16.7, 64.4),
    school_name = "Jöklaskóli",
    teacher = teacher:one,
    students = [student:one, student:two, student:three];
```

A query using `SELECT * FROM classroom:one` will show the teacher and all of the students, but only their record IDs.

```surql title="Query and response"
SELECT * FROM classroom:one;

[
	{
		id: classroom:one,
		location: (-16.7, 64.4),
		school_name: 'Jöklaskóli',
		students: [
			student:one,
			student:two,
			student:three
		],
		teacher: teacher:one
	}
]
```

[The `.*` operator](/docs/surrealql/datamodel/idioms#all-elements) for the `teacher` and `student` fields can be used in this case, but note that the `.*` must be used twice in the case of the students: once to access each member of the array, and once more to access all of its fields.

```surql
SELECT *, teacher.*, students.*.* FROM classroom;
```

Using `FETCH` may be a nicer option in this case. The syntax is a bit more readable, and there is no need to think about which fields are single records and which ones are arrays.

```surql
SELECT * FROM classroom FETCH teacher, students;
```

Here is the result:

```surql title="Output"
[
	{
		id: classroom:one,
		location: (-16.7, 64.4),
		school_name: 'Jöklaskóli',
		students: [
			{
				id: student:one,
				name: 'one'
			},
			{
				id: student:two,
				name: 'two'
			},
			{
				id: student:three,
				name: 'three'
			}
		],
		teacher: {
			id: teacher:one,
			name: 'one'
		}
	}
]
```

## The Rust code

The code below that shows an example of `FETCH` is another example related to classes and students. Note that in one part it passes a [`Resource`](https://docs.rs/surrealdb/latest/surrealdb/opt/enum.Resource.html) into the [`create`](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.create) method in order to return a [`Value`](https://docs.rs/surrealdb/latest/surrealdb/struct.Value.html) and thus not have to specify a return type to deserialize into. For more information on this technique, see [the page on flexible typing](/docs/sdk/rust/concepts/flexible-typing).

```rust
use serde::{Deserialize, Serialize};
use surrealdb::{
    engine::remote::ws::Ws,
    opt::{auth::Root, Resource},
    sql::Datetime,
    RecordId, Surreal,
};

// Dance classes table name
const DANCE: &str = "dance";
// Students table name
const STUDENT: &str = "student";

// Dance class table schema
#[derive(Debug, Serialize, Deserialize)]
struct DanceClass {
    id: RecordId,
    name: String,
    created_at: Datetime,
}

// Student table schema
#[derive(Debug, Serialize)]
struct Student {
    id: RecordId,
    name: String,
    classes: Vec<RecordId>,
    created_at: Datetime,
}

// Student model with full class details
#[derive(Debug, Deserialize)]
#[allow(dead_code)]
struct StudentClasses {
    id: RecordId,
    name: String,
    classes: Vec<DanceClass>,
    created_at: Datetime,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    // Connect to the database server
    let db = Surreal::new::<Ws>("localhost:8000").await?;

    // Sign in into the server
    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    // Select the namespace and database to use
    db.use_ns("namespace").use_db("database").await?;

    // Create a dance class and store the result
    let classes: Option<DanceClass> = db
        .create(DANCE)
        .content(DanceClass {
            id: RecordId::from((DANCE, "dc101")),
            name: "Introduction to Dancing".to_owned(),
            created_at: Datetime::default(),
        })
        .await?;

    // Create a student and assign her to the previous dance class
    // We don't care about the result here so we don't need to
    // type-hint and store it. We use `Resource::from` to return
    // a `sql::Value` instead and ignore it.
    db.create(Resource::from(STUDENT))
        .content(Student {
            id: RecordId::from((STUDENT, "jane")),
            name: "Jane Doe".to_owned(),
            classes: classes.into_iter().map(|class| class.id).collect(),
            created_at: Datetime::default(),
        })
        .await?;

    // Run a query to retrieve students and full class info
    let mut results = db.query(format!("SELECT * FROM {STUDENT} FETCH classes")).await?;

    // Extract the first query statement result and deserialise it as a vector of students
    let students: Vec<StudentClasses> = results.take(0)?;

    // Use the result as you see fit. In this case we are simply pretty printing it.
    println!("Students = {:?}", students);

    Ok(())
}
```

Here is the final output:

```
Students = [StudentClasses { id: RecordId { table: "student", key: String("jane") }, name: "Jane Doe", classes: [DanceClass { id: RecordId { table: "dance", key: String("dc101") }, name: "Introduction to Dancing", created_at: Datetime(2024-11-06T02:15:05.116807Z) }], created_at: Datetime(2024-11-06T02:15:05.117644Z) }]
```


================================================
FILE: src/content/doc-sdk-rust/concepts/flexible-typing.mdx
================================================
---
sidebar_position: 4
sidebar_label: Flexible typing
title: Flexible Typing in Rust | Rust SDK | SurrealDB
description: The Rust SDK for SurrealDB offers methods for working with types without deserialization
---

# Flexible typing

Most examples in the Rust SDK feature strict types like the following that can be serialized and deserialized as needed.

```rust
#[derive(Debug, Serialize, Deserialize)]
struct Student {
    name: String,
    class_id: u32,
}
```

However, sometimes you will need to work with types that have a more dynamic structure. This page offers a few methods to use in such a case.

## Getting started

Start a running database using the following command:

```
surreal start --user root --pass secret 
```

To follow along interactively, connect [using Surrealist](/docs/surrealist/getting-started#creating-a-connection) or the following command to open up the CLI:

```
surrealdb % surreal sql --user root --pass secret --ns namespace --db database --pretty
```

Then use the `cargo add` command to add four crates: `surrealdb`, `serde`, `serde_json`, and `tokio`. Your `Cargo.toml` file should look something like this.

```toml
[dependencies]
serde = "1.0.214"
serde_json = "1.0.132"
surrealdb = "2.0.4"
tokio = "1.41.0"
```

## Strict vs. flexible typing

The following example is a typical one, featuring a `Student` struct that holds a `name` and a `class_id`, followed by the `.select()` function to display all the students.

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::{Error, Surreal};

#[derive(Debug, Serialize, Deserialize)]
struct Student {
    name: String,
    class_id: u32,
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    // Connect to the database server
    let db = Surreal::new::<Ws>("localhost:8000").await?;

    // Sign in into the server
    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    // Select the namespace and database to use
    db.use_ns("namespace").use_db("database").await?;

    let all_students: Vec<Student> = db.select("student").await?;
    println!("All students: {all_students:?}");

    Ok(())
}
```

Before running this code, first use Surrealist or the CLI to populate the database with two students.

```surql
CREATE student SET name = "Student 1", class_id = 10; CREATE student SET name = "Another student", class_id = 20;
```

Once that is done, running `cargo run` will display the following output.

```
All students: [Student { name: "Another student", class_id: 20 }, Student { name: "Student 1", class_id: 10 }]
```

So far so good, but what if we were still experimenting with the data and created a `student` that diverged from the `Student` struct?

```surql
CREATE student SET name = "Third student", class_id = 40, metadata = { teacher: teacher:mr_gundry_white, favourite_classes: ["Music", "Industrial arts"] };
```

In this case the output would still conform to the `Student` struct and the extra information in the third student would not show up.

```
All students: [Student { name: "Another student", class_id: 20 }, Student { name: "Student 1", class_id: 10 }, Student { name: "Third student", class_id: 40 }]
```

One possibility here is to use the `.query()` method, which will always return the output as received from the database.

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::{Error, Surreal};

#[derive(Debug, Serialize, Deserialize)]
struct Student {
    name: String,
    class_id: u32,
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    // Connect to the database server
    let db = Surreal::new::<Ws>("localhost:8000").await?;

    // Sign in into the server
    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    // Select the namespace and database to use
    db.use_ns("namespace").use_db("database").await?;

    let all_students = db.query("SELECT * FROM student").await?;
    println!("All students: {all_students:?}");

    Ok(())
}
```

However, the output is a bit noisy.

```
All students: Response { client: Surreal { router: OnceLock(Router { sender: Sender { .. }, last_id: 4, features: {LiveQueries} }), engine: PhantomData<surrealdb::api::engine::any::Any> }, results: {0: (Stats { execution_time: Some(65.417µs) }, Ok(Array(Array([Object(Object({"class_id": Number(Int(20)), "id": RecordId(RecordId { table: "student", key: String("7bhlb23ti1vedykpsnzd") }), "name": Strand(Strand("Another student"))})), Object(Object({"class_id": Number(Int(10)), "id": RecordId(RecordId { table: "student", key: String("rpi0qmsqc7rwaxddfxpb") }), "name": Strand(Strand("Student 1"))})), Object(Object({"class_id": Number(Int(40)), "id": RecordId(RecordId { table: "student", key: String("xl5rzvlkghtn01nh5tw2") }), "metadata": Object(Object({"favourite_classes": Array(Array([Strand(Strand("Music")), Strand(Strand("Industrial arts"))])), "teacher": RecordId(RecordId { table: "teacher", key: String("mr_gundry_white") })})), "name": Strand(Strand("Third student"))}))]))))}, live_queries: {} }
```

A better solution when working with dynamic structures in a situation like this is to pass in a [`Resource`](https://docs.rs/surrealdb/latest/surrealdb/opt/enum.Resource.html) into the methods we use. Database methods that take a `Resource` will automatically return a [`Value`](https://docs.rs/surrealdb/latest/surrealdb/struct.Value.html) which contains an enum of all the possible data types in SurrealDB, and thus does not require deserializing. In addition, a `Value' implements `Display`, making the output similar to that in the CLI.

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::opt::Resource;
use surrealdb::{Error, Surreal};

#[derive(Debug, Serialize, Deserialize)]
struct Student {
    name: String,
    class_id: u32,
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    // Connect to the database server
    let db = Surreal::new::<Ws>("localhost:8000").await?;

    // Sign in into the server
    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    // Select the namespace and database to use
    db.use_ns("namespace").use_db("database").await?;

    let all_students = db.select(Resource::from("student")).await?;
    println!("All students debug: {all_students:?}\n");
    println!("All students display: {all_students}");

    Ok(())
}
```

As the output shows, `Debug` printing returns an output similar to the `.query()` example above, while using `Display` is much neater.

```
All students debug: Array(Array([Object(Object({"class_id": Number(Int(20)), "id": RecordId(RecordId { table: "student", key: String("7bhlb23ti1vedykpsnzd") }), "name": Strand(Strand("Another student"))})), Object(Object({"class_id": Number(Int(10)), "id": RecordId(RecordId { table: "student", key: String("rpi0qmsqc7rwaxddfxpb") }), "name": Strand(Strand("Student 1"))})), Object(Object({"class_id": Number(Int(40)), "id": RecordId(RecordId { table: "student", key: String("xl5rzvlkghtn01nh5tw2") }), "metadata": Object(Object({"favourite_classes": Array(Array([Strand(Strand("Music")), Strand(Strand("Industrial arts"))])), "teacher": RecordId(RecordId { table: "teacher", key: String("mr_gundry_white") })})), "name": Strand(Strand("Third student"))}))]))

All students display: [{ class_id: 20, id: student:7bhlb23ti1vedykpsnzd, name: 'Another student' }, { class_id: 10, id: student:rpi0qmsqc7rwaxddfxpb, name: 'Student 1' }, { class_id: 40, id: student:xl5rzvlkghtn01nh5tw2, metadata: { favourite_classes: ['Music', 'Industrial arts'], teacher: teacher:mr_gundry_white }, name: 'Third student' }]
```

A `Value` from `serde_json` can be passed into functions like `.create()`, allowing the [`json!`](https://docs.rs/serde_json/latest/serde_json/macro.json.html) macro to also be used.

```rust
use serde::{Deserialize, Serialize};
use serde_json::json;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::opt::Resource;
use surrealdb::{Error, Surreal};

#[derive(Debug, Serialize, Deserialize)]
struct Student {
    name: String,
    class_id: u32,
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    // Connect to the database server
    let db = Surreal::new::<Ws>("localhost:8000").await?;

    // Sign in into the server
    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    // Select the namespace and database to use
    db.use_ns("namespace").use_db("database").await?;

    let new_student = db.create(Resource::from("student")).content(json!({
        "age": 15,
        "weekly_allowance": 20.5
    })).await?;
    
    println!("{new_student}");

    Ok(())
}
```

Output:

```
{ age: 15, id: student:gp6g0p7t23musi3ms77d, weekly_allowance: 20.5f }
```


================================================
FILE: src/content/doc-sdk-rust/concepts/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: SDK Concepts
title: JavaScript | SDK | Concepts
description: The SurrealDB SDK for JavaScript enables simple and advanced querying of a remote or embedded database.
---

# Concepts 

In this section, we will go over the core concepts of the SurrealDB SDK for Rust. You will learn how to connect to a SurrealDB instance, manage authentication, and interact with the database.

- [Fetching linked records](/docs/sdk/rust/concepts/fetch)
- [Manual transactions](/docs/sdk/rust/concepts/transaction)
- [Flexible typing](/docs/sdk/rust/concepts/flexible-typing)
- [Live queries](/docs/sdk/rust/concepts/live)
- [Authenticating users](/docs/sdk/rust/concepts/authenticating-users)
- [Improving performance with concurrency](/docs/sdk/rust/concepts/concurrency)


================================================
FILE: src/content/doc-sdk-rust/concepts/live.mdx
================================================
---
sidebar_position: 5
sidebar_label: Live queries
title: Live Queries in Rust | Rust SDK | SurrealDB
description: The Rust SDK for SurrealDB allows changes to tables in real time to be observed
---

# Live queries

A [`LIVE SELECT`](/docs/surrealql/statements/live) statement creates a session that keeps track of changes to a table in real time. Inside the Rust SDK, this is accomplished by appending [`.live()`](https://docs.rs/surrealdb/latest/surrealdb/method/struct.Select.html#method.live) to the end of a [`.select()`](/docs/sdk/rust/methods/select) query.

## Getting started

Start a running database using the following command:

```
surreal start --user root --pass secret 
```

To follow along interactively, connect [using Surrealist](/docs/surrealist/getting-started#creating-a-connection) or the following command to open up the CLI:

```
surrealdb % surreal sql --user root --pass secret --ns namespace --db database --pretty
```

Then use the `cargo add` command to add four crates: `surrealdb` and `tokio`, the `futures` crate for the [`StreamExt`](https://docs.rs/futures/latest/futures/stream/trait.StreamExt.html) trait needed to use the async stream, as well as with `serde` with the "serde_derive" feature (`cargo add serde --features serde_derive`). The dependencies inside `Cargo.toml` should look something like this:

cargo add serde --features serde_derive

```toml
[dependencies]
futures = "0.3.31"
serde = { version = "1.0.214", features = ["serde_derive"] }
surrealdb = "2.0.4"
tokio = "1.41.0"
```

The example code below shows a live select that keeps track of changes made to a sample of records from the `account` table. By adding the [`.range()`](https://docs.rs/surrealdb/latest/surrealdb/method/struct.Select.html#method.range-1) method, it can be restricted to certain record IDs, in this case any record IDs in between the letters a and g.

The stream from the `.live()` method returns a stream of [`Notification`](https://docs.rs/surrealdb/latest/surrealdb/struct.Notification.html)s. These contain an action (an `Action::Create`, `Action::Update`, or `Action::Delete`), and a field called `data` that contains anything that can be deserialized. In this case, the `data` field will deserialize into a struct that we create called `Account`. It also contains a `query_id` field that contains the ID of the live query itself, for record keeping or to cancel using the [`KILL`](/docs/surrealql/statements/kill) statement.

Once the following code is run, the Rust client will continue to listen for changes to the `account` table indefinitely.

```rust
use futures::StreamExt;
use serde::Deserialize;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::{RecordId, Surreal};

const ACCOUNT: &str = "account";

#[derive(Debug, Deserialize)]
struct Account {
    id: RecordId,
    balance: f64,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("localhost:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("namespace").use_db("database").await?;

    let mut sample_accounts = db.select(ACCOUNT).range("a"..="g").live().await?;

    while let Some(result) = sample_accounts.next().await {
        match result {
            Ok(notification) => {
                let action = notification.action;
                let account: Account = notification.data;
                let id = notification.query_id;
                println!("{action:?} from live ID {id}:\n  {account:#?}\n");
            }
            Err(error) => eprintln!("{error}"),
        }
    }

    Ok(())
}
```

We can now move to Surrealist or the CLI to execute a few queries and see what happens. The following queries create, update, and delete ten `account` records.

```surql
FOR $_ IN 0..10 { CREATE account SET balance = 10 };
UPDATE account SET balance += 1000;
DELETE account;
```

The Rust client will keep track for any with a record ID in between a and g, returning an output similar to the following.

```bash
Create from live ID 63853ee1-aa9b-4e04-a54a-3b900a3cbaaa:
  Account {
    id: RecordId {
        table: "account",
        key: String(
            "cjk4pk2am5chjs4hxjpz",
        ),
    },
    balance: 10.0,
}

Create from live ID 63853ee1-aa9b-4e04-a54a-3b900a3cbaaa:
  Account {
    id: RecordId {
        table: "account",
        key: String(
            "dp98mide1w91fnjoezf0",
        ),
    },
    balance: 10.0,
}

Update from live ID 63853ee1-aa9b-4e04-a54a-3b900a3cbaaa:
  Account {
    id: RecordId {
        table: "account",
        key: String(
            "cjk4pk2am5chjs4hxjpz",
        ),
    },
    balance: 1010.0,
}

Update from live ID 63853ee1-aa9b-4e04-a54a-3b900a3cbaaa:
  Account {
    id: RecordId {
        table: "account",
        key: String(
            "dp98mide1w91fnjoezf0",
        ),
    },
    balance: 1010.0,
}

Delete from live ID 63853ee1-aa9b-4e04-a54a-3b900a3cbaaa:
  Account {
    id: RecordId {
        table: "account",
        key: String(
            "cjk4pk2am5chjs4hxjpz",
        ),
    },
    balance: 1010.0,
}

Delete from live ID 63853ee1-aa9b-4e04-a54a-3b900a3cbaaa:
  Account {
    id: RecordId {
        table: "account",
        key: String(
            "dp98mide1w91fnjoezf0",
        ),
    },
    balance: 1010.0,
}
```


================================================
FILE: src/content/doc-sdk-rust/concepts/rust_after-3.0.mdx
================================================
---
sidebar_position: 9
sidebar_label: Types after version 3.0
title: Using the Rust crate after SurrealDB 3.0
description: Many structural changes were implemented in SurrealDB 3.0, bringing large improvements to working with types in the Rust SDK.
---

import Since from "@components/shared/Since.astro";

# The `surrealdb-types` crate

The largest user experience improvement for Rust users of SurrealDB 3.0 is the [surrealdb-types](https://crates.io/crates/surrealdb-types) crate, which was created to have a shared public value type system for SurrealDB.

This crate was separated from the SurrealDB core to decouple types and type conversions from core database logic, and to allow other crates to make use of types on their own without needing the entire SurrealDB database along with it.

# The `SurrealValue` trait

The main difference between SurrealDB 3.0 and previous versions for Rust users is the existence of a `SurrealValue` trait that can be derived automatically. Deriving this trait is all that is needed to use a Rust type for serialization and deserialization.

```rust
use surrealdb::engine::any::connect;
use surrealdb_types::SurrealValue;

#[derive(Debug, SurrealValue)]
struct Employee {
    name: String,
    active: bool,
}

#[tokio::main]
async fn main() {
    let db = connect("memory").await.unwrap();

    db.use_ns("ns").use_db("db").await.unwrap();

    let mut res = db
        .query("CREATE employee:bobby SET name = 'Bobby', active = true")
        .await
        .unwrap();

    let bobby = res.take::<Option<Employee>>(0).unwrap().unwrap();

    // Employee { name: "Bobby", active: true }
    println!("{bobby:?}");
}
```

The `SurrealValue` trait can be implemented manually via three methods: one to indicate the matching SurrealDB type, a second to convert into a SurrealDB Value, and a third to convert out of a SurrealDB Value.

```rust
#[derive(Debug)]
struct MyOwnDateTime(i64);

impl SurrealValue for MyOwnDateTime {
    fn kind_of() -> surrealdb_types::Kind {
        Kind::Datetime
    }

    fn into_value(self) -> surrealdb_types::Value {
        Value::Datetime(Datetime::from_timestamp(self.0, 0).unwrap())
    }

    fn from_value(value: surrealdb_types::Value) -> anyhow::Result<Self>
    where
        Self: Sized,
    {
        match value {
            Value::Datetime(n) => Ok(MyOwnDateTime(n.timestamp_millis())),
            _ => Err(anyhow!("No good")),
        }
    }
}

#[tokio::main]
async fn main() {
    let db = connect("memory").await.unwrap();

    db.use_ns("ns").use_db("db").await.unwrap();

    println!(
        "{:?}",
        db.query("time::now()")
            .await
            .unwrap()
            .take::<Option<MyOwnDateTime>>(0)
    );
}
```

An example of successful and unsuccessful conversions into the usercreated `MyOwnDateTime` struct:

```rust
#[tokio::main]
async fn main() {
    let db = connect("memory").await.unwrap();

    db.use_ns("ns").use_db("db").await.unwrap();

    println!(
        "{:?}\n",
        db.query("time::now()")
            .await
            .unwrap()
            .take::<Option<MyOwnDateTime>>(0)
    );

    println!(
        "{:?}",
        db.query("CREATE person")
            .await
            .unwrap()
            .take::<Option<MyOwnDateTime>>(0)
    );
}
```

Output:

```
Ok(Some(MyOwnDateTime(1760330504574)))

Err(InternalError("Couldn't convert Object(Object({\"id\": RecordId(RecordId { table: \"person\", key: String(\"tcblzaktx3ponin9dyci\") })})) to MyOwnDateTime"))
```

# Convenience methods for the `Value` type

Importing the `SurrealValue` trait gives access to a lot of convenience methods.

One example is the `.into_value()` method which converts a large number of Rust standard library types into a SurrealQL `Value`.

```rust
use surrealdb_types::{SurrealValue, Value};

fn main() {
    let string_val = "string".into_value();
    assert!(string_val.is_string());
    assert_eq!(string_val, Value::String("string".into()));
}
```

One more example of `.into_value()` to convert a `HashMap<String, &'str>` into a `Value`:

```rust
use std::collections::HashMap;

use surrealdb::engine::any::connect;
use surrealdb_types::{SurrealValue, Value};

#[tokio::main]
async fn main() {
    let db = connect("memory").await.unwrap();
    db.use_ns("db").use_db("db").await.unwrap();

    let mut map = HashMap::new();
    map.insert("name".to_string(), "Billy");
    map.insert("id".to_string(), "person:one");

    // Turn HashMap into SurrealDB Value
    let as_person = map.into_value();

    // Object(Object({"id": String("person:one"), "name": String("Billy")}))
    println!("{as_person:?}");

    // Insert it into a query to create a record
    let res = db
        .query("CREATE ONLY person CONTENT $person")
        .bind(("person", as_person))
        .await
        .unwrap()
        .take::<Value>(0)
        .unwrap();

    // Object(Object({"id": RecordId(RecordId { table: "person", key: String("person:one") }), "name": String("Billy")}))
    println!("{res:?}");
}
```

A `Value` can be manually constructed using any of the various structs and enums contained within it. This is particularly useful when constructing a complex ID made up of a table name and an array for the key.

```rust
use std::str::FromStr;

use surrealdb::engine::any::connect;
use surrealdb_types::{Array, Datetime, RecordId, RecordIdKey, Value};

#[tokio::main]
async fn main() {
    let db = connect("memory").await.unwrap();
    db.use_ns("db").use_db("db").await.unwrap();

    let date = "2025-10-13T05:16:11.343Z";

    let complex_id = RecordId {
        table: "weather".into(),
        key: RecordIdKey::Array(Array::from(vec![
            Value::String("London".to_string()),
            Value::Datetime(Datetime::from_str(date).unwrap()),
        ])),
    };

    let mut res = db
        .query("CREATE ONLY weather SET id = $id")
        .bind(("id", complex_id))
        .await
        .unwrap();

    // Object(Object({"id": RecordId(RecordId { table: "weather", key: Array(Array([String("London"), Datetime(Datetime(2025-10-13T05:16:11.343Z))])) })}))
    println!("{:?}", res.take::<Value>(0).unwrap());
}
```

The `.is()` method for a `Value` returns `true` if the type(s) in question can be converted to the type indicated when the method is called.

```rust
use std::collections::HashMap;
use surrealdb_types::SurrealValue;

fn main() {
    // true
    println!("{}", "string".into_value().is::<String>());

    let mut map = HashMap::new();
    map.insert("name".to_string(), "Billy");
    map.insert("id".to_string(), "person:one");

    // true
    println!("{}", map.clone().into_value().is::<HashMap<String, &str>>());
    // Also true
    println!("{}", map.into_value().is::<HashMap<String, String>>());
}
```

A `Value` can be converted into a `serde_json::Value` using the `.into_json_value()` method, and vice versa using `.into_value()`.

```rust
use surrealdb::engine::any::connect;
use surrealdb_types::Value;

#[tokio::main]
async fn main() {
    let db = connect("memory").await.unwrap();
    db.use_ns("db").use_db("db").await.unwrap();

    let value = db
        .query("CREATE ONLY person:one SET age = 21")
        .await
        .unwrap()
        .take::<Value>(0)
        .unwrap();

    // Object(Object({"age": Number(Int(21)), "id": RecordId(RecordId { table: "person", key: String("one") })}))
    println!("{value:?}");
    // Object {"age": Number(21), "id": String("person:one")}
    println!("{:?}", value.into_json_value());

    // Round trip
    value.into_json_value().into_value();
}
```


================================================
FILE: src/content/doc-sdk-rust/concepts/transaction.mdx
================================================
---
sidebar_position: 3
sidebar_label: Manual transactions
title: Manual Transactions in Rust | Rust SDK | SurrealDB
description: Manual transactions can be used via the Rust SDK in the same manner as regular SurrealQL queries
---

# Manual transactions

While every query in SurrealDB is run [inside its own transaction](/docs/surrealql/transactions), manual transactions made up of multiple statements can be used via the [BEGIN](/docs/surrealql/statements/begin) and [COMMIT](/docs/surrealql/statements/commit) keywords.

The [`.query()`](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.query) method can take any number of statements, returning a [`Response`](https://docs.rs/surrealdb/latest/surrealdb/struct.Response.html) that contains the results of each of them. In addition, the same method before being called returns [a struct](https://docs.rs/surrealdb/latest/surrealdb/method/struct.Query.html) that also allows [the same `.query()` method](https://docs.rs/surrealdb/latest/surrealdb/method/struct.Query.html#method.query) to be called on it, chaining the new query onto the existing query. This can help greatly with readability, as the example code below shows.

## Getting started

Start a running database using the following command:

```
surreal start --user root --pass secret 
```

To follow along interactively, connect [using Surrealist](/docs/surrealist/getting-started#creating-a-connection) or the following command to open up the CLI:

```
surrealdb % surreal sql --user root --pass secret --ns namespace --db database --pretty
```

Then use the `cargo add` command to add the `surrealdb` and `tokio` crates. The dependencies inside `Cargo.toml` should look something like this:

```toml
[dependencies]
surrealdb = "2.0.4"
tokio = "1.41.0"
```

Once this is done, copy and paste the following code to run a manual transaction that creates two `account` records and then transfers 300 units from one account to the other.

```rust
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::Surreal;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
	let db = Surreal::new::<Ws>("localhost:8000").await?;

	db.signin(Root {
		username: "root",
		password: "secret",
	})
	.await?;

	db.use_ns("namespace").use_db("database").await?;

    let response = db

        // Start transaction
        .query("BEGIN")

        // Setup accounts
        .query("
            CREATE account:one SET balance = 135605.16;
            CREATE account:two SET balance = 91031.31;
        ")

        // Move money
        .query("
            UPDATE account:one SET balance += 300.00;
            UPDATE account:two SET balance -= 300.00;
        ")

        // Finalise
        .query("COMMIT")
        .await?;

    println!("{response:#?}");

	// See if any errors were returned
	response.check()?;

	Ok(())
}
```

To avoid the possibility of typos, the [`.set()`](/docs/sdk/rust/methods/set) method can be used to set the amount to transfer.

```rust
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::Surreal;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
	let db = Surreal::new::<Ws>("localhost:8000").await?;

	db.signin(Root {
		username: "root",
		password: "secret",
	})
	.await?;

	db.use_ns("namespace").use_db("database").await?;

    // Set the parameter $transfer_amount for later use
    db.set("transfer_amount", 300).await?;

    let response = db

        // Start transaction
        .query("BEGIN")

        // Setup accounts
        .query("
            CREATE account:one SET balance = 135605.16;
            CREATE account:two SET balance = 91031.31;
        ")

        // Move money
        .query("
            UPDATE account:one SET balance += $transfer_amount;
            UPDATE account:two SET balance -= $transfer_amount;
        ")

        // Finalise
        .query("COMMIT")
        .await?;

    println!("{response:#?}");

	// See if any errors were returned
	response.check()?;

	Ok(())
}
```


================================================
FILE: src/content/doc-sdk-rust/concepts/vector-embeddings.mdx
================================================
---
sidebar_position: 8
sidebar_label: Vector embeddings
title: Vector embeddings in Rust | Rust SDK | SurrealDB
description: Many crates are available to work with vector embeddings via the SurrealDB Rust SDK.
---

# Vector embeddings

The quickest way to retrieve vector embeddings is to use the [fastembed crate](/docs/integrations/embeddings/fastembed#language-specific-examples), which does not require a user key or calling into an external service.

The following blog posts include runnable examples using vector embeddings via the Rust SDK.

* [Building an AI-native multi-model UI with SurrealDB
](/blog/building-an-ai-native-multi-model-ui-with-surrealdb): a UI built with Iced.rs with OpenAI and Mistral embeddings
* [Hybrid vector + text Search in the terminal with SurrealDB and Ratatui](/blog/hybrid-vector-text-search-in-the-terminal-with-surrealdb-and-ratatui): a UI built with Ratatui.rs with OpenAI and Mistral embeddings
* [Make a medical chatbot using GraphRAG with SurrealDB + LangChain](/blog/make-a-medical-chatbot-using-graphrag-with-surrealdb-langchain)
* [Semantic search in Rust with SurrealDB and Mistral AI
](/blog/semantic-search-in-rust-with-surrealdb-and-mistral-ai)
* [Semantic search with SurrealDB and OpenAI
](/blog/semantic-search-with-surrealdb-and-openai)
* [Building a smart knowledge agent with SurrealDB and Rig.rs](/blog/rag-can-be-rigged)



================================================
FILE: src/content/doc-sdk-rust/frameworks/actix.mdx
================================================
---
sidebar_position: 2
sidebar_label: Actix
title: Rust | SDKs | Integration
description: The SDK for Rust allows SurrealDB to be used as the storage backend for an Actix web server
---

# SurrealDB with Actix

The following tutorial will set up a server with SurrealDB and [Actix Web](https://actix.rs/) that has a few endpoints:

* Some endpoints to demonstrate how the HTTP endpoints work to create, select, modify etc. a `person` table in a database,
* Other endpoints to display some helpful info for the user,
* Two endpoints to allow signing up and signing in as a [record user](/docs/surrealql/statements/define/access/record).

## Getting started

First, open up a terminal window and use the following command to start an empty database.

```bash
surreal start --user root --pass secret
```

You can also use the [Start serving](/docs/surrealist/concepts/local-database-serving) button on [Surrealist](/docs/surrealist) to do the same if you have it installed locally.

The database initiated by the [surreal start](/docs/surrealdb/cli/start) command stores data in memory by default, which then disappears every time the database is shut down. As such, you can simply use Ctrl+C every time you want to start the database anew with no existing definitions or data. To save data to disk which will persist after shutting down, add a [positional argument](/docs/surrealdb/cli/start#positional-argument) for one of the storage backends such as `rocksdb://mydatabase` or `surrealkv://mydatabase` (or `surrealkv+versioned//mydatabase` to include SurrealKV versioning).

With the database running, we will now connect to the database "test" located in the namespace "test". You can connect to it by [creating a connection](/docs/surrealist/getting-started#creating-a-connection) inside Surrealist, or by using the following command to start an interactive shell.

```bash
surreal sql --user root --pass secret --ns test --db test --pretty
```

Next, create a new Rust project with the command `cargo new your_project_name`, go into the newly created directory, and use `cargo add` to add each of the following dependencies:

* `surrealdb` (of course),
* `actix-web`,
* `serde`, for serializing and deserializing Rust structs passed to and from the database and Actix,
* `thiserror`, to make it easy to convert between SurrealDB's error type, other errors and Actix's response types,
* `rand` and `faker_rand`, to create random user names that can be used to sign in to the database as a record user.

The `serde` crate will need the `derive` flag enabled as well. Your `cargo.toml` dependencies should look like this:

```
actix-web = "4.9.0"
faker_rand = "0.1.1"
rand = "0.8.5"
serde = { version = "1.0.209", features = ["derive"] }
surrealdb = "2.0.4"
thiserror = "1.0.64"
```

## Starting the Rust code

The first thing to do is a bit of groundwork to convert database errors into an error type of our own. Implementing `From<surrealdb::Error>` for this type will let it be used with the `?` operator when handling results. Finally, it will also need to implement Actix's `ResponseError` trait so that it can be used as output for the server. All of this can be done manually if you prefer, but the `thiserror` crate saves a certain amount of typing.

```rust
mod error {
    use actix_web::{HttpResponse, ResponseError};
    use thiserror::Error;

    #[derive(Error, Debug)]
    pub enum Error {
        #[error("database error")]
        Db(String),
    }

    impl ResponseError for Error {
        fn error_response(&self) -> HttpResponse {
            match self {
                Error::Db(e) => HttpResponse::InternalServerError().body(e.to_string()),
            }
        }
    }

    impl From<surrealdb::Error> for Error {
        fn from(error: surrealdb::Error) -> Self {
            eprintln!("{error}");
            Self::Db(error.to_string())
        }
    }
}
```

Next, we will put the database client together. Actix provides an [`.app_data()`](https://actix.rs/docs/application/#state) method when starting a router that would give us access to the database inside its functions. However, for simplicity we can instead wrap the client inside a `LazyLock` to make it into a global static.

```rust
use std::sync::LazyLock;
static DB: LazyLock<Surreal<Client>> = LazyLock::new(Surreal::init);
```

Inside `main()`, we will do the following:

* Connect to the database running at `localhost:8000`
* Sign in as the root user that was created through the `surreal start` command
* Use (move to) the namespace "test" and database "test"
* Use the `.query()` method to pass in a few definitions for the database.

```rust
DB.connect::<Ws>("localhost:8000").await?;

DB.signin(Root {
    username: "root",
    password: "secret",
})
.await?;

DB.use_ns("test").use_db("test").await?;

DB.query(
    "
DEFINE TABLE IF NOT EXISTS person SCHEMALESS
    PERMISSIONS FOR 
        CREATE, SELECT WHERE $auth,
        FOR UPDATE, DELETE WHERE created_by = $auth;
DEFINE FIELD IF NOT EXISTS name ON TABLE person TYPE string;
DEFINE FIELD IF NOT EXISTS created_by ON TABLE person VALUE $auth READONLY;

DEFINE INDEX IF NOT EXISTS unique_name ON TABLE user FIELDS name UNIQUE;
DEFINE ACCESS IF NOT EXISTS account ON DATABASE TYPE RECORD
SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
DURATION FOR TOKEN 15m, FOR SESSION 12h
;",
)
.await?;
```

## What the database definitions do

The first item that stands out with the definitions above is that they all contain a `IF NOT EXISTS` clause. As the `DEFINE` statements will be executed every time the app starts, it is possible that they might be executed on a database that already has the definitions in place. Since version 2.0, SurrealDB simply returns an error if a definition already exists, requiring the `OVERWRITE` clause if a definition needs to be redone. Without `IF NOT EXISTS`, the message "The table 'person' already exists" will be returned.

Note that this would not affect our app, as this would still be a successful usage of the `.query()` method. Instead, its output would contain a number of error results that could be handled individually:

```
Response { client: Surreal { router: OnceLock(Router { sender: Sender { .. }, last_id: 4, features: {LiveQueries} }), engine: PhantomData<surrealdb::api::engine::any::Any> }, results: {0: (Stats { execution_time: Some(252.625µs) }, Err(Api(Query("The table 'person' already exists")))), 1: (Stats { execution_time: Some(79.167µs) }, Err(Api(Query("The field 'name' already exists")))), 2: (Stats { execution_time: Some(69.5µs) }, Err(Api(Query("The field 'created_by' already exists")))), 3: (Stats { execution_time: Some(73.625µs) }, Err(Api(Query("The index 'unique_name' already exists")))), 4: (Stats { execution_time: Some(73.583µs) }, Err(Api(Query("The access method 'account' already exists in the database 'test'"))))}, live_queries: {} }
```

However, adding `IF NOT EXISTS` is a nice way to change the results from errors into successful results, and to avoid the rare case in which they end up applied to some other version 1.x database that would rewrite its definitions if `IF NOT EXISTS` is present. So while not necessary in our case, it is a good practice to follow and makes for cleaner output.

Now let's go over each of the definitions to see what they do.

The first three statements define a `person` table. This table is schemaless, but has one required field `name`, which must be present and must be a string. This table has defined permissions by which a record user is able to use `CREATE` and `SELECT` on the `person` table, but can only `UPDATE` and `DELETE` records that it has created. The root user, however, is not subject to permissions rules.

The way these permissions are set is by using the `$auth` parameter. This parameter has a value whenever a record user is set as the authorized used for the database. The `WHERE $auth` clause simply means "where a value exists for the parameter `$auth`" (`WHERE $auth IS NOT NONE` would also work in this case). But for `UPDATE` and `DELETE` queries, it is not enough for `$auth` to just be present, the `created_by` field of a `person` record must also match the ID of the currently authenticated user.

This `created_by` field is automatically generated from its definition in the `DEFINE FIELD` statement. It is given the value of `$auth`, and is `READONLY` and thus cannot be changed. When logged in as a system user (like a root user), its value will be `NONE`. But when logged in as a record user, its value will be something like `user:qx2apv5oc8mh03wtah0q`.

```surql
DEFINE TABLE IF NOT EXISTS person SCHEMALESS
    PERMISSIONS FOR 
        CREATE, SELECT WHERE $auth,
        FOR UPDATE, DELETE WHERE created_by = $auth;
DEFINE FIELD IF NOT EXISTS name ON TABLE person TYPE string;
DEFINE FIELD IF NOT EXISTS created_by ON TABLE person VALUE $auth READONLY;
```

So where does an ID like `user:qx2apv5oc8mh03wtah0q` come from? This is thanks to the following definitions that set the signup and signin behaviour of the record users. A typical [`DEFINE ACCESS`](/docs/surrealql/statements/define/access/record) statement will create some sort of record on signup (in this case, a `user`) record, and will compare it against a password during signin. Note that the access has a name that we gave it (`account`), so that it can be referenced elsewhere.

In addition, a `DEFINE INDEX` statement with a `UNIQUE` clause is used to ensure that no two users can have the same name.

```surql
    DEFINE INDEX IF NOT EXISTS unique_name ON TABLE user FIELDS name UNIQUE;
    DEFINE ACCESS IF NOT EXISTS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 15m, FOR SESSION 12h
```

For an actual user in production, you would probably want to require an email and some other fields. Functions like [`string::is_email`](/docs/surrealql/functions/database/string#stringis_email) can be used to ensure that the value passed in is valid.

```surql
DEFINE FIELD email ON TABLE user TYPE string ASSERT $value.is_email();
```

However, for this simple example, each user will simply have a unique name and a password. The password will be stored in hashed and salted form on the database, making it unique and unreadable every time it is generated. The only way to check if it is correct is by using a [compare function](/docs/surrealql/functions/database/crypto#cryptoargon2compare) of the output with an attempted password. Here is a short SurrealQL sample to show how the process works.

```surql
LET $hash1 = crypto::argon2::generate("myPaSSWord");
LET $hash2 = crypto::argon2::generate("myPaSSWord");

RETURN [$hash1, $hash2];
-- First returns true, second returns false
RETURN [
    crypto::argon2::compare($hash1, "myPaSSWord")
    crypto::argon2::compare($hash1, "Wrongpassword")
];
```

## The rest of the code

The last step is where the majority of the work takes place: setting up the paths for Actix to handle, and writing the functions that handle the endpoints and (usually) access the database to handle the request. To start, we'll create a function for the `"/"` root path to display a helpful message to anybody giving the server a try via the browser or an app like curl or Postman. These paths and curl examples can all be seen on [the page for SurrealDB's HTTP endpoints](/docs/surrealdb/integration/http).

```rust
    #[get("/")]
    pub async fn paths() -> &'static str {
        r#"

-----------------------------------------------------------------------------------------------------------------------------------------
        PATH                |           SAMPLE COMMAND                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------
/session: See session data  |  curl -X GET    -H "Content-Type: application/json"                          http://localhost:8080/session
                            |
/person/{id}:               |
  Create a person           |  curl -X POST   -H "Content-Type: application/json" -d '{"name":"John Doe"}' http://localhost:8080/person/one
  Get a person              |  curl -X GET    -H "Content-Type: application/json"                          http://localhost:8080/person/one
  Update a person           |  curl -X PUT    -H "Content-Type: application/json" -d '{"name":"Jane Doe"}' http://localhost:8080/person/one
  Delete a person           |  curl -X DELETE -H "Content-Type: application/json"                          http://localhost:8080/person/one
                            |
/people: List all people    |  curl -X GET    -H "Content-Type: application/json"                          http://localhost:8080/people

/new_user:  Create a new record user
/new_token: Get instructions for a new token if yours has expired"#
    }
```

Each of these functions will be put into a mod called `routes`, leading to the following code inside `main()`.

```rust
HttpServer::new(|| {
    App::new()
        .service(routes::create_person)
        .service(routes::read_person)
        .service(routes::update_person)
        .service(routes::delete_person)
        .service(routes::list_people)
        .service(routes::paths)
        .service(routes::session)
        .service(routes::make_new_user)
        .service(routes::get_new_token)
})
.bind(("localhost", 8080))?
.run()
.await?;
```

Many functions require some JSON data from the user, which will be deserialized into a `PersonData` struct. The database can then use it in methods like `.create().content()`. The output returned will now have a `name` and an `id`, which the `Person` struct holds.

```rust
#[derive(Serialize, Deserialize, Clone)]
pub struct PersonData {
    name: String,
}

#[derive(Serialize, Deserialize)]
pub struct Person {
    name: String,
    id: RecordId,
}
```

Each of these functions are pretty straightforward: obtain some user input, initiate a query, feed the user input into it, and return it as JSON.

```rust
const PERSON: &str = "person";

#[post("/person/{id}")]
pub async fn create_person(
    id: Path<String>,
    person: Json<PersonData>,
) -> Result<Json<Option<Person>>, Error> {
    let person = DB.create((PERSON, &*id)).content(person).await?;
    Ok(Json(person))
}

#[get("/person/{id}")]
pub async fn read_person(id: Path<String>) -> Result<Json<Option<Person>>, Error> {
    let person = DB.select((PERSON, &*id)).await?;
    Ok(Json(person))
}

#[put("/person/{id}")]
pub async fn update_person(
    id: Path<String>,
    person: Json<PersonData>,
) -> Result<Json<Option<Person>>, Error> {
    let person = DB.update((PERSON, &*id)).content(person).await?;
    Ok(Json(person))
}

#[delete("/person/{id}")]
pub async fn delete_person(id: Path<String>) -> Result<Json<Option<Person>>, Error> {
    let person = DB.delete((PERSON, &*id)).await?;
    Ok(Json(person))
}

#[get("/people")]
pub async fn list_people() -> Result<Json<Vec<Person>>, Error> {
    let people = DB.select(PERSON).await?;
    Ok(Json(people))
}
```

The `session()` function is also quite small, and is just a convenience for a user curious about the current session data. As the `.query()` method can take more than one statement, it returns each of these responses in order with an index for each (starting at 0). The `.take()` method can then be used to access the response at that index, and turn it into anything that can be deserialized back into a Rust type. In our case, a `String` is all we need here as the output will only be used to show the user the current session info.

```rust
pub async fn session() -> Result<Json<String>, Error> {
    let res: Option<String> = DB.query("RETURN <string>$session").await?.take(0)?;

    Ok(Json(res.unwrap_or("No session data found!".into())))
}
```

Two most interesting function is the one used to create a new record user. To make it really easy to try out the experience of logging in as a record user, this function will use create a random name and password each time it is accessed. It will then pass in a [`Record`](https://docs.rs/surrealdb/latest/surrealdb/opt/auth/struct.Record.html) struct which is used to sign up a new record user. Note the following:

* The access name is `"account"`, which is the name we chose in the `DEFINE ACCESS` statement above.
* The `params` field takes anything that implements `Serialize`, in this case a struct we put together called `Params`.
* The `.signup()` method returns a redacted `Jwt` by default. To make the token visible, you can use the `.into_insecure_token()` method as we have done here. As a small guide to getting started, this example is not concerned about security. However, if you are looking to create something more production-worthy, do take a look at the [security](/docs/surrealdb/security) section of the documentation and the [security best practices](/docs/surrealdb/reference-guide/security-best-practices) page.

The function will then end with an output showing the username, password, token, and instructions for how to log in using the CLI. This can be copied and pasted to begin making queries immediately.

```rust
#[derive(Serialize, Deserialize)]
struct Params<'a> {
    name: &'a str,
    pass: &'a str,
}

#[get("/new_user")]
pub async fn make_new_user() -> Result<String, Error> {
    let name = rand::random::<FirstName>().to_string();
    let pass = rand::random::<FirstName>().to_string();
    let jwt = DB
        .signup(Record {
            access: "account",
            namespace: "namespace",
            database: "database",
            params: Params {
                name: &name,
                pass: &pass,
            },
        })
        .await?
        .into_insecure_token();
    Ok(format!("New user created!\n\nName: {name}\nPassword: {pass}\nToken: {jwt}\n\nTo log in, use this command:\n\nsurreal sql --namespace namespace --database database --pretty --token \"{jwt}\""))
}
```

A record user with an expired token can use the `/signin` endpoint to get a new token. Since this requires passing in a username and password, we'll just have this function return a `String` that contains a curl example to get a new token.

```rust
#[get("/new_token")]
pub async fn get_new_token() -> String {
    let command = r#"curl -X POST -H "Accept: application/json" -d '{"ns":"namespace","db":"database","ac":"account","user":"your_username","pass":"your_password"}' http://localhost:8000/signin"#;
    format!("Need a new token? Use this command:\n\n{command}\n\nThen log in with surreal sql --namespace namespace --database database --pretty --token YOUR_TOKEN_HERE")
}
```

## Experimenting with the app

The final code looks like this:

```rust
use actix_web::{App, HttpServer};
use std::sync::LazyLock;
use surrealdb::engine::remote::ws::Client;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::Surreal;

static DB: LazyLock<Surreal<Client>> = LazyLock::new(Surreal::init);

mod error {
    use actix_web::{HttpResponse, ResponseError};
    use thiserror::Error;

    #[derive(Error, Debug)]
    pub enum Error {
        #[error("database error")]
        Db(String),
    }

    impl ResponseError for Error {
        fn error_response(&self) -> HttpResponse {
            match self {
                Error::Db(e) => HttpResponse::InternalServerError().body(e.to_string()),
            }
        }
    }

    impl From<surrealdb::Error> for Error {
        fn from(error: surrealdb::Error) -> Self {
            eprintln!("{error}");
            Self::Db(error.to_string())
        }
    }
}

mod routes {

    use faker_rand::en_us::names::FirstName;
    use surrealdb::opt::auth::Record;

    use crate::error::Error;
    use crate::DB;
    use actix_web::web::{Json, Path};
    use actix_web::{delete, get, post, put};
    use serde::{Deserialize, Serialize};
    use surrealdb::RecordId;
    const PERSON: &str = "person";

    #[derive(Serialize, Deserialize)]
    pub struct PersonData {
        name: String,
    }

    #[derive(Serialize, Deserialize)]
    pub struct Person {
        name: String,
        id: RecordId,
    }

    #[get("/")]
    pub async fn paths() -> &'static str {
        r#"

-----------------------------------------------------------------------------------------------------------------------------------------
        PATH                |           SAMPLE COMMAND                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------
/session: See session data  |  curl -X GET    -H "Content-Type: application/json"                          http://localhost:8080/session
                            |
/person/{id}:               |
  Create a person           |  curl -X POST   -H "Content-Type: application/json" -d '{"name":"John Doe"}' http://localhost:8080/person/one
  Get a person              |  curl -X GET    -H "Content-Type: application/json"                          http://localhost:8080/person/one
  Update a person           |  curl -X PUT    -H "Content-Type: application/json" -d '{"name":"Jane Doe"}' http://localhost:8080/person/one
  Delete a person           |  curl -X DELETE -H "Content-Type: application/json"                          http://localhost:8080/person/one
                            |
/people: List all people    |  curl -X GET    -H "Content-Type: application/json"                          http://localhost:8080/people

/new_user:  Create a new record user
/new_token: Get instructions for a new token if yours has expired"#
    }

    #[get("/session")]
    pub async fn session() -> Result<Json<String>, Error> {
        let res: Option<String> = DB.query("RETURN <string>$session").await?.take(0)?;

        Ok(Json(res.unwrap_or("No session data found!".into())))
    }

    #[post("/person/{id}")]
    pub async fn create_person(
        id: Path<String>,
        person: Json<PersonData>,
    ) -> Result<Json<Option<Person>>, Error> {
        let person = DB.create((PERSON, &*id)).content(person).await?;
        Ok(Json(person))
    }

    #[get("/person/{id}")]
    pub async fn read_person(id: Path<String>) -> Result<Json<Option<Person>>, Error> {
        let person = DB.select((PERSON, &*id)).await?;
        Ok(Json(person))
    }

    #[put("/person/{id}")]
    pub async fn update_person(
        id: Path<String>,
        person: Json<PersonData>,
    ) -> Result<Json<Option<Person>>, Error> {
        let person = DB.update((PERSON, &*id)).content(person).await?;
        Ok(Json(person))
    }

    #[delete("/person/{id}")]
    pub async fn delete_person(id: Path<String>) -> Result<Json<Option<Person>>, Error> {
        let person = DB.delete((PERSON, &*id)).await?;
        Ok(Json(person))
    }

    #[get("/people")]
    pub async fn list_people() -> Result<Json<Vec<Person>>, Error> {
        let people = DB.select(PERSON).await?;
        Ok(Json(people))
    }

    #[derive(Serialize, Deserialize)]
    struct Params<'a> {
        name: &'a str,
        pass: &'a str,
    }

    #[get("/new_user")]
    pub async fn make_new_user() -> Result<String, Error> {
        let name = rand::random::<FirstName>().to_string();
        let pass = rand::random::<FirstName>().to_string();
        let jwt = DB
            .signup(Record {
                access: "account",
                namespace: "namespace",
                database: "database",
                params: Params {
                    name: &name,
                    pass: &pass,
                },
            })
            .await?
            .into_insecure_token();
        Ok(format!("New user created!\n\nName: {name}\nPassword: {pass}\nToken: {jwt}\n\nTo log in, use this command:\n\nsurreal sql --namespace namespace --database database --pretty --token \"{jwt}\""))
    }

    #[get("/new_token")]
    pub async fn get_new_token() -> String {
        let command = r#"curl -X POST -H "Accept: application/json" -d '{"ns":"namespace","db":"database","ac":"account","user":"your_username","pass":"your_password"}' http://localhost:8000/signin"#;
        format!("Need a new token? Use this command:\n\n{command}\n\nThen log in with surreal sql --namespace namespace --database database --pretty --token YOUR_TOKEN_HERE")
    }
}

#[actix_web::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    DB.connect::<Ws>("localhost:8000").await?;

    DB.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    DB.use_ns("namespace").use_db("database").await?;

    DB.query(
        "DEFINE TABLE person SCHEMALESS
        PERMISSIONS FOR 
            CREATE, SELECT WHERE $auth,
            FOR UPDATE, DELETE WHERE created_by = $auth;
    DEFINE FIELD name ON TABLE person TYPE string;
    DEFINE FIELD created_by ON TABLE person VALUE $auth READONLY;

    DEFINE INDEX unique_name ON TABLE user FIELDS name UNIQUE;
    DEFINE ACCESS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 15m, FOR SESSION 12h
;",
    )
    .await?;

    HttpServer::new(|| {
        App::new()
            .service(routes::create_person)
            .service(routes::read_person)
            .service(routes::update_person)
            .service(routes::delete_person)
            .service(routes::list_people)
            .service(routes::paths)
            .service(routes::session)
            .service(routes::make_new_user)
            .service(routes::get_new_token)
    })
    .bind(("localhost", 8080))?
    .run()
    .await?;

    Ok(())
}
```

As the database client is logged in as a root user, the `/person/` routes can be used to perform any operation on the `person` records of the database.

You can also log in to the CLI or Surrealist as a root user and separately as a record user using the output of the `/new_user` endpoint to compare the experience between the two.

For example, the output when creating a `person` record as a root user will look like this:

```bash
test/test> CREATE person SET name = 'Aeon';
-- Query 1
[
	{
		id: person:hdl0unwts4atic65nh7l,
		name: 'Aeon'
	}
]
```

But as a record user, it will include a `created_by` field, set by the value found at the `$auth` paremeter.

```bash
test/test> CREATE person SET name = 'Aeon';
-- Query 1
[
	{
		created_by: user:qx2apv5oc8mh03wtah0q,
		id: person:8syfiq2ovztn2tbr8mhb,
		name: 'Aeon'
	}
]
```

As a result, a `DELETE person RETURN BEFORE` statement (which deletes all `person` records and returns the records deleted) used by a record user will only delete the single record that it created earlier. The following `SELECT` statement shows that the `person` record created by the root user cannot be deleted or modified by the record user.

```bash
test/test> DELETE person RETURN BEFORE;
-- Query 1
[
	{
		created_by: user:qx2apv5oc8mh03wtah0q,
		id: person:8y06y06jmmb7e58trckz,
		name: 'Aeon'
	}
]

test/test> SELECT * FROM person;
-- Query 1
[
	{
		id: person:hdl0unwts4atic65nh7l,
		name: 'Aeon'
	}
]

test/test> UPDATE person SET name = "Yogurt";
-- Query 1
[]
```

Also note that the root user is able to see the `user` tables and their information. A record user cannot, as a record user by default has no permissions except what it is given by the `PERMISSIONS` clause. If you create a record user using the `/new_user` endpoint, the root user will be able to view it. However, the password has been obscured by the `crypto::argon2::generate` function so that nobody else can use it.

```surql
[
	{
		id: user:qx2apv5oc8mh03wtah0q,
		name: 'Gerard',
		pass: '$argon2id$v=19$m=19456,t=2,p=1$j0ktTqUxRjOWYnwS5LoMFQ$2NcGkf5+IuLml6NorPy/Le6T8RppYXTXakwY5cDiZPY'
	}
]
```

## Further steps

Now that you have a running Actix server with SurrealDB as the backend, here are some other ideas that you might want to explore.

* Using the [`AUTHENTICATE`](/docs/surrealql/statements/define/access/record#example-failing-authentication) clause inside the `DEFINE ACCESS` statement. This will result in increased performance thanks to only being executed once, compared to permissions checks which are executed for each query.
* Adding some interesting behaviour to the database such as [changefeeds](/docs/surrealql/statements/define/table#example-usage) or [events](/docs/surrealql/statements/define/event).


================================================
FILE: src/content/doc-sdk-rust/frameworks/axum.mdx
================================================
---
sidebar_position: 3
sidebar_label: Axum
title: Rust | SDKs | Integration
description: The SDK for Rust allows SurrealDB to be used as the storage backend for an Axum web server
---

# SurrealDB with Axum

The following tutorial will set up a server with SurrealDB and [Axum](https://docs.rs/axum/latest/axum/) that has a few endpoints:

* Some endpoints to demonstrate how the HTTP endpoints work to create, select, modify etc. a `person` table in a database,
* Other endpoints to display some helpful info for the user,
* Two endpoints to allow signing up and signing in as a [record user](/docs/surrealql/statements/define/access/record).

## Getting started

First, open up a terminal window and use the following command to start an empty database.

```bash
surreal start --user root --pass secret
```

You can also use the [Start serving](/docs/surrealist/concepts/local-database-serving) button on [Surrealist](/docs/surrealist) to do the same if you have it installed locally.

The database initiated by the [surreal start](/docs/surrealdb/cli/start) command stores data in memory by default, which then disappears every time the database is shut down. As such, you can simply use Ctrl+C every time you want to start the database anew with no existing definitions or data. To save data to disk which will persist after shutting down, add a [positional argument](/docs/surrealdb/cli/start#positional-argument) for one of the storage backends such as `rocksdb://mydatabase` or `surrealkv://mydatabase` (or `surrealkv+versioned//mydatabase` to include SurrealKV versioning).

With the database running, we will now connect to the database "test" located in the namespace "test". You can connect to it by [creating a connection](/docs/surrealist/getting-started#creating-a-connection) inside Surrealist, or by using the following command to start an interactive shell.

```bash
surreal sql --user root --pass secret --ns test --db test --pretty
```

Next, create a new Rust project with the command `cargo new your_project_name`, go into the newly created directory, and use `cargo add` to add each of the following dependencies:

* `surrealdb` (of course),
* `axum`,
* `serde`, for serializing and deserializing Rust structs passed to and from the database and Axum,
* `tokio`, for the async runtime used by both Axum and SurrealDB,
* `thiserror`, to make it easy to convert between SurrealDB's error type, other errors and Axum's response types,
* `rand` and `faker_rand`, to create random user names that can be used to sign in to the database as a record user.

The `serde` crate will also need a feature flag for its `Serialize` and `Deserialize` macros. Your `cargo.toml` dependencies should look like this:

```
axum = "0.7.7"
faker_rand = "0.1.1"
rand = "0.8.5"
serde = { version = "1.0.209", features = ["derive"] }
surrealdb = "2.0.4"
thiserror = "1.0.64"
tokio = "1.40.0"
```

## Starting the Rust code

The first thing to do is a bit of groundwork to convert database errors into an error type of our own. Implementing `From<surrealdb::Error>` for this type will let it be used with the `?` operator when handling results. Finally, it will also need to implement Axum's `IntoResponse` trait so that it can be used as output for the server. All of this can be done manually if you prefer, but the `thiserror` crate saves a certain amount of typing.

```rust
mod error {
    use axum::http::StatusCode;
    use axum::response::IntoResponse;
    use axum::response::Response;
    use axum::Json;
    use thiserror::Error;

    #[derive(Error, Debug)]
    pub enum Error {
        #[error("database error")]
        Db,
    }

    impl IntoResponse for Error {
        fn into_response(self) -> Response {
            (StatusCode::INTERNAL_SERVER_ERROR, Json(self.to_string())).into_response()
        }
    }

    impl From<surrealdb::Error> for Error {
        fn from(error: surrealdb::Error) -> Self {
            eprintln!("{error}");
            Self::Db
        }
    }
}
```

Next, we will put the database client together. Axum provides a [`.with_state()`](https://docs.rs/axum/latest/axum/routing/struct.Router.html#method.with_state) method when starting a router that would give us access to the database inside its functions. However, for simplicity we can instead wrap the client inside a `LazyLock` to make it into a global static.

```rust
use std::sync::LazyLock;
static DB: LazyLock<Surreal<Client>> = LazyLock::new(Surreal::init);
```

Inside `main()`, we will do the following:

* Connect to the database running at `localhost:8000`
* Sign in as the root user that was created through the `surreal start` command
* Use (move to) the namespace "test" and database "test"
* Use the `.query()` method to pass in a few definitions for the database.

```rust
DB.connect::<Ws>("localhost:8000").await?;

DB.signin(Root {
    username: "root",
    password: "secret",
})
.await?;

DB.use_ns("test").use_db("test").await?;

DB.query(
    "
DEFINE TABLE IF NOT EXISTS person SCHEMALESS
    PERMISSIONS FOR 
        CREATE, SELECT WHERE $auth,
        FOR UPDATE, DELETE WHERE created_by = $auth;
DEFINE FIELD IF NOT EXISTS name ON TABLE person TYPE string;
DEFINE FIELD IF NOT EXISTS created_by ON TABLE person VALUE $auth READONLY;

DEFINE INDEX IF NOT EXISTS unique_name ON TABLE user FIELDS name UNIQUE;
DEFINE ACCESS IF NOT EXISTS account ON DATABASE TYPE RECORD
SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
DURATION FOR TOKEN 15m, FOR SESSION 12h
;",
)
.await?;
```

## What the database definitions do

The first item that stands out with the definitions above is that they all contain a `IF NOT EXISTS` clause. As the `DEFINE` statements will be executed every time the app starts, it is possible that they might be executed on a database that already has the definitions in place. Since version 2.0, SurrealDB simply returns an error if a definition already exists, requiring the `OVERWRITE` clause if a definition needs to be redone. Without `IF NOT EXISTS`, the message "The table 'person' already exists" will be returned.

Note that this would not affect our app, as this would still be a successful usage of the `.query()` method. Instead, its output would contain a number of error results that could be handled individually:

```
Response { client: Surreal { router: OnceLock(Router { sender: Sender { .. }, last_id: 4, features: {LiveQueries} }), engine: PhantomData<surrealdb::api::engine::any::Any> }, results: {0: (Stats { execution_time: Some(252.625µs) }, Err(Api(Query("The table 'person' already exists")))), 1: (Stats { execution_time: Some(79.167µs) }, Err(Api(Query("The field 'name' already exists")))), 2: (Stats { execution_time: Some(69.5µs) }, Err(Api(Query("The field 'created_by' already exists")))), 3: (Stats { execution_time: Some(73.625µs) }, Err(Api(Query("The index 'unique_name' already exists")))), 4: (Stats { execution_time: Some(73.583µs) }, Err(Api(Query("The access method 'account' already exists in the database 'test'"))))}, live_queries: {} }
```

However, adding `IF NOT EXISTS` is a nice way to change the results from errors into successful results, and to avoid the rare case in which they end up applied to some other version 1.x database that would rewrite its definitions if `IF NOT EXISTS` is present. So while not necessary in our case, it is a good practice to follow and makes for cleaner output.

Now let's go over each of the definitions to see what they do.

The first three statements define a `person` table. This table is schemaless, but has one required field `name`, which must be present and must be a string. This table has defined permissions by which a record user is able to use `CREATE` and `SELECT` on the `person` table, but can only `UPDATE` and `DELETE` records that it has created. The root user, however, is not subject to permissions rules.

The way these permissions are set is by using the `$auth` parameter. This parameter has a value whenever a record user is set as the authorized used for the database. The `WHERE $auth` clause simply means "where a value exists for the parameter `$auth`" (`WHERE $auth IS NOT NONE` would also work in this case). But for `UPDATE` and `DELETE` queries, it is not enough for `$auth` to just be present, the `created_by` field of a `person` record must also match the ID of the currently authenticated user.

This `created_by` field is automatically generated from its definition in the `DEFINE FIELD` statement. It is given the value of `$auth`, and is `READONLY` and thus cannot be changed. When logged in as a system user (like a root user), its value will be `NONE`. But when logged in as a record user, its value will be something like `user:qx2apv5oc8mh03wtah0q`.

```surql
DEFINE TABLE IF NOT EXISTS person SCHEMALESS
    PERMISSIONS FOR 
        CREATE, SELECT WHERE $auth,
        FOR UPDATE, DELETE WHERE created_by = $auth;
DEFINE FIELD IF NOT EXISTS name ON TABLE person TYPE string;
DEFINE FIELD IF NOT EXISTS created_by ON TABLE person VALUE $auth READONLY;
```

So where does an ID like `user:qx2apv5oc8mh03wtah0q` come from? This is thanks to the following definitions that set the signup and signin behaviour of the record users. A typical [`DEFINE ACCESS`](/docs/surrealql/statements/define/access/record) statement will create some sort of record on signup (in this case, a `user`) record, and will compare it against a password during signin. Note that the access has a name that we gave it (`account`), so that it can be referenced elsewhere.

In addition, a `DEFINE INDEX` statement with a `UNIQUE` clause is used to ensure that no two users can have the same name.

```surql
    DEFINE INDEX IF NOT EXISTS unique_name ON TABLE user FIELDS name UNIQUE;
    DEFINE ACCESS IF NOT EXISTS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 15m, FOR SESSION 12h
```

For an actual user in production, you would probably want to require an email and some other fields. Functions like [`string::is_email`](/docs/surrealql/functions/database/string#stringis_email) can be used to ensure that the value passed in is valid.

```surql
DEFINE FIELD email ON TABLE user TYPE string ASSERT $value.is_email();
```

However, for this simple example, each user will simply have a unique name and a password. The password will be stored in hashed and salted form on the database, making it unique and unreadable every time it is generated. The only way to check if it is correct is by using a [compare function](/docs/surrealql/functions/database/crypto#cryptoargon2compare) of the output with an attempted password. Here is a short SurrealQL sample to show how the process works.

```surql
LET $hash1 = crypto::argon2::generate("myPaSSWord");
LET $hash2 = crypto::argon2::generate("myPaSSWord");

RETURN [$hash1, $hash2];
-- First returns true, second returns false
RETURN [
    crypto::argon2::compare($hash1, "myPaSSWord")
    crypto::argon2::compare($hash1, "Wrongpassword")
];
```

## The rest of the code

The last step is where the majority of the work takes place: setting up the paths for Axum to handle, and writing the functions that handle the endpoints and (usually) access the database to handle the request. To start, we'll create a function for the `"/"` root path to display a helpful message to anybody giving the server a try via the browser or an app like curl or Postman. These paths and curl examples can all be seen on [the page for SurrealDB's HTTP endpoints](/docs/surrealdb/integration/http).

```rust
    pub async fn paths() -> &'static str {
        r#"
-----------------------------------------------------------------------------------------------------------------------------------------
        PATH                |           SAMPLE COMMAND                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------
/session: See session data  |  curl -X GET    -H "Content-Type: application/json"                      http://localhost:8080/session
                            |
/person/{id}:               |
  Create a person           |  curl -X POST   -H "Content-Type: application/json" -d '{"name":"John"}' http://localhost:8080/person/one
  Update a person           |  curl -X PUT    -H "Content-Type: application/json" -d '{"name":"Jane"}' http://localhost:8080/person/one
  Get a person              |  curl -X GET    -H "Content-Type: application/json"                      http://localhost:8080/person/one
  Delete a person           |  curl -X DELETE -H "Content-Type: application/json"                      http://localhost:8080/person/one
                            |
/people: List all people    |  curl -X GET    -H "Content-Type: application/json"                      http://localhost:8080/people

/new_user:  Create a new record user
/new_token: Get instructions for a new token if yours has expired"#
    }
```

Each of these functions will be put into a mod called `routes`, leading to the following code inside `main()`.

```rust
let listener = TcpListener::bind("localhost:8080").await?;
let router = Router::new()
    .route("/", get(routes::paths))
    .route("/person/:id", post(routes::create_person))
    .route("/person/:id", get(routes::read_person))
    .route("/person/:id", put(routes::update_person))
    .route("/person/:id", delete(routes::delete_person))
    .route("/people", get(routes::list_people))
    .route("/session", get(routes::session))
    .route("/new_user", get(routes::make_new_user))
    .route("/new_token", get(routes::get_new_token));
axum::serve(listener, router).await?;
```

Many functions require some JSON data from the user, which will be deserialized into a `PersonData` struct. The database can then use it in methods like `.create().content()`. The output returned will now have a `name` and an `id`, which the `Person` struct holds.

```rust
#[derive(Serialize, Deserialize, Clone)]
pub struct PersonData {
    name: String,
}

#[derive(Serialize, Deserialize)]
pub struct Person {
    name: String,
    id: RecordId,
}
```

Each of these functions are pretty straightforward: obtain some user input, initiate a query, feed the user input into it, and return it as JSON.

```rust
    const PERSON: &str = "person";

    pub async fn create_person(
        id: Path<String>,
        Json(person): Json<PersonData>,
    ) -> Result<Json<Option<Person>>, Error> {
        let person = DB.create((PERSON, &*id)).content(person).await?;
        Ok(Json(person))
    }

    pub async fn read_person(id: Json<String>) -> Result<Json<Option<Person>>, Error> {
        let person = DB.select((PERSON, &*id)).await?;
        Ok(Json(person))
    }

    pub async fn update_person(
        id: Path<String>,
        Json(person): Json<PersonData>,
    ) -> Result<Json<Option<Person>>, Error> {
        let person = DB.update((PERSON, &*id)).content(person).await?;
        Ok(Json(person))
    }

    pub async fn delete_person(id: String) -> Result<Json<Option<Person>>, Error> {
        let person = DB.delete((PERSON, &*id)).await?;
        Ok(Json(person))
    }

    pub async fn list_people() -> Result<Json<Vec<Person>>, Error> {
        let people = DB.select(PERSON).await?;
        Ok(Json(people))
    }
```

The `session()` function is also quite small, and is just a convenience for a user curious about the current session data. As the `.query()` method can take more than one statement, it returns each of these responses in order with an index for each (starting at 0). The `.take()` method can then be used to access the response at that index, and turn it into anything that can be deserialized back into a Rust type. In our case, a `String` is all we need here as the output will only be used to show the user the current session info.

```rust
pub async fn session() -> Result<Json<String>, Error> {
    let res: Option<String> = DB.query("RETURN <string>$session").await?.take(0)?;

    Ok(Json(res.unwrap_or("No session data found!".into())))
}
```

Two most interesting function is the one used to create a new record user. To make it really easy to try out the experience of logging in as a record user, this function will use create a random name and password each time it is accessed. It will then pass in a [`Record`](https://docs.rs/surrealdb/latest/surrealdb/opt/auth/struct.Record.html) struct which is used to sign up a new record user. Note the following:

* The access name is `"account"`, which is the name we chose in the `DEFINE ACCESS` statement above.
* The `params` field takes anything that implements `Serialize`, in this case a struct we put together called `Params`.
* The `.signup()` method returns a redacted `Jwt` by default. To make the token visible, you can use the `.into_insecure_token()` method as we have done here. As a small guide to getting started, this example is not concerned about security. However, if you are looking to create something more production-worthy, do take a look at the [security](/docs/surrealdb/security) section of the documentation and the [security best practices](/docs/surrealdb/reference-guide/security-best-practices) page.

The function will then end with an output showing the username, password, token, and instructions for how to log in using the CLI. This can be copied and pasted to begin making queries immediately.

```rust
#[derive(Serialize, Deserialize)]
struct Params<'a> {
    name: &'a str,
    pass: &'a str,
}

pub async fn make_new_user() -> Result<String, Error> {
    let name = rand::random::<FirstName>().to_string();
    let pass = rand::random::<FirstName>().to_string();
    let jwt = DB
        .signup(Record {
            access: "account",
            namespace: "test",
            database: "test",
            params: Params {
                name: &name,
                pass: &pass,
            },
        })
        .await?
        .into_insecure_token();
    Ok(format!("New user created!\n\nName: {name}\nPassword: {pass}\nToken: {jwt}\n\nTo log in, use this command:\n\nsurreal sql --ns test --db test --pretty --token \"{jwt}\""))
}
```

A record user with an expired token can use the `/signin` endpoint to get a new token. Since this requires passing in a username and password, we'll just have this function return a `String` that contains a curl example to get a new token.

```rust
    pub async fn get_new_token() -> String {
        let command = r#"curl -X POST -H "Accept: application/json" -d '{"ns":"test","db":"test","ac":"account","user":"your_username","pass":"your_password"}' http://localhost:8000/signin"#;
        format!("Need a new token? Use this command:\n\n{command}\n\nThen log in with surreal sql --ns test --db test --pretty --token YOUR_TOKEN_HERE")
    }
```

## Experimenting with the app

The final code looks like this:

```rust
use std::sync::LazyLock;
use axum::{Router, routing::{delete, get, post, put}};
use surrealdb::{Surreal, engine::remote::ws::{Client, Ws}, opt::auth::Root};
use tokio::net::TcpListener;

static DB: LazyLock<Surreal<Client>> = LazyLock::new(Surreal::init);

mod error {
    use axum::http::StatusCode;
    use axum::response::IntoResponse;
    use axum::response::Response;
    use axum::Json;
    use thiserror::Error;

    #[derive(Error, Debug)]
    pub enum Error {
        #[error("database error")]
        Db,
    }

    impl IntoResponse for Error {
        fn into_response(self) -> Response {
            (StatusCode::INTERNAL_SERVER_ERROR, Json(self.to_string())).into_response()
        }
    }

    impl From<surrealdb::Error> for Error {
        fn from(error: surrealdb::Error) -> Self {
            eprintln!("{error}");
            Self::Db
        }
    }
}

mod routes {
    use crate::error::Error;
    use crate::DB;

    use axum::{extract::Path, Json};
    use faker_rand::en_us::names::FirstName;
    use surrealdb::{RecordId, opt::auth::Record};
    use serde::{Deserialize, Serialize};

    const PERSON: &str = "person";

    #[derive(Serialize, Deserialize, Clone)]
    pub struct PersonData {
        name: String,
    }

    #[derive(Serialize, Deserialize)]
    pub struct Person {
        name: String,
        id: RecordId,
    }

    pub async fn paths() -> &'static str {
        r#"
-----------------------------------------------------------------------------------------------------------------------------------------
        PATH                |           SAMPLE COMMAND                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------
/session: See session data  |  curl -X GET    -H "Content-Type: application/json"                      http://localhost:8080/session
                            |
/person/{id}:               |
  Create a person           |  curl -X POST   -H "Content-Type: application/json" -d '{"name":"John"}' http://localhost:8080/person/one
  Update a person           |  curl -X PUT    -H "Content-Type: application/json" -d '{"name":"Jane"}' http://localhost:8080/person/one
  Get a person              |  curl -X GET    -H "Content-Type: application/json"                      http://localhost:8080/person/one
  Delete a person           |  curl -X DELETE -H "Content-Type: application/json"                      http://localhost:8080/person/one
                            |
/people: List all people    |  curl -X GET    -H "Content-Type: application/json"                      http://localhost:8080/people

/new_user:  Create a new record user
/new_token: Get instructions for a new token if yours has expired"#
    }

    pub async fn session() -> Result<Json<String>, Error> {
        let res: Option<String> = DB.query("RETURN <string>$session").await?.take(0)?;

        Ok(Json(res.unwrap_or("No session data found!".into())))
    }

    pub async fn create_person(
        id: Path<String>,
        Json(person): Json<PersonData>,
    ) -> Result<Json<Option<Person>>, Error> {
        let person = DB.create((PERSON, &*id)).content(person).await?;
        Ok(Json(person))
    }

    pub async fn read_person(id: Path<String>) -> Result<Json<Option<Person>>, Error> {
        let person = DB.select((PERSON, &*id)).await?;
        Ok(Json(person))
    }

    pub async fn update_person(
        id: Path<String>,
        Json(person): Json<PersonData>,
    ) -> Result<Json<Option<Person>>, Error> {
        let person = DB.update((PERSON, &*id)).content(person).await?;
        Ok(Json(person))
    }

    pub async fn delete_person(id: Path<String>) -> Result<Json<Option<Person>>, Error> {
        let person = DB.delete((PERSON, &*id)).await?;
        Ok(Json(person))
    }

    pub async fn list_people() -> Result<Json<Vec<Person>>, Error> {
        let people = DB.select(PERSON).await?;
        Ok(Json(people))
    }

    #[derive(Serialize, Deserialize)]
    struct Params<'a> {
        name: &'a str,
        pass: &'a str,
    }

    pub async fn make_new_user() -> Result<String, Error> {
        let name = rand::random::<FirstName>().to_string();
        let pass = rand::random::<FirstName>().to_string();
        let jwt = DB
            .signup(Record {
                access: "account",
                namespace: "test",
                database: "test",
                params: Params {
                    name: &name,
                    pass: &pass,
                },
            })
            .await?
            .into_insecure_token();
        Ok(format!("New user created!\n\nName: {name}\nPassword: {pass}\nToken: {jwt}\n\nTo log in, use this command:\n\nsurreal sql --ns test --db test --pretty --token \"{jwt}\""))
    }

    pub async fn get_new_token() -> String {
        let command = r#"curl -X POST -H "Accept: application/json" -d '{"ns":"test","db":"test","ac":"account","user":"your_username","pass":"your_password"}' http://localhost:8000/signin"#;
        format!("Need a new token? Use this command:\n\n{command}\n\nThen log in with surreal sql --ns test --db test --pretty --token YOUR_TOKEN_HERE")
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    DB.connect::<Ws>("localhost:8000").await?;

    DB.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    DB.use_ns("test").use_db("test").await?;

    DB.query(
        "
    DEFINE TABLE IF NOT EXISTS person SCHEMALESS
        PERMISSIONS FOR 
            CREATE, SELECT WHERE $auth,
            FOR UPDATE, DELETE WHERE created_by = $auth;
    DEFINE FIELD IF NOT EXISTS name ON TABLE person TYPE string;
    DEFINE FIELD IF NOT EXISTS created_by ON TABLE person VALUE $auth READONLY;

    DEFINE INDEX IF NOT EXISTS unique_name ON TABLE user FIELDS name UNIQUE;
    DEFINE ACCESS IF NOT EXISTS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 15m, FOR SESSION 12h
;",
    )
    .await?;

    let listener = TcpListener::bind("localhost:8080").await?;
    let router = Router::new()
        .route("/", get(routes::paths))
        .route("/person/:id", post(routes::create_person))
        .route("/person/:id", get(routes::read_person))
        .route("/person/:id", put(routes::update_person))
        .route("/person/:id", delete(routes::delete_person))
        .route("/people", get(routes::list_people))
        .route("/session", get(routes::session))
        .route("/new_user", get(routes::make_new_user))
        .route("/new_token", get(routes::get_new_token));
    axum::serve(listener, router).await?;
    Ok(())
}
```

As the database client is logged in as a root user, the `/person/` routes can be used to perform any operation on the `person` records of the database.

You can also log in to the CLI or Surrealist as a root user and separately as a record user using the output of the `/new_user` endpoint to compare the experience between the two.

For example, the output when creating a `person` record as a root user will look like this:

```bash
test/test> CREATE person SET name = 'Aeon';
-- Query 1
[
	{
		id: person:hdl0unwts4atic65nh7l,
		name: 'Aeon'
	}
]
```

But as a record user, it will include a `created_by` field, set by the value found at the `$auth` paremeter.

```bash
test/test> CREATE person SET name = 'Aeon';
-- Query 1
[
	{
		created_by: user:qx2apv5oc8mh03wtah0q,
		id: person:8syfiq2ovztn2tbr8mhb,
		name: 'Aeon'
	}
]
```

As a result, a `DELETE person RETURN BEFORE` statement (which deletes all `person` records and returns the records deleted) used by a record user will only delete the single record that it created earlier. The following `SELECT` statement shows that the `person` record created by the root user cannot be deleted or modified by the record user.

```bash
test/test> DELETE person RETURN BEFORE;
-- Query 1
[
	{
		created_by: user:qx2apv5oc8mh03wtah0q,
		id: person:8y06y06jmmb7e58trckz,
		name: 'Aeon'
	}
]

test/test> SELECT * FROM person;
-- Query 1
[
	{
		id: person:hdl0unwts4atic65nh7l,
		name: 'Aeon'
	}
]

test/test> UPDATE person SET name = "Yogurt";
-- Query 1
[]
```

Also note that the root user is able to see the `user` tables and their information. A record user cannot, as a record user by default has no permissions except what it is given by the `PERMISSIONS` clause. If you create a record user using the `/new_user` endpoint, the root user will be able to view it. However, the password has been obscured by the `crypto::argon2::generate` function so that nobody else can use it.

```surql
[
	{
		id: user:qx2apv5oc8mh03wtah0q,
		name: 'Gerard',
		pass: '$argon2id$v=19$m=19456,t=2,p=1$j0ktTqUxRjOWYnwS5LoMFQ$2NcGkf5+IuLml6NorPy/Le6T8RppYXTXakwY5cDiZPY'
	}
]
```

## Further steps

Now that you have a running Axum server with SurrealDB as the backend, here are some other ideas that you might want to explore.

* Using the [`AUTHENTICATE`](/docs/surrealql/statements/define/access/record#example-failing-authentication) clause inside the `DEFINE ACCESS` statement. This will result in increased performance thanks to only being executed once, compared to permissions checks which are executed for each query.
* Adding some interesting behaviour to the database such as [changefeeds](/docs/surrealql/statements/define/table#example-usage) or [events](/docs/surrealql/statements/define/event).


================================================
FILE: src/content/doc-sdk-rust/frameworks/egui.mdx
================================================
---
sidebar_position: 4
sidebar_label: Egui
title: Rust | SDKs | Integration
description: The SDK for Rust allows SurrealDB to be used as the storage backend for an Egui visual app
---

# SurrealDB with Egui

The following tutorial will set up a small app with Egui that uses SurrealDB as its database.

## Getting started

First, open up a terminal window and use the following command to start an empty database.

```bash
surreal start --user root --pass secret
```

You can also use the [Start serving](/docs/surrealist/concepts/local-database-serving) button on [Surrealist](/docs/surrealist) to do the same if you have it installed locally.

The database initiated by the [surreal start](/docs/surrealdb/cli/start) command stores data in memory by default, which then disappears every time the database is shut down. As such, you can simply use Ctrl+C every time you want to start the database anew with no existing definitions or data. To save data to disk which will persist after shutting down, add a [positional argument](/docs/surrealdb/cli/start#positional-argument) for one of the storage backends such as `rocksdb://mydatabase` or `surrealkv://mydatabase` (or `surrealkv+versioned//mydatabase` to include SurrealKV versioning).

With the database running, it's time to start setting up the Rust code.

## Starting the Rust code

First create a new Rust project with the command `cargo new your_project_name`, go into the newly created directory, and use `cargo add` to add each of the following dependencies:

* `anyhow`, to allow us to not worry about how to handle different error types,
* `egui` and its framework `eframe`,
* `rand` and `faker_rand`, to create random user names that can be used to sign in to the database as a record user,
* `serde` and `serde_json`, for serializing and deserializing Rust structs passed to and from the database and Egui,
* `tokio`, for the async runtime that SurrealDB uses.

The `serde` crate will need the `derive` flag enabled, and `tokio` will need the `rt` flag enabled as well. Your `cargo.toml` dependencies should look like this:

```
anyhow = "1.0.91"
eframe = "0.29.1"
egui = "0.29.1"
faker_rand = "0.1.1"
rand = "0.8.5"
serde = { version = "1.0.209", features = ["derive"] }
serde_json = "1.0.132"
surrealdb = "2.0.4"
tokio = { version = "1.41.0", features = ["rt"] }
```

Before we get around to the Egui frontend, let's set up the database.

SurrealDB's Rust crate uses async code, and while usually you will see an `async fn main()` with a `#[tokio::main]` attribute on top in SurrealDB examples, Egui does not use async. To isolate one from the other, we can create the tokio runtime manually and call `.block_on()` to isolate the database in its own space. Later one, we will create two [channels](https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html) to communicate between the database and the Egui app.

Inside `main()`, we will do the following:

* Connect to the database running at `localhost:8000`
* Sign in as the root user that was created through the `surreal start` command
* Use (move to) the namespace "test" and database "test"
* Use the `.query()` method to pass in a few definitions for the database.

```rust
fn main() -> Result<(), Error> {
    let rt = tokio::runtime::Runtime::new()?;

    let _: Result<(), Error> = rt.block_on(async {

            let db = Surreal::new::<Ws>("localhost:8000").await?;

            db.signin(Root {
                username: "root",
                password: "secret",
            })
            .await?;

            db.use_ns("test").use_db("test").await?;

            db.query(
                "    DEFINE TABLE person SCHEMALESS
                PERMISSIONS FOR
                    CREATE, SELECT WHERE $auth,
                    FOR UPDATE, DELETE WHERE created_by = $auth;
            DEFINE FIELD name ON TABLE person TYPE string;
            DEFINE FIELD created_by ON TABLE person VALUE $auth READONLY;

            DEFINE INDEX unique_name ON TABLE user FIELDS name UNIQUE;
            DEFINE ACCESS account ON DATABASE TYPE RECORD
            SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
            SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
            DURATION FOR TOKEN 15m, FOR SESSION 12h
        ;",
            )
            .await?;
        Ok(())
        });
    Ok(())
}
```

## What the database definitions do

The first item that stands out with the definitions above is that they all contain a `IF NOT EXISTS` clause. As the `DEFINE` statements will be executed every time the app starts, it is possible that they might be executed on a database that already has the definitions in place. Since version 2.0, SurrealDB simply returns an error if a definition already exists, requiring the `OVERWRITE` clause if a definition needs to be redone. Without `IF NOT EXISTS`, the message "The table 'person' already exists" will be returned.

Note that this would not affect our app, as this would still be a successful usage of the `.query()` method. Instead, its output would contain a number of error results that could be handled individually:

```
Response { client: Surreal { router: OnceLock(Router { sender: Sender { .. }, last_id: 4, features: {LiveQueries} }), engine: PhantomData<surrealdb::api::engine::any::Any> }, results: {0: (Stats { execution_time: Some(252.625µs) }, Err(Api(Query("The table 'person' already exists")))), 1: (Stats { execution_time: Some(79.167µs) }, Err(Api(Query("The field 'name' already exists")))), 2: (Stats { execution_time: Some(69.5µs) }, Err(Api(Query("The field 'created_by' already exists")))), 3: (Stats { execution_time: Some(73.625µs) }, Err(Api(Query("The index 'unique_name' already exists")))), 4: (Stats { execution_time: Some(73.583µs) }, Err(Api(Query("The access method 'account' already exists in the database 'test'"))))}, live_queries: {} }
```

However, adding `IF NOT EXISTS` is a nice way to change the results from errors into successful results, and to avoid the rare case in which they end up applied to some other version 1.x database that would rewrite its definitions if `IF NOT EXISTS` is present. So while not necessary in our case, it is a good practice to follow and makes for cleaner output.

Now let's go over each of the definitions to see what they do.

The first three statements define a `person` table. This table is schemaless, but has one required field `name`, which must be present and must be a string. This table has defined permissions by which a record user is able to use `CREATE` and `SELECT` on the `person` table, but can only `UPDATE` and `DELETE` records that it has created. The root user, however, is not subject to permissions rules.

The way these permissions are set is by using the `$auth` parameter. This parameter has a value whenever a record user is set as the authorized used for the database. The `WHERE $auth` clause simply means "where a value exists for the parameter `$auth`" (`WHERE $auth IS NOT NONE` would also work in this case). But for `UPDATE` and `DELETE` queries, it is not enough for `$auth` to just be present, the `created_by` field of a `person` record must also match the ID of the currently authenticated user.

This `created_by` field is automatically generated from its definition in the `DEFINE FIELD` statement. It is given the value of `$auth`, and is `READONLY` and thus cannot be changed. When logged in as a system user (like a root user), its value will be `NONE`. But when logged in as a record user, its value will be something like `user:qx2apv5oc8mh03wtah0q`.

```surql
DEFINE TABLE IF NOT EXISTS person SCHEMALESS
    PERMISSIONS FOR 
        CREATE, SELECT WHERE $auth,
        FOR UPDATE, DELETE WHERE created_by = $auth;
DEFINE FIELD IF NOT EXISTS name ON TABLE person TYPE string;
DEFINE FIELD IF NOT EXISTS created_by ON TABLE person VALUE $auth READONLY;
```

So where does an ID like `user:qx2apv5oc8mh03wtah0q` come from? This is thanks to the following definitions that set the signup and signin behaviour of the record users. A typical [`DEFINE ACCESS`](/docs/surrealql/statements/define/access/record) statement will create some sort of record on signup (in this case, a `user`) record, and will compare it against a password during signin. Note that the access has a name that we gave it (`account`), so that it can be referenced elsewhere.

In addition, a `DEFINE INDEX` statement with a `UNIQUE` clause is used to ensure that no two users can have the same name.

```surql
    DEFINE INDEX IF NOT EXISTS unique_name ON TABLE user FIELDS name UNIQUE;
    DEFINE ACCESS IF NOT EXISTS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 15m, FOR SESSION 12h
```

For an actual user in production, you would probably want to require an email and some other fields. Functions like [`string::is_email`](/docs/surrealql/functions/database/string#stringis_email) can be used to ensure that the value passed in is valid.

```surql
DEFINE FIELD email ON TABLE user TYPE string ASSERT $value.is_email();
```

However, for this simple example, each user will simply have a unique name and a password. The password will be stored in hashed and salted form on the database, making it unique and unreadable every time it is generated. The only way to check if it is correct is by using a [compare function](/docs/surrealql/functions/database/crypto#cryptoargon2compare) of the output with an attempted password. Here is a short SurrealQL sample to show how the process works.

```surql
LET $hash1 = crypto::argon2::generate("myPaSSWord");
LET $hash2 = crypto::argon2::generate("myPaSSWord");

RETURN [$hash1, $hash2];
-- First returns true, second returns false
RETURN [
    crypto::argon2::compare($hash1, "myPaSSWord")
    crypto::argon2::compare($hash1, "Wrongpassword")
];
```

## The Egui code

### The Database struct

We are now at the point where the majority of the work takes place: creating the actual app and a way for it to interact with the database.

To keep the code to a minimum, our app will be as simple as possible. It will have a few buttons, a panel to take user input, and a second panel to display results. The buttons will be as follows:

* `Create person`: Instructs the database to try to create a `person` record based on the input provided by the user.
* `Delete person`: Deletes all the `person` records if the user input is left blank, otherwise will take a single id.
* `List people`: Shows all the `person` records in the database.
* `Session data`: Shows the current session data.
* `Raw query`: Allows the user to execute a raw query.
* `New user`: Creates a new record user with a random name and password, displayed as an object.
* `Sign in as record user`: Signs in using an object with a name and a password. The `New user` output can be pasted in to sign in here.
* `Sign in as root`: Signs back in as the database root user.

The behaviour of an Egui app takes place inside a single [.update()](https://docs.rs/eframe/latest/eframe/trait.App.html#tymethod.update), which takes a mutable reference to the app (usually a struct).

Because this function can be called up to several times per second, waiting for even short database queries might have noticeable effects on the repainting of the app. To ensure that this won't happen, we will create two channels between the Egui app and the database. The first channel will send commands from the app to the database, while the second channel will send each response back as a simple `String`. The database will loop continuously as it checks for commands, while the app will check for responses during every iteration of the `.update()` function.

Here are the two apps and the types used to communicate with each other.

```rust
struct SurrealDbApp {
    input: String,
    results: String,
    command_sender: Sender<Command>,
    response_receiver: Receiver<String>,
}

struct Database {
    client: Surreal<Client>,
    command_receiver: Receiver<Command>,
    response_sender: Sender<String>,
}

#[derive(Debug, Clone)]
enum Command {
    CreatePerson(String),
    DeletePerson(String),
    ListPeople,
    RawQuery(String),
    SignUp,
    SignIn(String),
    SignInRoot,
    Session,
}
```

Egui has some sample code [here](https://docs.rs/eframe/latest/eframe/#usage-native) on how to start running an app that we can copy and paste, only changing the name. Here is what the `main()` portion of the final code will look like.

```rust
fn main() -> Result<(), Error> {
    let (command_sender, command_receiver) = channel();
    let (response_sender, response_receiver) = channel();

    std::thread::spawn(|| -> Result<(), Error> {
        let rt = tokio::runtime::Runtime::new()?;

        rt.block_on(async {

            let client = Surreal::new::<Ws>("localhost:8000").await?;

            let db = Database {
                client,
                command_receiver,
                response_sender
            };

            db.signin(Root {
                username: "root",
                password: "secret",
            })
            .await?;

            db.use_ns("test").use_db("test").await?;

            db.query(
                "    DEFINE TABLE person SCHEMALESS
                PERMISSIONS FOR
                    CREATE, SELECT WHERE $auth,
                    FOR UPDATE, DELETE WHERE created_by = $auth;
            DEFINE FIELD name ON TABLE person TYPE string;
            DEFINE FIELD created_by ON TABLE person VALUE $auth READONLY;

            DEFINE INDEX unique_name ON TABLE user FIELDS name UNIQUE;
            DEFINE ACCESS account ON DATABASE TYPE RECORD
            SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
            SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
            DURATION FOR TOKEN 15m, FOR SESSION 12h
        ;",
            )
            .await?;

        loop {
            if let Ok(command) = db.command_receiver.try_recv() {
                match db.handle_command(command).await {
                    Ok(s) => db.response_sender.send(s)?,
                    Err(e) => db.response_sender.send(e.to_string())?
                }
            }
        }
        })
    });

    let app = SurrealDbApp {
        input: String::new(),
        results: String::new(),
        command_sender,
        response_receiver,
    };

    let native_options = eframe::NativeOptions::default();
    let _ = eframe::run_native(
        "SurrealDB App",
        native_options,
        Box::new(|_cc| Ok(Box::new(app))),
    );
    Ok(())
}
```

The database calls a function called `.handle_command()` every time it receives a command, so let's take a look at that one. It uses a simple `match` statement and executes database queries depending on what it is asked to do.

We'll start with some notable parts of the `.handle_command()` function and related code.

First we have two pieces of code added for convenience. One implements `Deref` so that the `Database` struct can call methods like `.create()` instead of `.client.create()`. The other is a helper trait so that we can call `.string()` after each method that returns an `Option<Person>` instead of having to use a `match` statement every time. There is also a `const` declared with `const PERSON: &str = "person"` that removes the possibility of typos inside the various query methods.

```rust
impl Deref for Database {
    type Target = Surreal<Client>;

    fn deref(&self) -> &Self::Target {
        &self.client
    }
}

trait StringIt {
    fn string(self) -> Result<String, Error>;
}

impl StringIt for Option<Person> {
    fn string(self) -> Result<String, Error> {
        match self {
            Some(t) => Ok(format!("{t:?}")),
            None => Ok("[]".into()),
        }
    }
}

const PERSON: &str = "person";
```

When the `.handle_command()` method comes across a `Command::CreatePerson`, which contains a `String`, it will attempt to turn it into this `PersonData` struct.

```rust
#[derive(Serialize, Deserialize, Clone, Default)]
pub struct PersonData {
    name: String,
    id: Option<String>,
}
```

This can be done using the `serde_json::from_str()` function. If the input is properly formatted, such as `{ "name": "Billy" }`, it will deserialize into a `PersonData` that can then be passed into the `.create()` function. The helper function `.string()` will then pass it back as an `Ok` with the `String` data inside if successful.

For simplicity, data passed in will only ever deserialize into a `Person` app with three fields: a name, a record Id, and a possible `created_by` field which will have a value if the `person` record is created by a record user.

```rust
#[derive(Serialize, Deserialize, Debug)]
pub struct Person {
    name: String,
    id: RecordId,
    created_by: Option<RecordId>,
}

Command::CreatePerson(s) => {
    let person_data: PersonData = serde_json::from_str(&s)?;
    self.create::<Option<Person>>(PERSON)
        .content(person_data)
        .await?
        .string()
}
```

For the `Command::DeletePerson` variant, a check is made to see whether the user input is empty, in which case it will delete every `person` record. Otherwise, it will assume that the input is the key of a record ID (like the `one` in `person:one`) and delete that record if it exists.

```rust
Command::DeletePerson(s) => {
    if s.is_empty() {
        let res: Vec<Person> = self.delete(PERSON).await?;
        Ok(format!("{res:?}"))
    } else {
        let key = RecordIdKey::from(s);
        self.delete::<Option<Person>>((PERSON, key)).await?.string()
    }
}
```

The other three query methods are pretty simple. `Command::ListPeople` returns all `person` records, `Command::RawQuery` takes a direct SurrealQL input and returns the result, and `Command::Session` just accesses the `$session` parameter cast into a string.

```rust
Command::ListPeople => {
    let person: Vec<Person> = self.select(PERSON).await?;
    Ok(format!("{person:?}"))
}
Command::RawQuery(q) => match self.query(q).await {
    Ok(ok) => Ok(format!("{ok:?}")),
    Err(e) => Ok(e.to_string()),
},
Command::Session => Ok(self
    .query("RETURN <string>$session")
    .await?
    .take::<Option<String>>(0)?
    .unwrap_or("No session data found!".into()))
```

The `Command::SignUp` and `Command::SignIn` variants are a bit more interesting.

A user is allowed to choose a name and a password when signing up as a record user, but to make the process as quick as possible we will use the `faker_rand` crate to generate two names: one for the username and one for the password.

The [`.signup()`](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.signup) method actually returns a token (a [`JWT`](https://docs.rs/surrealdb/latest/surrealdb/opt/auth/struct.Jwt.html) struct) that can [display the actual token](https://docs.rs/surrealdb/latest/surrealdb/opt/auth/struct.Jwt.html#method.as_insecure_token) if preferred, but these tokens are mostly useful when signing in via the [surreal sql](/docs/surrealdb/cli/sql) command or through Surrealist. In our case, we can simply use the `.signin()` method along with a name and password and so we don't need to display the token.

The `Params` struct is our own struct, which holds a `name` and a `pass` field because those are the two fields that we specified in the `DEFINE ACCESS` statement which creates a new `user` record every time a record user is signed up. Similarly, the `access` field inside `.signup()` takes the input "account" because that is the name that we have to the `DEFINE ACCESS` statement.

```rust
// DEFINE ACCESS account ON DATABASE TYPE RECORD
// SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
// SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
// DURATION FOR TOKEN 15m, FOR SESSION 12h

#[derive(Serialize, Deserialize)]
struct Params<'a> {
    name: &'a str,
    pass: &'a str,
}

Command::SignUp => {
    let name = rand::random::<FirstName>().to_string();
    let pass = rand::random::<FirstName>().to_string();
    self.signup(Record {
        access: "account",
        namespace: "test",
        database: "test",
        params: Params {
            name: &name,
            pass: &pass,
        },
    })
    .await?;
    Ok(format!(
        "New user created!\n\n{{ \"name\": \"{name}\", \n \"pass\": \"{pass}\" }}"
    ))
}
```

The output when the button is clicked to sign up a new user is in `JSON` format so that the user can copy and paste it to sign in.

```
New user created!

{ "name": "Rebecca", 
 "pass": "Neha" }
```

Signing in is pretty similar, except that it begins by trying to deserialize the user input into a `Params` struct. The `.signin()` method also returns a `Jwt` that we don't need, so the output will just let the user know that it has signed in under a certain name.

```rust
Command::SignIn(s) => {
    let Ok(Params { name, pass }) = serde_json::from_str::<Params>(&s) else {
        return Ok("Params don't work!".to_string());
    };
    self.signin(Record {
        access: "account",
        namespace: "test",
        database: "test",
        params: Params { name, pass },
    })
    .await?;
    Ok(format!("Signed in as {name}!"))
}
```

The last command will allow the user to sign back in as the root user. To make it easy to experiment with the database as a record user vs. a root user, we won't make the user type in the root user's name and password each time.

```rust
Command::SignInRoot => {
    self.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;
    Ok(format!("Back to root!"))
}
```

### The Egui app struct

The struct for the Egui app is quite simple, with only four fields. Two of them hold the user input and database results, which will be displayed on the screen at all times. The other two fields are for the sending and receiving end of the two channels.

```rust
struct SurrealDbApp {
    input: String,
    results: String,
    command_sender: Sender<Command>,
    response_receiver: Receiver<String>,
}
```

Since the [`.send()`](https://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html#method.send) function for channels in Rust returns a `Result` but Egui's `.update()` function doesn't, we'll save ourselves a lot of typing by putting together a quick method for this struct called `.send()` that does the error handling. All it will do is turn any errors into a `String` which it will then give to the `results` field.

```rust
impl SurrealDbApp {
    fn send(&mut self, command: Command) {
        if let Err(e) = self.command_sender.send(command) {
            self.results = e.to_string()
        }
    }
}
```

After that, the final task left to us is to create the layout and buttons for the Egui app inside the `update()` function that all Egui app structs are required to implement. The first line will be the one where the app checks to see if the database has sent it a message. All of these messages are simple Strings, so it will just set the `results` field with them so the user can see what was sent. Note that the `Ok` here just means that `.try_recv()` has successfully received a message, not that the database has succeeded at what it was instructed to do. The `String` might contain successful data, or an error message.

```rust
if let Ok(response) = self.response_receiver.try_recv() {
    self.results = response;
}
```

After this come the buttons. The [`SidePanel::left()`](https://docs.rs/egui/latest/egui/containers/panel/struct.SidePanel.html) will create a panel on the left side of the screen inside which we can add the buttons. If the button is clicked, the app will send off a command that may or might not include the data from the `input` field.

```rust
egui::SidePanel::left("left").show(ctx, |ui| {
    if let Ok(response) = self.response_receiver.try_recv() {
        self.results = response;
    }
    if ui.button("Create person").clicked() {
        self.send(Command::CreatePerson(self.input.clone()))
    };
    if ui.button("Delete person").clicked() {
        self.send(Command::DeletePerson(self.input.clone()))
    }
    if ui.button("List people").clicked() {
        self.send(Command::ListPeople)
    }
    if ui.button("Session data").clicked() {
        self.send(Command::Session)
    }
    if ui.button("New user").clicked() {
        self.send(Command::SignUp)
    }
    if ui.button("Sign in as record user").clicked() {
        self.send(Command::SignIn(self.input.clone()));
    }
    if ui.button("Sign in as root").clicked() {
        self.send(Command::SignInRoot)
    }
    if ui.button("Raw query").clicked() {
        self.send(Command::RawQuery(self.input.clone()))
    }
});
```

The final bit of code just involves creating two more panels, one in the centre and one on the right. The one on the right will add a [`ScrollArea`](https://docs.rs/egui/latest/egui/containers/scroll_area/struct.ScrollArea.html) so that the user can scroll through any results that are larger than the space in the right panel.

```rust
egui::CentralPanel::default().show(ctx, |ui| {
    ui.label(RichText::new("Input:").heading());
    ui.text_edit_multiline(&mut self.input);
});
egui::SidePanel::right("right").show(ctx, |ui| {
    egui::ScrollArea::vertical().show(ui, |ui| {
        ui.label(RichText::new("Results:").heading());
        ui.text_edit_multiline(&mut self.results);
    });
});
```

And that's all the code!

## Experimenting with the app

The final code looks like this:

```rust
use std::{
    ops::Deref,
    sync::mpsc::{channel, Receiver, Sender},
};

use egui::RichText;
use surrealdb::{
    engine::remote::ws::{Client, Ws},
    opt::auth::{Record, Root},
    RecordId, RecordIdKey, Surreal,
};

use anyhow::Error;
use faker_rand::en_us::names::FirstName;
use serde::{Deserialize, Serialize};

const PERSON: &str = "person";

#[derive(Serialize, Deserialize)]
struct Params<'a> {
    name: &'a str,
    pass: &'a str,
}

#[derive(Serialize, Deserialize, Clone, Default)]
pub struct PersonData {
    name: String,
    id: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Person {
    name: String,
    id: RecordId,
    created_by: Option<RecordId>,
}

#[derive(Debug, Clone)]
enum Command {
    CreatePerson(String),
    DeletePerson(String),
    ListPeople,
    RawQuery(String),
    SignUp,
    SignIn(String),
    SignInRoot,
    Session,
}

struct Database {
    client: Surreal<Client>,
    command_receiver: Receiver<Command>,
    response_sender: Sender<String>,
}

impl Deref for Database {
    type Target = Surreal<Client>;

    fn deref(&self) -> &Self::Target {
        &self.client
    }
}

trait StringIt {
    fn string(self) -> Result<String, Error>;
}

impl StringIt for Option<Person> {
    fn string(self) -> Result<String, Error> {
        match self {
            Some(t) => Ok(format!("{t:?}")),
            None => Ok("[]".into()),
        }
    }
}

impl Database {
    async fn handle_command(&self, command: Command) -> Result<String, Error> {
        match command {
            Command::CreatePerson(s) => {
                let person_data: PersonData = serde_json::from_str(&s)?;
                self.create::<Option<Person>>(PERSON)
                    .content(person_data)
                    .await?
                    .string()
            }
            Command::DeletePerson(s) => {
                if s.is_empty() {
                    let res: Vec<Person> = self.delete(PERSON).await?;
                    Ok(format!("{res:?}"))
                } else {
                    let key = RecordIdKey::from(s);
                    self.delete::<Option<Person>>((PERSON, key)).await?.string()
                }
            }
            Command::ListPeople => {
                let person: Vec<Person> = self.select(PERSON).await?;
                Ok(format!("{person:?}"))
            }
            Command::SignUp => {
                let name = rand::random::<FirstName>().to_string();
                let pass = rand::random::<FirstName>().to_string();
                self.signup(Record {
                    access: "account",
                    namespace: "test",
                    database: "test",
                    params: Params {
                        name: &name,
                        pass: &pass,
                    },
                })
                .await?;
                Ok(format!(
                    "New user created!\n\n{{ \"name\": \"{name}\", \n \"pass\": \"{pass}\" }}"
                ))
            }
            Command::RawQuery(q) => match self.query(q).await {
                Ok(ok) => Ok(format!("{ok:?}")),
                Err(e) => Ok(e.to_string()),
            },
            Command::SignIn(s) => {
                let Ok(Params { name, pass }) = serde_json::from_str::<Params>(&s) else {
                    return Ok("Params don't work!".to_string());
                };
                self.signin(Record {
                    access: "account",
                    namespace: "test",
                    database: "test",
                    params: Params { name, pass },
                })
                .await?;
                Ok(format!("Signed in as {name}!"))
            }
            Command::SignInRoot => {
                self.signin(Root {
                    username: "root",
                    password: "secret",
                })
                .await?;
                Ok(format!("Back to root!"))
            }
            Command::Session => Ok(self
                .query("RETURN <string>$session")
                .await?
                .take::<Option<String>>(0)?
                .unwrap_or("No session data found!".into())),
        }
    }
}

struct SurrealDbApp {
    input: String,
    results: String,
    command_sender: Sender<Command>,
    response_receiver: Receiver<String>,
}

impl SurrealDbApp {
    fn send(&mut self, command: Command) {
        if let Err(e) = self.command_sender.send(command) {
            self.results = e.to_string()
        }
    }
}

impl eframe::App for SurrealDbApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        egui::SidePanel::left("left").show(ctx, |ui| {
            if let Ok(response) = self.response_receiver.try_recv() {
                self.results = response;
            }
            if ui.button("Create person").clicked() {
                self.send(Command::CreatePerson(self.input.clone()))
            };
            if ui.button("Delete person").clicked() {
                self.send(Command::DeletePerson(self.input.clone()))
            }
            if ui.button("List people").clicked() {
                self.send(Command::ListPeople)
            }
            if ui.button("Session data").clicked() {
                self.send(Command::Session)
            }
            if ui.button("New user").clicked() {
                self.send(Command::SignUp)
            }
            if ui.button("Sign in as record user").clicked() {
                self.send(Command::SignIn(self.input.clone()));
            }
            if ui.button("Sign in as root").clicked() {
                self.send(Command::SignInRoot)
            }
            if ui.button("Raw query").clicked() {
                self.send(Command::RawQuery(self.input.clone()))
            }
        });
        egui::CentralPanel::default().show(ctx, |ui| {
            ui.label(RichText::new("Input:").heading());
            ui.text_edit_multiline(&mut self.input);
        });
        egui::SidePanel::right("right").show(ctx, |ui| {
            egui::ScrollArea::vertical().show(ui, |ui| {
                ui.label(RichText::new("Results:").heading());
                ui.text_edit_multiline(&mut self.results);
            });
        });
    }
}

fn main() -> Result<(), Error> {
    let (command_sender, command_receiver) = channel();
    let (response_sender, response_receiver) = channel();

    std::thread::spawn(|| -> Result<(), Error> {
        let rt = tokio::runtime::Runtime::new()?;

        rt.block_on(async {

            let client = Surreal::new::<Ws>("localhost:8000").await?;
      
            let db = Database {
                client,
                command_receiver,
                response_sender
            };

            db.signin(Root {
                username: "root",
                password: "secret",
            })
            .await?;

            db.use_ns("test").use_db("test").await?;

            db.query(
                "    DEFINE TABLE person SCHEMALESS
                PERMISSIONS FOR
                    CREATE, SELECT WHERE $auth,
                    FOR UPDATE, DELETE WHERE created_by = $auth;
            DEFINE FIELD name ON TABLE person TYPE string;
            DEFINE FIELD created_by ON TABLE person VALUE $auth READONLY;

            DEFINE INDEX unique_name ON TABLE user FIELDS name UNIQUE;
            DEFINE ACCESS account ON DATABASE TYPE RECORD
            SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
            SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
            DURATION FOR TOKEN 15m, FOR SESSION 12h
        ;",
            )
            .await?;

        loop {
            if let Ok(command) = db.command_receiver.try_recv() {
                match db.handle_command(command).await {
                    Ok(s) => db.response_sender.send(s)?,
                    Err(e) => db.response_sender.send(e.to_string())?
                }
            }
        }
        })
    });

    let app = SurrealDbApp {
        input: String::new(),
        results: String::new(),
        command_sender,
        response_receiver,
    };

    let native_options = eframe::NativeOptions::default();
    let _ = eframe::run_native(
        "SurrealDB App",
        native_options,
        Box::new(|_cc| Ok(Box::new(app))),
    );
    Ok(())
}
```

Here are some experiments you can do now that the app is up and running.

* `Create person` button: pass in `{ "name": "Billy", "id": "billy" }` and see the return value `Person { name: "Billy", id: RecordId { table: "person", key: String("billy") }, created_by: None }`.
* `Delete person` button: pass in `billy` to delete `person:billy`, or leave it blank to delete all the `person` records. As `.delete()` in the Rust SDK returns the records that are deleted, you will see `Person { name: "Billy", id: RecordId { table: "person", key: String("billy") }, created_by: None }` here as well.
* `List people`, `Session data`, and `Sign in as root` buttons, which only require a single click.
* `New user` button: will return an output like `New user created! { "name": "Estrella", "pass": "Jeromy" }`.
* `Sign in as record user` button: if you paste in the output from the `New user` button, you will see an output like `Signed in as Lonnie!`. Note that this query will take a fraction of a second to compute. This is because the algorithms behind cryptographic functions like [`crypto::argon2::compare()`](/docs/surrealql/functions/database/crypto#cryptoargon2compare) are [meant to be computationally expensive](/docs/surrealdb/reference-guide/security-best-practices#passwords) so that comparing real passwords to hashed and salted passwords takes as long as possible - but just quick enough that a single comparison is barely noticed by a legitimate user.
* `Raw query` button: runs [a raw query](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.query) and returns a [Response](https://docs.rs/surrealdb/latest/surrealdb/struct.Response.html). The output is not particularly pretty, but being able to run any query is convenient in a pinch.

Since the app lets you sign in as both a record user and a root user, let's use this to compare the permissions between the two.

First, paste in `{ "name": "Billy", "id": "billy" }` as a root user and click `Create person`, then again with `{ "name": "Billina", "id": "billina" }`.

Next, click on `New user`, copy the `JSON` output, paste it into the input in the central panel, and click on `Sign in as record user`.

Now try creating a `person` by entering `{ "name": "recorduserperson" }` into the input box and clicking on `Create person`. You should see a different output this time, as now the `created_by` field has been filled in because the `$auth` parameter currently holds the record user's ID. It should look something like this. `Person { name: "recorduserperson", id: RecordId { table: "person", key: String("70fpp3dd72hriekgclfb") }, created_by: Some(RecordId { table: "user", key: String("141datbkzq5tum9h5xvk") }) }`

We'll now imagine that the record user wants to delete all of the `person` records in the database. Delete everything in the Input box and click on `Delete person`. You should see the same output as before: just the `person` record that the record user created.

Finally, click on `List people`. The results will show that the Billy and Billina `person` records are safe and sound, because record users can only delete `person` records that they have created.

## Further steps

Now that you have a running Egui app with SurrealDB as the backend, here are some other ideas that you might want to explore.

* Compiling to WASM (and even deploying to a website). Egui can be compiled to WASM, and SurrealDB can use IndexedDB as [one of its backends](/docs/surrealdb/cli/start#positional-argument).



================================================
FILE: src/content/doc-sdk-rust/frameworks/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Crates
title: Rust | SDKs | Integration
description: The SurrealDB SDK for Rust enables simple and advanced querying of a remote or embedded database.
---

import Boxes from "@components/boxes/Boxes.astro";
import IconBox from "@components/boxes/IconBox.astro";
import Image from "@components/Image.astro";

import Version from '@components/Version.astro';
import LightLogo from "@img/icon/light/rust.png";
import DarkLogo from "@img/icon/light/rust.png";
import LightActixLogo from "@img/icon/light/actix.png";
import DarkActixLogo from "@img/icon/dark/actix.png";
import LightAxumLogo from "@img/icon/light/axum.png";
import DarkAxumLogo from "@img/icon/dark/axum.png";
import LightRerunLogo from "@img/icon/light/rerun.png";
import DarkRerunLogo from "@img/icon/dark/rerun.png";
import LightRocketLogo from "@img/icon/light/rocket.png";
import DarkRocketLogo from "@img/icon/dark/rocket.png";

<div class="flag-title">
	<Image
		alt="Rust"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Frameworks
</div>

The following pages each contain a tutorial that walks through the setting up of a web server (for Actix, Axum, and Rocket) or a UI (for Egui) that uses SurrealDB as its storage backend.

<Boxes>
    <IconBox
        title="Actix"
        href="/docs/sdk/rust/frameworks/actix"
        icon={{
                light: LightActixLogo,
                dark: DarkActixLogo,
        }}
    />
    <IconBox
        title="Axum"
        href="/docs/sdk/rust/frameworks/axum"
        icon={{
                light: LightAxumLogo,
                dark: DarkAxumLogo,
        }}
    />
    <IconBox
        title="Egui"
        href="/docs/sdk/rust/frameworks/egui"
        icon={{
                light: LightRerunLogo,
                dark: DarkRerunLogo,
        }}
    />
    <IconBox
        title="Rocket"
        href="/docs/sdk/rust/frameworks/rocket"
        icon={{
                light: LightRocketLogo,
                dark: DarkRocketLogo,
        }}
    />
</Boxes>



================================================
FILE: src/content/doc-sdk-rust/frameworks/rocket.mdx
================================================
---
sidebar_position: 5
sidebar_label: Rocket
title: Rust | SDKs | Integration
description: The SDK for Rust allows SurrealDB to be used as the storage backend for a Rocket web server
---

# SurrealDB with Rocket

The following tutorial will set up a server with SurrealDB and [Rocket](https://rocket.rs/) that has a few endpoints:

* Some endpoints to demonstrate how the HTTP endpoints work to create, select, modify etc. a `person` table in a database,
* Other endpoints to display some helpful info for the user,
* Two endpoints to allow signing up and signing in as a [record user](/docs/surrealql/statements/define/access/record).

## Getting started

First, open up a terminal window and use the following command to start an empty database.

```bash
surreal start --user root --pass secret
```

You can also use the [Start serving](/docs/surrealist/concepts/local-database-serving) button on [Surrealist](/docs/surrealist) to do the same if you have it installed locally.

The database initiated by the [surreal start](/docs/surrealdb/cli/start) command stores data in memory by default, which then disappears every time the database is shut down. As such, you can simply use Ctrl+C every time you want to start the database anew with no existing definitions or data. To save data to disk which will persist after shutting down, add a [positional argument](/docs/surrealdb/cli/start#positional-argument) for one of the storage backends such as `rocksdb://mydatabase` or `surrealkv://mydatabase` (or `surrealkv+versioned//mydatabase` to include SurrealKV versioning).

With the database running, we will now connect to the database "test" located in the namespace "test". You can connect to it by [creating a connection](/docs/surrealist/getting-started#creating-a-connection) inside Surrealist, or by using the following command to start an interactive shell.

```bash
surreal sql --user root --pass secret --ns test --db test --pretty
```

Next, create a new Rust project with the command `cargo new your_project_name`, go into the newly created directory, and use `cargo add` to add each of the following dependencies:

* `surrealdb` (of course),
* `rocket`,
* `serde`, for serializing and deserializing Rust structs passed to and from the database and Rocket,
* `thiserror`, to make it easy to convert between SurrealDB's error type, other errors and Rocket's response types,
* `rand` and `faker_rand`, to create random user names that can be used to sign in to the database as a record user.

The `serde` crate will need the `derive` flag, and `rocket` will need the `json` flag enabled. Your `cargo.toml` dependencies should look like this:

```
faker_rand = "0.1.1"
rand = "0.8.5"
rocket = { version = "0.5.1", features = ["json"] }
serde = { version = "1.0.209", features = ["derive"] }
surrealdb = "2.0.4"
thiserror = "1.0.64"
```

## Starting the Rust code

The first thing to do is a bit of groundwork to convert database errors into an error type of our own. Implementing `From<surrealdb::Error>` for this type will let it be used with the `?` operator when handling results. Finally, it will also need to implement Rocket's `Responder` trait so that it can be used as output for the server. All of this can be done manually if you prefer, but the `thiserror` crate saves a certain amount of typing.

```rust
mod error {
    use rocket::http::Status;
    use rocket::response::{self, Responder, Response};
    use rocket::Request;
    use thiserror::Error;

    #[derive(Error, Debug)]
    pub enum Error {
        #[error("database error")]
        Db,
    }

    impl<'r> Responder<'r, 'static> for Error {
        fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {
            let error_message = format!(r#"{{ "error": "{self}" }}"#);
            Response::build()
                .status(Status::InternalServerError)
                .header(rocket::http::ContentType::JSON)
                .sized_body(error_message.len(), std::io::Cursor::new(error_message))
                .ok()
        }
    }

    impl From<surrealdb::Error> for Error {
        fn from(error: surrealdb::Error) -> Self {
            eprintln!("{error}");
            Self::Db
        }
    }
}
```

Next, we will put the database client together. Rocket provides a [`.manage()`](https://rocket.rs/guide/v0.5/state/) method when starting a router that would give us access to the database inside its functions. However, for simplicity we can instead wrap the client inside a `LazyLock` to make it into a global static.

```rust
use std::sync::LazyLock;
static DB: LazyLock<Surreal<Client>> = LazyLock::new(Surreal::init);
```

Inside a method called `init()` to initiate the database, we will do the following:

* Connect to the database running at `localhost:8000`
* Sign in as the root user that was created through the `surreal start` command
* Use (move to) the namespace "test" and database "test"
* Use the `.query()` method to pass in a few definitions for the database.

```rust
async fn init() -> Result<(), surrealdb::Error> {
    DB.connect::<Ws>("localhost:8000").await?;

    DB.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    DB.use_ns("namespace").use_db("database").await?;

    DB.query(
        "    DEFINE TABLE person SCHEMALESS
        PERMISSIONS FOR 
            CREATE, SELECT WHERE $auth,
            FOR UPDATE, DELETE WHERE created_by = $auth;
    DEFINE FIELD name ON TABLE person TYPE string;
    DEFINE FIELD created_by ON TABLE person VALUE $auth READONLY;

    DEFINE INDEX unique_name ON TABLE user FIELDS name UNIQUE;
    DEFINE ACCESS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 15m, FOR SESSION 12h
;",
    )
    .await?;
    Ok(())
}
```

## What the database definitions do

The first item that stands out with the definitions above is that they all contain a `IF NOT EXISTS` clause. As the `DEFINE` statements will be executed every time the app starts, it is possible that they might be executed on a database that already has the definitions in place. Since version 2.0, SurrealDB simply returns an error if a definition already exists, requiring the `OVERWRITE` clause if a definition needs to be redone. Without `IF NOT EXISTS`, the message "The table 'person' already exists" will be returned.

Note that this would not affect our app, as this would still be a successful usage of the `.query()` method. Instead, its output would contain a number of error results that could be handled individually:

```
Response { client: Surreal { router: OnceLock(Router { sender: Sender { .. }, last_id: 4, features: {LiveQueries} }), engine: PhantomData<surrealdb::api::engine::any::Any> }, results: {0: (Stats { execution_time: Some(252.625µs) }, Err(Api(Query("The table 'person' already exists")))), 1: (Stats { execution_time: Some(79.167µs) }, Err(Api(Query("The field 'name' already exists")))), 2: (Stats { execution_time: Some(69.5µs) }, Err(Api(Query("The field 'created_by' already exists")))), 3: (Stats { execution_time: Some(73.625µs) }, Err(Api(Query("The index 'unique_name' already exists")))), 4: (Stats { execution_time: Some(73.583µs) }, Err(Api(Query("The access method 'account' already exists in the database 'test'"))))}, live_queries: {} }
```

However, adding `IF NOT EXISTS` is a nice way to change the results from errors into successful results, and to avoid the rare case in which they end up applied to some other version 1.x database that would rewrite its definitions if `IF NOT EXISTS` is present. So while not necessary in our case, it is a good practice to follow and makes for cleaner output.

Now let's go over each of the definitions to see what they do.

The first three statements define a `person` table. This table is schemaless, but has one required field `name`, which must be present and must be a string. This table has defined permissions by which a record user is able to use `CREATE` and `SELECT` on the `person` table, but can only `UPDATE` and `DELETE` records that it has created. The root user, however, is not subject to permissions rules.

The way these permissions are set is by using the `$auth` parameter. This parameter has a value whenever a record user is set as the authorized used for the database. The `WHERE $auth` clause simply means "where a value exists for the parameter `$auth`" (`WHERE $auth IS NOT NONE` would also work in this case). But for `UPDATE` and `DELETE` queries, it is not enough for `$auth` to just be present, the `created_by` field of a `person` record must also match the ID of the currently authenticated user.

This `created_by` field is automatically generated from its definition in the `DEFINE FIELD` statement. It is given the value of `$auth`, and is `READONLY` and thus cannot be changed. When logged in as a system user (like a root user), its value will be `NONE`. But when logged in as a record user, its value will be something like `user:qx2apv5oc8mh03wtah0q`.

```surql
DEFINE TABLE IF NOT EXISTS person SCHEMALESS
    PERMISSIONS FOR 
        CREATE, SELECT WHERE $auth,
        FOR UPDATE, DELETE WHERE created_by = $auth;
DEFINE FIELD IF NOT EXISTS name ON TABLE person TYPE string;
DEFINE FIELD IF NOT EXISTS created_by ON TABLE person VALUE $auth READONLY;
```

So where does an ID like `user:qx2apv5oc8mh03wtah0q` come from? This is thanks to the following definitions that set the signup and signin behaviour of the record users. A typical [`DEFINE ACCESS`](/docs/surrealql/statements/define/access/record) statement will create some sort of record on signup (in this case, a `user`) record, and will compare it against a password during signin. Note that the access has a name that we gave it (`account`), so that it can be referenced elsewhere.

In addition, a `DEFINE INDEX` statement with a `UNIQUE` clause is used to ensure that no two users can have the same name.

```surql
    DEFINE INDEX IF NOT EXISTS unique_name ON TABLE user FIELDS name UNIQUE;
    DEFINE ACCESS IF NOT EXISTS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 15m, FOR SESSION 12h
```

For an actual user in production, you would probably want to require an email and some other fields. Functions like [`string::is_email`](/docs/surrealql/functions/database/string#stringis_email) can be used to ensure that the value passed in is valid.

```surql
DEFINE FIELD email ON TABLE user TYPE string ASSERT $value.is_email();
```

However, for this simple example, each user will simply have a unique name and a password. The password will be stored in hashed and salted form on the database, making it unique and unreadable every time it is generated. The only way to check if it is correct is by using a [compare function](/docs/surrealql/functions/database/crypto#cryptoargon2compare) of the output with an attempted password. Here is a short SurrealQL sample to show how the process works.

```surql
LET $hash1 = crypto::argon2::generate("myPaSSWord");
LET $hash2 = crypto::argon2::generate("myPaSSWord");

RETURN [$hash1, $hash2];
-- First returns true, second returns false
RETURN [
    crypto::argon2::compare($hash1, "myPaSSWord")
    crypto::argon2::compare($hash1, "Wrongpassword")
];
```

## The rest of the code

The last step is where the majority of the work takes place: setting up the paths for Rocket to handle, and writing the functions that handle the endpoints and (usually) access the database to handle the request. To start, we'll create a function for the `"/"` root path to display a helpful message to anybody giving the server a try via the browser or an app like curl or Postman. These paths and curl examples can all be seen on [the page for SurrealDB's HTTP endpoints](/docs/surrealdb/integration/http).

```rust
    #[get("/")]
    pub async fn paths() -> &'static str {
        r#"

-----------------------------------------------------------------------------------------------------------------------------------------
        PATH                |           SAMPLE COMMAND                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------
/session: See session data  |  curl -X GET    -H "Content-Type: application/json"                          http://localhost:8080/session
                            |
/person/{id}:               |
  Create a person           |  curl -X POST   -H "Content-Type: application/json" -d '{"name":"John Doe"}' http://localhost:8080/person/one
  Get a person              |  curl -X GET    -H "Content-Type: application/json"                          http://localhost:8080/person/one
  Update a person           |  curl -X PUT    -H "Content-Type: application/json" -d '{"name":"Jane Doe"}' http://localhost:8080/person/one
  Delete a person           |  curl -X DELETE -H "Content-Type: application/json"                          http://localhost:8080/person/one
                            |
/people: List all people    |  curl -X GET    -H "Content-Type: application/json"                          http://localhost:8080/people

/new_user:  Create a new record user
/new_token: Get instructions for a new token if yours has expired"#
    }
```

Each of these functions will be put into a mod called `routes`, leading to the following code inside Rocket's `rocket()` function (its equivalent of `main()`).

```rust
#[launch]
pub async fn rocket() -> _ {
    std::env::set_var("ROCKET_PORT", "8080");
    init().await.expect("Something went wrong, shutting down");
    rocket::build().mount(
        "/",
        routes![
            routes::create_person,
            routes::read_person,
            routes::update_person,
            routes::delete_person,
            routes::list_people,
            routes::paths,
            routes::make_new_user,
            routes::get_new_token,
            routes::session
        ],
    )
}
```

Many functions require some JSON data from the user, which will be deserialized into a `PersonData` struct. The database can then use it in methods like `.create().content()`. The output returned will now have a `name` and an `id`, which the `Person` struct holds.

```rust
#[derive(Serialize, Deserialize, Clone)]
pub struct PersonData {
    name: String,
}

#[derive(Serialize, Deserialize)]
pub struct Person {
    name: String,
    id: RecordId,
}
```

Each of these functions are pretty straightforward: obtain some user input, initiate a query, feed the user input into it, and return it as JSON.

```rust
const PERSON: &str = "person";

#[post("/person/<id>", data = "<person>")]
pub async fn create_person(
    id: String,
    person: Json<PersonData>,
) -> Result<Json<Option<Person>>, Error> {
    let person = DB
        .create((PERSON, &*id))
        .content(person.into_inner())
        .await?;
    Ok(Json(person))
}

#[get("/person/<id>")]
pub async fn read_person(id: String) -> Result<Json<Option<Person>>, Error> {
    let person = DB.select((PERSON, &*id)).await?;
    Ok(Json(person))
}

#[put("/person/<id>", data = "<person>")]
pub async fn update_person(
    id: String,
    person: Json<PersonData>,
) -> Result<Json<Option<Person>>, Error> {
    let person = DB
        .update((PERSON, &*id))
        .content(person.into_inner())
        .await?;
    Ok(Json(person))
}

#[delete("/person/<id>")]
pub async fn delete_person(id: String) -> Result<Json<Option<Person>>, Error> {
    let person = DB.delete((PERSON, &*id)).await?;
    Ok(Json(person))
}

#[get("/people")]
pub async fn list_people() -> Result<Json<Vec<Person>>, Error> {
    let people = DB.select(PERSON).await?;
    Ok(Json(people))
}
```

The `session()` function is also quite small, and is just a convenience for a user curious about the current session data. As the `.query()` method can take more than one statement, it returns each of these responses in order with an index for each (starting at 0). The `.take()` method can then be used to access the response at that index, and turn it into anything that can be deserialized back into a Rust type. In our case, a `String` is all we need here as the output will only be used to show the user the current session info.

```rust
#[get("/session")]
pub async fn session() -> Result<Json<String>, Error> {
    let res: Option<String> = DB.query("RETURN <string>$session").await?.take(0)?;

    Ok(Json(res.unwrap_or("No session data found!".into())))
}
```

Two most interesting function is the one used to create a new record user. To make it really easy to try out the experience of logging in as a record user, this function will use create a random name and password each time it is accessed. It will then pass in a [`Record`](https://docs.rs/surrealdb/latest/surrealdb/opt/auth/struct.Record.html) struct which is used to sign up a new record user. Note the following:

* The access name is `"account"`, which is the name we chose in the `DEFINE ACCESS` statement above.
* The `params` field takes anything that implements `Serialize`, in this case a struct we put together called `Params`.
* The `.signup()` method returns a redacted `Jwt` by default. To make the token visible, you can use the `.into_insecure_token()` method as we have done here. As a small guide to getting started, this example is not concerned about security. However, if you are looking to create something more production-worthy, do take a look at the [security](/docs/surrealdb/security) section of the documentation and the [security best practices](/docs/surrealdb/reference-guide/security-best-practices) page.

The function will then end with an output showing the username, password, token, and instructions for how to log in using the CLI. This can be copied and pasted to begin making queries immediately.

```rust
#[derive(Serialize, Deserialize)]
struct Params<'a> {
    name: &'a str,
    pass: &'a str,
}

#[get("/new_user")]
pub async fn make_new_user() -> Result<String, Error> {
    let name = rand::random::<FirstName>().to_string();
    let pass = rand::random::<FirstName>().to_string();
    let jwt = DB
        .signup(Record {
            access: "account",
            namespace: "namespace",
            database: "database",
            params: Params {
                name: &name,
                pass: &pass,
            },
        })
        .await?
        .into_insecure_token();
    Ok(format!("New user created!\n\nName: {name}\nPassword: {pass}\nToken: {jwt}\n\nTo log in, use this command:\n\nsurreal sql --namespace namespace --database database --pretty --token \"{jwt}\""))
}
```

A record user with an expired token can use the `/signin` endpoint to get a new token. Since this requires passing in a username and password, we'll just have this function return a `String` that contains a curl example to get a new token.

```rust
#[get("/new_token")]
pub async fn get_new_token() -> String {
    let command = r#"curl -X POST -H "Accept: application/json" -d '{"ns":"namespace","db":"database","ac":"account","user":"your_username","pass":"your_password"}' http://localhost:8000/signin"#;
    format!("Need a new token? Use this command:\n\n{command}\n\nThen log in with surreal sql --namespace namespace --database database --pretty --token YOUR_TOKEN_HERE")
}
```

## Experimenting with the app

The final code looks like this:

```rust
#[macro_use]
extern crate rocket;

use std::sync::LazyLock;
use surrealdb::engine::remote::ws::Client;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::Surreal;

static DB: LazyLock<Surreal<Client>> = LazyLock::new(Surreal::init);

mod error {
    use rocket::http::Status;
    use rocket::response::{self, Responder, Response};
    use rocket::Request;
    use thiserror::Error;

    #[derive(Error, Debug)]
    pub enum Error {
        #[error("database error")]
        Db,
    }

    impl<'r> Responder<'r, 'static> for Error {
        fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {
            let error_message = format!(r#"{{ "error": "{self}" }}"#);
            Response::build()
                .status(Status::InternalServerError)
                .header(rocket::http::ContentType::JSON)
                .sized_body(error_message.len(), std::io::Cursor::new(error_message))
                .ok()
        }
    }

    impl From<surrealdb::Error> for Error {
        fn from(error: surrealdb::Error) -> Self {
            eprintln!("{error}");
            Self::Db
        }
    }
}

mod routes {

    use faker_rand::en_us::names::FirstName;
    use surrealdb::opt::auth::Record;

    use crate::error::Error;
    use crate::DB;
    use rocket::serde::json::Json;
    use rocket::{delete, get, post, put};
    use serde::{Deserialize, Serialize};
    use surrealdb::RecordId;
    const PERSON: &str = "person";

    #[derive(Serialize, Deserialize)]
    struct Params<'a> {
        name: &'a str,
        pass: &'a str,
    }

    #[derive(Serialize, Deserialize, Clone)]
    pub struct PersonData {
        name: String,
    }

    #[derive(Serialize, Deserialize)]
    pub struct Person {
        name: String,
        id: RecordId,
    }

    #[get("/")]
    pub async fn paths() -> &'static str {
        r#"

-----------------------------------------------------------------------------------------------------------------------------------------
        PATH                |           SAMPLE COMMAND                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------
/session: See session data  |  curl -X GET    -H "Content-Type: application/json"                          http://localhost:8080/session
                            |
/person/{id}:               |
  Create a person           |  curl -X POST   -H "Content-Type: application/json" -d '{"name":"John Doe"}' http://localhost:8080/person/one
  Get a person              |  curl -X GET    -H "Content-Type: application/json"                          http://localhost:8080/person/one
  Update a person           |  curl -X PUT    -H "Content-Type: application/json" -d '{"name":"Jane Doe"}' http://localhost:8080/person/one
  Delete a person           |  curl -X DELETE -H "Content-Type: application/json"                          http://localhost:8080/person/one
                            |
/people: List all people    |  curl -X GET    -H "Content-Type: application/json"                          http://localhost:8080/people

/new_user:  Create a new record user
/new_token: Get instructions for a new token if yours has expired"#
    }

    #[get("/session")]
    pub async fn session() -> Result<Json<String>, Error> {
        let res: Option<String> = DB.query("RETURN <string>$session").await?.take(0)?;

        Ok(Json(res.unwrap_or("No session data found!".into())))
    }

    #[post("/person/<id>", data = "<person>")]
    pub async fn create_person(
        id: String,
        person: Json<PersonData>,
    ) -> Result<Json<Option<Person>>, Error> {
        let person = DB
            .create((PERSON, &*id))
            .content(person.into_inner())
            .await?;
        Ok(Json(person))
    }

    #[get("/person/<id>")]
    pub async fn read_person(id: String) -> Result<Json<Option<Person>>, Error> {
        let person = DB.select((PERSON, &*id)).await?;
        Ok(Json(person))
    }

    #[put("/person/<id>", data = "<person>")]
    pub async fn update_person(
        id: String,
        person: Json<PersonData>,
    ) -> Result<Json<Option<Person>>, Error> {
        let person = DB
            .update((PERSON, &*id))
            .content(person.into_inner())
            .await?;
        Ok(Json(person))
    }

    #[delete("/person/<id>")]
    pub async fn delete_person(id: String) -> Result<Json<Option<Person>>, Error> {
        let person = DB.delete((PERSON, &*id)).await?;
        Ok(Json(person))
    }

    #[get("/people")]
    pub async fn list_people() -> Result<Json<Vec<Person>>, Error> {
        let people = DB.select(PERSON).await?;
        Ok(Json(people))
    }

    #[get("/new_user")]
    pub async fn make_new_user() -> Result<String, Error> {
        let name = rand::random::<FirstName>().to_string();
        let pass = rand::random::<FirstName>().to_string();
        let jwt = DB
            .signup(Record {
                access: "account",
                namespace: "namespace",
                database: "database",
                params: Params {
                    name: &name,
                    pass: &pass,
                },
            })
            .await?
            .into_insecure_token();
        Ok(format!("New user created!\n\nName: {name}\nPassword: {pass}\nToken: {jwt}\n\nTo log in, use this command:\n\nsurreal sql --namespace namespace --database database --pretty --token \"{jwt}\""))
    }

    #[get("/new_token")]
    pub async fn get_new_token() -> String {
        let command = r#"curl -X POST -H "Accept: application/json" -d '{"ns":"namespace","db":"database","ac":"account","user":"your_username","pass":"your_password"}' http://localhost:8000/signin"#;
        format!("Need a new token? Use this command:\n\n{command}\n\nThen log in with surreal sql --namespace namespace --database database --pretty --token YOUR_TOKEN_HERE")
    }
}

async fn init() -> Result<(), surrealdb::Error> {
    DB.connect::<Ws>("localhost:8000").await?;

    DB.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    DB.use_ns("namespace").use_db("database").await?;

    DB.query(
        "    DEFINE TABLE person SCHEMALESS
        PERMISSIONS FOR 
            CREATE, SELECT WHERE $auth,
            FOR UPDATE, DELETE WHERE created_by = $auth;
    DEFINE FIELD name ON TABLE person TYPE string;
    DEFINE FIELD created_by ON TABLE person VALUE $auth READONLY;

    DEFINE INDEX unique_name ON TABLE user FIELDS name UNIQUE;
    DEFINE ACCESS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET name = $name, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE name = $name AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 15m, FOR SESSION 12h
;",
    )
    .await?;
    Ok(())
}

#[launch]
pub async fn rocket() -> _ {
    std::env::set_var("ROCKET_PORT", "8080");
    init().await.expect("Something went wrong, shutting down");
    rocket::build().mount(
        "/",
        routes![
            routes::create_person,
            routes::read_person,
            routes::update_person,
            routes::delete_person,
            routes::list_people,
            routes::paths,
            routes::make_new_user,
            routes::get_new_token,
            routes::session
        ],
    )
}
```

As the database client is logged in as a root user, the `/person/` routes can be used to perform any operation on the `person` records of the database.

You can also log in to the CLI or Surrealist as a root user and separately as a record user using the output of the `/new_user` endpoint to compare the experience between the two.

For example, the output when creating a `person` record as a root user will look like this:

```bash
test/test> CREATE person SET name = 'Aeon';
-- Query 1
[
	{
		id: person:hdl0unwts4atic65nh7l,
		name: 'Aeon'
	}
]
```

But as a record user, it will include a `created_by` field, set by the value found at the `$auth` paremeter.

```bash
test/test> CREATE person SET name = 'Aeon';
-- Query 1
[
	{
		created_by: user:qx2apv5oc8mh03wtah0q,
		id: person:8syfiq2ovztn2tbr8mhb,
		name: 'Aeon'
	}
]
```

As a result, a `DELETE person RETURN BEFORE` statement (which deletes all `person` records and returns the records deleted) used by a record user will only delete the single record that it created earlier. The following `SELECT` statement shows that the `person` record created by the root user cannot be deleted or modified by the record user.

```bash
test/test> DELETE person RETURN BEFORE;
-- Query 1
[
	{
		created_by: user:qx2apv5oc8mh03wtah0q,
		id: person:8y06y06jmmb7e58trckz,
		name: 'Aeon'
	}
]

test/test> SELECT * FROM person;
-- Query 1
[
	{
		id: person:hdl0unwts4atic65nh7l,
		name: 'Aeon'
	}
]

test/test> UPDATE person SET name = "Yogurt";
-- Query 1
[]
```

Also note that the root user is able to see the `user` tables and their information. A record user cannot, as a record user by default has no permissions except what it is given by the `PERMISSIONS` clause. If you create a record user using the `/new_user` endpoint, the root user will be able to view it. However, the password has been obscured by the `crypto::argon2::generate` function so that nobody else can use it.

```surql
[
	{
		id: user:qx2apv5oc8mh03wtah0q,
		name: 'Gerard',
		pass: '$argon2id$v=19$m=19456,t=2,p=1$j0ktTqUxRjOWYnwS5LoMFQ$2NcGkf5+IuLml6NorPy/Le6T8RppYXTXakwY5cDiZPY'
	}
]
```

## Further steps

Now that you have a running Rocket server with SurrealDB as the backend, here are some other ideas that you might want to explore.

* Using the [`AUTHENTICATE`](/docs/surrealql/statements/define/access/record#example-failing-authentication) clause inside the `DEFINE ACCESS` statement. This will result in increased performance thanks to only being executed once, compared to permissions checks which are executed for each query.
* Adding some interesting behaviour to the database such as [changefeeds](/docs/surrealql/statements/define/table#example-usage) or [events](/docs/surrealql/statements/define/event).


================================================
FILE: src/content/doc-sdk-rust/methods/authenticate.mdx
================================================
---
sidebar_position: 2
sidebar_label: authenticate
title: Authenticate Method in Rust | Rust SDK | Integration | SurrealDB
description: The .authenticate() method for the SurrealDB Rust SDK authenticates the current connection with a JWT token.
---

# `authenticate()`

Authenticates the current connection with a JWT token.

```rust title="Method Syntax"
db.authenticate(token)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>token</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The JWT authentication token.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

Note: the following example uses the `ureq` crate with the `json` feature to first send a request to the database's [`/signup`](/docs/surrealdb/integration/http#signup) endpoint which returns a token. The `reqwest` crate and others can be used here instead.

Alternatively, you could use a command like `curl -X POST -H "Accept: application/json" -d '{"ns":"test","db":"test","ac":"account","user":"info@surrealdb.com","pass":"123456"}' http://localhost:8000/signup`, copy the returned token, and paste it into the `.authenticate()` method. As the `DEFINE ACCESS` method below shows, a token will remain valid by default for 15 minutes.

```rust
// Use the following statement to set up the access
//
// DEFINE ACCESS account ON DATABASE TYPE RECORD
// 	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
// 	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
// 	DURATION FOR TOKEN 15m, FOR SESSION 12h
// ;

// DEFINE TABLE cat SCHEMALESS
//     PERMISSIONS for select, update, delete, create
//     WHERE $auth.id;

use serde::Deserialize;
use std::fmt::Display;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::Surreal;

#[derive(Deserialize)]
struct Response {
    token: String,
}

impl Display for Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.token)
    }
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;
    let token = ureq::post("http://127.0.0.1:8000/signup")
        .set("Accept", "application/json")
        .send_json(ureq::json!({
            "ns": "test",
            "db": "test",
            "ac": "account",
            "email": "info@surrealdb.com",
            "pass": "123456"
        }))
        .unwrap()
        .into_json::<Response>()
        .unwrap()
        .to_string();

    // Not signed in, doesn't work
    dbg!(db.query("CREATE cat;").await?);
    db.authenticate(token).await?;
    // Now it works
    dbg!(db.query("CREATE cat;").await?);

    Ok(())
}
```

### See also

* [.authenticate() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.authenticate)


================================================
FILE: src/content/doc-sdk-rust/methods/connect.mdx
================================================
---
sidebar_position: 3
sidebar_label: connect
title: Connect Method in Rust | Rust SDK | Integration | SurrealDB
description: The .connect() method for the SurrealDB Rust SDK connects to a local or remote database endpoint.
---

# `connect()`

Connects to a local or remote database endpoint.

```rust title="Method Syntax"
db.connect(address)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>endpoint</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database endpoint to connect to.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

The `.connect()` method will usually take a `String` or a type that implements `Into<String>`. Note that the final `.connect()` with a `Config` is possible because of the implementation `impl<T> IntoEndpoint for (T, Config)
where T: Into<String>`.

```rust
use std::sync::LazyLock;
use std::time::Duration;
use surrealdb::engine::remote::ws::{Client, Ws, Wss};
use surrealdb::opt::Config;
use surrealdb::Surreal;

static DB: LazyLock<Surreal<Client>> = LazyLock::new(Surreal::init);

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    // Connect to a local endpoint
    DB.connect::<Ws>("127.0.0.1:8000").await?;
    // Connect to a remote endpoint
    DB.connect::<Wss>("cloud.surrealdb.com").await?;
    // A tuple with a Config struct can also be passed in for fine tuning of the connection
    let config = Config::default().query_timeout(Duration::from_millis(1500));
    DB.connect::<Ws>(("127.0.0.1:8000", config)).await?;
    Ok(())
}
```

### See also

* [.connect() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/engine/any/fn.connect.html)



================================================
FILE: src/content/doc-sdk-rust/methods/create.mdx
================================================
---
sidebar_position: 4
sidebar_label: create
title: Create Method in Rust | Rust SDK | Integration | SurrealDB
description: The .create() method for the SurrealDB Rust SDK creates one or more records in the database.
---

# `create()`

Creates one or more records in the database.

```rust title="Method Syntax"
db.create(resource).content(data)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>resource</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;
use surrealdb::RecordId;

#[derive(Debug, Serialize, Deserialize)]
struct Person {
    name: Option<String>,
    marketing: Option<bool>
}

#[derive(Debug, Deserialize)]
struct Record {
    id: RecordId,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("ws://localhost:8000").await?;
    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;
    db.use_ns("ns").use_db("db").await?;

    // Create a record with a random ID
    let person: Option<Person> = db.create("person").await?;
    dbg!(person);
    // Create a record with a specific ID
    let record: Option<Record> = db
        .create(("person", "tobie"))
        .content(Person {
            name: Some("Tobie".into()),
            marketing: Some(true),
        })
        .await?;
    dbg!(record);
    Ok(())
}
```

### Translated query
This function will run the following query in the database:

```surql
CREATE $resource CONTENT $data;
```

### See also

* [.create() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.create)


================================================
FILE: src/content/doc-sdk-rust/methods/delete.mdx
================================================
---
sidebar_position: 5
sidebar_label: delete
title: Delete Method in Rust | Rust SDK | Integration | SurrealDB
description: The .delete() method for the SurrealDB Rust SDK deletes all or specific records from the database.
---

# `delete()`

Deletes all records in a table, or a specific record, from the database.

```rust title="Method Syntax"
db.delete(resource)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>resource</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a record ID to select. Will also accept a tuple of record name and ID.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;
use surrealdb::opt::Resource;
use surrealdb::RecordId;

#[derive(Debug, Serialize, Deserialize)]
struct Person {
    id: RecordId,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("ws://localhost:8000").await?;
    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;
    db.use_ns("ns").use_db("db").await?;

    // Create three `person` records
    db.create(Resource::from(("person", "one"))).await?;
    db.create(Resource::from(("person", "two"))).await?;
    db.create(Resource::from(("person", "three"))).await?;

    let deleted_one: Option<Person> = db.delete(("person", "one")).await?;
    dbg!(deleted_one);
    let deleted_rest: Vec<Person> = db.delete("person").await?;
    dbg!(deleted_rest);
    Ok(())
}

```

### Translated query

While SurrealQL's `DELETE` statement returns an empty array by default, this function translates into a query that adds a `RETURN BEFORE` clause to return the deleted items.

```surql
DELETE FROM $resource RETURN BEFORE;
```

### See also

* [.delete() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.delete)


================================================
FILE: src/content/doc-sdk-rust/methods/export.mdx
================================================
---
sidebar_position: 6
sidebar_label: export
title: Export Method in Rust | Rust SDK | Integration | SurrealDB
description: The .export() method for the SurrealDB Rust SDK dumps the database contents to a file.
---

import Since from "@components/shared/Since.astro";

# `export()`

Dumps the database contents to a file.

> [!NOTE]
> WebSocket connections currently do not support exports and imports. Be sure to use an HTTP endpoint when using this method.

```rust title="Method Syntax"
db.export(target)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>resource</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a record ID to select. Will also accept a tuple of record name and ID.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

The `.export()` method can be used to save the contents of a database to a file.

```rust
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;
use surrealdb::opt::Resource;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("http://localhost:8000").await?;
    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;
    db.use_ns("ns").use_db("db").await?;

    // Create a `person` record
    db.create(Resource::from("person")).await?;

    db.export("backup.surql").await?;
    Ok(())
}
```

If an empty tuple is passed in for the file name, the `.export()` method will instead return an async stream of bytes.

```rust
use futures::StreamExt;
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;
use surrealdb::opt::Resource;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("http://localhost:8000").await?;
    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;
    db.use_ns("ns").use_db("db").await?;

    // Create a `person` record
    db.create(Resource::from("person")).await?;

    let mut stream = db.export(()).await?;

    while let Some(Ok(line)) = stream.next().await {
        let content = String::from_utf8(line).unwrap();
        println!("{content}");
    }
    Ok(())
}
```

The output for the above sample should look like the following.

```
-- ------------------------------

-- OPTION

-- ------------------------------



OPTION IMPORT;



-- ------------------------------

-- TABLE: person

-- ------------------------------



DEFINE TABLE person TYPE ANY SCHEMALESS PERMISSIONS NONE;



-- ------------------------------

-- TABLE DATA: person

-- ------------------------------



INSERT [ { id: person:bgq0b0rblnozrufizdjm } ];
```

### Export configuration

<Since v="v2.1.0" />

The [`Export`](https://docs.rs/surrealdb/2/surrealdb/method/struct.Export.html) struct has a method called `.with_config()` that gives access to the configuration parameters for the export. These can be chained one after another inside a single line of code. The majority of these functions take a single `bool`:

* `.versions()`: whether to include [version information](/docs/surrealql/statements/select#the-version-clause) for the SurrealKV storage backend
* `.accesses()`: whether to include [`DEFINE ACCESS` statements](/docs/surrealql/statements/define/access/record)
* `.analyzers()`: whether to include [`DEFINE ANALYZER` statements](/docs/surrealql/statements/define/analyzer)
* `.functions()`: whether to include [`DEFINE FUNCTION` statements](/docs/surrealql/statements/define/function)
* `.records()`: whether to include the existing records in the database
* `.params()`: whether to include [`DEFINE PARAM` statements](/docs/surrealql/statements/define/param)
* `.users()`: whether to include [`DEFINE USER` statements](/docs/surrealql/statements/define/user)

`.tables()` takes a `Vec` of strings in addition to a boolean.

* `.tables()`: a list of tables to export, as opposed to all of the tables in the database.

Example of export configuration:

```rust
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("http://localhost:8000").await?;
    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;
    db.use_ns("ns").use_db("db").await?;

    db.query(
        "
    DEFINE FUNCTION fn::get_cats() { RETURN SELECT * FROM cat };
    DEFINE TABLE person SCHEMAFULL;
    DEFINE FIELD name ON person TYPE string;
    DEFINE FIELD age ON person TYPE int;
    CREATE person SET name = 'Aeon', age = 20;
    CREATE cat SET name = 'Cat of Aeon';
    ",
    )
    .await?;

    // Cat-related implementation is still experimental
    // so don't export the cat table or get_cats() function
    db.export("backup.surql")
        .with_config()
        .tables(vec!["person"])
        .functions(false)
        .await?;
    Ok(())
}
```

### See also

* [.export() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.export)



================================================
FILE: src/content/doc-sdk-rust/methods/get.mdx
================================================
---
sidebar_position: 7
sidebar_label: get
title: Get Method in Rust | Rust SDK | Integration | SurrealDB
description: The .get() method for the SurrealDB Rust SDK retrieves the value at a certain field or index.
---

import Since from '@components/shared/Since.astro'

# `get()`

<Since v="v3.0.0-alpha.1" />

The `.get()` method for the `Value` struct retrieves the value at a certain field for an object, or a certain index for an array. The method takes a `&str` or a `usize` as an argument.

> [!NOTE]
> To use this method, you must be using version `3.0.0-alpha.1` or higher of SurrealDB when connecting to the Rust SDK.

```rust title="Method Syntax"
value.get(target)
```

### Example usage

```rust
use surrealdb::engine::any::connect;
use surrealdb::Value;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("mem://").await?;
    db.use_ns("test").use_db("test").await?;

    let mut res = db
        .query(
            "[
	{
		a: {
			big: [
				'nested',
				'object'
			]
		}
	},
	{
		another: {
			big: [
				'nested',
				'object'
			]
		}
	}
];",
        )
        .await?;
    let as_value = res.take::<Value>(0)?;
    // Get the value at index 0, field 'a'
    // Output: { big: ['nested', 'object'] }
    println!("{}", as_value.get(0).get("a"));
    Ok(())
}
```

As the `.get()` method will always return a `Value`, internally a `Value::None` is returned when nothing is found at a certain index or field. The methods `.is_none()` and `.into_option()` can be used on the `Value` struct to check if the `.get()` method has returned a non-None value or not.

### See also

* [.get() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Value.html#method.get)


================================================
FILE: src/content/doc-sdk-rust/methods/import.mdx
================================================
---
sidebar_position: 8
sidebar_label: import
title: Import Method in Rust | Rust SDK | Integration | SurrealDB
description: The .import() method for the SurrealDB Rust SDK restores the database from a file.
---

# `import()`

Restores the database from a file.

> [!NOTE]
> WebSocket connections currently do not support exports and imports. Be sure to use an HTTP endpoint when using this method.

```rust title="Method Syntax"
db.import(source)
```

### Example usage

```rust
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("http://localhost:8000").await?;
    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;
    db.use_ns("ns").use_db("db").await?;
    db.import("backup.surql").await?;
    Ok(())
}
```

### See also

* [.import() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.import)



================================================
FILE: src/content/doc-sdk-rust/methods/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: SDK methods
title: Rust Methods | Rust SDK | Integration | SurrealDB
description: The SurrealDB SDK for Rust enables simple and advanced querying of a remote or embedded database.
---

# SDK methods

Most methods in the SurrealDB SDK involve either working with or creating an instance of the [`Surreal`](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html) struct, which serves as the database client instance for embedded or remote databases.

## Initialization methods

<table>
	<thead>
		<tr>
			<th scope="col">Function</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/connect"> <code>db.connect()</code></a></td>
			<td scope="row" data-label="Description">Connects to a local or remote database endpoint</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/init"> <code>Surreal::init()</code></a></td>
			<td scope="row" data-label="Description">Initializes a non-connected instance of the database client</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/new"> <code>Surreal::new()</code></a></td>
			<td scope="row" data-label="Description">Initializes a connected instance of the database client</td>
		</tr>
		<tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/set"> <code>db.set()</code></a></td>
            <td scope="row" data-label="Description">Assigns a value as a parameter for this connection</td>
        </tr>
		<tr>
			<td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/use"> <code> db.use_ns().use_db()</code></a></td>
			<td scope="row" data-label="Description">Switch to a specific namespace and database</td>
		</tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/unset"> <code>db.unset()</code></a></td>
            <td scope="row" data-label="Description">Removes a parameter for this connection</td>
        </tr>
	</tbody>
</table>

## Query methods

<table>
    <thead>
        <tr>
            <th scope="col">Function</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/query"> <code>db.query()</code></a></td>
            <td scope="row" data-label="Description">Runs a set of [SurrealQL statements](/docs/surrealql) against the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/run"> <code>db.run()</code></a></td>
            <td scope="row" data-label="Description">Runs a SurrealQL function</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/select"> <code>db.select()</code></a></td>
            <td scope="row" data-label="Description">Selects all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/select-live"> <code>db.select().live()</code></a></td>
            <td scope="row" data-label="Description">Performs a LIVE SELECT query on the database</td>
        </tr>
    </tbody>
</table>

## Mutation methods

<table>
    <thead>
        <tr>
            <th scope="col">Function</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/create"> <code>db.create()</code></a></td>
            <td scope="row" data-label="Description">Creates a record in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/delete"> <code>db.delete()</code></a></td>
            <td scope="row" data-label="Description">Deletes all records, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/insert"> <code>db.insert()</code></a></td>
            <td scope="row" data-label="Description">Inserts one or multiple records or relations in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/update"> <code>db.update()</code></a></td>
            <td scope="row" data-label="Description">Updates all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/upsert"> <code>db.upsert()</code></a></td>
            <td scope="row" data-label="Description">Upserts all records in a table, or a specific record</td>
        </tr>
    </tbody>
</table>

## Authentication methods

<table>
    <thead>
        <tr>
            <th scope="col">Function</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/authenticate"> <code>db.authenticate()</code></a></td>
            <td scope="row" data-label="Description">Authenticates the current connection with a JWT token</td>
        </tr>
		<tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/invalidate"> <code>db.invalidate()</code></a></td>
            <td scope="row" data-label="Description">Invalidates the authentication for the current connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/signin"> <code>db.signin()</code></a></td>
            <td scope="row" data-label="Description">Signs this connection in to a specific authentication scope</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/signup"> <code>db.signup()</code></a></td>
            <td scope="row" data-label="Description">Signs this connection up to a specific authentication scope</td>
        </tr>
    </tbody>
</table>

## Data methods

<table>
    <thead>
        <tr>
            <th scope="col">Function</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/export"> <code>db.export()</code></a></td>
            <td scope="row" data-label="Description">Exports the database to a file or a live stream of bytes</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/import"> <code>db.import()</code></a></td>
            <td scope="row" data-label="Description">Imports the contents of another database from a file=</td>
        </tr>
    </tbody>
</table>

## Other methods

<table>
    <thead>
        <tr>
            <th scope="col">Function</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Function"><a href="/docs/sdk/rust/methods/version"> <code>db.version()</code></a></td>
            <td scope="row" data-label="Description">Returns the current database version</td>
        </tr>
    </tbody>
</table>



================================================
FILE: src/content/doc-sdk-rust/methods/init.mdx
================================================
---
sidebar_position: 9
sidebar_label: init
title: Init Method in Rust | Rust SDK | Integration | SurrealDB
description: The .init() method for the SurrealDB Rust SDK initializes a new unconnected instance.
---

# `init()`

The .init() method initializes a new unconnected instance of the client.
This is typically used to create a global, static instance of the client.

```rust title="Method Syntax"
Surreal::init()
```

### Example usage

```rust
use std::sync::LazyLock;
use surrealdb::engine::remote::ws::{Client, Ws};
use surrealdb::Surreal;

static DB: LazyLock<Surreal<Client>> = LazyLock::new(Surreal::init);

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    // Connect to the database
    DB.connect::<Ws>("127.0.0.1:8000").await?;
    Ok(())
}
```

`Surreal::init()` can also be used to create an instance of `Surreal<Any>`, allowing you to choose at runtime which way to connect.

```rust
use std::env;
use std::sync::LazyLock;
use surrealdb::engine::any::Any;
use surrealdb::Surreal;

static DB: LazyLock<Surreal<Any>> = LazyLock::new(Surreal::init);

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    // Choose an endpoint at runtime using the `DB_ENDPOINT` environment variable
    // or fallback to the memory engine.
    let endpoint = env::var("DB_ENDPOINT").unwrap_or_else(|_| "mem://".to_owned());
    DB.connect(endpoint).await?;
    Ok(())
}
```

### See also

* [.init() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.init)


================================================
FILE: src/content/doc-sdk-rust/methods/insert.mdx
================================================
---
sidebar_position: 10
sidebar_label: insert
title: Insert Method in Rust | Rust SDK | Integration | SurrealDB
description: The .insert() method for the SurrealDB Rust SDK inserts a record or records into a table.
---

# `insert()`

```rust title="Method Syntax"
db.insert(resource).content(data);
db.insert(resource).relation(data);
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>resource</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The relation table data to insert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

Inserting a record with a specific ID:

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;

#[derive(Debug, Serialize, Deserialize)]
struct Settings {
    active: bool,
    marketing: bool,
}

#[derive(Serialize)]
struct Data<'a> {
    name: &'a str,
    settings: Settings,
}

#[derive(Debug, Deserialize)]
struct Person {
    name: String,
    settings: Settings,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("ws://localhost:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    let person: Option<Person> = db
        .insert(("person", "tobie"))
        .content(Data {
            name: "Tobie",
            settings: Settings {
                active: true,
                marketing: true,
            },
        })
        .await?;
    dbg!(person);
    Ok(())
}
```

Inserting multiple records into a table:

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;

#[derive(Debug, Serialize, Deserialize)]
struct Settings {
    active: bool,
    marketing: bool,
}

#[derive(Serialize)]
struct Data<'a> {
    name: &'a str,
    settings: Settings,
}

#[derive(Debug, Deserialize)]
struct Person {
    name: String,
    settings: Settings,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("ws://localhost:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    let people: Vec<Person> = db
        .insert("person")
        .content(vec![
            Data {
                name: "Tobie",
                settings: Settings {
                    active: true,
                    marketing: false,
                },
            },
            Data {
                name: "Jaime",
                settings: Settings {
                    active: true,
                    marketing: true,
                },
            },
        ])
        .await?;
    dbg!(people);
    Ok(())
}
```

The `.insert()` method can take an empty tuple instead of a table ID if the following method contains [a record ID](https://docs.rs/surrealdb/latest/surrealdb/struct.RecordId.html).

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;
use surrealdb::RecordId;

#[derive(Debug, Serialize, Deserialize)]
struct Settings {
    active: bool,
    marketing: bool,
}

#[derive(Serialize)]
struct Data<'a> {
    id: RecordId,
    name: &'a str,
}

#[derive(Debug, Deserialize)]
struct Person {
    name: String,
    id: RecordId,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("ws://localhost:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    let people: Vec<Person> = db
        .insert(())
        .content(vec![
            Data {
                id: RecordId::from(("person", "tobie")),
                name: "Tobie",
            },
            Data {
                id: RecordId::from(("person", "jaime")),
                name: "Jaime",
            },
        ])
        .await?;
    dbg!(people);
    Ok(())
}
```

An example of two `person` records and one `company` record, followed by `.insert().relation()` to create a relation between them. Note the usage of the `#[serde(rename)]` attribute to interface between the Rust struct `Founded` and the original relation table, which must have [an `in` and an `out` field](/docs/surrealql/statements/relate).

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;
use surrealdb::RecordId;

#[derive(Debug, Serialize, Deserialize)]
struct Settings {
    active: bool,
    marketing: bool,
}

#[derive(Serialize)]
struct Data<'a> {
    id: RecordId,
    name: &'a str,
}

#[derive(Debug, Deserialize)]
struct Record {
    name: String,
    id: RecordId,
}

#[derive(Debug, Serialize, Deserialize)]
struct Founded {
    #[serde(rename = "in")]
    founder: RecordId,
    #[serde(rename = "out")]
    company: RecordId,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("ws://localhost:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    let records: Vec<Record> = db
        .insert(())
        .content(vec![
            Data {
                id: RecordId::from(("person", "tobie")),
                name: "Tobie",
            },
            Data {
                id: RecordId::from(("person", "jaime")),
                name: "Jaime",
            },
            Data {
                id: RecordId::from(("company", "surrealdb")),
                name: "SurrealDB",
            },
        ])
        .await?;
    dbg!(records);

    let founded: Vec<Founded> = db
        .insert("founded")
        .relation(vec![
            Founded {
                founder: RecordId::from(("person", "tobie")),
                company: RecordId::from(("company", "surrealdb")),
            },
            Founded {
                founder: RecordId::from(("person", "jaime")),
                company: RecordId::from(("company", "surrealdb")),
            },
        ])
        .await?;
    dbg!(founded);
    Ok(())
}
```

The equivalent SurrealQL statements to create and query the relations are:

```surql
RELATE [person:jaime, person:tobie]->founded->company:surrealdb;
SELECT ->founded->company FROM person;
```

### See also

* [.insert() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.insert)


================================================
FILE: src/content/doc-sdk-rust/methods/invalidate.mdx
================================================
---
sidebar_position: 11
sidebar_label: invalidate
title: Invalidate Method in Rust | Rust SDK | Integration | SurrealDB
description: The .invalidate() method for the SurrealDB Rust SDK invalidates the authentication for the current connection.
---

# `invalidate()`

Invalidates the authentication for the current connection.

```rust title="Method Syntax"
db.invalidate()
```

### Example usage

Note: the following example uses the `ureq` crate with the `json` feature to first send a request to the database's [`/signup`](/docs/surrealdb/integration/http#signup) endpoint which returns a token. The `reqwest` crate and others can be used here instead.

Alternatively, you could use a command like `curl -X POST -H "Accept: application/json" -d '{"ns":"test","db":"test","ac":"account","user":"info@surrealdb.com","pass":"123456"}' http://localhost:8000/signup`, copy the returned token, and paste it into the `.authenticate()` method which is used before `.invalidate()`. As the `DEFINE ACCESS` method below shows, a token will remain valid by default for 15 minutes.

```rust
// Use the following statement to set up the access
//
// DEFINE ACCESS account ON DATABASE TYPE RECORD
// 	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
// 	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
// 	DURATION FOR TOKEN 15m, FOR SESSION 12h
// ;

// DEFINE TABLE cat SCHEMALESS
//     PERMISSIONS for select, update, delete, create
//     WHERE $auth.id;

use serde::Deserialize;
use std::fmt::Display;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::Surreal;

#[derive(Deserialize)]
struct Response {
    token: String,
}

impl Display for Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.token)
    }
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;

    let token = ureq::post("http://127.0.0.1:8000/signup")
        .set("Accept", "application/json")
        .send_json(ureq::json!({
            "ns": "ns",
            "db": "db",
            "ac": "account",
            "email": "info@surrealdb.com",
            "pass": "123456"
        }))
        .unwrap()
        .into_json::<Response>()
        .unwrap()
        .to_string();

    db.authenticate(token).await?;
    // User is present inside the $auth parameter
    dbg!(db.query("RETURN $auth").await?);

    db.invalidate().await?;
    // User is now gone
    dbg!(db.query("RETURN $auth;").await?);

    Ok(())
}
```

### See also

* [.invalidate() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.invalidate)


================================================
FILE: src/content/doc-sdk-rust/methods/new.mdx
================================================
---
sidebar_position: 12
sidebar_label: new
title: New Method in Rust | Rust SDK | Integration | SurrealDB
description: The .new() method for the SurrealDB Rust SDK connects to a local or remote database endpoint.
---

# `new()`

Connects to a local or remote database endpoint.

```rust title="Method Syntax"
Surreal::new::<T>(address)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>endpoint</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database endpoint to connect to.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

#### Basic example

```rust
use surrealdb::engine::remote::ws::Ws;
use surrealdb::Surreal;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;
    Ok(())
}
```

#### Configuring the database

The `new()` function takes an argument of [`impl IntoEndpoint`](https://docs.rs/surrealdb/latest/surrealdb/opt/trait.IntoEndpoint.html#foreign-impls), which is implemented not only for strings and string-like structs like [`PathBuf`](https://doc.rust-lang.org/std/path/struct.PathBuf.html) and [`SocketAddr`](https://doc.rust-lang.org/std/net/enum.SocketAddr.html), but also a tuple of one of these types for the address along with a second [`Config`](https://docs.rs/surrealdb/latest/surrealdb/opt/struct.Config.html) struct for the configuration.

```rust title="Example with all capabilities enabled except one function"
#[tokio::main]
async fn main() -> Result<(), Error> {
    let config = Config::default()
        .capabilities(Capabilities::all().with_deny_function("math::abs")?);
    let db = connect(("mem://", config)).await?;

    db.use_ns("ns").use_db("db").await?;

    // Result: Err(Db(FunctionNotAllowed("math::abs")))
    println!("{:?}", db.query("math::abs(-10)").await?);
    println!("{:?}", db.run::<i32>("math::abs").args(-10).await);

    Ok(())
}
```

#### Using SurrealKV with versioning

To make a new connection that includes SurrealKV versioning, add the "surreal-kv" feature flag to the `surrealdb` dependency in `Cargo.toml`, add the path to the folder containing the database inside `new()`, and call the `.versioned()` method.

```rust
use surrealdb::engine::local::SurrealKv;
use surrealdb::Surreal;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<SurrealKv>("path/to/database-folder").versioned().await?;
    Ok(())
}
```

### See also

* [.new() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.new)


================================================
FILE: src/content/doc-sdk-rust/methods/query.mdx
================================================
---
sidebar_position: 13
sidebar_label: query
title: Query Method in Rust | Rust SDK | Integration | SurrealDB
description: The .query() method for the SurrealDB Rust SDK runs one or more SurrealQL statements against the database.
---

# `query()`

Runs one or more SurrealQL statements against the database.

```rust title="Method Syntax"
db.query(query)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>query</code>
            </td>
            <td colspan="2" scope="row" data-label="Type">
                <code>query</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

The `.query()` method serves as a default way to pass queries into the Rust SDK. The simplest usage of this method is by passing in a `&str` and returning a [`Response`](https://docs.rs/surrealdb/latest/surrealdb/struct.Response.html).

```rust
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("ws://localhost:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    let query = r#"
        LET $data = ["J. Jonah Jameson", "James Earl Jones"];
        RETURN $data.map(|$name| {
            LET $names = $name.split(' ');
            {
                first_name:  $names[0],
                middle_name: $names[1],
                last_name:   $names[2]
            }
        });
    "#;

    let result = db.query(query).await?;
    println!("Number of statements: {}", result.num_statements());
    dbg!(result);
    Ok(())
}
```

The `.take()` method can be used to pull out one of the responses into a deserialized format. Note that in the next example the `LET` statement is the first statement received by the database, and thus `.take(1)` is used to grab the output of the second statement to deserialize into a `Person` struct.

```rust
use serde::Deserialize;
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;

#[derive(Debug, Deserialize)]
struct Person {
    first_name: String,
    middle_name: String,
    last_name: String,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("ws://localhost:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    let query = r#"
    LET $data = ["J. Jonah Jameson", "James Earl Jones"];
    RETURN $data.map(|$name| {
    LET $names = $name.split(' ');
    {
       first_name:  $names[0],
       middle_name: $names[1],
       last_name:   $names[2]
    }
    });"#;

    let mut result = db.query(query).await?;
    let people: Vec<Person> = result.take(1)?;
    dbg!(people);
    Ok(())
}
```

The return value from this method is `Result<Response, Error>`. A `Result::Ok(Response)` only means that the query or queries were successfully executed, but does not mean that each query contained in the `Response` was successful.

Take the following code for example which contains one successful query, followed by one with incorrect syntax (an integer where a string is expected).

```rust
use surrealdb::engine::any::connect;

#[tokio::main]
async fn main() {
    let db = connect("memory").await.unwrap();
    let res = db.query("
        LET $x = 9;
        LET $x: string = 9") // valid SurrealQL but wrong type
        .await;
    println!("{res:?}");
}
```

The `.query()` method returns an `Ok(Response)`, showing that the database was able to understand and process the queries, even though the latter returned an error.

```
Ok(Response { results: {0: (Stats { execution_time: Some(197.875µs) }, Ok(None)), 1: (Stats { execution_time: Some(207.625µs) }, Err(Db(SetCheck { value: "9", name: "x", check: "string" })))}, live_queries: {} })
```

But if the function contains input that the database is unable to parse into a query in the first place, an `Err` will be returned for the entire `.query()` call.
If the `string` syntax is changed to something nonsensical like `Hi how are you?`, the database is unable to process the query in the first place and `.query()` will return an `Err` for the whole call.

```rust
use surrealdb::engine::any::connect;

#[tokio::main]
async fn main() {
    let db = connect("memory").await.unwrap();
    let res = db.query("
        LET $x = 9;
        Hi how are you?;") // invalid SurrealQL
        .await;
    println!("{res:?}");
}
```

```
Err(Db(InvalidQuery(RenderedError { errors: ["Unexpected token `an identifier`, expected Eof"], snippets: [Snippet { source: "LET $x = 9; Hi how are you?", truncation: None, location: Location { line: 1, column: 16 }, offset: 15, length: 3, label: None, kind: Error }] })))
```

The `Response` struct contains helper metods such as [`.check()`](https://docs.rs/surrealdb/latest/surrealdb/struct.Response.html#method.check) to check for errors, or [`.take_errors()`](https://docs.rs/surrealdb/latest/surrealdb/struct.Response.html#method.take_errors) which removes the errors from the main `Response`.

```rust
use surrealdb::engine::any::connect;

#[tokio::main]
async fn main() {
    let db = connect("memory").await.unwrap();
    db.use_ns("ns").use_db("db").await.unwrap();
    let mut res = db
        .query(
        "LET $x = 9;
        LET $x: string = 9;
        LET $x: bool = 9;
        CREATE person",
        )
        .await
        .unwrap();

    println!("Errors: {:?}\n", res.take_errors());
    println!("Successes: {:?}", res);
}
```

Output:

```
Errors: {1: Db(SetCheck { value: "9", name: "x", check: "string" }), 2: Db(SetCheck { value: "9", name: "x", check: "bool" })}

Successes: Response { results: {0: (Stats { execution_time: Some(143.458µs) }, Ok(None)), 3: (Stats { execution_time: Some(1.463583ms) }, Ok(Array(Array([Object(Object({"id": RecordId(RecordId { table: "person", key: String("aokn0fp36pmqlxprjhre") })}))]))))}, live_queries: {} }
```

### Security when using the .query() method

As the `.query()` method can be used to pass any SurrealQL query on to the database, it is an easy go-to when using complex queries. However, be sure to keep [the following best practices in mind](/docs/surrealdb/reference-guide/security-best-practices#query-safety) when doing so.

<blockquote>
When using SurrealDB as a traditional backend database, your application will usually build SurrealQL queries that may need to contain some untrusted input, such as that provided by the users of your application. To do so, SurrealDB offers bind as a method to query, which should always be used when including untrusted input into queries. Otherwise, SurrealDB will be unable to separate the actual query syntax from the user input, resulting in the well-known SQL injection vulnerabilities. This practice is known as prepared statements or parameterised queries.
</blockquote>

Thus, instead of using user input to directly construct a string:

```rust
let bad_sql = format!("
CREATE {user_input};
SELECT * FROM {user_input};");
```

You can insert a parameter using SurrealQL's `$` parameter syntax,

```rust
let sql = "
    CREATE person;
    SELECT * FROM type::table($table);
";
```

And then apply the `.bind()` method to pass the parameter in.

```rust
use serde::Deserialize;
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;
use surrealdb::RecordId;

#[derive(Debug, Deserialize)]
struct Person {
    id: RecordId,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("ws://localhost:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    let sql = "
        CREATE person;
        SELECT * FROM type::table($table);
    ";
    let mut result = db.query(sql).bind(("table", "person")).await?;
    // Get the first result from the first query
    let created: Option<Person> = result.take(0)?;
    dbg!(created);
    // Get all of the results from the second query
    let people: Vec<Person> = result.take(1)?;
    dbg!(people);
    Ok(())
}
```

### See also

* [.query() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.query)


================================================
FILE: src/content/doc-sdk-rust/methods/run.mdx
================================================
---
sidebar_position: 14
sidebar_label: run
title: Run Method in Rust | Rust SDK | Integration | SurrealDB
description: The .run() method for the SurrealDB Rust SDK runs a SurrealQL function.
---

# `run()`

Runs a SurrealQL function.

```rust title="Method Syntax"
db.run(function)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>function</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the path of the function.
            </td>
        </tr>
    </tbody>
</table>


### Example usage

Calling an existing SurrealQL function:

```rust
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("ws://localhost:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    let res: f32 = db.run("rand::float").await?;
    dbg!(res);
    Ok(())
}
```

User-defined functions can be called as well.

```rust
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("ws://localhost:8000").await?;
    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;
    db.use_ns("ns").use_db("db").await?;

    db.query("DEFINE FUNCTION fn::return_one() -> int { RETURN 1 };")
        .await?;

    let res: i32 = db.run("fn::return_one").await?;
    dbg!(res);
    Ok(())
}
```

The return value of the `.run()` function can be deserialized in the same way as any other database function.

```rust
use serde::Deserialize;
use surrealdb::engine::any::connect;
use surrealdb::opt::auth::Root;

#[derive(Debug, Deserialize)]
struct Person {
    first_name: String,
    middle_name: String,
    last_name: String,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("ws://localhost:8000").await?;
    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;
    db.use_ns("ns").use_db("db").await?;

    db.query(
        "DEFINE FUNCTION fn::j_jonah_jameson() -> object { RETURN 
        { 
          first_name: 'J',
          middle_name: 'Jonah',
          last_name: 'Jameson'
        } 
    };",
    )
    .await?;

    let res: Person = db.run("fn::j_jonah_jameson").await?;
    dbg!(res);
    Ok(())
}
```

### See also

* [.run() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.run)


================================================
FILE: src/content/doc-sdk-rust/methods/select-live.mdx
================================================
---
sidebar_position: 15
sidebar_label: select_live
title: Live Select Method in Rust | Rust SDK | Integration | SurrealDB
description: The .select().live() methods for the SurrealDB Rust SDK initiate live queries for a live stream of notifications.
---

# `select().live()`

Initiate live queries for a live stream of notifications.

```rust title="Method Syntax"
db.select(resource).live()
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>resource</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a record ID to select.
            </td>
        </tr>
    </tbody>
</table>

### Example usage: Listen for live updates

The following example requires adding the `futures` crate with `cargo add futures` in order to work with the results of the async stream. Once run, the program will continue to wait and listen for events for the `person` table to happen.

```rust
use futures::StreamExt;
use serde::Deserialize;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::{Notification, Surreal};
use surrealdb::RecordId;

#[derive(Debug, Deserialize)]
struct Person {
    id: RecordId,
}

// Handle the result of the live query notification
fn handle(result: Result<Notification<Person>, surrealdb::Error>) {
    println!("Received notification: {:?}", result);
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    // Select the "person" table and listen for live updates.
    let mut stream = db.select("person").live().await?;

    // Process updates as they come in.
    while let Some(result) = stream.next().await {
        // Do something with the notification
        handle(result);
    }
    Ok(())
}
```

Then connect to it using Surrealist or open a new terminal window with the following command.

```
surreal sql --namespace ns --database db --user root --pass secret --pretty
```

You can then use queries like the following to work with some `person` records.

```surql
CREATE person;
UPDATE person SET is_nice_person = true;
DELETE person;
```

The following output will then show up in the terminal window running the Rust example.

```
Received notification: Ok(Notification { query_id: b55d31dc-e657-4a6b-a32b-f5abed4ef459, action: Create, data: Person { id: RecordId { table: "person", key: String("334mabva9ibitsypabm5") } } })
Received notification: Ok(Notification { query_id: b55d31dc-e657-4a6b-a32b-f5abed4ef459, action: Update, data: Person { id: RecordId { table: "person", key: String("334mabva9ibitsypabm5") } } })
Received notification: Ok(Notification { query_id: b55d31dc-e657-4a6b-a32b-f5abed4ef459, action: Delete, data: Person { id: RecordId { table: "person", key: String("334mabva9ibitsypabm5") } } })
```

### See also

* [.live() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/method/struct.Select.html#method.live)


================================================
FILE: src/content/doc-sdk-rust/methods/select.mdx
================================================
---
sidebar_position: 16
sidebar_label: select
title: Select Method in Rust | Rust SDK | Integration | SurrealDB
description: The .select() method for the SurrealDB Rust SDK selects all or specific records from the database.
---

# `select()`

import Label from "@components/shared/Label.astro";

Selects all records in a table, or a specific record, from the database.

```rust title="Method Syntax"
db.select(resource)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>resource</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a record ID to select.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```rust
// Select all records from a table
let people: Vec<Person> = db.select("person").await?;
// Select a specific record from a table
let person: Option<Person> = db.select(("person", "h5wxrf2ewk8xjxosxtyc")).await?;
```

### Example usage: Retrieve unique id of a record
```rust
use serde::Deserialize;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::RecordId;
use surrealdb::Surreal;

#[derive(Debug, Deserialize)]
struct Person {
	id: RecordId,
	name: String,
	age: u8,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
	// Connect to the database
	let db = Surreal::new::<Ws>("localhost:8000").await?;

	// Sign in
	db.signin(Root {
		username: "root",
		password: "secret",
	})
	.await?;

	// Select namespace and database to use
	db.use_ns("namespace").use_db("database").await?;

	// Create a person
	db.query("CREATE person:john SET name = 'John Doe', age = 25").await?.check()?;

	// Query that person
	let john: Option<Person> = db.select(("person", "john")).await?;
	dbg!(john);

	Ok(())
}
```

### Translated query
This function will run the following query in the database:

```surql
SELECT * FROM $resource;
```

### See also

* [.select() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.select)


================================================
FILE: src/content/doc-sdk-rust/methods/set.mdx
================================================
---
sidebar_position: 17
sidebar_label: set
title: Set Method in Rust | Rust SDK | Integration | SurrealDB
description: The .set() method for the SurrealDB Rust SDK assigns a value as a parameter for this connection.
---

# `set()`

import Label from "@components/shared/Label.astro";

Assigns a value as a parameter for this connection.

```rust title="Method Syntax"
db.set(key, value)
```

This is equivalent to using a [`LET`](/docs/surrealql/statements/let) statement in SurrealQL, such as this one.

```surql
LET $name = {
    first: "Tobie",
    last: "Morgan Hitchcock",
};
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>key</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>val</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns the value to the variable name.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```rust
use serde::Serialize;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::Surreal;

#[derive(Debug, Serialize)]
struct Name<'a> {
    first: &'a str,
    last: &'a str,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    // Assign the variable on the connection
    db.set(
        "name",
        Name {
            first: "Tobie",
            last: "Morgan Hitchcock",
        },
    )
    .await?;
    // Use the variable in a subsequent query
    let create = db.query("CREATE person SET name = $name").await?;
    dbg!(create);
    // Use the variable in a subsequent query
    let select = db
        .query("SELECT * FROM person WHERE name.first = $name.first")
        .await?;
    dbg!(select);
    Ok(())
}
```

### See also

* [.set() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.set)


================================================
FILE: src/content/doc-sdk-rust/methods/signin.mdx
================================================
---
sidebar_position: 18
sidebar_label: signin
title: Signin Method in Rust | Rust SDK | Integration | SurrealDB
description: The .signin() method for the SurrealDB Rust SDK signs in to a specific access method.
---

# `signin()`

import Label from "@components/shared/Label.astro";

Signs in to a specific access method.

```rust title="Method Syntax"
db.signin(credentials)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>credentials</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Variables used in a signin query.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```rust
// Use the following statement to set up the access
//
// DEFINE ACCESS account ON DATABASE TYPE RECORD
// 	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
// 	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
// 	DURATION FOR TOKEN 15m, FOR SESSION 12h
// ;

use serde::Serialize;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Record;
use surrealdb::Surreal;

#[derive(Serialize)]
struct Credentials<'a> {
    email: &'a str,
    pass: &'a str,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;
    let jwt = db
        .signin(Record {
            namespace: "test",
            database: "test",
            access: "account",
            params: Credentials {
                email: "info@surrealdb.com",
                pass: "123456",
            },
        })
        .await?;

    // ⚠️: It is important to note that the token should be handled securely and protected from unauthorized access.
    let token = jwt.as_insecure_token();
    dbg!(token);
    Ok(())
}
```

### See also

* [.signin() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.signin)


================================================
FILE: src/content/doc-sdk-rust/methods/signup.mdx
================================================
---
sidebar_position: 19
sidebar_label: signup
title: Signup Method in Rust | Rust SDK | Integration | SurrealDB
description: The .signup() method for the SurrealDB Rust SDK signs up to a specific access method.
---

# `signup()`

Signs up as a record user (formerly known as a scope user) to a specific access method.

```rust title="Method Syntax"
db.signup(credentials)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>credentials</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Variables used in a signup query.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```rust
// Use the following statement to set up the access
// 
//  DEFINE ACCESS account ON DATABASE TYPE RECORD
// 	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
// 	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
// 	DURATION FOR TOKEN 15m, FOR SESSION 12h
// ;

use serde::Serialize;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Record;
use surrealdb::Surreal;

#[derive(Serialize)]
struct Credentials<'a> {
    email: &'a str,
    pass: &'a str,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;
    let jwt = db
        .signup(Record {
            namespace: "test",
            database: "test",
            access: "account",
            params: Credentials {
                email: "info@surrealdb.com",
                pass: "123456",
            },
        })
        .await?;

    // ⚠️: It is important to note that the token should be handled securely and protected from unauthorized access.
    let token = jwt.as_insecure_token();
    dbg!(token);
    Ok(())
}
```

### See also

* [.signup() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.signup)


================================================
FILE: src/content/doc-sdk-rust/methods/unset.mdx
================================================
---
sidebar_position: 20
sidebar_label: unset
title: Unset Method in Rust | Rust SDK | Integration | SurrealDB
description: The .unset() method for the SurrealDB Rust SDK removes a parameter from the connection.
---

# `unset()`

Removes a parameter from this connection.

```rust title="Method Syntax"
db.unset(key)
```

### Example usage

```rust
use serde::Serialize;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::Surreal;

#[derive(Debug, Serialize)]
struct Name<'a> {
    first: &'a str,
    last: &'a str,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    // Assign the variable on the connection
    db.set(
        "name",
        Name {
            first: "Tobie",
            last: "Morgan Hitchcock",
        },
    )
    .await?;
    dbg!(db.query("RETURN $name").await?);

    db.unset("name").await?;
    // Aaaand now it's gone
    dbg!(db.query("RETURN $name").await?);
    Ok(())
}
```

### See also

* [.unset() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.unset)


================================================
FILE: src/content/doc-sdk-rust/methods/update.mdx
================================================
---
sidebar_position: 21
sidebar_label: update
title: Update Method in Rust | Rust SDK | Integration | SurrealDB
description: The .update() method for the SurrealDB Rust SDK updates all or specific records in the database.
---

# `update()`

Update all or specific records in the database.

```rust title="Method Syntax"
db.update(resource)
```

The `.update()` method is followed by second method that refers to the type of update to use: an update with `.content()`, `.merge()`, or `.patch()`.

## `.update().content()`

Updates all records in a table, or a specific record, in the database.

```rust title="Method Syntax"
db.update(resource).content(data)
```

> [!NOTE]
> This function replaces the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>resource</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>data</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::Surreal;

#[derive(Debug, Serialize, Deserialize, Default)]
struct Person {
    name: Option<String>,
    company: Option<String>,
    settings: Option<Settings>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Settings {
    active: bool,
    marketing: bool,
}

#[derive(Debug, Serialize)]
struct Company {
    company: String,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    db.query("CREATE person:tobie, person:jaime").await?;

    // Update all records in a table
    let people: Vec<Person> = db
        .update("person")
        .content(Company {
            company: "SurrealDB".into(),
        })
        .await?;
    dbg!(people);
    Ok(())
}
```

### Translated query
This function will run the following query in the database:

```surql
UPDATE $resource CONTENT $data;
```

## `.update().merge()`

Modifies all records in a table, or a specific record, in the database.

```rust title="Method Syntax"
db.update(resource).merge(data)
```

> [!NOTE]
> This function merges the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>resource</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>data</code>
            </td>
            <td colspan="2" scope="row" data-label="Type">
                <code>resource</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::Surreal;

#[derive(Debug, Serialize, Deserialize, Default)]
struct Person {
    name: String,
    company: Option<String>,
    active: Option<bool>,
    marketing: Option<bool>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Settings {
    active: bool,
    marketing: bool,
}

#[derive(Debug, Serialize)]
struct Company {
    company: String,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    db.query("CREATE person:tobie SET name = 'Tobie'; CREATE person:jaime SET name = 'jaime';")
        .await?;

    // Update all records in a table
    let people: Vec<Person> = db
        .update("person")
        .merge(Company {
            company: "SurrealDB".into(),
        })
        .await?;
    dbg!(people);

    // Update a single record
    let person: Option<Person> = db
        .update(("person", "jaime"))
        .merge(Settings {
            active: true,
            marketing: true,
        })
        .await?;
    dbg!(person);
    Ok(())
}
```

### Translated query
This function will run the following query in the database:

```surql
UPDATE $resource MERGE $data;
```

## `.update().patch()`

Applies JSON Patch changes to all records, or a specific record, in the database.

```rust title="Method Syntax"
db.update(resource).patch(patch_op)
```

> [!NOTE]
> This function patches the current document / record data with the specified JSON Patch data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>resource</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to modify.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>data</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The JSON Patch data with which to modify the records.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

The `.patch()` method uses a struct called a `PatchOp` that contains the four methods `add()`, `change()`, `remove()`, and `replace()`. Each of these methods takes different arguments depending on the operation. For example, `PathOp::remove()` only takes a single argument (a path), while `PathOp::replace()` takes a second value for the replacement value.

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::opt::PatchOp;
use surrealdb::sql::Datetime;
use surrealdb::Surreal;

#[derive(Debug, Serialize, Deserialize, Default)]
struct Person {
    name: String,
    company: Option<String>,
    settings: Option<Settings>,
    created_at: Option<Datetime>,
    tags: Option<Vec<String>>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Settings {
    active: bool,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    db.query(
        "
        CREATE person:tobie SET name = 'Tobie', company = 'SurrealDB'; 
        CREATE person:jaime SET name = 'jaime', company = 'SurrealDB';",
    )
    .await?;

    // Update all records in a table
    let people: Vec<Person> = db
        .update("person")
        .patch(PatchOp::replace("/created_at", Datetime::default()))
        .await?;
    dbg!(people);

    // Update a record with a specific ID
    let person: Option<Person> = db
        .update(("person", "tobie"))
        .patch(PatchOp::replace("/settings/active", false))
        .patch(PatchOp::add("/tags", &["developer", "engineer"]))
        .patch(PatchOp::remove("/company"))
        .await?;
    dbg!(person);
    Ok(())
}
```

### Translated query
This function will run the following query in the database:

```surql
UPDATE $resource PATCH $data;
```

### See also

* [.update() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.update)


================================================
FILE: src/content/doc-sdk-rust/methods/upsert.mdx
================================================
---
sidebar_position: 22
sidebar_label: upsert
title: Upsert Method in Rust | Rust SDK | Integration | SurrealDB
description: The .upsert() method for the SurrealDB Rust SDK upserts all or specific records in a table.
---

# `upsert()`

Upserts all records in a table, or a specific record.

```rust title="Method Syntax"
db.upsert(resource)
```

The `.upsert()` method is followed by second method that refers to the type of upsert to use: an upsert with `.content()`, `.merge()`, or `.patch()`.

## `.upsert().content()`

Upserts all records in a table, or a specific record, in the database.

```rust title="Method Syntax"
db.upsert(resource).content(data)
```

> [!NOTE]
> This function replaces the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>resource</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>data</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::RecordId;
use surrealdb::Surreal;

#[derive(Debug, Serialize, Deserialize)]
struct Person {
    id: RecordId,
    name: Option<String>,
    company: Option<String>,
    settings: Option<Settings>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Settings {
    active: bool,
    marketing: bool,
}

#[derive(Debug, Serialize)]
struct Company {
    company: String,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    // upsert one record in a table
    let person: Option<Person> = db
        .upsert(("person", "jaime"))
        .content(Company {
            company: "SurrealDB".into(),
        })
        .await?;
    dbg!(person);
    Ok(())
}
```

### Translated query
This function will run the following query in the database:

```surql
upsert $resource CONTENT $data;
```

## `.upsert().merge()`

Modifies all records in a table, or a specific record, in the database.

```rust title="Method Syntax"
db.upsert(resource).merge(data)
```

> [!NOTE]
> This function merges the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>resource</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>data</code>
            </td>
            <td colspan="2" scope="row" data-label="Type">
                <code>resource</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::Surreal;

#[derive(Debug, Serialize, Deserialize, Default)]
struct Person {
    name: String,
    company: Option<String>,
    active: Option<bool>,
    marketing: Option<bool>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Settings {
    active: bool,
    marketing: bool,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    // upsert a single record
    let person: Option<Person> = db
        .upsert(("person", "tobie"))
        .merge(Person {
            name: "Tobie".into(),
            ..Default::default()
        })
        .await?;

    dbg!(person);
    Ok(())
}
```

### Translated query
This function will run the following query in the database:

```surql
upsert $resource MERGE $data;
```

## `.upsert().patch()`

Applies JSON Patch changes to all records, or a specific record, in the database.

```rust title="Method Syntax"
db.upsert(resource).patch(patch_op)
```

> [!NOTE]
> This function patches the current document / record data with the specified JSON Patch data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>resource</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to modify.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>data</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The JSON Patch data with which to modify the records.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

The `.patch()` method uses a struct called a `PatchOp` that contains the four methods `add()`, `change()`, `remove()`, and `replace()`. Each of these methods takes different arguments depending on the operation. For example, `PathOp::remove()` only takes a single argument (a path), while `PathOp::replace()` takes a second value for the replacement value.

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::opt::PatchOp;
use surrealdb::sql::Datetime;
use surrealdb::Surreal;

#[derive(Debug, Serialize, Deserialize, Default)]
struct Person {
    name: String,
    company: Option<String>,
    settings: Option<Settings>,
    created_at: Option<Datetime>,
    tags: Option<Vec<String>>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Settings {
    active: bool,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;

    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await?;

    db.use_ns("ns").use_db("db").await?;

    // upsert a record with a specific ID
    let person: Option<Person> = db
        .upsert(("person", "tobie"))
        .patch(PatchOp::replace("/settings/active", false))
        .patch(PatchOp::add("/tags", &["developer", "engineer"]))
        .patch(PatchOp::remove("/company"))
        .await?;
    dbg!(person);
    Ok(())
}
```

### Translated query
This function will run the following query in the database:

```surql
UPSERT $resource PATCH $data;
```

### See also

* [.upsert() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.upsert)


================================================
FILE: src/content/doc-sdk-rust/methods/use.mdx
================================================
---
sidebar_position: 23
sidebar_label: db.use_ns().use_db()
title: Use Method in Rust | Rust SDK | Integration | SurrealDB
description: The .use_ns() and .use_db() methods for the SurrealDB Rust SDK switch to a specific namespace and database.
---

# `use_ns()`, `use_db()`

Switch to a specific namespace and database.

```rust title="Method Syntax"
db.use_ns(ns).use_db(db)
```

### Arguments

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>ns</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Switches to a specific namespace.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>db</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Switches to a specific database.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
use surrealdb::engine::remote::ws::Ws;
use surrealdb::Surreal;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;
    db.use_ns("ns").use_db("db").await?;
    Ok(())
}
```

### See also

* [.use_db() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.use_db)
* [.use_ns() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.use_ns)


================================================
FILE: src/content/doc-sdk-rust/methods/version.mdx
================================================
---
sidebar_position: 24
sidebar_label: version
title: Version Method in Rust | Rust SDK | Integration | SurrealDB
description: The .version() method for the SurrealDB Rust SDK returns the version of the server.
---

# `version()`

Returns the version of the server.

```rust title="Method Syntax"
db.version()
```

### Example usage

```rust
use surrealdb::engine::any::connect;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = connect("ws://localhost:8000").await?;

    println!("{:?}", db.version().await?);
    Ok(())
}
```

The function resolves to a [`Version`](https://docs.rs/semver/latest/semver/struct.Version.html) struct as defined in the `semver` crate. Output of the above example in October 2024:

```
Version { major: 2, minor: 0, patch: 3 }
```

### See also

* [.version() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.version)


================================================
FILE: src/content/doc-sdk-rust/methods/wait-for.mdx
================================================
---
sidebar_position: 25
sidebar_label: wait_for
title: Wait for Method in Rust | Rust SDK | Integration | SurrealDB
description: The .wait_for() method for the SurrealDB Rust SDK waits for the selected event to happen before proceeding.
---

# `wait_for()`

Wait for the selected event to happen before proceeding.

```rust title="Method Syntax"
db.wait_for(event)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Argument</th>
            <th colspan="2" scope="col">Type</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>event</code>
            </td>
            <td colspan="2" scope="row" data-label="Type">
                <code>WaitFor</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The event to wait for before proceeding.
            </td>
        </tr>
    </tbody>
</table>

`WaitFor` is a simple enum with two variants representing the event to wait for.

```rust
pub enum WaitFor {
    Connection,
    Database,
}
```

### Example usage

The following test from the source code demonstrates the behaviour of the `.wait_for_()` method in a variety of situations.

```rust
use std::task::Poll;

use surrealdb::engine::remote::ws::{Client, Ws};
use surrealdb::opt::auth::Root;
use surrealdb::opt::WaitFor::{Connection, Database};
use surrealdb::Surreal;

use futures::poll;
use std::pin::pin;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {

    // Create an unconnected client
    // At this point wait_for should continue to wait for both the connection and database selection.
    let db: Surreal<Client> = Surreal::init();
    assert_eq!(poll!(pin!(db.wait_for(Connection))), Poll::Pending);
    assert_eq!(poll!(pin!(db.wait_for(Database))), Poll::Pending);

    // Connect to the server
    // The connection event should fire and allow wait_for to return immediately when waiting for a connection.
    // When waiting for a database to be selected, it should continue waiting.
    db.connect::<Ws>("127.0.0.1:8000").await.unwrap();
    assert_eq!(poll!(pin!(db.wait_for(Connection))), Poll::Ready(()));
    assert_eq!(poll!(pin!(db.wait_for(Database))), Poll::Pending);

    // Sign into the server
    // At this point the connection has already been established but the database hasn't been selected yet.
    db.signin(Root {
        username: "root",
        password: "secret",
    })
    .await
    .unwrap();
    assert_eq!(poll!(pin!(db.wait_for(Connection))), Poll::Ready(()));
    assert_eq!(poll!(pin!(db.wait_for(Database))), Poll::Pending);

    // Selecting a namespace shouldn't fire the database selection event.
    db.use_ns("namespace").await.unwrap();
    assert_eq!(poll!(pin!(db.wait_for(Connection))), Poll::Ready(()));
    assert_eq!(poll!(pin!(db.wait_for(Database))), Poll::Pending);

    // Select the database to use
    // Both the connection and database events have fired, wait_for should return immediately for both.
    db.use_db("database").await.unwrap();
    assert_eq!(poll!(pin!(db.wait_for(Connection))), Poll::Ready(()));
    assert_eq!(poll!(pin!(db.wait_for(Database))), Poll::Ready(()));
    Ok(())
}
```

### See also

* [.wait_for() method on Docs.rs](https://docs.rs/surrealdb/latest/surrealdb/struct.Surreal.html#method.wait_for)


================================================
FILE: src/content/doc-surrealdb/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Overview
title: SurrealDB
description: SurrealDB makes building and scaling realtime apps dramatically quicker and easier. Get started by installing the server and jump into our getting started guide.
no_page_headings: true
---

import { Icon } from 'astro-icon/components';
import Image from "@components/Image.astro";
import Check from "@components/Check.astro";
import IconBox from '@components/boxes/IconBox.astro';
import Boxes from '@src/components/boxes/Boxes.astro';
import BasicBox from '@src/components/boxes/BasicBox.astro';
import BaseLayout from '@src/components/layout/BaseLayout.astro';

import Logo from "@img/icon/dark/surrealdb.png";
import DarkLabs from '@img/logo/dark/labs.svg';
import LightLabs from '@img/logo/light/labs.svg';

import LightGettingStarted from "@img/image/light/gettingstarted.png";
import DarkGettingStarted from "@img/image/dark/gettingstarted.png";

import LightSidekick from '@img/icon/light/sidekick-light.png';
import DarkSidekick from '@img/icon/dark/sidekick.png';

import LightDeployment from '@img/icon/light/deployment-light.png';
import DarkDeployment from '@img/icon/dark/deployment.png';

import EmbeddingLight from '@img/icon/light/embeddingg-light.png';
import EmbeddingDark from '@img/icon/dark/embeddingg.png';

import CLIlight from '@img/icon/light/clisdb-light.png';
import CLIdark from '@img/icon/dark/clisdb.png';

import ReferenceLight from '@img/icon/light/reference-guides-light.png';
import ReferenceDark from '@img/icon/dark/reference-guides.png';

import CBORDark from '@img/icon/dark/cbor.png';
import CBORLight from '@img/icon/light/cbor-light.png';

import LightDotnet from '@img/icon/light/dotnet.png';
import LightGolang from '@img/icon/light/golang.png';
import LightJava from '@img/icon/light/java.png';
import LightJavascript from '@img/icon/light/javascript.png';
import LightNodejs from '@img/icon/light/nodejs.png';
import LightPhp from '@img/icon/light/php.png';
import LightPython from '@img/icon/light/python.png';
import LightRust from '@img/icon/light/rust.png';
import LightWasm from '@img/icon/light/webassembly.png';

import LightIntegrations from '@img/icon/dark/integrations.png';
import DarkIntegrations from '@img/icon/dark/integrations.png';
import LightCloud from '@img/icon/light/cloud-light.png';
import DarkCloud from '@img/icon/dark/cloud.png';

import DarkDotnet from '@img/icon/dark/dotnet.png';
import DarkGolang from '@img/icon/dark/golang.png';
import DarkJava from '@img/icon/dark/java.png';
import DarkJavascript from '@img/icon/dark/javascript.png';
import DarkNodejs from '@img/icon/dark/nodejs.png';
import DarkPhp from '@img/icon/dark/php.png';
import DarkPython from '@img/icon/dark/python.png';
import DarkRust from '@img/icon/dark/rust.png';
import DarkWasm from '@img/icon/dark/webassembly.png';

import LightBook from '@img/icon/light/book-light.png';
import LightSurrealist from '@img/icon/light/surrealist-light.png';
import LightUniversity from '@img/icon/light/university-light.png';

import DarkBook from '@img/icon/dark/book.png';
import DarkSurrealist from '@img/icon/dark/surrealist.png';
import DarkUniversity from '@img/icon/dark/university.png';

import LightSurrealKV from '@img/icon/light/kv.png';
import LightSurrealML from '@img/icon/light/ml-light.png';
import LightSurrealQL from '@img/icon/light/ql-light.png';
import LightSurrealDB from '@img/icon/light/surrealdb.png';

import DarkSurrealKV from '@img/icon/dark/kv.png';
import DarkSurrealDB from '@img/icon/dark/surrealdb.png';
import DarkSurrealML from '@img/icon/dark/surrealml.png';
import DarkSurrealQL from '@img/icon/dark/surrealql.png';

import DarkDocument from '@img/icon/dark/document.png';
import LightDocument from '@img/icon/light/document-light.png';

import DarkGeospatial from '@img/icon/dark/geospatial.png';
import LightGeospatial from '@img/icon/light/geospatial-light.png';

import DarkTimeSeries from '@img/icon/dark/time-series.png';
import LightTimeSeries from '@img/icon/light/time-series-light.png';

import FullTextSearchDark from '@img/icon/dark/full-text-search.png';
import FullTextSearchLight from '@img/icon/light/full-text-search.png';

import GraphDark from '@img/icon/dark/graph.png';
import GraphLight from '@img/icon/light/graph.png';

import HttpDark from '@img/icon/dark/http.png';
import HttpLight from '@img/icon/light/http-light.png';

import VectorDark from '@img/icon/dark/vector.png';
import VectorLight from '@img/icon/light/vector.png';

import SystemAccessDark from '@img/icon/dark/system-access.png';
import SystemAccessLight from '@img/icon/light/system-access.png';

import TokenAccessDark from '@img/icon/dark/token-access.png';
import TokenAccessLight from '@img/icon/light/token-access.png';

import RecordAccessDark from '@img/icon/dark/record-access.png';
import RecordAccessLight from '@img/icon/light/record-access.png';

import RPCDark from '@img/icon/dark/rpc.png';
import RPCLight from '@img/icon/light/rpc-light.png';

import SidekickDark from '@img/icon/dark/sidekick.png';
import SidekickLight from '@img/icon/light/sidekick-light.png';

import DarkSurreal from '@img/logo/dark/surrealdb.svg';
import LightSurreal from '@img/logo/light/surrealdb.svg';

<div class="flag-title">
	<Image
		class="h-12"
		alt="SurrealDB"
		src={{
			light: LightSurreal,
			dark: DarkSurreal,
		}}
	/>
</div>

SurrealDB is a native, open-source, [multi-model database](/features/multi-model-database) that lets you store and manage data across relational, document, graph, time-series, vector & search, and geospatial models—all in one place.

Powered by a flexible, SQL-like query language called [SurrealQL](/docs/surrealql), you can write queries using familiar syntax while leveraging the capabilities of a modern, unified database. Built to be [distributed and scalable](/docs/surrealdb/introduction/architecture), SurrealDB makes it easy to grow with your application.

You can also interact with SurrealDB through additional query methods like [GraphQL](/docs/surrealdb/querying/graphql), [HTTP](/docs/surrealdb/integration/http), and [RPC](/docs/surrealdb/integration/rpc), or integrate directly using a range of [SDKs](/docs/surrealdb/integration/sdks) in your native development environment.

<div class="flex gap-4 items-center mt-6 mb-16">
	<a
		href="/docs/surrealdb/introduction/start"
		class="gradient-button group"
	>
		Get started with SurrealDB
		<Icon name="fa6-solid:arrow-right" class="w-4 transition-transform group-hover:translate-x-1" />
	</a>
	<a
		href="/docs/surrealdb/installation"
		class="outline-button group"
	>
		Installation guide
		<Icon name="fa6-solid:arrow-right" class="w-4 transition-transform group-hover:translate-x-1" />
	</a>
</div>

# Topics
<Boxes columns={2} wider class="pt-2">
	<IconBox
		title="SurrealDB Cloud "
		subtitle="Managed Cloud Hosting"
		description="Effortlessly deploy, manage, and scale your SurrealDB instances in the cloud."
		href="/docs/cloud"
		icon={{ light: LightCloud, dark: DarkCloud }}
	/>
	<IconBox
		title="Surrealist"
		subtitle="Management Interface"
		description="The official dashboard to query and manage your SurrealDB databases."
		href="/docs/surrealist"
		icon={{ light: LightSurrealist, dark: DarkSurrealist }}
	/>
	<IconBox
		title="SurrealQL"
		subtitle="Query Language"
		description="Discover SurrealQL, a powerful and intuitive SQL-like language built for SurrealDB."
		href="/docs/surrealql"
		icon={{ light: LightSurrealQL, dark: DarkSurrealQL }}
	/>
</Boxes>
	
# Data Models
<Boxes wider class="pt-2">
	<IconBox
		title="Document"
		description="Document database that is designed to make building and scaling realtime apps dramatically quicker and easier."
		href="/docs/surrealdb/models/document"
		icon={{ light: LightDocument, dark: DarkDocument }}
	/>
	<IconBox
		title="Graph"
		description="Graph database that is designed to make building and scaling realtime apps dramatically quicker and easier."
		href="/docs/surrealdb/models/graph"
		icon={{ light: GraphLight, dark: GraphDark }}
	/>
	<IconBox
		title="Vector"
		description="Vector database that is designed to make building and scaling realtime apps dramatically quicker and easier."
		href="/docs/surrealdb/models/vector"
		icon={{ light: VectorLight, dark: VectorDark }}
	/>
	<IconBox
		title="Full-Text Search"
		description="Full-Text Search database that is designed to make building and scaling realtime apps dramatically quicker and easier."
		href="/docs/surrealdb/models/full-text-search"
		icon={{ light: FullTextSearchLight, dark: FullTextSearchDark }}
	/>
	<IconBox
		title="Time Series"
		description="Time Series database that is designed to make building and scaling realtime apps dramatically quicker and easier."
		href="/docs/surrealdb/models/time-series"
		icon={{ light: LightTimeSeries, dark: DarkTimeSeries }}
	/>
	<IconBox
		title="Geospatial"
		description="Geospatial database that is designed to make building and scaling realtime apps dramatically quicker and easier."
		href="/docs/surrealdb/models/geospatial"
		icon={{ light: LightGeospatial, dark: DarkGeospatial }}
	/>
</Boxes>
	
# Integrations
<Boxes columns={3} wider class="pt-2">
	<IconBox
		title="Data Management"
		description="SurrealDB integrates with Airbyte, Fivetran, and more to help you manage your data."
		href="/docs/integrations/data-management"
		icon={{ light: LightIntegrations, dark: DarkIntegrations }}
	/>
	<IconBox
	title="Embeddings"
	description="SurrealDB provides a number of different embeddings features that can be used to manage your data."
	href="/docs/integrations/embeddings"
	icon={{ light: LightIntegrations, dark: DarkIntegrations }}
	/>
	<IconBox
	title="Frameworks"
	description="SurrealDB integrates with a number of different frameworks to help you build your applications."
	href="/docs/integrations/frameworks"
	icon={{ light: LightIntegrations, dark: DarkIntegrations }}
	/>
</Boxes>

# Authentication
<Boxes columns={3} wider class="pt-2">
	<IconBox
		title="System Access"
		description=" System access is used to authenticate and authorize users to access the SurrealDB server."
		href="/docs/surrealdb/security/authentication"
		icon={{ light: SystemAccessLight, dark: SystemAccessDark }}
	/>
	<IconBox
		title="Record Access"
		description="Record access is used to authenticate and authorize users to access the SurrealDB database."
		href="/docs/surrealql/statements/define/access/record"
		icon={{ light: RecordAccessLight, dark: RecordAccessDark }}
	/>
	<IconBox
		title="Token Accesss"
		description="Token access is used to authenticate and authorize users to access the SurrealDB database."
		href="/docs/surrealql/statements/define/access/jwt"
		target="_blank"
		rel="noopener noreferrer"
		icon={{ light: TokenAccessLight, dark: TokenAccessDark }}
	/>
</Boxes>

# Education
<Boxes columns={3} wider class="pt-2">
	<IconBox
		title="SurrealDB University"
		description="Watch videos, live streams, and expert talks to quickly learn key SurrealDB concepts and insights."
		href="/learn"
		icon={{ light: LightUniversity, dark: DarkUniversity }}
	/>
	<IconBox
		title="Aeon's Surreal Renaissance"
		description="Learn SurrealDB through an engaging, story-driven experience that feels like watching a movie."
		href="/learn/book"
		icon={{ light: LightBook, dark: DarkBook }}
	/>
	<IconBox
		title="Surreal Sidekick"
		description="Surreal Sidekick is your go to AI assistant for all things SurrealDB related."
		href="https://app.surrealdb.com/chat"
		target="_blank"
		rel="noopener noreferrer"
		icon={{ light: SidekickLight, dark: SidekickDark }}
	/>
</Boxes>

# SDKs
<Boxes columns={3} wider class="pt-2">
	<IconBox
		title="Rust"
		description="Connect to SurrealDB in Rust applications."
		href="/docs/sdk/rust"
		icon={{ light: LightRust, dark: DarkRust }}
	>
		<Check>HTTP & WebSocket</Check>
		<Check>In-memory and on-disk</Check>
	</IconBox>
	<IconBox
		title="JavaScript"
		description="Connect to SurrealDB from JavaScript environments."
		href="/docs/sdk/javascript"
		icon={{ light: LightJavascript, dark: DarkJavascript }}
	>
		<Check>HTTP & WebSocket</Check>
	</IconBox>
	<IconBox
		title="Node.js"
		description="Node.js adapter for the JavaScript SDK."
		href="/docs/sdk/javascript/engines/node"
		icon={{ light: LightNodejs, dark: DarkNodejs }}
	>
		<Check>HTTP & WebSocket</Check>
		<Check>In-memory and on-disk</Check>
	</IconBox>
	<IconBox
		title="WASM"
		description="WebAssembly adapter for the JavaScript SDK."
		href="/docs/sdk/javascript/engines/wasm"
		icon={{ light: LightWasm, dark: DarkWasm }}
	>
		<Check>In-memory and IndexedDB</Check>
	</IconBox>
	<IconBox
		title="Java"
		description="Connect to SurrealDB in Java applications."
		href="/docs/sdk/java"
		icon={{ light: LightJava, dark: DarkJava }}
	>
		<Check>HTTP & WebSocket</Check>
		<Check>In-memory and on-disk</Check>
	</IconBox>
	<IconBox
		title="Golang"
		description="Connect to SurrealDB in Go applications."
		href="/docs/sdk/golang"
		icon={{ light: LightGolang, dark: DarkGolang }}
	>
		<Check>HTTP & WebSocket</Check>
		<Check>In-memory and on-disk</Check>
	</IconBox>
	<IconBox
		title="Python"
		description="Connect to SurrealDB in Python applications."
		href="/docs/sdk/python"
		icon={{ light: LightPython, dark: DarkPython }}
	>
		<Check>HTTP & WebSocket</Check>
		<Check>In-memory and on-disk</Check>
	</IconBox>
	<IconBox
		title=".NET"
		description="Connect to SurrealDB in .NET applications."
		href="/docs/sdk/dotnet"
		icon={{ light: LightDotnet, dark: DarkDotnet }}
	>
		<Check>HTTP & WebSocket</Check>
		<Check>In-memory and on-disk</Check>
	</IconBox>
	<IconBox
		title="PHP"
		description="Connect to SurrealDB in PHP applications."
		href="/docs/sdk/php"
		icon={{ light: LightPhp, dark: DarkPhp }}
	>
		<Check>HTTP & WebSocket</Check>
	</IconBox>
</Boxes>


# Resources
<BasicBox href="/docs/labs" class="group block">
	<Image
		class="block h-5"
		alt="SurrealDB"
		src={{
			light: LightLabs,
			dark: DarkLabs,
		}}
	/>
	<div class="mt-6">
		Dive into the full range of tools, libraries, and integrations built around SurrealDB. SurrealDB Labs brings together first- and third-party resources to help you build, manage, and extend your SurrealDB applications with ease.
	</div>
	<div class="mt-6 flex gap-2 items-center">
		<div class="!text-surreal-pink">Explore SurrealDB Labs</div>
		<Icon name="fa6-solid:arrow-right" class="w-4 text-surreal-pink transition-transform group-hover:translate-x-1" />
	</div>
</BasicBox>


================================================
FILE: src/content/doc-surrealdb/cli/env.mdx
================================================
---
sidebar_position: 13
sidebar_label: Environment variables
title: Environment variables used for SurrealDB
description: A list of the available environment variables used when running SurrealDB.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";
import Since from "@components/shared/Since.astro";

# Environment variables

Environment variables can be used to tailor the behaviour of a running SurrealDB instance.

## SurrealDB environment variables

<table>
  <thead>
    <tr>
      <th scope="col" style={{width: '50%'}}>Environment variable</th>
      <th scope="col" style={{width: '20%'}}>Default value</th>
      <th scope="col" style={{width: '30%'}}>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ACCESSIBLE_OUTPUT</code></td>
      <td scope="row" data-label="Default">false</td>
      <td scope="row" data-label="Notes"><Since v="v3.0.0-alpha.7" /> Displays characters unable to be read by screen readers, braile displays etc. in a more readable way.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_BUCKET_FOLDER_ALLOWLIST</code></td>
      <td scope="row" data-label="Default">empty</td>
      <td scope="row" data-label="Notes">Specifies a list of paths in which files can be accessed.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_BUILD_METADATA</code></td>
      <td scope="row" data-label="Default">false</td>
      <td scope="row" data-label="Notes">The version identifier of this build. Defaults to the CARGO_PKG_VERSION environment variable if not specified.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_CHANGEFEED_GC_INTERVAL</code></td>
      <td scope="row" data-label="Default">10s</td>
      <td scope="row" data-label="Notes">The interval at which to perform changefeed garbage collection.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_COUNT_BATCH_SIZE</code></td>
      <td scope="row" data-label="Default">10,000</td>
      <td scope="row" data-label="Notes"><Since v="v2.2.0" /> The maximum number of keys that should be scanned at once for count queries.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_DATASTORE_CACHE_SIZE</code></td>
      <td scope="row" data-label="Default">1,000</td>
      <td scope="row" data-label="Notes"><Since v="v2.1.0" /> The number of definitions which can be cached across transactions.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_EXPERIMENTAL_GRAPHQL</code></td>
      <td scope="row" data-label="Default">false</td>
      <td scope="row" data-label="Notes">Enables experimental graphql integration. Still under active development. Using this experimental feature may introduce risks related to breaking changes and security issues.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_EXPORT_BATCH_SIZE</code></td>
      <td scope="row" data-label="Default">1000</td>
      <td scope="row" data-label="Notes">The maximum number of keys that should be scanned at once for export queries.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_EXTERNAL_SORTING_BUFFER_LIMIT</code></td>
      <td scope="row" data-label="Default">50000</td>
      <td scope="row" data-label="Notes">Specifies the buffer limit for external sorting.</td>
    </tr>
     <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_FILE_ALLOWLIST</code></td>
      <td scope="row" data-label="Default">20</td>
      <td scope="row" data-label="Notes"><Since v="v2.1.5" /> Limits file access for the mapper filter to only the specified allowed file paths. The paths must be provided as absolute paths, separated by a colon (:) on Unix-like systems or a semicolon (;) on Windows.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_FUNCTION_ALLOCATION_LIMIT</code></td>
      <td scope="row" data-label="Default">20</td>
      <td scope="row" data-label="Notes">Used to limit allocation for builtin functions.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_GLOBAL_BUCKET</code></td>
      <td scope="row" data-label="Default">None</td>
      <td scope="row" data-label="Notes">Specifies the name of a global bucket for file data.</td>
    </tr>
     <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_GENERATION_ALLOCATION_LIMIT</code></td>
      <td scope="row" data-label="Default">20</td>
      <td scope="row" data-label="Notes">Limits memory allocation for certain built-in functions (e.g., string::replace) to avoid uncontrolled memory usage. default is 1,048,576 bytes (computed as 2^20).</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_GLOBAL_BUCKET_ENFORCED</code></td>
      <td scope="row" data-label="Default">false</td>
      <td scope="row" data-label="Notes">Whether to enforce a global bucket for file data.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_HNSW_CACHE_SIZE</code></td>
      <td scope="row" data-label="Default">256 MiB</td>
      <td scope="row" data-label="Notes">The maximum size of the HNSW vector cache.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_HTTP_MAX_API_BODY_SIZE</code></td>
      <td scope="row" data-label="Default">1 MiB</td>
      <td scope="row" data-label="Notes">The maximum HTTP body size of the HTTP /api endpoint.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_HTTP_MAX_IMPORT_BODY_SIZE</code></td>
      <td scope="row" data-label="Default">4398046511104 (4 GiB)</td>
      <td scope="row" data-label="Notes">Maximum HTTP body size of the HTTP /import endpoints</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_HTTP_MAX_KEY_BODY_SIZE</code></td>
      <td scope="row" data-label="Default">16384 (16 KiB)</td>
      <td scope="row" data-label="Notes">Maximum HTTP body size of the HTTP /key endpoints</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_HTTP_MAX_ML_BODY_SIZE</code></td>
      <td scope="row" data-label="Default">4398046511104 (4 GiB)</td>
      <td scope="row" data-label="Notes">Maximum HTTP body size of the HTTP /ml endpoints</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_HTTP_MAX_RPC_BODY_SIZE</code></td>
      <td scope="row" data-label="Default">4194304 (4 MiB)</td>
      <td scope="row" data-label="Notes">Maximum HTTP body size of the HTTP /rpc endpoint.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_HTTP_MAX_SQL_BODY_SIZE</code></td>
      <td scope="row" data-label="Default">1048576 (1 MiB)</td>
      <td scope="row" data-label="Notes">Maximum HTTP body size of the HTTP /sql endpoint</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_HTTP_MAX_SIGNIN_BODY_SIZE</code></td>
      <td scope="row" data-label="Default">1024 (1 KiB)</td>
      <td scope="row" data-label="Notes">The maximum HTTP body size of the HTTP /signin endpoints</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_HTTP_MAX_SIGNUP_BODY_SIZE</code></td>
      <td scope="row" data-label="Default">1024 (1 KiB)</td>
      <td scope="row" data-label="Notes">Maximum HTTP body size of the HTTP /signup endpoint.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_IDIOM_RECURSION_LIMIT</code></td>
      <td scope="row" data-label="Default">256</td>
      <td scope="row" data-label="Notes">The maximum recursive idiom path depth allowed.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_IMPORT_FILE</code></td>
      <td scope="row" data-label="Default">None</td>
      <td scope="row" data-label="Notes">Path to a SurrealQL file that will be imported when starting the server.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_INDEXING_BATCH_SIZE</code></td>
      <td scope="row" data-label="Default">250</td>
      <td scope="row" data-label="Notes">The maximum number of keys to scan at once per concurrent indexing batch.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_INSECURE_FORWARD_ACCESS_ERRORS</code></td>
      <td scope="row" data-label="Default">false</td>
      <td scope="row" data-label="Notes">Forward all signup/signin/authenticate query errors to a client performing authentication. Do not use in production.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_MAX_COMPUTATION_DEPTH</code></td>
      <td scope="row" data-label="Default">120</td>
      <td scope="row" data-label="Notes">/// Specifies how deep recursive computation will go before erroring.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_MAX_CONCURRENT_TASKS</code></td>
      <td scope="row" data-label="Default">64</td>
      <td scope="row" data-label="Notes">Specifies how many concurrent jobs can be buffered in the worker channel.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_MAX_HTTP_REDIRECTS</code></td>
      <td scope="row" data-label="Default">10</td>
      <td scope="row" data-label="Notes"><Since v="v2.0.5" /> The maximum number of HTTP redirects allowed within http functions.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_MAX_OBJECT_PARSING_DEPTH</code></td>
      <td scope="row" data-label="Default">10</td>
      <td scope="row" data-label="Notes">Specifies how deep the parser will parse nested objects and arrays in a query.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_MAX_ORDER_LIMIT_PRIORITY_QUEUE_SIZE</code></td>
      <td scope="row" data-label="Default">1000</td>
      <td scope="row" data-label="Notes"><Since v="v2.2.0" /> The maximum size of the priority queue triggering usage of the priority queue for the result collector.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_MAX_QUERY_PARSING_DEPTH</code></td>
      <td scope="row" data-label="Default">20</td>
      <td scope="row" data-label="Notes">Specifies how deep the parser will parse recursive queries (queries within queries).</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_MAX_STREAM_BATCH_SIZE</code></td>
      <td scope="row" data-label="Default">1000</td>
      <td scope="row" data-label="Notes">The maximum number of keys that should be fetched when streaming range scans in a Scanner.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_MEMORY_THRESHOLD</code></td>
      <td scope="row" data-label="Default"> </td>
      <td scope="row" data-label="Notes"><Since v="v2.1.5" /> Configuring the memory threshold which can be used across the programme to check if the amount of memory available to the programme is lower than required. The value can be specified as bytes (b, or without any suffix), kibibytes (k, kb, or kib), mebibytes (m, mb, or mib), or gibibytes (g, gb, or gib). If the environment variable is not specified, then the threshold is not used, and no memory limit is enabled.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_NET_MAX_CONCURRENT_REQUESTS</code></td>
      <td scope="row" data-label="Default">1,048,576 concurrent requests</td>
      <td scope="row" data-label="Notes">Adds a global limit for concurrent server requests, and introduces a new environment variable</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_NODE_MEMBERSHIP_CHECK_INTERVAL</code></td>
      <td scope="row" data-label="Default">15s</td>
      <td scope="row" data-label="Notes">The interval at which to process and archive inactive nodes.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_NODE_MEMBERSHIP_CLEANUP_INTERVAL</code></td>
      <td scope="row" data-label="Default">300s</td>
      <td scope="row" data-label="Notes">The interval at which to process and cleanup archived nodes.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_NODE_MEMBERSHIP_REFRESH_INTERVAL</code></td>
      <td scope="row" data-label="Default">3s</td>
      <td scope="row" data-label="Notes">The interval at which to refresh node registration information.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_NORMAL_FETCH_SIZE</code></td>
      <td scope="row" data-label="Default">500</td>
      <td scope="row" data-label="Notes">The maximum number of keys that should be scanned at once in general queries.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_REGEX_CACHE_SIZE</code></td>
      <td scope="row" data-label="Default">100</td>
      <td scope="row" data-label="Notes">The number of computed regexes which can be cached in the engine.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_REGEX_SIZE_LIMIT</code></td>
      <td scope="row" data-label="Default">10,485,760</td>
      <td scope="row" data-label="Notes"><Since v="v2.1.5" /> Limits the maximum allowed size (in bytes) for compiled regular expressions. This prevents excessive memory consumption when building complex or very large regex patterns.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_RUNTIME_MAX_BLOCKING_THREADS</code></td>
      <td scope="row" data-label="Default">512</td>
      <td scope="row" data-label="Notes">Number of threads which can be started for blocking operations.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_RUNTIME_STACK_SIZE</code></td>
      <td scope="row" data-label="Default">10485760 (10 MiB)</td>
      <td scope="row" data-label="Notes">Runtime thread memory stack size. Stack size is doubled if compiled from source in Debug mode.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_RUNTIME_WORKER_THREADS</code></td>
      <td scope="row" data-label="Default">Number of CPU cores (minimum 4)</td>
      <td scope="row" data-label="Notes">Number of runtime worker threads used to start.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_SCRIPTING_MAX_MEMORY_LIMIT</code></td>
      <td scope="row" data-label="Default">2097152 (2 MiB)</td>
      <td scope="row" data-label="Notes">Maximum memory limit of the JavaScript function runtime.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_SCRIPTING_MAX_STACK_SIZE</code></td>
      <td scope="row" data-label="Default">262144 (256 KiB)</td>
      <td scope="row" data-label="Notes">Maximum stack size of the JavaScript function runtime.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_SCRIPTING_MAX_TIME_LIMIT</code></td>
      <td scope="row" data-label="Default">5000 (5000 milliseconds or 5 seconds)</td>
      <td scope="row" data-label="Notes"><Since v="v2.0.5" /> Maximum allowed time that a JavaScript function is allowed to run for.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_SURREALCS_CONNECTION_POOL_SIZE</code></td>
      <td scope="row" data-label="Default">Number of CPUs on the current device</td>
      <td scope="row" data-label="Notes"><Since v="v2.0.2" /> Size of the SurrealCS connection pool.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_SURREALISM_CACHE_SIZE</code></td>
      <td scope="row" data-label="Default">100</td>
      <td scope="row" data-label="Notes"><Since v="v3.0.0-alpha.12" /> The number of surrealism modules which can be cached across transactions.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TELEMETRY_DISABLE_METRICS</code></td>
      <td scope="row" data-label="Default">false</td>
      <td scope="row" data-label="Notes"><Since v="v2.1.3" /> Disables sending metrics to the GRPC OTEL collector.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TELEMETRY_DISABLE_TRACING</code></td>
      <td scope="row" data-label="Default">false</td>
      <td scope="row" data-label="Notes"><Since v="v2.1.3" /> Disables sending traces to the GRPC OTEL collector.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TELEMETRY_NAMESPACE</code></td>
      <td scope="row" data-label="Default">None</td>
      <td scope="row" data-label="Notes">If set then use this as value for the namespace label when sending telemetry</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TELEMETRY_PROVIDER</code></td>
      <td scope="row" data-label="Default">None</td>
      <td scope="row" data-label="Notes">If set to "otlp" then telemetry is sent to the GRPC OTEL collector.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TEMPORARY_DIRECTORY</code></td>
      <td scope="row" data-label="Default">None</td>
      <td scope="row" data-label="Notes">Sets the directory for storing temporary database files.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TOKIO_CONSOLE_ENABLED</code></td>
      <td scope="row" data-label="Default">false</td>
      <td scope="row" data-label="Notes"><Since v="v3.0.0-alpha.7" /> Whether to enable [tokio console](https://github.com/tokio-rs/console).</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TOKIO_CONSOLE_RETENTION</code></td>
      <td scope="row" data-label="Default">60</td>
      <td scope="row" data-label="Notes"><Since v="v3.0.0-alpha.7" /> How long, in seconds, to retain data for completed events.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TOKIO_CONSOLE_SOCKET_ADDR</code></td>
      <td scope="row" data-label="Default">false</td>
      <td scope="row" data-label="Notes"><Since v="v3.0.0-alpha.7" /> The socket address that Tokio Console will bind to.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TRANSACTION_CACHE_SIZE</code></td>
      <td scope="row" data-label="Default">10000</td>
      <td scope="row" data-label="Notes">Specifies the number of items which can be cached within a single transaction.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_WEBSOCKET_MAX_CONCURRENT_REQUESTS</code></td>
      <td scope="row" data-label="Default">4 times the number of CPU cores, minimum 12</td>
      <td scope="row" data-label="Notes">Maximum concurrent tasks that can be handled on each WebSocket.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_WEBSOCKET_MAX_MESSAGE_SIZE</code></td>
      <td scope="row" data-label="Default">134217728 (128 MiB)</td>
      <td scope="row" data-label="Notes">Maximum WebSocket message size.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_WEBSOCKET_RESPONSE_BUFFER_SIZE</code></td>
      <td scope="row" data-label="Default">0</td>
      <td scope="row" data-label="Notes">How many responses can be buffered when delivering to the client.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_WEBSOCKET_RESPONSE_CHANNEL_SIZE</code></td>
      <td scope="row" data-label="Default">100</td>
      <td scope="row" data-label="Notes">Configuring the WebSocket buffer size and the WebSocket response queue size.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_WEBSOCKET_RESPONSE_FLUSH_PERIOD</code></td>
      <td scope="row" data-label="Default">3</td>
      <td scope="row" data-label="Notes">How often (in milliseconds) any buffered responses are flushed to the WebSocket client.</td>
    </tr>
  </tbody>
</table>

## Command environment variables

Many of the arguments passed into [the CLI](/docs/surrealdb/cli/start) can be set using the above environment variables instead.

As each of these environment variables correspond to a flag passed into a command, it is good practice to put together a command that matches the environment variables you wish to set. Once the database server conforms to your expected behaviour, you can then pull out the values passed into each flag for your environment variables.

For example, take the following command to start the database.

```bash
surreal start --user root --pass root --allow-net --deny-funcs "crypto::md5, http::post, http::delete"
```

If we now wanted to use environment variables instead of the `--allow-net` and `--deny-funcs` flags, we would use the `SURREAL_CAPS_ALLOW_NET` and `SURREAL_CAPS_DENY_FUNC` environment variables.

As the `--allow-net` flag was passed in without a following value, the same will be the case with the `SURREAL_CAPS_ALLOW_NET` environment variable, becoming `SURREAL_CAPS_ALLOW_NET=`. The `--deny-funcs` flag can also be used on its own to deny execution of all functions, but in this case is followed by a string to indicate which exact functions are not allowed to be executed. As such, the `SURREAL_CAPS_DENY_FUNC` environment variable must also be followed by a string, becoming `SURREAL_CAPS_DENY_FUNC="crypto::md5, http::post, http::delete"`.

The command would then look like the following:

<Tabs groupId="start-command">

<TabItem value="bash" label="Bash" >
```bash
SURREAL_CAPS_ALLOW_NET
SURREAL_CAPS_DENY_FUNC="crypto::md5, http::post, http::delete"
surreal start --user root --pass root
```
</TabItem>

<TabItem value="powershell" label="PowerShell" >
```powershell
$env:SURREAL_CAPS_ALLOW_NET
$env:SURREAL_CAPS_DENY_FUNC="crypto::md5, http::post, http::delete"
surreal start --user root --pass root
```
</TabItem>
</Tabs>

<table>
  <thead>
    <tr>
      <th scope="col" style={{width: '30%'}}>Environment variable</th>
      <th scope="col" style={{width: '20%'}}>For command(s)</th>
      <th scope="col" style={{width: '10%'}}>arg</th>
      <th scope="col" style={{width: '30%'}}>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_AUTH_LEVEL</code></td>
      <td scope="row" data-label="Command">surreal export, import, sql</td>
      <td scope="row" data-label="Argument">auth-level</td>
      <td scope="row" data-label="Details">Authentication level to use when connecting.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_BIND</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">bind</td>
      <td scope="row" data-label="Details">The hostname or IP address(es) to listen for connections on.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_CAPS_ALLOW_ALL</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">allow-all</td>
      <td scope="row" data-label="Details">Allow all capabilities.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_CAPS_ALLOW_ARBITRARY_QUERY</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">allow-arbitrary-query</td>
      <td scope="row" data-label="Details">Allows arbitrary queries to be used by user groups. Possible user groups are: 'guest', 'record', and 'system'.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_CAPS_ALLOW_EXPERIMENTAL</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">allow-experimental</td>
      <td scope="row" data-label="Details">Allow execution of experimental features.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_CAPS_ALLOW_FUNC</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">allow-funcs</td>
      <td scope="row" data-label="Details">Allow execution of all or certain functions.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_CAPS_ALLOW_GUESTS</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">allow-guests</td>
      <td scope="row" data-label="Details">Allow guest users to execute queries.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_CAPS_ALLOW_NET</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">allow-net</td>
      <td scope="row" data-label="Details">Allow all or certain outbound network access.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_CAPS_ALLOW_SCRIPT</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">allow-scripting</td>
      <td scope="row" data-label="Details">Allow execution of embedded scripting functions.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_CAPS_DENY_ALL</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">deny-all</td>
      <td scope="row" data-label="Details">Deny all capabilities.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_CAPS_DENY_FUNC</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">deny-funcs</td>
      <td scope="row" data-label="Details">Deny execution of all or certain functions.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_CAPS_DENY_GUESTS</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">deny-guests</td>
      <td scope="row" data-label="Details">Deny guest users from executing queries.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_CAPS_DENY_NET</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">deny-net</td>
      <td scope="row" data-label="Details">Deny all or certain outbound access paths.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_CAPS_DENY_SCRIPT</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">deny-scripting</td>
      <td scope="row" data-label="Details">Deny execution of embedded scripting functions.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_CLIENT_IP</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">client-ip</td>
      <td scope="row" data-label="Details">The method of detecting the client's IP address.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_DATABASE</code></td>
      <td scope="row" data-label="Command">surreal export, import, sql</td>
      <td scope="row" data-label="Argument">database</td>
      <td scope="row" data-label="Details">The database selected for the operation.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_HIDE_WELCOME</code></td>
      <td scope="row" data-label="Command">surreal sql</td>
      <td scope="row" data-label="Argument">hide-welcome</td>
      <td scope="row" data-label="Details">Whether to show welcome message.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_INDEX_COMPACTION_INTERVAL</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">index-compaction-interval</td>
      <td scope="row" data-label="Notes"><Since v="v3.0.0-alpha.8" /> Changes the default 5s interval used for full-text search background compaction.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_KEY</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">key</td>
      <td scope="row" data-label="Details">Encryption key to use for on-disk encryption.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_KVS_CA</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">kvs-ca</td>
      <td scope="row" data-label="Details">Path to the CA file used when connecting to the remote KV store.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_KVS_CERT</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">kvs-cert</td>
      <td scope="row" data-label="Details">Path to the certificate file used when connecting to the remote KV store.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_KVS_KEY</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">kvs-key</td>
      <td scope="row" data-label="Details">Path to the private key file used when connecting to the remote KV store.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_LOG</code></td>
      <td scope="row" data-label="Command">surreal fix, start</td>
      <td scope="row" data-label="Argument">log</td>
      <td scope="row" data-label="Details">The logging level for the database server.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_LOG_FILE_ENABLED</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">log-file-enabled</td>
      <td scope="row" data-label="Details"><Since v="v2.4.0" /> Toggles file output (default: false)</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_LOG_FILE_FORMAT</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">log-file-format</td>
      <td scope="row" data-label="Details"><Since v="v2.4.0" /> The format for log file output. Possible values: text, json</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_LOG_FILE_LEVEL</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">log-file-level</td>
      <td scope="row" data-label="Details"><Since v="v2.4.0" /> Override the logging level for file output</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_LOG_FILE_NAME</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">log-file-name</td>
      <td scope="row" data-label="Details"><Since v="v2.4.0" /> Filename for logs (default: `surrealdb.log`)</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_LOG_FILE_PATH</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">log-file-path</td>
      <td scope="row" data-label="Details"><Since v="v2.4.0" /> Sets the directory for logs (default: `./logs`)</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_LOG_FILE_ROTATION</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">log-file-rotation</td>
      <td scope="row" data-label="Details"><Since v="v2.4.0" /> Sets the rotation duration for logs (one of `daily`, `hourly`, `never`; default: `daily`)</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_LOG_FORMAT</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">log-format</td>
      <td scope="row" data-label="Details"><Since v="v2.4.0" /> Sets the format for logs (one of `text`, `json`; default: `text`)</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_LOG_OTEL_LEVEL</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">log-otel-level</td>
      <td scope="row" data-label="Details"><Since v="v2.4.0" /> Override the logging level for OpenTelemetry</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_LOG_SOCKET</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">log-socket</td>
      <td scope="row" data-label="Details"><Since v="v3.0.0-alpha.8" /> Send logs to the specified host:port</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_LOG_SOCKET_FORMAT</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">log-socket-format</td>
      <td scope="row" data-label="Details"><Since v="v3.0.0-alpha.8" /> Set the format of the logs to the socket ("text" or "json"; default: "text")</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_LOG_SOCKET_LEVEL</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">log-socket-level</td>
      <td scope="row" data-label="Details"><Since v="v3.0.0-alpha.8" /> Override the logging level for socket logs. Possible values: none, full, error, warn, info, debug, trace</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_NAME</code></td>
      <td scope="row" data-label="Command">surreal ml export</td>
      <td scope="row" data-label="Argument">name</td>
      <td scope="row" data-label="Details">The name of the model.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_NAMESPACE</code></td>
      <td scope="row" data-label="Command">surreal export, import, sql</td>
      <td scope="row" data-label="Argument">namespace</td>
      <td scope="row" data-label="Details">The namespace selected for the operation.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_NO_BANNER</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">no-banner</td>
      <td scope="row" data-label="Details">Whether to hide the startup banner.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_NO_IDENTIFICATION_HEADERS</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">no-identification-headers</td>
      <td scope="row" data-label="Details">Whether to suppress the server name and version headers.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_PASS</code></td>
      <td scope="row" data-label="Command">surreal export, import, sql, start</td>
      <td scope="row" data-label="Argument">password, pass</td>
      <td scope="row" data-label="Details">Database authentication password to use when connecting.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_PATH</code></td>
      <td scope="row" data-label="Command">surreal fix, start</td>
      <td scope="row" data-label="Argument">path</td>
      <td scope="row" data-label="Details">Database path used for storing data.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_QUERY_TIMEOUT</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">query-timeout</td>
      <td scope="row" data-label="Details">The maximum duration that a set of statements can run for.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_SLOW_QUERY_LOG_THRESHOLD</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">--slow-log-threshold=duration</td>
      <td scope="row" data-label="Details"><Since v="v2.3.8" /> A duration specifying the minimum execution time after which a log is made to indicate a slow query</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_SLOW_QUERY_LOG_PARAM_ALLOW</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">--slow-log-param-allow=a,b,c</td>
      <td scope="row" data-label="Details"><Since v="v2.3.9" /> A comma-separated list of parameter names to include in slow query logs</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_SLOW_QUERY_LOG_PARAM_DENY</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">--slow-log-param-deny=x,y,z</td>
      <td scope="row" data-label="Details"><Since v="v2.3.9" /> A comma-separated list of parameter names to omit from slow query logs</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_STRICT</code></td>
      <td scope="row" data-label="Command">start</td>
      <td scope="row" data-label="Argument">strict</td>
      <td scope="row" data-label="Details">Whether strict mode is enabled on this database instance.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TEMPORARY_DIRECTORY</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">temporary-directory</td>
      <td scope="row" data-label="Details">Sets the directory for storing temporary database files</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TOKEN</code></td>
      <td scope="row" data-label="Command">surreal export, import, sql</td>
      <td scope="row" data-label="Argument">token</td>
      <td scope="row" data-label="Details">Authentication token in JWT format to use when connecting.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TRANSACTION_TIMEOUT</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">transaction-timeout</td>
      <td scope="row" data-label="Details">The maximum duration that any single transaction can run for.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_UNAUTHENTICATED</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">unauthenticated</td>
      <td scope="row" data-label="Details">Whether to allow unauthenticated access.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_USER</code></td>
      <td scope="row" data-label="Command">surreal export, import, sql, start</td>
      <td scope="row" data-label="Argument">username, user</td>
      <td scope="row" data-label="Details">Database authentication username to use when connecting.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_VERSION</code></td>
      <td scope="row" data-label="Command">surreal ml export</td>
      <td scope="row" data-label="Argument">version</td>
      <td scope="row" data-label="Details">The version of the model.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_WEB_CRT</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">web-crt</td>
      <td scope="row" data-label="Details">Path to the certificate file for encrypted client connections.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_WEB_KEY</code></td>
      <td scope="row" data-label="Command">surreal start</td>
      <td scope="row" data-label="Argument">web-key</td>
      <td scope="row" data-label="Details">Path to the private key file for encrypted client connections.</td>
    </tr>
  </tbody>
</table>

## Environment variables by storage backend

These environment variables are used to configure the storage backend for SurrealDB.

### FoundationDB environment variables

> [!WARNING]
> FoundationDB support is deprecated in SurrealDB `3.0`. Please plan to migrate to a supported storage backend.

<table>
  <thead>
    <tr>
      <th scope="col">Environment variable</th>
      <th scope="col">Default value</th>
      <th scope="col">Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_FOUNDATIONDB_TRANSACTION_MAX_RETRY_DELAY</code></td>
      <td scope="row" data-label="Default">500</td>
      <td scope="row" data-label="Notes">The maximum delay between transaction retries in milliseconds.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_FOUNDATIONDB_TRANSACTION_RETRY_LIMIT</code></td>
      <td scope="row" data-label="Default">5</td>
      <td scope="row" data-label="Notes">The maximum number of times a transaction can be retried.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_FOUNDATIONDB_TRANSACTION_TIMEOUT</code></td>
      <td scope="row" data-label="Default">5000</td>
      <td scope="row" data-label="Notes">The maximum transaction timeout in milliseconds.</td>
    </tr>
  </tbody>
</table>


### RocksDB environment variables

Many RocksDB environment variables pertain to memory use. The default configuration results in the following rough estimates of RocksDB memory use on different instances:

| Instance memory size  | Estimate
| ------------- |:-------------:|
| 512 MiB | ~ 80MiB |
| 1 GiB | ~ 80MiB
| 2 GiB | ~ 640MiB
| 4 GiB | ~ 1.25GiB
| 8 GiB | ~ 3.25GiB
| 24 GiB | ~ 12GiB
| 128 GiB | ~ 67GiB

The available environment variables for configuring a RocksDB instance are:

<table>
  <thead>
    <tr>
      <th scope="col" style={{width: '50%'}}>Environment variable</th>
      <th scope="col" style={{width: '20%'}}>Default value</th>
      <th scope="col" style={{width: '30%'}}>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_BACKGROUND_FLUSH</code></td>
      <td scope="row" data-label="Default">false</td>
      <td scope="row" data-label="Notes">Whether to enable background WAL file flushing.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_BACKGROUND_FLUSH_INTERVAL</code></td>
      <td scope="row" data-label="Default">200</td>
      <td scope="row" data-label="Notes">The interval in milliseconds between background flushes.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_BLOB_COMPRESSION_TYPE</code></td>
      <td scope="row" data-label="Default">none</td>
      <td scope="row" data-label="Notes">none, snappy, lz4, zstd</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_BLOB_FILE_SIZE</code></td>
      <td scope="row" data-label="Default">256 MiB</td>
      <td scope="row" data-label="Notes">The target blob file size for RocksDB.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_ENABLE_BLOB_GC</code></td>
      <td scope="row" data-label="Default">false</td>
      <td scope="row" data-label="Notes">Whether to enable blob garbage collection for RocksDB.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_BLOB_GC_AGE_CUTOFF</code></td>
      <td scope="row" data-label="Default">0.25</td>
      <td scope="row" data-label="Notes">Fractional age cutoff for blob GC eligibility in [0,1].</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_BLOB_GC_FORCE_THRESHOLD</code></td>
      <td scope="row" data-label="Default">1.0</td>
      <td scope="row" data-label="Notes">Discardable ratio threshold to force GC in [0,1].</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_BLOB_COMPACTION_READAHEAD_SIZE</code></td>
      <td scope="row" data-label="Default">0</td>
      <td scope="row" data-label="Notes">Readahead size for blob compaction/GC.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_BLOCK_CACHE_SIZE</code></td>
      <td scope="row" data-label="Default">Dynamic from 16MiB to ~45% of total machine memory</td>
      <td scope="row" data-label="Notes">RocksDB <a href="https://github.com/facebook/rocksdb/wiki/memory-usage-in-rocksdb">block cache size</a> in bytes</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_BLOCK_SIZE</code></td>
      <td scope="row" data-label="Default">64 KiB</td>
      <td scope="row" data-label="Notes">The size of each uncompressed data block in bytes.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_COMPACTION_READAHEAD_SIZE</code></td>
      <td scope="row" data-label="Default">Dynamic from 4 MiB to 16 MiB depending on total system memory</td>
      <td scope="row" data-label="Notes">The readahead buffer size used during compaction.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_COMPACTION_STYLE</code></td>
      <td scope="row" data-label="Default">"level"</td>
      <td scope="row" data-label="Notes"><Since v="v2.0.3" /> Use to specify the database compaction style.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_DELETION_FACTORY_DELETION_COUNT</code></td>
      <td scope="row" data-label="Default">50</td>
      <td scope="row" data-label="Notes"><Since v="v2.0.3" /> The number of deletions to track in the window.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_DELETION_FACTORY_RATIO</code></td>
      <td scope="row" data-label="Default">0.5</td>
      <td scope="row" data-label="Notes"><Since v="v2.0.3" /> The ratio of deletions to track in the window.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_DELETION_FACTORY_WINDOW_SIZE</code></td>
      <td scope="row" data-label="Default">1000</td>
      <td scope="row" data-label="Notes"><Since v="v2.0.3" /> The size of the window used to track deletions.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_ENABLE_BLOB_FILES</code></td>
      <td scope="row" data-label="Default">true</td>
      <td scope="row" data-label="Notes">Whether to enable separate key and value file storage.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_ENABLE_MEMORY_MAPPED_READS</code></td>
      <td scope="row" data-label="Default">false</td>
      <td scope="row" data-label="Notes">Whether to enable memory-mapped reads.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_ENABLE_MEMORY_MAPPED_WRITES</code></td>
      <td scope="row" data-label="Default">false</td>
      <td scope="row" data-label="Notes">Whether to enable memory-mapped writes.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_ENABLE_PIPELINED_WRITES</code></td>
      <td scope="row" data-label="Default">true</td>
      <td scope="row" data-label="Notes">Whether to use separate queues for WAL writes and memtable writes.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_FILE_COMPACTION_TRIGGER</code></td>
      <td scope="row" data-label="Default">4</td>
      <td scope="row" data-label="Notes">The number of files needed to trigger level 0 compaction.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_JOBS_COUNT</code></td>
      <td scope="row" data-label="Default">Number of CPUs * 2</td>
      <td scope="row" data-label="Notes"><Since v="v2.0.3" /> The maximum number of threads to use for flushing and compaction.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_KEEP_LOG_FILE_NUM</code></td>
      <td scope="row" data-label="Default">10</td>
      <td scope="row" data-label="Notes">The maximum number of information log files to keep.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_MAX_CONCURRENT_SUBCOMPACTIONS</code></td>
      <td scope="row" data-label="Default">4</td>
      <td scope="row" data-label="Notes">The maximum number threads which will perform compactions.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_MAX_OPEN_FILES</code></td>
      <td scope="row" data-label="Default">1024</td>
      <td scope="row" data-label="Notes">The maximum number of open files which can be opened by RocksDB.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_MAX_WRITE_BUFFER_NUMBER</code></td>
      <td scope="row" data-label="Default">Dynamic from 2 to 32 depending on total system memory</td>
      <td scope="row" data-label="Notes">The maximum number of write buffers which can be used.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_MIN_BLOB_SIZE</code></td>
      <td scope="row" data-label="Default">4096</td>
      <td scope="row" data-label="Notes">The minimum size of a value for it to be stored in blob files.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_MIN_WRITE_BUFFER_NUMBER_TO_MERGE</code></td>
      <td scope="row" data-label="Default">2</td>
      <td scope="row" data-label="Notes">The minimum number of write buffers to merge before writing to disk.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_SST_MAX_ALLOWED_SPACE_USAGE</code></td>
      <td scope="row" data-label="Default">0</td>
      <td scope="row" data-label="Notes">The maximum allowed space usage for SST files in bytes. The default of 0 means unlimited. When this limit is reached, the datastore enters read-and-deletion-only mode, where only read and delete operations are allowed. This allows gradual space recovery through data deletion. Set to 0 to disable space monitoring.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_STORAGE_LOG_LEVEL</code></td>
      <td scope="row" data-label="Default">"warn"</td>
      <td scope="row" data-label="Notes">The information log level of the RocksDB library.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_TARGET_FILE_SIZE_BASE</code></td>
      <td scope="row" data-label="Default">64 MiB</td>
      <td scope="row" data-label="Notes">The target file size for compaction in bytes.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_TARGET_FILE_SIZE_MULTIPLIER</code></td>
      <td scope="row" data-label="Default">2</td>
      <td scope="row" data-label="Notes">The target file size multiplier for each compaction level.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_THREAD_COUNT</code></td>
      <td scope="row" data-label="Default">Number of CPUs on machine</td>
      <td scope="row" data-label="Notes">The number of threads to start for flushing and compaction.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_WAL_SIZE_LIMIT</code></td>
      <td scope="row" data-label="Default">0 MB</td>
      <td scope="row" data-label="Notes">The write-ahead-log size limit in MiB.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_ROCKSDB_WRITE_BUFFER_SIZE</code></td>
      <td scope="row" data-label="Default">Dynamic from 32 MiB to 128 MiB depending on total system memory</td>
      <td scope="row" data-label="Notes">The amount of data each write buffer can build up in memory.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_SYNC_DATA</code></td>
      <td scope="row" data-label="Default">false</td>
      <td scope="row" data-label="Notes">Controls the behaviour of RocksDB and SurrealKV. Allows data durability configuration, ensuring that the database can be configured for writes to be synced to disk before transactions are confirmed to be completed.</td>
    </tr>
  </tbody>
</table>

### SurrealKV environment variables

<table>
  <thead>
    <tr>
      <th scope="col" style={{width: '50%'}}>Environment variable</th>
      <th scope="col" style={{width: '20%'}}>Default value</th>
      <th scope="col" style={{width: '30%'}}>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_SURREALKV_MAX_SEGMENT_SIZE</code></td>
      <td scope="row" data-label="Default">512 MiB</td>
      <td scope="row" data-label="Notes">The maximum size of a single data file segment.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_SURREALKV_MAX_VALUE_CACHE_SIZE</code></td>
      <td scope="row" data-label="Default">Whichever is larger of "System total memory / 2 - 1GiB" and "16 MiB"</td>
      <td scope="row" data-label="Notes">The size of the in-memory value cache for SurrealKV.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_SURREALKV_MAX_VALUE_THRESHOLD</code></td>
      <td scope="row" data-label="Default">64</td>
      <td scope="row" data-label="Notes">The size in bytes to store values in the tree, or a separate log file.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_SYNC_DATA</code></td>
      <td scope="row" data-label="Default">false</td>
      <td scope="row" data-label="Notes">Controls the behaviour of RocksDB and SurrealKV. Allows data durability configuration, ensuring that the database can be configured for writes to be synced to disk before transactions are confirmed to be completed.</td>
    </tr>
  </tbody>
</table>

### TiKV environment variables

<table>
  <thead>
    <tr>
      <th scope="col" style={{width: '50%'}}>Environment variable</th>
      <th scope="col" style={{width: '20%'}}>Default value</th>
      <th scope="col" style={{width: '30%'}}>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TIKV_API_VERSION</code></td>
      <td scope="row" data-label="Default">1</td>
      <td scope="row" data-label="Notes">Which TiKV cluster API version to use.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TIKV_ASYNC_COMMIT</code></td>
      <td scope="row" data-label="Default">true</td>
      <td scope="row" data-label="Notes">Whether to use asynchronous transactions.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TIKV_KEYSPACE</code></td>
      <td scope="row" data-label="Default">None</td>
      <td scope="row" data-label="Notes">A string specifying the keyspace identifier for data isolation.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TIKV_GRPC_MAX_DECODING_MESSAGE_SIZE</code></td>
      <td scope="row" data-label="Default">4194304 (4 MiB)</td>
      <td scope="row" data-label="Notes"><Since v="v2.1.8" />Sets the maximum decoding size of a gRPC message.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TIKV_ONE_PHASE_COMMIT</code></td>
      <td scope="row" data-label="Default">true</td>
      <td scope="row" data-label="Notes">Whether to use one-phase transaction commit.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Env var"><code>SURREAL_TIKV_REQUEST_TIMEOUT</code></td>
      <td scope="row" data-label="Default">10</td>
      <td scope="row" data-label="Notes">The duration in seconds for requests before they time out.</td>
    </tr>
  </tbody>
</table>

## Command environment variables

Many of the arguments passed into [the CLI](/docs/surrealdb/cli/start) can be set using the above environment variables instead.

As each of these environment variables correspond to a flag passed into a command, it is good practice to put together a command that matches the environment variables you wish to set. Once the database server conforms to your expected behaviour, you can then pull out the values passed into each flag for your environment variables.

For example, take the following command to start the database.

```bash
surreal start --user root --pass secret --allow-net --deny-funcs "crypto::md5, http::post, http::delete"
```

If we now wanted to use environment variables instead of the `--allow-net` and `--deny-funcs` flags, we would use the `SURREAL_CAPS_ALLOW_NET` and `SURREAL_CAPS_DENY_FUNC` environment variables.

As the `--allow-net` flag was passed in without a following value, the same will be the case with the `SURREAL_CAPS_ALLOW_NET` environment variable, becoming `SURREAL_CAPS_ALLOW_NET=`. The `--deny-funcs` flag can also be used on its own to deny execution of all functions, but in this case is followed by a string to indicate which exact functions are not allowed to be executed. As such, the `SURREAL_CAPS_DENY_FUNC` environment variable must also be followed by a string, becoming `SURREAL_CAPS_DENY_FUNC="crypto::md5, http::post, http::delete"`.

The command would then look like the following:

<Tabs groupId="start-command">

<TabItem value="bash" label="Bash" >
```bash
SURREAL_CAPS_ALLOW_NET
SURREAL_CAPS_DENY_FUNC="crypto::md5, http::post, http::delete"
surreal start --user root --pass secret
```
</TabItem>

<TabItem value="powershell" label="PowerShell" >
```powershell
$env:SURREAL_CAPS_ALLOW_NET
$env:SURREAL_CAPS_DENY_FUNC="crypto::md5, http::post, http::delete"
surreal start --user root --pass secret
```
</TabItem>
</Tabs>

## SurrealDB Cloud environment variables

Instances on SurrealDB Cloud are not started with a CLI command or environment variables. Instead, they can be set on the [Configure Instance](/docs/cloud/advanced-topics/configure-an-instance) panel.


================================================
FILE: src/content/doc-surrealdb/cli/export.mdx
================================================
---
sidebar_position: 5
sidebar_label: Export command
title: Export command | CLI tool
description: A command to export data from a SurrealDB database server into a SurrealQL file format.
---

import Label from "@components/shared/Label.astro";

# Export command

The export command exports a SurrealQL script file from a local or remote SurrealDB database server.

> [!NOTE: BEFORE YOU START]
> Make sure you’ve [installed SurrealDB](/docs/surrealdb/installation) — it should only take a second!

## Syntax 

```bash title="Export a database as a SurrealQL script"
surreal export [OPTIONS] --namespace <NAMESPACE> --database <DATABASE> [FILE]
```

## Command options 

<table>
    <thead>
        <tr>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td>
                `-e` / `--endpoint` / `--conn`
               <Label label="optional" />
            </td>
            <td>
            Sets the url of the database server to connect to. Defaults to http://127.0.0.1:8000 if not specified
            </td>
        </tr>
        <tr>
            <td>
                `-u` / `--user`
                <Label label="required" />
            </td>
            <td>
                Sets master username for the database
            </td>
        </tr>
        <tr>
            <td>
                `-p` / `--pass`
                <Label label="required" />
            </td>
            <td>
                Sets master password for the database
            </td>
        </tr>
        <tr>
            <td>
                `-t` / `--token`
               <Label label="optional" />
            </td>
            <td>
                Sets the authentication token to use when connecting to the server. Connect to SurrealDB using a JWT instead of user credentials
            </td>
        </tr>
        <tr>
            <td>
                `--ns`
                <Label label="required" />
            </td>
            <td>
                Sets the desired namespace in which to export data
            </td>
        </tr>
        <tr>
            <td>
                `--db`
                <Label label="required" />
            </td>
            <td>
                Sets the desired database into which to export data
            </td>
        </tr>
    </tbody>
</table>

## Export options 

<table>
    <thead>
        <tr>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td>
                `--only`
                <Label label="optional" />
            </td>
            <td>
                Whether only specific resources should be exported. When provided, only the resources specified will be exported.
            </td>
        </tr>
        <tr>
            <td>
                `--users`
                <Label label="optional" />
            </td>
            <td>
                Whether system users should be exported [possible values: true, false].
            </td>
        </tr>
        <tr>
            <td>
                `--accesses`
                <Label label="optional" />
            </td>
            <td>
                Whether access methods (Record or JWT) should be exported [possible values: true, false]
            </td>
        </tr>
        <tr>
            <td>
                `--params`
                <Label label="optional" />
            </td>
            <td>
                Whether databases parameters should be exported [possible values: true, false]
            </td>
        </tr>
        <tr>
            <td>
                `--functions`
                <Label label="optional" />
            </td>
            <td>
                Whether functions should be exported [possible values: true, false]
            </td>
        </tr>
        <tr>
            <td>
                `--analyzers`
                <Label label="optional" />
            </td>
            <td>
                Whether analyzers should be exported [possible values: true, false]
            </td>
        </tr>
        <tr>
            <td>
                `--tables [tables]`
                <Label label="optional" />
            </td>
            <td>
                Whether tables should be exported, optionally providing a list of tables
            </td>
        </tr>
        <tr>
            <td>
                `--versions`
                <Label label="optional" />
            </td>
            <td>
                Whether SurrealKV versioned records should be exported [possible values: true, false]
            </td>
        </tr>
        <tr>
            <td>
                `--records`
                <Label label="optional" />
            </td>
            <td>
                Whether records should be exported [possible values: true, false]
            </td>
        </tr>
                <tr>
            <td>
                `-l` / `--log`
                <Label label="optional" />
            </td>
            <td>
                The logging level for the command-line tool [default: info] [possible values: none, full, error, warn, info, debug, trace]
            </td>
        </tr>
    </tbody>
</table>

## Positional argument

<table>
    <thead>
        <tr>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td>
                `file`
                <Label label="optional" />
            </td>
            <td>
                Sets the path to the file which should be exported. If not provided, export data will be printed to stdout (and can thus be redirected using `>`).
            </td>
        </tr>
    </tbody>
</table>

## Example usage

To perform a SurrealQL database export into a local file, in a terminal run the `surreal export` command with the required arguments.

```bash
surreal export --conn http://localhost:8000 --user root --pass secret --ns test --db test export.surql
```

Using token-based authentication

```bash
surreal export --conn http://localhost:8000 --token <token> --ns test --db test export.surql
```

## OPTION IMPORT keyword

The output of a database export includes a line that contains the keywords `OPTION IMPORT`. This command is used internally to ensure that side effects do not run when the data is imported, such as [events](/docs/surrealql/statements/define/event) and [table views](/docs/surrealql/statements/define/table#pre-computed-table-views).

## Using environment variables

When using the `surreal export` command, you can also use environment variables to set the values for the command-line flags. 
>[!IMPORTANT]
> Most of the flags mentioned in the command output above also mention a corresponding [environment variables](/docs/surrealdb/cli/env#command-environment-variables). 
>
> For example, the `--username` flag can be configured with the `SURREAL_USER` environment variable instead. 

For more on the environment variables available for CLI commands or SurrealDB instances in general, see the [environment variables](/docs/surrealdb/cli/env#command-environment-variables) page.

## Command help

To see the help information and usage instructions, in a terminal run the `surreal export --help` command without any further arguments. This command gives general information on the arguments, inputs, and additional options for the export command.

```bash
surreal export --help
```

The output of the above command :

```
Export an existing database as a SurrealQL script

Usage: surreal export [OPTIONS] --namespace <NAMESPACE> --database <DATABASE> [FILE]

Arguments:
  [FILE]  Path to the SurrealQL file to export. Use dash - to write into stdout. [default: -]

Options:
  -e, --endpoint <ENDPOINT>      Remote database server url to connect to [default: ws://localhost:8000] [aliases: conn]
  -u, --username <USERNAME>      Database authentication username to use when connecting [env: SURREAL_USER=] [aliases: user]
  -p, --password <PASSWORD>      Database authentication password to use when connecting [env: SURREAL_PASS=] [aliases: pass]
  -t, --token <TOKEN>            Authentication token in JWT format to use when connecting [env: SURREAL_TOKEN=]
      --auth-level <AUTH_LEVEL>  Level on which the authenticating user is defined [env: SURREAL_AUTH_LEVEL=] [default: root] [possible values: root, namespace, ns, database, db]
      --namespace <NAMESPACE>    The namespace selected for the operation [env: SURREAL_NAMESPACE=] [aliases: ns]
      --database <DATABASE>      The database selected for the operation [env: SURREAL_DATABASE=] [aliases: db]
      --only                     Whether only specific resources should be exported
      --users [<USERS>]          Whether users should be exported [possible values: true, false]
      --accesses [<ACCESSES>]    Whether access methods should be exported [possible values: true, false]
  -l, --log <LOG>                The logging level for the command-line tool [env: SURREAL_LOG=] [default: info] [possible values: none, full, error, warn, info, debug, trace]
      --params [<PARAMS>]        Whether params should be exported [possible values: true, false]
      --functions [<FUNCTIONS>]  Whether functions should be exported [possible values: true, false]
      --analyzers [<ANALYZERS>]  Whether analyzers should be exported [possible values: true, false]
      --tables [<TABLES>]        Whether tables should be exported, optionally providing a list of tables
      --versions [<VERSIONS>]    Whether versions should be exported [possible values: true, false]
      --records [<RECORDS>]      Whether records should be exported [possible values: true, false]
  -h, --help                     Print help
```




================================================
FILE: src/content/doc-surrealdb/cli/fix.mdx
================================================
---
sidebar_position: 6
sidebar_label: Fix command
title: Fix command | CLI tool
description: A command to convert SurrealDB version 1.x data into a usable format for versions 2.0 and above.
---

import Label from "@components/shared/Label.astro";

# Fix command

The fix command converts SurrealDB version 1.x data into a format that can be used in SurrealDB 2.x.

> [!NOTE: BEFORE YOU START]
> Make sure you’ve [installed SurrealDB](/docs/surrealdb/installation) — it should only take a second!

## Command options 

<table>
    <thead>
        <tr>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td>
                `-e` / `--log`
               <Label label="optional" />
            </td>
            <td>
            Sets the logging level during the command
            </td>
        </tr>
    </tbody>
</table>

## Positional argument

<table>
    <thead>
        <tr>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td>
                `file`
            </td>
            <td>
                Sets the path to the existing data to convert to 2.x storage format
            </td>
        </tr>
    </tbody>
</table>

## Example usage

To perform a fix from SurrealDB 1.x to 2.x storage, run the `surreal fix` command in a terminal with the path to the stored data.

```bash
surreal fix surrealkv://mydatabase.db

surreal fix rocksdb:somedatabase
```

## Using environment variables

When using the `surreal fix` command, you can also use environment variables to set the values for the command-line flags. 
>[!IMPORTANT]
> Most of the flags mentioned in the command output above also mention a corresponding [environment variables](/docs/surrealdb/cli/env#command-environment-variables). 
>
> For example, the `--log` flag can be configured with the `SURREAL_LOG` environment variable instead. 

For more on the environment variables available for CLI commands or SurrealDB instances in general, see the [environment variables](/docs/surrealdb/cli/env#command-environment-variables) page.

## Command help

To see the help information and usage instructions, in a terminal run the `surreal fix --help` command without any further arguments. This command gives general information on the arguments, inputs, and additional options for the export command.

```bash
surreal fix --help
```

The output of the above command:

```
Fix database storage issues

Usage: surreal fix [OPTIONS] [PATH]

Arguments:
  [PATH]  Database path used for storing data [env: SURREAL_PATH=] [default: memory]

Options:
  -l, --log <LOG>  The logging level for the command-line tool [env: SURREAL_LOG=] [default: info] [possible values: none, full, error, warn, info, debug, trace]
  -h, --help       Print help
```




================================================
FILE: src/content/doc-surrealdb/cli/help.mdx
================================================
---
sidebar_position: 4
sidebar_label: Help command
title: Help command | CLI tool
description: A command to display all possible top-level commands and arguments used in the the SurrealDB binary.
---

# Help command

The help command displays help information and instructions on the command-line tool and its arguments.

> [!NOTE: BEFORE YOU START]
> Make sure you’ve [installed SurrealDB](/docs/surrealdb/installation) — it should only take a second!

## Show the command-line help information

To see the general help information for the command-line tool, in a terminal run the `surreal help` command without any further arguments. This command gives general information on the other functionality which can be run with the command-line tool.

```bash
surreal help
```

The output of the above command:

```bash
 .d8888b.                                             888 8888888b.  888888b.
d88P  Y88b                                            888 888  'Y88b 888  '88b
Y88b.                                                 888 888    888 888  .88P
 'Y888b.   888  888 888d888 888d888  .d88b.   8888b.  888 888    888 8888888K.
    'Y88b. 888  888 888P'   888P'   d8P  Y8b     '88b 888 888    888 888  'Y88b
      '888 888  888 888     888     88888888 .d888888 888 888    888 888    888
Y88b  d88P Y88b 888 888     888     Y8b.     888  888 888 888  .d88P 888   d88P
 'Y8888P'   'Y88888 888     888      'Y8888  'Y888888 888 8888888P'  8888888P'


To get started using SurrealDB, and for guides on connecting to and building applications
on top of SurrealDB, check out the SurrealDB documentation (https://surrealdb.com/docs).

If you have questions or ideas, join the SurrealDB community (https://surrealdb.com/community).

If you find a bug, submit an issue on GitHub (https://github.com/surrealdb/surrealdb/issues).

We would love it if you could star the repository (https://github.com/surrealdb/surrealdb).

----------

Usage: surreal [OPTIONS] <COMMAND>

Commands:
  start     Start the database server
  import    Import a SurrealQL script into an existing database
  export    Export an existing database as a SurrealQL script
  version   Output the command-line tool and remote server version information
  upgrade   Upgrade to the latest stable version
  sql       Start an SQL REPL in your terminal with pipe support
  ml        Manage SurrealML models within an existing database
  is-ready  Check if the SurrealDB server is ready to accept connections [aliases: isready]
  validate  Validate SurrealQL query files
  fix       Fix database storage issues
  help      Print this message or the help of the given subcommand(s)

Options:
  -l, --log <LOG>             The logging level for the command-line tool [env: SURREAL_LOG=] [default: info] [possible values: none, full, error, warn, info, debug, trace]
      --online-version-check  Whether to allow web check for client version upgrades at start [env: SURREAL_ONLINE_VERSION_CHECK=]
  -h, --help                  Print help
  -V, --version               Print version
```

## Getting help on individual commands

For individual commands, such as `surreal start` and `surreal sql`, a help prompt can be displayed by adding the `--help` flag. This flag overrides all other flags, and thus can be added to the end of any command regardless of length.

```bash
surreal start --help
surreal start --user root --pass secret --strict --help
```


================================================
FILE: src/content/doc-surrealdb/cli/import.mdx
================================================
---
sidebar_position: 7
sidebar_label: Import command
title: Import command | CLI tool
description: A command that imports a file in SurrealQL format into a local or remote SurrealDB database server.
---

import Label from "@components/shared/Label.astro";

# Import command

The import command imports a SurrealQL script file into a local or remote SurrealDB database server.

> [!NOTE: BEFORE YOU START]
> Make sure you’ve [installed SurrealDB](/docs/surrealdb/installation) — it should only take a second!

## Command options 

<table>
    <thead>
        <tr>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td>
                `-e` / `--endpoint` / `--conn`
               <Label label="optional" />
            </td>
            <td>
                Sets the url of the database server to connect to. Defaults to http://127.0.0.1:8000 if not specified
            </td>
        </tr>
        <tr>
            <td>
                `-u` / `--user`
                <Label label="required" />
            </td>
            <td>
                Sets master username for the database
            </td>
        </tr>
        <tr>
            <td>
                `-p` / `--pass`
                <Label label="required" />
            </td>
            <td>
                Sets master password for the database
            </td>
        </tr>
        <tr>
            <td>
                `-t` / `--token`
               <Label label="optional" />
            </td>
            <td>
                Sets the authentication token to use when connecting to the server. Connect to SurrealDB using a JWT instead of user credentials
            </td>
        </tr>
        <tr>
            <td>
                `--ns`
                <Label label="required" />
            </td>
            <td>
                Sets the desired namespace in which to import data
            </td>
        </tr>
        <tr>
            <td>
                `--db`
                <Label label="required" />
            </td>
            <td>
                Sets the desired database into which to import data
            </td>
        </tr>
    </tbody>
</table>

## Positional argument

<table>
    <thead>
        <tr>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td>
                `file`
                <Label label="required" />
            </td>
            <td>
            Sets the path to the file which should be imported
            </td>
        </tr>
    </tbody>
</table>

## Example usage

To perform a SurrealQL database import from a local file, in a terminal run the `surreal import` command with the required arguments.

```bash
surreal import --conn http://localhost:8000 --user root --pass secret --ns test --db test downloads/surreal_deal_v1.surql
```

Using token-based authentication:

```bash 
surreal import --conn http://localhost:8000 --token <token> --ns test --db test downloads/surreal_deal_v1.surql
```

> [!NOTE]
> If you are using Surrealist, you can import files into your database by using the `Import database` button in the Explorer view. See the [Surrealist documentation](/docs/surrealist/concepts/explore-database-records) for more information.

## OPTION IMPORT

The output of a database export includes a line that contains the keywords `OPTION IMPORT`. This command is used internally to ensure that side effects do not run when the data is imported, such as [events](/docs/surrealql/statements/define/event) and [table views](/docs/surrealql/statements/define/table#pre-computed-table-views).

## Using environment variables

When using the `surreal import` command, you can also use environment variables to set the values for the command-line flags. 

>[!IMPORTANT]
> Most of the flags mentioned in the command output above also mention a corresponding [environment variables](/docs/surrealdb/cli/env#command-environment-variables). 
>
> For example, the `--username` flag can be configured with the `SURREAL_USER` environment variable instead. 

For more on the environment variables available for CLI commands or SurrealDB instances in general, see the [environment variables](/docs/surrealdb/cli/env#command-environment-variables) page.

## Command help

To see the help information and usage instructions, in a terminal run the `surreal import --help` command without any further arguments. This command gives general information on the arguments, inputs, and additional options for the `import` command.

```bash
surreal import --help
```

The output of the above command:

```
Import a SurrealQL script into an existing database

Usage: surreal import [OPTIONS] --namespace <NAMESPACE> --database <DATABASE> <FILE>

Arguments:
  <FILE>  Path to the SurrealQL file to import

Options:
  -e, --endpoint <ENDPOINT>      Remote database server url to connect to [default: ws://localhost:8000] [aliases: conn]
  -u, --username <USERNAME>      Database authentication username to use when connecting [env: SURREAL_USER=] [aliases: user]
  -p, --password <PASSWORD>      Database authentication password to use when connecting [env: SURREAL_PASS=] [aliases: pass]
  -t, --token <TOKEN>            Authentication token in JWT format to use when connecting [env: SURREAL_TOKEN=]
      --auth-level <AUTH_LEVEL>  Level on which the authenticating user is defined [env: SURREAL_AUTH_LEVEL=] [default: root] [possible values: root, namespace, ns, database, db]
      --namespace <NAMESPACE>    The namespace selected for the operation [env: SURREAL_NAMESPACE=] [aliases: ns]
      --database <DATABASE>      The database selected for the operation [env: SURREAL_DATABASE=] [aliases: db]
  -l, --log <LOG>                The logging level for the command-line tool [env: SURREAL_LOG=] [default: info] [possible values: none, full, error, warn, info, debug, trace]
  -h, --help                     Print help
```




================================================
FILE: src/content/doc-surrealdb/cli/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: CLI
title: CLI tool
description: The SurrealDB command-line tool can be used to export a dataset as SurrealQL from a local or remote SurrealDB database, import SurrealQL data into a local or remote database, and start a single SurrealDB instance or distributed cluster.
---

# CLI tool

The SurrealDB command-line tool uses a single command for functionality such as [starting a single SurrealDB instance](/docs/surrealdb/cli/start), [exporting a dataset as a `.surql` file](/docs/surrealdb/cli/export), [importing SurrealQL](/docs/surrealdb/cli/import) into a local or remote database, [upgrading](/docs/surrealdb/cli/upgrade) to a new version of SurrealDB, or [opening a REPL](/docs/surrealdb/cli/sql) to make queries on a running instance.

>[!IMPORTANT]
>Before using the CLI, you will need to [install SurrealDB](/docs/surrealdb/installation). To experiment with SurrealDB before installing, see the [Surrealist sandbox](https://app.surrealdb.com/).

## Getting Started

The CLI allows you to use the `surreal` command from your terminal or command prompt. This documentation provides detailed information on each command, including usage examples and options.

When starting with the CLI, the most commonly used commands are [`surreal start`](/docs/surrealdb/cli/start) to start the server, along with [`surreal sql`](/docs/surrealdb/cli/sql) to open up an interactive shell to make queries. Other common commands are [`surreal upgrade`](/docs/surrealdb/cli/upgrade) to switch between versions of SurrealDB, and [`surreal import`](/docs/surrealdb/cli/import) and [`surreal export`](/docs/surrealdb/cli/export) to import and export your data.


For a quickstart, [`surreal start`](/docs/surrealdb/cli/start) and [`surreal sql`](/docs/surrealdb/cli/sql) will be enough to get you started.

```bash
surreal start --user root --pass secret
```
Unless you specify otherwise, the CLI will start a database in memory that serves at `127.0.0.1:8000 or (http://localhost:8000)`. This database has a single root user named `root` and a password `root`.

In another window, you can then open up an interactive shell to make queries using the  `surreal sql` command.

```bash
surreal sql --namespace ns --database db --username root --password root --pretty
```

> [!WARNING]
> Using generic usernames and passwords is not recommended for production use. Please replace the authentication credentials with your own.

This will start an interactive shell to make queries. Since you are logged in as the root user inside a namespace called `ns` and a database called `db`, with pretty (easily readable) output per query.

You can then try out a few queries and see the output.

```bash
ns/db> CREATE person SET age = 20;
ns/db> CREATE person SET age = 30;
ns/db> SELECT * FROM person WHERE age > 25;
```

```bash title="Output"
[
	{
		age: 20,
		id: person:6jodx8xv39jsxdgykt0t
	}
]

[
	{
		age: 30,
		id: person:10bcq2owseyqqoinjgxl
	}
]

[
	{
		age: 30,
		id: person:10bcq2owseyqqoinjgxl
	}
]
```

Alternatively, you can start a local database in memory with the command below. The `--endpoint memory` flag will start a database in memory, while the other arguments will connect to a single namespace called `test` and a database called `test`. Please replace the username and password with your own. 

```bash
surreal sql --endpoint memory --namespace test --database test --username username --password password
```

>[!WARNING]
> The above command will start a database in memory with a single namespace called `test` and a database called `test` and allow root access to the database. Using generic usernames and passwords is not recommended for production use.

We hope that the SurrealDB CLI simplifies your interactions with SurrealDB and empowers you to efficiently manage your databases and clusters. Let's dive into the CLI section and explore its capabilities!



================================================
FILE: src/content/doc-surrealdb/cli/isready.mdx
================================================
---
sidebar_position: 8
sidebar_label: Isready command
title: Isready command | CLI tool
description: A command that determines whether a SurrealDB server has started and is able to accept connections.
---
import Label from "@components/shared/Label.astro";

# Isready command

The isready command attempts to connect to a remote SurrealDB server to detect if it has successfully started and is ready to accept connections.

> [!NOTE: BEFORE YOU START]
> Make sure you’ve [installed SurrealDB](/docs/surrealdb/installation) — it should only take a second!

## Command options

<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2">
                `-e` / `--endpoint` / `--conn `
               <Label label="optional" />
            </td>
            <td>
        Sets the url of the database server to connect to
            </td>
        </tr>
    </tbody>
</table>

## Example usage

To display the current command-line tool version, along with the platform and architecture, in a terminal run the surreal version command without any further arguments.

```bash 
surreal isready --conn http://localhost:8000
```

## Command help

To see the help information and usage instructions, in a terminal run the `surreal isready --help` command without any further arguments. This command gives general information on the arguments, inputs, and additional options for the export command.

```bash
surreal isready --help
```

The output of the above command:

```bash
Check if the SurrealDB server is ready to accept connections

Usage: surreal is-ready [OPTIONS]

Options:
  -e, --endpoint <ENDPOINT>  Remote database server url to connect to [default: ws://localhost:8000] [aliases: conn]
  -l, --log <LOG>            The logging level for the command-line tool [env: SURREAL_LOG=] [default: info] [possible values: none, full, error, warn, info, debug, trace]
  -h, --help                 Print help
```


================================================
FILE: src/content/doc-surrealdb/cli/sql.mdx
================================================
---
sidebar_position: 3
sidebar_label: SQL command
title: SQL command | CLI tool
description: A command that starts a command-line REPL to make SurrealQL to a local or remote SurrealDB database server.
---
import Since from '@components/shared/Since.astro'
import Label from "@components/shared/Label.astro";

# SQL command

The SQL command starts a REPL for running or piping SurrealQL queries to a local or remote SurrealDB database server.

> [!NOTE: BEFORE YOU START]
> Make sure you’ve [installed SurrealDB](/docs/surrealdb/installation) — it should only take a second!

## Command options

<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2">
                `-e` / `--endpoint` / `--conn`
               <Label label="optional" />
            </td>
            <td>
            Sets the url of the database server to connect to
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-u` / `--user`
                <Label label="required" />
            </td>
            <td>
                Sets master username for the database
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-p` / `--pass`
                <Label label="required" />
            </td>
            <td>
                Sets master password for the database
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--allow-experimental`
               <Label label="optional" />
            </td>
            <td>
                Enable experimental capabilities
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--ns`
               <Label label="optional" />
            </td>
            <td>
                Sets the desired namespace in which to import data
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--db`
               <Label label="optional" />
            </td>
            <td>
                Sets the desired database into which to import data
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--auth-level`
               <Label label="optional" />
            </td>
            <td>
                The authentication level to use when connecting to the server.
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-t` / `--token`
               <Label label="optional" />
            </td>
            <td>
                Sets the authentication token to use when connecting to the server. Connect to SurrealDB using a JWT instead of user credentials
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--pretty`
               <Label label="optional" />
            </td>
            <td>
                Sets whether database responses should be pretty printed
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--json`
               <Label label="optional" />
            </td>
            <td>
                Sets whether to emit results in JSON
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--multi`
               <Label label="optional" />
            </td>
            <td>
                Sets whether omitting semicolon causes a newline 
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-h` / `--help`
               <Label label="optional" />
            </td>
            <td>
                Prints help
            </td>
        </tr>
    </tbody>
</table>


## `--auth-level` option

<Since v="v2.0.0" />

The `--auth-level` option sets the authentication level to use when connecting to the database. The option has three possible values: `root`, `namespace`, and `database`. The `root` value is the highest level of authentication, while the `namespace` and `database` values are used for authenticating as users defined on a specific namespace or database. 

There are a few things to keep in mind when using the `--auth-level` option:

- The `root` value is used to access the database server as a root user, and if not specified is the default value.

```bash
surreal sql --endpoint http://localhost:8000 --namespace test --database test --auth-level root --username username --password password
```

- The `namespace` value is used for accessing a specific namespace and all databases within that namespace. When this level is specified, a namespace must be provided via `--namespace`.

```bash
surreal sql --endpoint http://localhost:8000 --namespace test --database test --auth-level namespace --username username --password password
```

- The `database` value is used for accessing a specific database within a namespace. When this level is specified, a namespace and a database must be provided via `--namespace` and `--database`.

```bash
surreal sql --endpoint http://localhost:8000 --namespace test --database test --auth-level database --username username --password password
```

## `--token` option

<Since v="v2.0.0" />

The `--token` option sets the authentication token to use when connecting to the server. This option allows you to connect to SurrealDB using a JWT instead of user credentials. The token is used to authenticate the user and provide access to the database server which means it cannot be provided at the same time as `--username`, `--password` or `--auth-level`.

```bash
surreal sql --endpoint http://localhost:8000 --namespace test --database test --token <token>
```

### Experimental capabilities

<Since v="v2.2.1" />

To use experimental capabilities, set the `SURREAL_CAPS_ALLOW_EXPERIMENTAL` [environment variable](/docs/surrealdb/cli/env) to the experimental capability you want to allow. 

For example, to use [Surrealism](/docs/surrealdb/querying/surrealism), set the `SURREAL_CAPS_ALLOW_EXPERIMENTAL` environment variable to `surrealism`.

```bash
SURREAL_CAPS_ALLOW_EXPERIMENTAL="surrealism" surreal sql ... 
```

or, using the `--allow-experimental` flag:

```bash
surreal sql -e [CONNECTION_STRING] --allow-experimental surrealism 
```

Multiple experimental capabilities can be enabled by separating them with a comma.

```bash
SURREAL_CAPS_ALLOW_EXPERIMENTAL="surrealism, graphql" surreal sql ...

-- OR 

surreal sql -e [CONNECTION_STRING] --allow-experimental surrealism,graphql
```

The current experimental targets are `graphql`, `define_api`, `files`, and `surrealism`.

> [!NOTE]
> The experimental capability is completely hidden in the CLI help command, and `--allow-all` will not enable the experimental capabilities by default.

## Example usage

To start a REPL and run or pipe queries to a local or remote SurrealDB database, run the `surreal sql` command in a terminal with the required arguments.

Once you see the `>` character you can type your SurrealQL query, followed by the `enter` key. The command has support for `↑` and `↓` arrows for selecting previous SQL statements, and stores the statement history in a `history.txt` file. To exit the REPL, use the `ctrl + c` or `ctrl + d` key combinations.

```bash
surreal sql --endpoint http://localhost:8000 --namespace test --database test --auth-level root --username username --password password
```

It is also possible to pipe a set of statements to a remote database. This functionality is only designed for submitting a small number of queries to the database server. For a large number of queries, use the [import command](/docs/surrealdb/cli/import).

```bash
cat myfile.surql | surreal sql --endpoint http://localhost:8000 --username root --password root --namespace test --database test
```

## Using environment variables

When using the `surreal sql` command, you can also use environment variables to set the values for the command-line flags. 

>[!IMPORTANT]
> Most of the flags mentioned in the command output above also mention a corresponding [environment variables](/docs/surrealdb/cli/env#command-environment-variables). 
>
> For example, the `--database` flag can be configured with the `SURREAL_DATABASE` environment variable instead. 

For more on the environment variables available for CLI commands or SurrealDB instances in general, see the [environment variables](/docs/surrealdb/cli/env#command-environment-variables) page.

## Command help
To see the help information and usage instructions, in a terminal run the `surreal sql --help` command without any further arguments. This command gives general information on the arguments, inputs, and additional options for the `sql` command.

```bash
surreal sql --help
```

The output of the above command:

```
Start an SQL REPL in your terminal with pipe support

Usage: surreal sql [OPTIONS]

Options:
  -e, --endpoint <ENDPOINT>
          Remote database server url to connect to
          
          [default: ws://localhost:8000]
          [aliases: conn]

  -u, --username <USERNAME>
          Database authentication username to use when connecting
          
          [env: SURREAL_USER=]
          [aliases: user]

  -p, --password <PASSWORD>
          Database authentication password to use when connecting
          
          [env: SURREAL_PASS=]
          [aliases: pass]

  -t, --token <TOKEN>
          Authentication token in JWT format to use when connecting
          
          [env: SURREAL_TOKEN=]

      --auth-level <AUTH_LEVEL>
          Level on which the authenticating user is defined
          
          [env: SURREAL_AUTH_LEVEL=]
          [default: root]
          [possible values: root, namespace, ns, database, db]

      --namespace <NAMESPACE>
          The selected namespace
          
          [env: SURREAL_NAMESPACE=]
          [aliases: ns]

      --database <DATABASE>
          The selected database
          
          [env: SURREAL_DATABASE=]
          [aliases: db]

      --pretty
          Whether database responses should be pretty printed

      --json
          Whether to emit results in JSON

      --multi
          Whether omitting semicolon causes a newline

      --hide-welcome
          Whether to show welcome message
          
          [env: SURREAL_HIDE_WELCOME=]

  -l, --log <LOG>
          The logging level for the command-line tool
          
          [env: SURREAL_LOG=]
          [default: info]
          [possible values: none, full, error, warn, info, debug, trace]

  -h, --help
          Print help (see a summary with '-h')

Capabilities:
  -A, --allow-all
          Allow all capabilities except for those more specifically denied
          
          [env: SURREAL_CAPS_ALLOW_ALL=]

      --allow-scripting
          Allow execution of embedded scripting functions
          
          [env: SURREAL_CAPS_ALLOW_SCRIPT=]

      --allow-guests
          Allow guest users to execute queries
          
          [env: SURREAL_CAPS_ALLOW_GUESTS=]

      --allow-funcs [<ALLOW_FUNCS>...]
          Allow execution of all functions except for functions that are specifically denied. Alternatively, you can provide a comma-separated list of function names to allow
          Specifically denied functions and function families prevail over any other allowed function execution.
          Function names must be in the form <family>[::<name>]. For example:
           - 'http' or 'http::*' -> Include all functions in the 'http' family
           - 'http::get' -> Include only the 'get' function in the 'http' family
          
          
          [env: SURREAL_CAPS_ALLOW_FUNC=]

      --allow-arbitrary-query [<ALLOW_ARBITRARY_QUERY>...]
          Allow execution of arbitrary queries by certain user groups except when specifically denied. Alternatively, you can provide a comma-separated list of user groups to allow
          Specifically denied user groups prevail over any other allowed user group.
          User groups must be one of "guest", "record" or "system".
          
          
          [env: SURREAL_CAPS_ALLOW_ARBITRARY_QUERY=]

      --allow-net [<ALLOW_NET>...]
          Allow all outbound network connections except for network targets that are specifically denied. Alternatively, you can provide a comma-separated list of network targets to allow
          Specifically denied network targets prevail over any other allowed outbound network connections.
          Targets must be in the form of <host>[:<port>], <ipv4|ipv6>[/<mask>]. For example:
           - 'surrealdb.com', '127.0.0.1' or 'fd00::1' -> Match outbound connections to these hosts on any port
           - 'surrealdb.com:80', '127.0.0.1:80' or 'fd00::1:80' -> Match outbound connections to these hosts on port 80
           - '10.0.0.0/8' or 'fd00::/8' -> Match outbound connections to any host in these networks
          
          
          [env: SURREAL_CAPS_ALLOW_NET=]

      --allow-rpc [<ALLOW_RPC>...]
          Allow all RPC methods to be called except for routes that are specifically denied. Alternatively, you can provide a comma-separated list of RPC methods to allow.
          
          [env: SURREAL_CAPS_ALLOW_RPC=]
          [default: ]

      --allow-http [<ALLOW_HTTP>...]
          Allow all HTTP routes to be requested except for routes that are specifically denied. Alternatively, you can provide a comma-separated list of HTTP routes to allow.
          
          [env: SURREAL_CAPS_ALLOW_HTTP=]
          [default: ]

  -D, --deny-all
          Deny all capabilities except for those more specifically allowed
          
          [env: SURREAL_CAPS_DENY_ALL=]

      --deny-scripting
          Deny execution of embedded scripting functions
          
          [env: SURREAL_CAPS_DENY_SCRIPT=]

      --deny-guests
          Deny guest users to execute queries
          
          [env: SURREAL_CAPS_DENY_GUESTS=]

      --deny-funcs [<DENY_FUNCS>...]
          Deny execution of all functions except for functions that are specifically allowed. Alternatively, you can provide a comma-separated list of function names to deny.
          Specifically allowed functions and function families prevail over a general denial of function execution.
          Function names must be in the form <family>[::<name>]. For example:
           - 'http' or 'http::*' -> Include all functions in the 'http' family
           - 'http::get' -> Include only the 'get' function in the 'http' family
          
          
          [env: SURREAL_CAPS_DENY_FUNC=]

      --deny-arbitrary-query [<DENY_ARBITRARY_QUERY>...]
          Deny execution of arbitrary queries by certain user groups except when specifically allowed. Alternatively, you can provide a comma-separated list of user groups to deny
          Specifically allowed user groups prevail over a general denial of user group.
          User groups must be one of "guest", "record" or "system".
          
          
          [env: SURREAL_CAPS_DENY_ARBITRARY_QUERY=]

      --deny-net [<DENY_NET>...]
          Deny all outbound network connections except for network targets that are specifically allowed. Alternatively, you can provide a comma-separated list of network targets to deny.
          Specifically allowed network targets prevail over a general denial of outbound network connections.
          Targets must be in the form of <host>[:<port>], <ipv4|ipv6>[/<mask>]. For example:
           - 'surrealdb.com', '127.0.0.1' or 'fd00::1' -> Match outbound connections to these hosts on any port
           - 'surrealdb.com:80', '127.0.0.1:80' or 'fd00::1:80' -> Match outbound connections to these hosts on port 80
           - '10.0.0.0/8' or 'fd00::/8' -> Match outbound connections to any host in these networks
          
          
          [env: SURREAL_CAPS_DENY_NET=]

      --deny-rpc [<DENY_RPC>...]
          Deny all RPC methods from being called except for methods that are specifically allowed. Alternatively, you can provide a comma-separated list of RPC methods to deny.
          
          [env: SURREAL_CAPS_DENY_RPC=]

      --deny-http [<DENY_HTTP>...]
          Deny all HTTP routes from being requested except for routes that are specifically allowed. Alternatively, you can provide a comma-separated list of HTTP routes to deny.
          
          [env: SURREAL_CAPS_DENY_HTTP=]
```






================================================
FILE: src/content/doc-surrealdb/cli/start.mdx
================================================
---
sidebar_position: 2
sidebar_label: Start command
title: Start command | CLI tool
description: A command that begins a running instance of a SurrealDB server with arguments to set the storage backend, authentication and more.
---
import Since from '@components/shared/Since.astro'
import Label from "@components/shared/Label.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Start command

The start command starts a SurrealDB server in memory, on disk, or in a distributed setup.

> [!NOTE: BEFORE YOU START]
> Make sure you’ve [installed SurrealDB](/docs/surrealdb/installation) — it should only take a second!

## Command options

<Tabs groupId="surreal-start">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2">
                `-b` / `--bind`
               <Label label="optional" />
            </td>
            <td>
            Sets the hostname or IP address to listen for connections on
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-l` / `--log`
               <Label label="optional" />
            </td>
            <td>
                Sets the logging level for the database server
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-u` / `--user`
               <Label label="optional" />
            </td>
            <td>
                Sets master username for the database
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-p` / `--pass`
               <Label label="optional" />
            </td>
            <td>
                Sets master password for the database
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--allow-experimental`
               <Label label="optional" />
            </td>
            <td>
                Enable experimental capabilities
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--auth`
               <Label label="optional" />
            </td>
            <td>
                Sets authentication to enabled
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--no-identification-headers`
               <Label label="optional" />
            </td>
            <td>
                Whether to suppress the server name and version headers
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-s` / `--strict`
               <Label label="optional" />
            </td>
            <td>
                Sets whether strict mode is enabled on this database instance
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2">
                `-b` / `--bind`
               <Label label="optional" />
            </td>
            <td>
            Sets the hostname or IP address to listen for connections on
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--import-file`
               <Label label="optional" />
            </td>
            <td>
            Path to a SurrealQL (`.surql`) file that will be imported when starting the server
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-l` / `--log`
               <Label label="optional" />
            </td>
            <td>
                Sets the logging level for the database server
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-u` / `--user`
               <Label label="optional" />
            </td>
            <td>
                Sets master username for the database
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-p` / `--pass`
               <Label label="optional" />
            </td>
            <td>
                Sets master password for the database
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--unauthenticated`
               <Label label="optional" />
            </td>
            <td>
                Whether to allow unauthenticated access
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--no-identification-headers`
               <Label label="optional" />
            </td>
            <td>
                Whether to suppress the server name and version headers
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-s` / `--strict`
               <Label label="optional" />
            </td>
            <td>
                Sets whether strict mode is enabled on this database instance
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--temporary-directory`
               <Label label="optional" />
            </td>
            <td>
                Sets the directory for storing temporary database files
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--allow-experimental`
               <Label label="optional" />
            </td>
            <td>
                Sets the experimental capabilities to the experimental capabilities you want to allow.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

</Tabs>

## Positional argument

> [!WARNING]
> FoundationDB support is deprecated in SurrealDB `3.0`. Please plan to migrate to a supported storage backend.

In the `surreal start` command, the path argument is used to specify the location of the database. If no argument is given, the default of `memory` for non-persistent storage in memory is assumed. 

When using a path argument with SurrealDB, we recommend not using the `file://` prefix. Instead, please use [`surrealkv://`](/docs/surrealkv) or [`rocksdb://`](/docs/surrealdb/cli/start#rocksdb) as the path argument. If you are using the `file://` prefix, the database will start with the following warning:

> `file://` is deprecated, please use `surrealkv://` or `rocksdb://`

### Absolute vs. relative paths

The datastorage flavour (`rocksdb`, `surrealkv`, etc.) followed by `:` or `://` will be recognized as a relative path. Any other number of slashes such as `rocksdb:/path` or `surrealkv:///path` will be interpreted as an absolute path. As a short absolute path of this nature will often require elevated permissions, the output for this command may end in this sort of error.

> Failed to create RocksDB directory: `Os { code: 30, kind: ReadOnlyFilesystem, message: "Read-only file system" }`.

If you see this error without having intended to start the server on an absolute path, it is likely that the path passed in unintentionally contains either one slash or more than two slashes.

<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2">
                `path`
               <Label label="optional" />
            </td>
            <td>
                Sets the path for storing data. If no argument is given, the default of `memory` for non-persistent storage in memory is assumed.
                
                <br/>
                Arguments for persistent backends are a combination of the backend name, a `:` or `://`, and an address or filename.
                
                <br/>
                Examples: `surrealkv://mydb` or `rocksdb:database`.

                <br/>
                <ul>
                    <li>`rocksdb` for RocksDB</li>
                    <li>`fdb` for FoundationDB</li>
                    <li>`indxdb` for IndexedDB</li>
                    <li>`memory` (or no argument) for in-memory storage</li>
                    <li>`surrealkv` for SurrealKV without versioning (as of SurrealDB 2.1.1)</li>
                    <li>`surrealkv+versioned` for SurrealKV with versioning (as of SurrealDB 2.1.1)</li>
                    <li>`tikv` for TiKV</li>
                </ul>
            </td>
        </tr>
    </tbody>
</table>

> [!NOTE]
> Be sure not to use multiple storage backends in the same location, such as `rocksdb://path/to/database` followed by `surrealkv://path/to/database`. As storage is entirely delegated to the backend, the CLI is not aware of the structure of the data itself. While each backend uses its own file names and directory structure to store data, it is possible that data overwrite or other issues may occur.

## Getting started

This example will show how to host a SurrealDB server with the `surreal start` command, and then access the Surreal DB server using the [`surreal sql` command](/docs/surrealdb/cli/sql).

To start a SurrealDB server, run the `surreal start` command, using the options below. This example stores the database in memory, with a username and password, hosted at `127.0.0.1:8000` (the default location).

```bash
surreal start memory --user my_username --pass my_password
```

The server is actively running, and can be left alone until you want to stop hosting the SurrealDB server.

> [!NOTE]
> The message "Started web server on 127.0.0.1:8000", indicates where the server is being hosted and can be accessed by clients. The location `127.0.0.1:8000` is the default, and can be manually changed by specifying the `--bind` option of the `surreal start` command.

The `surreal start` command starts the server as a whole without regard to individual namespaces or databases.

To access the SurrealDB server that you have started hosting, open a new terminal which will act as the "client", while the previous terminal is still running the `surreal start` command described above. This is done using a separate [`surreal sql` command](/docs/surrealdb/cli/sql). A particular namespace and database can be specified using the `surreal sql` command, as seen below.

```bash
surreal sql --endpoint http://127.0.0.1:8000 --namespace my_namespace --database my_database --username my_username --password my_password
```

Ensure that the hosting location indicated by the output of the `surreal start` command is passed to the `--endpoint` argument, and that you specify the same `--username` and `--password` as in the `surreal start` command.

The above example also selects a namespace and database so that you can immediately start entering queries if you wish. See the documentation of the [`surreal sql` command](/docs/surrealdb/cli/sql) for more information.

## Strict mode

SurrealDB supports the ability to startup in strict mode. When running in strict mode, no `NAMESPACE`, `DATABASE`, or `TABLE` definitions will be enacted automatically when data is inserted. Instead, if the selected namespace, database, or table has not been specifically defined, then the query will return an error.

```bash
surreal start --strict --log debug memory
```

## RocksDB

To start a SurrealDB instance with RocksDB as the storage engine include the `rocksdb://` prefix in the path argument. 

```bash
surreal start -u root -p root rocksdb://mydb
```

## SurrealKV (Beta)

<Since v="v2.0.0" />

To start a SurrealDB instance with SurrealKV as the storage engine, include the `surrealkv://` prefix in the path argument.

```bash
surreal start -u root -p root surrealkv://mydb
```

While SurrealKV supports historical/temporal querying using the `VERSION` clause when [selecting](/docs/surrealql/statements/select#the-version-clause) or [creating](/docs/surrealql/statements/create#version) data, you must explicitly opt in to this using the `surrealkv+versioned://` prefix in the path argument.

```bash
surreal start -u root -p root surrealkv+versioned://mydb
```

You can learn more about SurrealKV and how it compares to RocksDB in the [SurrealKV documentation](/docs/surrealkv). 

## Authentication

When starting a SurrealDB instance, authentication is enabled by default, and your user credentials will be required to connect. If you are starting a new instance, the user credentials you use to run the `start` command will [define a new root user](/docs/surrealql/statements/define/user#roles) with the[`OWNER`](/docs/surrealql/statements/define/user#roles) role.

```bash
surreal start -user root -password root
```

## Enabling capabilities

> [!NOTE]
> If using SurrealDB Cloud , capabilities can be set using the [Configure Instance](/docs/cloud/advanced-topics/configure-an-instance) panel on Surrealist.

Capabilities arguments such as `allow-scripting` or `deny-net` can also be passed into the `surreal start` command. These arguments, the order in which they are evaluated, and other notes on security are presented in detail in a [separate page on capabilities](/docs/surrealdb/security/capabilities).

A production-oriented example of the `surreal start` command that begins with the `--deny-all` flag and only thereafter sets which capabilities will be allowed:

```
surreal start --deny-all --allow-funcs "array, string, crypto::argon2, http::get" --allow-net api.example.com:443
```

## Unauthenticated mode

<Since v="v2.0.0" />

Using the `--unauthenticated` flag, you can also start a SurrealDB instance in unauthenticated mode. By doing so, authentication will be disabled. In this mode, any guest user is considered to have the same permissions as a root user with the [`OWNER`](/docs/surrealql/statements/define/user#roles) role.

> [!NOTE]
> We recommend enabling authentication when running SurrealDB in production or in publicly exposed ways. Failure to do so may result in unauthorized access.

To start a SurrealDB instance in unauthenticated mode, run the following command:

```bash
surreal start --unauthenticated
```

## Identification headers

<Since v="v2.0.0" />

By default, SurrealDB includes headers in the HTTP response that identify the server name and version. You can suppress these headers by using the `--no-identification-headers` flag.

```bash
surreal start --no-identification-headers
```

## Experimental capabilities

<Since v="v2.2.0" />

To use experimental capabilities, set the `SURREAL_CAPS_ALLOW_EXPERIMENTAL` [environment variable](/docs/surrealdb/cli/env) to the experimental capability you want to allow. 

For example, to use [Surrealism](/docs/surrealdb/querying/surrealism), set the `SURREAL_CAPS_ALLOW_EXPERIMENTAL` environment variable to `surrealism`.

<table>
    <thead>
        <tr>
            <th>Feature</th>
            <th>Tag</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><a href="/docs/surrealdb/querying/graphql/surrealist">GraphQL</a></td>
            <td><code>graphql</code></td>
        </tr>
        <tr>
            <td><a href="/docs/surrealql/statements/define/config">DEFINE CONFIG API</a> and <a href="/docs/surrealql/statements/define/api">DEFINE API</a></td>
            <td><code>define_api</code></td>
        </tr>
        <tr>
            <td><a href="/docs/surrealql/statements/define/bucket">DEFINE BUCKET</a></td>
            <td><code>files</code></td>
        </tr>
    </tbody>
</table>

```bash
SURREAL_CAPS_ALLOW_EXPERIMENTAL="surrealism,graphql" surreal start  
```

or, using the `--allow-experimental` flag:

```bash
surreal start --allow-experimental graphql 
```
Multiple experimental capabilities can be enabled by separating them with a comma.

```bash
SURREAL_CAPS_ALLOW_EXPERIMENTAL="graphql, define_api" surreal start
surreal start --allow-experimental graphql,define_api
```

> [!NOTE]
> The experimental capability is completely hidden in the CLI help command, and `--allow-all` will not enable the experimental capabilities by default.

## Further examples

As `surreal start` is the command with by far the largest number of options, a few more examples will help give an idea of what sort of configurations are available.

An instance with a single root user, able to connect to the internet but unable to use three functions:

```bash
surreal start --user root --pass secret --allow-net --deny-funcs "crypto::md5, http::post, http::delete"
```

An instance with more verbose logging that uses RocksDB as its storage engine:

```bash
surreal start --log debug rocksdb:mydatabase.db
```

An instance with all capabilities denied except a few functions and a single endpoint:

```bash
surreal start --deny-all --allow-funcs "array, string, crypto::argon2, http::get" --allow-net api.example.com:443
```

An instance with a different default address, less verbose logging level, and ability to use JavaScript functions:

```bash
surreal start --bind 0.0.0.0:2218 --log warn --allow-scripting
```

## Using environment variables

When using the `surreal start` command, you can also use environment variables to set the values for the command-line flags. This is useful when you want to set the values for the command-line flags without having to pass them directly on the command line.

>[!IMPORTANT]
> Most of the flags mentioned in the command output above also mention a corresponding [environment variables](/docs/surrealdb/cli/env#command-environment-variables). 
>
> For example, the `--temporary-directory` flag can be configured with the `SURREAL_TEMPORARY_DIRECTORY` environment variable instead. 

For more on the environment variables available for CLI commands or SurrealDB instances in general, see the [environment variables](/docs/surrealdb/cli/env#command-environment-variables) page.

## Command help

To see the help information and usage instructions, in a terminal run the `surreal start --help` command without any further arguments. This command gives general information on the arguments, inputs, and additional options for the `start` command.

```bash
surreal start --help
```

The output of the above command:

```
Start the database server

Usage: surreal start [OPTIONS] [PATH]

Arguments:
  [PATH]
          Database path used for storing data

          [env: SURREAL_PATH=]
          [default: memory]

Options:
      --no-banner
          Whether to hide the startup banner

          [env: SURREAL_NO_BANNER=]

      --index-compaction-interval <INDEX_COMPACTION_INTERVAL>
          [env: SURREAL_INDEX_COMPACTION_INTERVAL=]
          [default: 5s]

  -h, --help
          Print help (see a summary with '-h')

Database:
      --node-membership-refresh-interval <NODE_MEMBERSHIP_REFRESH_INTERVAL>
          The interval at which to refresh node registration information

          [env: SURREAL_NODE_MEMBERSHIP_REFRESH_INTERVAL=]
          [default: 3s]

      --node-membership-check-interval <NODE_MEMBERSHIP_CHECK_INTERVAL>
          The interval at which process and archive inactive nodes

          [env: SURREAL_NODE_MEMBERSHIP_CHECK_INTERVAL=]
          [default: 15s]

      --node-membership-cleanup-interval <NODE_MEMBERSHIP_CLEANUP_INTERVAL>
          The interval at which to process and cleanup archived nodes

          [env: SURREAL_NODE_MEMBERSHIP_CLEANUP_INTERVAL=]
          [default: 300s]

      --changefeed-gc-interval <CHANGEFEED_GC_INTERVAL>
          The interval at which to perform changefeed garbage collection

          [env: SURREAL_CHANGEFEED_GC_INTERVAL=]
          [default: 10s]

  -s, --strict
          Whether strict mode is enabled on this database instance

          [env: SURREAL_STRICT=]

      --query-timeout <QUERY_TIMEOUT>
          The maximum duration that a set of statements can run for

          [env: SURREAL_QUERY_TIMEOUT=]

      --transaction-timeout <TRANSACTION_TIMEOUT>
          The maximum duration that any single transaction can run for

          [env: SURREAL_TRANSACTION_TIMEOUT=]

Authentication:
  -u, --username <USERNAME>
          The username for the initial database root user. Only if no other root user exists

          [env: SURREAL_USER=]
          [aliases: user]

  -p, --password <PASSWORD>
          The password for the initial database root user. Only if no other root user exists

          [env: SURREAL_PASS=]
          [aliases: pass]

      --unauthenticated
          Whether to allow unauthenticated access

          [env: SURREAL_UNAUTHENTICATED=]

Datastore connection:
      --kvs-ca <KVS_CA>
          Path to the CA file used when connecting to the remote KV store

          [env: SURREAL_KVS_CA=]

      --kvs-crt <KVS_CRT>
          Path to the certificate file used when connecting to the remote KV store

          [env: SURREAL_KVS_CRT=]

      --kvs-key <KVS_KEY>
          Path to the private key file used when connecting to the remote KV store

          [env: SURREAL_KVS_KEY=]

HTTP server:
      --web-crt <WEB_CRT>
          Path to the certificate file for encrypted client connections

          [env: SURREAL_WEB_CRT=]

      --web-key <WEB_KEY>
          Path to the private key file for encrypted client connections

          [env: SURREAL_WEB_KEY=]

      --client-ip <CLIENT_IP>
          The method of detecting the client's IP address

          [env: SURREAL_CLIENT_IP=]
          [default: socket]

          Possible values:
          - none:             Don't use client IP
          - socket:           Raw socket IP
          - CF-Connecting-IP: Cloudflare connecting IP
          - Fly-Client-IP:    Fly.io client IP
          - True-Client-IP:   Akamai, Cloudflare true client IP
          - X-Real-IP:        Nginx real IP
          - X-Forwarded-For:  Industry standard header used by many proxies

  -b, --bind <LISTEN_ADDRESSES>
          The hostname or IP address to listen for connections on

          [env: SURREAL_BIND=]
          [default: 127.0.0.1:8000]

      --no-identification-headers
          Whether to suppress the server name and version headers

          [env: SURREAL_NO_IDENTIFICATION_HEADERS=]

Capabilities:
  -A, --allow-all
          Allow all capabilities except for those more specifically denied

          [env: SURREAL_CAPS_ALLOW_ALL=]

      --allow-scripting
          Allow execution of embedded scripting functions

          [env: SURREAL_CAPS_ALLOW_SCRIPT=]

      --allow-guests
          Allow guest users to execute queries

          [env: SURREAL_CAPS_ALLOW_GUESTS=]

      --allow-funcs [<ALLOW_FUNCS>...]
          Allow execution of all functions except for functions that are specifically denied.
          Alternatively, you can provide a comma-separated list of function names to allow
          Specifically denied functions and function families prevail over any other allowed function execution.
          Function names must be in the form <family>[::<name>]. For example:
           - 'http' or 'http::*' -> Include all functions in the 'http' family
           - 'http::get' -> Include only the 'get' function in the 'http' family


          [env: SURREAL_CAPS_ALLOW_FUNC=]

      --allow-arbitrary-query [<ALLOW_ARBITRARY_QUERY>...]
          Allow execution of arbitrary queries by certain user groups except when specifically denied.
          Alternatively, you can provide a comma-separated list of user groups to allow
          Specifically denied user groups prevail over any other allowed user group.
          User groups must be one of "guest", "record" or "system".


          [env: SURREAL_CAPS_ALLOW_ARBITRARY_QUERY=]

      --allow-net [<ALLOW_NET>...]
          Allow all outbound network connections except for network targets that are specifically denied.
          Alternatively, you can provide a comma-separated list of network targets to allow
          Specifically denied network targets prevail over any other allowed outbound network connections.
          Targets must be in the form of <host>[:<port>], <ipv4|ipv6>[/<mask>]. For example:
           - 'surrealdb.com', '127.0.0.1' or 'fd00::1' -> Match outbound connections to these hosts on
           any port
           - 'surrealdb.com:80', '127.0.0.1:80' or 'fd00::1:80' -> Match outbound connections to these
           hosts on port 80
           - '10.0.0.0/8' or 'fd00::/8' -> Match outbound connections to any host in these networks


          [env: SURREAL_CAPS_ALLOW_NET=]

      --allow-rpc [<ALLOW_RPC>...]
          Allow all RPC methods to be called except for routes that are specifically denied.
          Alternatively, you can provide a comma-separated list of RPC methods to allow.

          [env: SURREAL_CAPS_ALLOW_RPC=]
          [default: ]

      --allow-http [<ALLOW_HTTP>...]
          Allow all HTTP routes to be requested except for routes that are specifically denied.
          Alternatively, you can provide a comma-separated list of HTTP routes to allow.

          [env: SURREAL_CAPS_ALLOW_HTTP=]
          [default: ]

  -D, --deny-all
          Deny all capabilities except for those more specifically allowed

          [env: SURREAL_CAPS_DENY_ALL=]

      --deny-scripting
          Deny execution of embedded scripting functions

          [env: SURREAL_CAPS_DENY_SCRIPT=]

      --deny-guests
          Deny guest users to execute queries

          [env: SURREAL_CAPS_DENY_GUESTS=]

      --deny-funcs [<DENY_FUNCS>...]
          Deny execution of all functions except for functions that are specifically allowed.
          Alternatively, you can provide a comma-separated list of function names to deny.
          Specifically allowed functions and function families prevail over a general denial of function execution.
          Function names must be in the form <family>[::<name>]. For example:
           - 'http' or 'http::*' -> Include all functions in the 'http' family
           - 'http::get' -> Include only the 'get' function in the 'http' family


          [env: SURREAL_CAPS_DENY_FUNC=]

      --deny-arbitrary-query [<DENY_ARBITRARY_QUERY>...]
          Deny execution of arbitrary queries by certain user groups except when specifically allowed.
          Alternatively, you can provide a comma-separated list of user groups to deny
          Specifically allowed user groups prevail over a general denial of user group.
          User groups must be one of "guest", "record" or "system".


          [env: SURREAL_CAPS_DENY_ARBITRARY_QUERY=]

      --deny-net [<DENY_NET>...]
          Deny all outbound network connections except for network targets that are specifically allowed.
          Alternatively, you can provide a comma-separated list of network targets to deny.
          Specifically allowed network targets prevail over a general denial of outbound network
          connections.
          Targets must be in the form of <host>[:<port>], <ipv4|ipv6>[/<mask>]. For example:
           - 'surrealdb.com', '127.0.0.1' or 'fd00::1' -> Match outbound connections to these hosts on
           any port
           - 'surrealdb.com:80', '127.0.0.1:80' or 'fd00::1:80' -> Match outbound connections to these
           hosts on port 80
           - '10.0.0.0/8' or 'fd00::/8' -> Match outbound connections to any host in these networks


          [env: SURREAL_CAPS_DENY_NET=]

      --deny-rpc [<DENY_RPC>...]
          Deny all RPC methods from being called except for methods that are specifically allowed.
          Alternatively, you can provide a comma-separated list of RPC methods to deny.

          [env: SURREAL_CAPS_DENY_RPC=]

      --deny-http [<DENY_HTTP>...]
          Deny all HTTP routes from being requested except for routes that are specifically allowed.
          Alternatively, you can provide a comma-separated list of HTTP routes to deny.

          [env: SURREAL_CAPS_DENY_HTTP=]

      --temporary-directory <TEMPORARY_DIRECTORY>
          Sets the directory for storing temporary database files

          [env: SURREAL_TEMPORARY_DIRECTORY=]

      --import-file <IMPORT_FILE>
          Path to a SurrealQL file that will be imported when starting the server

          [env: SURREAL_IMPORT_FILE=]

      --slow-log-threshold <SLOW_LOG_THRESHOLD>
          The minimum execution time in milliseconds to trigger slow query logging

          [env: SURREAL_SLOW_QUERY_LOG_THRESHOLD=]

      --slow-log-param-allow <SLOW_LOG_PARAM_ALLOW>...
          A comma-separated list of parameter names to include in slow query logs

          [env: SURREAL_SLOW_QUERY_LOG_PARAM_ALLOW=]

      --slow-log-param-deny <SLOW_LOG_PARAM_DENY>...
          A comma-separated list of parameter names to omit from slow query logs

          [env: SURREAL_SLOW_QUERY_LOG_PARAM_DENY=]

Logging:
  -l, --log <LOG>
          The logging level for the command-line tool

          [env: SURREAL_LOG=]
          [default: info]
          [possible values: none, full, error, warn, info, debug, trace]

      --log-format <LOG_FORMAT>
          The format for terminal log output

          [env: SURREAL_LOG_FORMAT=]
          [default: text]
          [possible values: text, json]

      --log-socket <LOG_SOCKET>
          Send logs to the specified host:port

          [env: SURREAL_LOG_SOCKET=]

      --log-file-level <LOG_FILE_LEVEL>
          Override the logging level for file output

          [env: SURREAL_LOG_FILE_LEVEL=]
          [possible values: none, full, error, warn, info, debug, trace]

      --log-otel-level <LOG_OTEL_LEVEL>
          Override the logging level for OpenTelemetry output

          [env: SURREAL_LOG_OTEL_LEVEL=]
          [possible values: none, full, error, warn, info, debug, trace]

      --log-socket-level <LOG_SOCKET_LEVEL>
          Override the logging level for unix socket output

          [env: SURREAL_LOG_SOCKET_LEVEL=]
          [possible values: none, full, error, warn, info, debug, trace]

      --log-socket-format <LOG_SOCKET_FORMAT>
          The format for socket output

          [env: SURREAL_LOG_SOCKET_FORMAT=]
          [default: text]
          [possible values: text, json]

      --log-file-enabled
          Whether to enable log file output

          [env: SURREAL_LOG_FILE_ENABLED=]

      --log-file-path <LOG_FILE_PATH>
          The directory where log files will be stored

          [env: SURREAL_LOG_FILE_PATH=]
          [default: logs]

      --log-file-name <LOG_FILE_NAME>
          The name of the log file

          [env: SURREAL_LOG_FILE_NAME=]
          [default: surrealdb.log]

      --log-file-format <LOG_FILE_FORMAT>
          The format for log file output

          [env: SURREAL_LOG_FILE_FORMAT=]
          [default: text]
          [possible values: text, json]

      --log-file-rotation <LOG_FILE_ROTATION>
          The log file rotation interval

          [env: SURREAL_LOG_FILE_ROTATION=]
          [default: daily]
          [possible values: daily, hourly, never]
```




================================================
FILE: src/content/doc-surrealdb/cli/upgrade.mdx
================================================
---
sidebar_position: 10
sidebar_label: Upgrade command
title: Upgrade command | CLI tool
description: A command to change the current version of SurrealDB to another one, including the latest version, specified version, or nightly.
---

import Since from '@components/shared/Since.astro'
import Label from "@components/shared/Label.astro";

# Upgrade command

The upgrade command upgrades SurrealDB to the latest version, nightly or a specified version.


> [!NOTE: BEFORE YOU START]
> Make sure you’ve [installed SurrealDB](/docs/surrealdb/installation) — it should only take a second!

## Command options

<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2">
                `--nightly`
               <Label label="optional" />
            </td>
            <td>
            installs the latest nightly version of SurrealDB
            </td>
        </tr>
                <tr>
            <td colspan="2">
                `--alpha`
               <Label label="optional" />
            </td>
            <td>
            installs the latest alpha version of SurrealDB
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--beta`
               <Label label="optional" />
            </td>
            <td>
            installs the latest beta version of SurrealDB
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--version`
               <Label label="optional" />
            </td>
            <td>
                installs a specific version of SurrealDB
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--dry-run`
               <Label label="optional" />
            </td>
            <td>
                Does not actually replace the currently installed version of SurrealDB.
            </td>
        </tr>
    </tbody>
</table>

## Example usage

This example shows how you can use the upgrade command to upgrade to the latest version of SurrealDB.

```bash
surreal upgrade
```

## Global install

If SurrealDB is installed globally on your system, you might need to run the upgrade command with elevated permissions, such as `sudo` on Unix-based systems or with administrator privileges in Windows.

```bash
sudo surreal upgrade
```

## Install specific version

Use the `--version` flag to upgrade to a specific version of SurrealDB.

```bash
surreal upgrade --version [VERSION]

-- example
surreal upgrade --version 2.2.1
```

For a list of available versions and their release notes, see the [releases](/releases) page.

## Install the alpha release

<Since v="v1.5.3" />

Use the `--alpha` flag to upgrade to the latest alpha version of SurrealDB.

```bash
surreal upgrade --alpha
```

## Install the beta release

<Since v="v1.1.0" />

Use the `--beta` flag to upgrade to the latest beta version of SurrealDB.

```bash
surreal upgrade --beta
```

## Install the nightly release 

Use the `--nightly` flag to upgrade to the latest nightly version of SurrealDB.

```bash
surreal upgrade --nightly
```

## Command help

To see the help information and usage instructions, in a terminal run the `surreal upgrade --help` command without any further arguments. This command gives general information on the arguments, inputs, and additional options for the `upgrade` command.

```bash
surreal upgrade --help
```

The output of the above command:

```
Upgrade to the latest stable version

Usage: surreal upgrade [OPTIONS]

Options:
      --nightly            Install the latest nightly version
      --alpha              Install the latest alpha version
      --beta               Install the latest beta version
      --version <VERSION>  Install a specific version
      --dry-run            Don't actually replace the executable
  -l, --log <LOG>          The logging level for the command-line tool [env: SURREAL_LOG=] [default: info] [possible values: none, full, error, warn, info, debug, trace]
  -h, --help               Print help
```



================================================
FILE: src/content/doc-surrealdb/cli/validate.mdx
================================================
---
sidebar_position: 11
sidebar_label: Validate command
title: Validate command | CLI tool
description: A command to confirm whether one or more SurrealQL files are valid or not.
---
import Label from "@components/shared/Label.astro";

# Validate command

The validate command validates one or many SurrealQL (`.surql`) language files.

> [!NOTE: BEFORE YOU START]
> Make sure you’ve [installed SurrealDB](/docs/surrealdb/installation) — it should only take a second!

## Command options

<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2">
                <code>[PATTERNS] </code>
            </td>
            <td>
        Glob pattern for the files to validate [default: "**/*.surql"]
            </td>
        </tr>
    </tbody>
</table>


## Example usage

To perform validation on a SurrealQL local file, in a terminal run the `surreal validate` command with the required argument.

Using the command on its own will validate all the `.surql` files in the current directory.

```bash
surreal validate
user1.surql: OK
user2.surql: OK
user3.surql: OK
```

You can perform validation on a single file, regardless of extension.

```bash
surreal validate user.surql
surreal validate user.txt
```

You can also perform validation on multiple files using a single glob pattern:

```bash
# equivalent to "surreal validate"
surreal validate **/*.surql
```

Finally, you can also perform validation on multiple files using multiple paths/patterns:

```bash
surreal validate index.surql schemas/*.surql queries/*.surql
surreal validate *.(txt|surql)
```

If any files are invalid, the command will abort at this point and return an error.

```bash
surreal validate
user1.surql: OK
user2.surql: KO
Parse error: Unexpected token `an identifier`, expected Eof
 --> [1:15]
  |
1 | CREATE person SE name = "Billy";
  |               ^^ 
```

## Command help

To see the help information and usage instructions, in a terminal run the `surreal validate --help` command without any further arguments. This command gives general information on the arguments, inputs, and additional options for the `validate` command.

```bash
surreal validate --help
```

The output of the above command:

```
Validate SurrealQL query files

Usage: surreal validate [OPTIONS] [PATTERNS]...

Arguments:
  [PATTERNS]...  Glob pattern for the files to validate [default: **/*.surql]

Options:
  -l, --log <LOG>  The logging level for the command-line tool [env: SURREAL_LOG=] [default: info] [possible values: none, full, error, warn, info, debug, trace]
  -h, --help       Print help
```



================================================
FILE: src/content/doc-surrealdb/cli/version.mdx
================================================
---
sidebar_position: 12
sidebar_label: Version command
title: Version command | CLI tool
description: A command to output the current version of the SurrealDB binary along with the machine architecture.
---
import Since from '@components/shared/Since.astro'
import Label from "@components/shared/Label.astro";

# Version command

The version command outputs the current version of the installed command-line tool, and the machine architecture.

> [!NOTE: BEFORE YOU START]
> Make sure you’ve [installed SurrealDB](/docs/surrealdb/installation) — it should only take a second!

## Command options

<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2">
                `-e` / `--endpoint`
               <Label label="optional" />
            </td>
            <td>
            Remote database server url to connect to [aliases: conn]
            </td>
        </tr>
    </tbody>
</table>

## Example usage

To display the current command-line tool version, along with the platform and architecture, in a terminal run the `surreal version` command without any further arguments.

```bash
surreal version
```

Sample output:

```
2.2.1 for macos on aarch64
```

If an endpoint is specified, only the version number will be displayed.

```bash
surreal version --endpoint http://localhost:8000
```

Output:

```
2.2.1
```

### Check version with CLI flags

<Since v="v1.2.0" />

```bash
surreal -V
```

```bash
surreal --version
```

Sample output:

```
SurrealDB command-line interface and server 2.2.1 for macos on aarch64
```

## Command help

To see the help information and usage instructions, in a terminal run the `surreal version --help` command without any further arguments. This command gives general information on the arguments, inputs, and additional options for the `version` command.

```bash
surreal version --help
```
The output of the above command:

```
Output the command-line tool and remote server version information

Usage: surreal version [OPTIONS]

Options:
  -e, --endpoint <ENDPOINT>  Remote database server url to connect to [aliases: conn]
  -l, --log <LOG>            The logging level for the command-line tool [env: SURREAL_LOG=] [default: info] [possible values: none, full, error, warn, info, debug, trace]
  -h, --help                 Print help
```



================================================
FILE: src/content/doc-surrealdb/cli/ml/export.mdx
================================================
---
sidebar_position: 3
sidebar_label: Export command
title: Export command | ML | CLI tool
description: The CLI ML export command is used to export a machine learning model from SurrealDB.
---

import Label from "@components/shared/Label.astro";

# Export command

The ML export command is used to export an existing machine learning model from SurrealDB.

> [!NOTE: BEFORE YOU START]
> Make sure you’ve [installed SurrealDB](/docs/surrealdb/installation) — it should only take a second!

## Command arguments

<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2">
                `-e,--endpoint/--conn`
               <Label label="optional" />
            </td>
            <td>
            Sets the url of the database server to connect to
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-u / --user`
                <Label label="required" />
            </td>
            <td>
                Sets master username for the database
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-p / --pass`
                <Label label="required" />
            </td>
            <td>
                Sets master password for the database
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-t` / `--token`
               <Label label="optional" />
            </td>
            <td>
                Sets the authentication token to use when connecting to the server. Connect to SurrealDB using a JWT instead of user credentials
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--ns`
                <Label label="required" />
            </td>
            <td>
                Sets the desired namespace in which to import data
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--db`
                <Label label="required" />
            </td>
            <td>
                Sets the desired database into which to import data
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--name`
                <Label label="required" />
            </td>
            <td>
                Represents the name of the model that you want to export
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--version`
                <Label label="required" />
            </td>
            <td>
                Represents the version of the model that you want to export
            </td>
        </tr>
    </tbody>
</table>

## Positional argument

<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2">
                `file`
                <Label label="required" />
            </td>
            <td>
            Sets the path to the file which should be exported
            </td>
        </tr>
    </tbody>
</table>

## Example usage
To perform a SurrealQL database import from a local file, in a terminal run the `surreal import` command with the required arguments.

```bash
surreal ml export --conn http://localhost:8000 --user root --pass secret --ns test --db test --name my-surrealml-model --version 1.0.0 my-surrealml-model.surml
```

Using token-based authentication:

```bash
surreal ml export --conn http://localhost:8000 --token <token> --ns test --db test --name my-surrealml-model --version 1.0.0 my-surrealml-model.surml
```

## Command help
To see the help information and usage instructions, in a terminal run the `surreal ml export --help` command without any further arguments. This command gives general information on the arguments, inputs, and additional options for the `ml export` command.

```bash
surreal ml export --help
```

The output of the above command :


```
Export a SurrealML model from an existing database

Usage: surreal ml export [OPTIONS] --name <NAME> --version <VERSION> --namespace <NAMESPACE> --database <DATABASE> [FILE]

Arguments:
  [FILE]  Path to the SurrealML file to export. Use dash - to write into stdout. [default: -]

Options:
      --name <NAME>              The name of the model [env: SURREAL_NAME=]
      --version <VERSION>        The version of the model [env: SURREAL_VERSION=]
  -e, --endpoint <ENDPOINT>      Remote database server url to connect to [default: ws://localhost:8000] [aliases: conn]
  -u, --username <USERNAME>      Database authentication username to use when connecting [env: SURREAL_USER=] [aliases: user]
  -p, --password <PASSWORD>      Database authentication password to use when connecting [env: SURREAL_PASS=] [aliases: pass]
    -t, --token <TOKEN>            Authentication token in JWT format to use when connecting [env: SURREAL_TOKEN=]
      --auth-level <AUTH_LEVEL>  Authentication level to use when connecting
                                 Must be enabled in the server and uses the values of '--namespace' and '--database'
                                  [env: SURREAL_AUTH_LEVEL=] [default: root] [possible values: root, namespace, ns, database, db]
      --namespace <NAMESPACE>    The namespace selected for the operation [env: SURREAL_NAMESPACE=] [aliases: ns]
      --database <DATABASE>      The database selected for the operation [env: SURREAL_DATABASE=] [aliases: db]
  -h, --help                     Print help
```

<br />


================================================
FILE: src/content/doc-surrealdb/cli/ml/import.mdx
================================================
---
sidebar_position: 2
sidebar_label: Import command
title: Import command | ML | CLI tool
description: The CLI ML import command is used to import a new machine learning model into SurrealDB.
---

import Label from "@components/shared/Label.astro";

# Import command

The ML import command is used to import a new machine learning model into SurrealDB.


> [!NOTE: BEFORE YOU START]
> Make sure you’ve [installed SurrealDB](/docs/surrealdb/installation) — it should only take a second!

## Command arguments

<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2">
                `-e, --endpoint / --conn`
               <Label label="optional" />
            </td>
            <td>
            Sets the url of the database server to connect to
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-u / --user`
                <Label label="required" />
            </td>
            <td>
                Sets master username for the database
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-p / --pass`
                <Label label="required" />
            </td>
            <td>
                Sets master password for the database
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--ns`
                <Label label="required" />
            </td>
            <td>
                Sets the desired namespace in which to import data
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `-t` / `--token`
               <Label label="optional" />
            </td>
            <td>
                Sets the authentication token to use when connecting to the server. Connect to SurrealDB using a JWT instead of user credentials
            </td>
        </tr>
        <tr>
            <td colspan="2">
                `--db`
                <Label label="required" />
            </td>
            <td>
                Sets the desired database into which to import data
            </td>
        </tr>
    </tbody>
</table>

## Positional argument

<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2">
                `file`
                <Label label="required" />
            </td>
            <td>
            Sets the path to the file which should be imported
            </td>
        </tr>
    </tbody>
</table>

## Example usage
To perform a SurrealQL database import from a local file, in a terminal run the `surreal import` command with the required arguments.

```bash
surreal ml import --conn http://localhost:8000 --user root --pass secret --ns test --db test my-surrealml-model.surml
```

Using token-based authentication:

```bash 
surreal import --conn http://localhost:8000 --token <token> --ns test --db test my-surrealml-model.surml
```


## Command help
To see the help information and usage instructions, in a terminal run the `surreal ml import --help` command without any further arguments. This command gives general information on the arguments, inputs, and additional options for the `ml import` command.

```bash
surreal ml import --help
```

The output of the above command :


```
Import a SurrealML model into an existing database

Usage: surreal ml import [OPTIONS] --namespace <NAMESPACE> --database <DATABASE> <FILE>

Arguments:
  <FILE>  Path to the SurrealML file to import

Options:
  -e, --endpoint <ENDPOINT>      Remote database server url to connect to [default: ws://localhost:8000] [aliases: conn]
  -u, --username <USERNAME>      Database authentication username to use when connecting [env: SURREAL_USER=] [aliases: user]
  -p, --password <PASSWORD>      Database authentication password to use when connecting [env: SURREAL_PASS=] [aliases: pass]
      --auth-level <AUTH_LEVEL>  Authentication level to use when connecting
                                 Must be enabled in the server and uses the values of '--namespace' and '--database'
                                  [env: SURREAL_AUTH_LEVEL=] [default: root] [possible values: root, namespace, ns, database, db]
      --namespace <NAMESPACE>    The namespace selected for the operation [env: SURREAL_NAMESPACE=] [aliases: ns]
      --database <DATABASE>      The database selected for the operation [env: SURREAL_DATABASE=] [aliases: db]
  -h, --help                     Print help
```

<br />



================================================
FILE: src/content/doc-surrealdb/cli/ml/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: ML Commands
title: ML | CLI tool
description: The ML commands can be used to import and export machine learning models.
---

# ML commands

The ML commands can be used to import and export machine learning models.


> [!NOTE: Before you begin]
> Make sure you’ve [installed SurrealDB](/docs/surrealdb/installation) — it should only take a second!


## ML Command help
To see the help information and usage instructions, in a terminal run the `surreal ml --help` command without any further arguments. This command gives general information on the arguments, inputs, and additional options for the `ml` command.

```bash
surreal ml --help
```

The output of the above command :


```
Manage SurrealML models within an existing database

Usage: surreal ml <COMMAND>

Commands:
  import  Import a SurrealML model into an existing database
  export  Export a SurrealML model from an existing database
  help    Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help
```

<br />


================================================
FILE: src/content/doc-surrealdb/deployment/amazon.mdx
================================================
---
sidebar_position: 7
sidebar_label: Deploy on Amazon EKS
title: Deploy on Amazon EKS | Deployment
description: A tutorial on how to deploy SurrealDB using Amazon Elastic Kubernetes Service.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/amazon.png";
import DarkLogo from "@img/icon/dark/amazon.png";

<div class="flag-title">
	<Image
		alt="Amazon"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Deploy on Amazon Elastic Kubernetes Service (EKS)
</div>

<br />

## What is Amazon EKS?

[Amazon Elastic Kubernetes Service (Amazon EKS)](https://docs.aws.amazon.com/eks/) is a managed service that eliminates the need to install, operate, and maintain your own Kubernetes control plane on Amazon Web Services (AWS).
This deployment guide covers setting up a highly available SurrealDB cluster backed by [TiKV](https://tikv.org/) on Amazon EKS.

## Requirements

- An account on [Amazon Web Services (AWS)](https://aws.amazon.com/) and also the necessary [Amazon Identity and Access Management (Amazon IAM)](https://aws.amazon.com/iam/) permissions to programmatically create resources in your account.
- [`kubectl`](https://kubernetes.io/docs/tasks/tools/install-kubectl/) To manage the Kubernetes cluster.
- AWS CLI [installed](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html) and [configured](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html) with your user's credentials
- [`eksctl`](https://eksctl.io/installation/) installed

> [!NOTE: COST CONSIDERATIONS]
> Provisioning the environment in your AWS account will create resources and there will be cost associated with them. The cleanup section provides a guide to remove them, preventing further charges.


> [!IMPORTANT]
> This guide was tested in `eu-west-1` (Ireland region) and it follows TiKV best practices for scalability and high availability. It will provision up to 12 Amazon Elastic Compute Cloud (Amazon EC2) instances, several Amazon Elastic Block Storage (Amazon EBS) drives, and up to three Amazon Elastic Loadbalancers (Amazon ELB). The forecasted cost to run this guide is $5 USD per hour.

## Building an EKS Cluster
This section outlines how to build a cluster by using the [`eksctl`](https://eksctl.io/) tool. The following is the configuration that will be used to build the cluster:

```yml title="SURREALDB CLUSTER CONFIG"
apiVersion: eksctl.io/v1alpha5
kind: ClusterConfig
metadata:
  name: ${CLUSTER_NAME}
  region: ${AWS_REGION}
  version: '1.27'
  tags:
    karpenter.sh/discovery: ${CLUSTER_NAME}
    env: ${CLUSTER_NAME}
iam:
  withOIDC: true
vpc:
  cidr: 10.0.0.0/16
  clusterEndpoints:
    privateAccess: true
    publicAccess: true
addons:
- name: vpc-cni
  resolveConflicts: overwrite
- name: aws-ebs-csi-driver
  wellKnownPolicies:      # add IAM and service account
    ebsCSIController: true

managedNodeGroups:

  - name: admin
    desiredCapacity: 1
    privateNetworking: true
    labels:
      dedicated: admin

  - name: pd-1a
    desiredCapacity: 1
    privateNetworking: true
    availabilityZones: ["${AWS_REGION}a"]
    instanceType: c5.xlarge
    labels:
      dedicated: pd
    taints:
    - key: "dedicated"
      value: "pd"
      effect: NoSchedule

  - name: pd-1b
    desiredCapacity: 1
    privateNetworking: true
    availabilityZones: ["${AWS_REGION}b"]
    instanceType: c5.xlarge
    labels:
      dedicated: pd
    taints:
    - key: "dedicated"
      value: "pd"
      effect: NoSchedule

  - name: pd-1c
    desiredCapacity: 1
    privateNetworking: true
    availabilityZones: ["${AWS_REGION}c"]
    instanceType: c5.xlarge
    labels:
      dedicated: pd
    taints:
    - key: "dedicated"
      value: "pd"
      effect: NoSchedule

  - name: tikv-1a
    desiredCapacity: 1
    privateNetworking: true
    availabilityZones: ["${AWS_REGION}a"]
    instanceType: r5b.2xlarge
    labels:
      dedicated: tikv
    taints:

    - key: "dedicated"
      value: "tikv"
      effect: NoSchedule

  - name: tikv-1b
    desiredCapacity: 1
    privateNetworking: true
    availabilityZones: ["${AWS_REGION}b"]
    instanceType: r5b.2xlarge
    labels:
      dedicated: tikv
    taints:
    - key: "dedicated"
      value: "tikv"
      effect: NoSchedule

  - name: tikv-1c
    desiredCapacity: 1
    privateNetworking: true
    availabilityZones: ["${AWS_REGION}c"]
    instanceType: r5b.2xlarge
    labels:
      dedicated: tikv
    taints:
    - key: "dedicated"
      value: "tikv"
      effect: NoSchedule

  - name: default
    desiredCapacity: 2
    minSize: 2
    maxSize: 4
    instanceType: m5.large
    privateNetworking: false
```

Based on this configuration eksctl will:

- Create a [VPC](https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html) across three availability zones
- Create an EKS cluster
- Create an [IAM OIDC](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc.html) provider
- Create the necessary node groups for TiKV according to [best practices](https://docs.pingcap.com/tidb-in-kubernetes/stable/deploy-on-aws-eks)
- Configure the [VPC CNI addon](https://docs.aws.amazon.com/eks/latest/userguide/managing-vpc-cni.html) to manage networking
- Configure the [EBS addon](https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.html) to manage storage volumes

Save the above configuration in a file named `surrealdb-cluster.yml` and apply the configuration file like so:

```yaml title="DEPLOY EKS CLUSTER"
export CLUSTER_NAME=surrealdb-cluster
export AWS_REGION=eu-west-1

envsubst < surrealdb-cluster.yml | eksctl create cluster -f -

aws eks update-kubeconfig --name $CLUSTER_NAME
```

> [!NOTE]
> The deployment of the cluster should take about 30 minutes.

## Deploy TiKV
The following instructions will install `TiKV` operators in your EKS cluster.

```yaml title="CREATE TIKV CLUSTER"
kubectl create namespace tidb-cluster

curl -O https://raw.githubusercontent.com/pingcap/tidb-operator/v1.6.1/examples/aws/tidb-cluster.yaml

kubectl apply -f tidb-cluster.yaml -n tidb-cluster
```

## Install ALB Controller
The following instructions will install the AWS Load Balancer Controller.

The AWS Load Balancer Controller provisions and manages the necessary AWS resources when Kubernetes creates an `Ingress` or a `LoadBalancer`

Formerly known as AWS ALB Ingress Controller, it's an open-source project on [GitHub](https://github.com/kubernetes-sigs/aws-load-balancer-controller).

```yaml title="INSTALL ALB CONTROLLER"
export ACCOUNT_NUMBER=$(aws sts get-caller-identity --query "Account" --output text)

curl -O https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.5.4/docs/install/iam_policy.json

aws iam create-policy \
    --policy-name AWSLoadBalancerControllerIAMPolicy \
    --policy-document file://iam_policy.json

eksctl create iamserviceaccount \
  --cluster=$CLUSTER_NAME \
  --namespace=kube-system \
  --name=aws-load-balancer-controller \
  --role-name AmazonEKSLoadBalancerControllerRole_${CLUSTER_NAME} \
  --attach-policy-arn=arn:aws:iam::$ACCOUNT_NUMBER:policy/AWSLoadBalancerControllerIAMPolicy \
  --approve

helm repo add eks https://aws.github.io/eks-charts
helm repo update eks

helm install aws-load-balancer-controller eks/aws-load-balancer-controller \
  -n kube-system \
  --set clusterName=$CLUSTER_NAME \
  --set serviceAccount.create=false \
  --set serviceAccount.name=aws-load-balancer-controller
```

## Install SurrealDB

The following script will install SurrealDB on your EKS cluster backed by TiKV with a public endpoint exposed via an Application Load Balancer (ALB).

```yaml title="INSTALL SURREALDB"
helm repo add surrealdb https://helm.surrealdb.com
helm repo update

TIKV_URL=tikv://basic-pd.tidb-cluster:2379

helm install \
    --set surrealdb.path=$TIKV_URL \
    --set surrealdb.auth=false \
    --set service.type="NodePort" \
    --set ingress.enabled=true \
    --set ingress.className="alb" \
    --set ingress.annotations."alb\.ingress\.kubernetes\.io/healthcheck-path"=/health \
    --set ingress.annotations."alb\.ingress\.kubernetes\.io/load-balancer-name"="ingress-${CLUSTER_NAME}" \
    --set ingress.annotations."alb\.ingress\.kubernetes\.io/scheme"="internet-facing" \
    --set ingress.annotations."alb\.ingress\.kubernetes\.io/target-type"="ip" \
    --set ingress.annotations."meta\.helm\.sh/release-name"="surrealdb-tikv" \
    --set ingress.annotations."meta\.helm\.sh/release-namespace"="default" \
    surrealdb-tikv surrealdb/surrealdb
```
## Test your SurrealDB Installation
You can get the endpoint to use with your SurrealDB client as follows:

```bash title="Test installation"
export SURREALDB_ENDPOINT=$(kubectl get ingress surrealdb-tikv -o json | jq '.status.loadBalancer.ingress[0].hostname' | xargs)
echo $SURREALDB_ENDPOINT

# sample output
> ingress-27v2-902764750.eu-west-1.elb.amazonaws.com
```

Test your connection with the following command:

```bash title="Connection test"
surreal sql -e https://$SURREALDB_ENDPOINT
>
```

## Cleanup

Cleanup can be performed with the following commands.

```bash title="Cleanup"
kubectl delete -f tidb-cluster.yaml -n tidb-cluster
helm uninstall surrealdb-tikv
helm -n kube-system uninstall aws-load-balancer-controller
helm -n tidb-admin uninstall tidb-operator

eksctl delete cluster \
    --force \
    --disable-nodegroup-eviction \
    --parallel 10 \
    --name $CLUSTER_NAME
```

The default cleanup behaviour is to preserve resources such as EBS volumes that were previously attached to your cluster. If this is not what you want, and in order to prevent you from incurring in additional charges related to the usage of these block storage devices, [navigate to the AWS console](https://eu-west-1.console.aws.amazon.com/ec2/home?region=eu-west-1#Volumes) and manually delete all volumes that were attached to your cluster, as shown in figure.

![AWS vloume](@img/aws-volumes.png)



================================================
FILE: src/content/doc-surrealdb/deployment/azure.mdx
================================================
---
sidebar_position: 9
sidebar_label: Deploy on Azure AKS
title: Deploy on Azure AKS | Deployment
description: Learn how to deploy SurrealDB on Azure Kubernetes Service, a managed Kubernetes service offered by Microsoft Azure.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/azure.png";
import DarkLogo from "@img/icon/dark/azure.png";

<div class="flag-title">
	<Image
		alt="Azure"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Deploy on Azure Kubernetes Service (AKS)
</div>

<br />

## What is AKS?

[Azure Kubernetes Service](https://azure.microsoft.com/products/kubernetes-service) is a managed Kubernetes service offered by the Microsoft Azure platform.

This article will guide you through setting up a highly available SurrealDB cluster backed by [TiKV](https://tikv.org/) on an Azure Kubernetes Service cluster.

## What is TiKV?

[TiKV](https://tikv.org/) is a cloud-native transactional key/value store built by PingCAP and that integrates well with Kubernetes thanks to their [TiDB operator](https://github.com/pingcap/tidb-operator).

## Prerequisites

In order for you to complete this tutorial you'll need:

- An account on [Microsoft Azure](https://azure.microsoft.com/)
- The [Azure CLI](https://learn.microsoft.com/cli/azure/install-azure-cli)
- [`kubectl`](https://kubernetes.io/docs/tasks/tools/install-kubectl/) to manage the Kubernetes cluster
- [`helm`](https://helm.sh/docs/intro/install/) to install SurrealDB server and TiKV
- [`Surreal CLI`](/install) to interact with the SurrealDB server

> [!NOTE]
> Provisioning the environment in your Azure account will create resources and there will be cost associated with them. The cleanup section provides a guide to remove them, preventing further charges.

> [!NOTE]
> This guide was tested in <code>westeurope</code> region and it follows TiKV best practices for scalability and high availability.
This tutorial is intended for production workloads using the <code>standard</code> tier. If you want to create a dev/test environment, you should root for the <code>free</code> tier and change the cluster and node pool configuration (no zone, fewer nodes).

## Create an AKS Cluster

1. Log in to Azure and get the current subscription if you have multiple subscriptions.

```bash title="Log in and get subscription"
$ az login
$ az account list
```

2. Create a new resource group:

```bash title="Create new group"
$ az group create --name rg-surrealdb-aks --location westeurope
```

3. Run the following command to create a new AKS cluster:

```bash title="Create new cluster"
$ az aks create \
    --resource-group rg-surrealdb-aks \
    --location westeurope \
    --name surrealdb-aks-cluster \
    --generate-ssh-keys \
    --load-balancer-sku standard \
    --node-count 3 \
    --zones 1 2 3 \
    --enable-addons monitoring \
    --tier standard
```

4. After creation finishes, get credentials to configure <code>kubectl</code> to connect to the new cluster:

```bash title="Get AKS cluster credentials"
$ az aks get-credentials --resource-group rg-surrealdb-aks --name surrealdb-aks-cluster
```

5. You can verify the connection to the cluster with the following command:

```bash title="Display cluster nodes"
$ kubectl get nodes

NAME                                STATUS   ROLES   AGE     VERSION
aks-nodepool1-33674805-vmss000000   Ready    agent   2m35s   v1.26.6
aks-nodepool1-33674805-vmss000001   Ready    agent   2m36s   v1.26.6
aks-nodepool1-33674805-vmss000002   Ready    agent   2m34s   v1.26.6
```

## Create cluster node pools

> [!NOTE]
> In order to speed things up, the following commands can be executed in parallel.

1. Create a TiDB Operator and monitor pool:

```bash title="Create operator and monitor"
$ az aks nodepool add --name admin \
    --resource-group rg-surrealdb-aks \
    --cluster-name surrealdb-aks-cluster \
    --zones 1 2 3 \
    --node-count 1 \
    --labels dedicated=admin
```

2. Create a PD node pool:

```bash title="Add node pool"
$ az aks nodepool add --name pd \
    --resource-group rg-surrealdb-aks \
    --cluster-name surrealdb-aks-cluster \
    --node-vm-size Standard_F4s_v2 \
    --zones 1 2 3 \
    --node-count 3 \
    --labels dedicated=pd \
    --node-taints dedicated=pd:NoSchedule
```

3. Create a TiKV node pool:

```bash title="Add node pool"
$ az aks nodepool add --name tikv \
    --resource-group rg-surrealdb-aks \
    --cluster-name surrealdb-aks-cluster \
    --node-vm-size Standard_E8s_v4 \
    --zones 1 2 3 \
    --node-count 3 \
    --labels dedicated=tikv \
    --node-taints dedicated=tikv:NoSchedule \
    --enable-ultra-ssd
```

## Deploy TiDB operator

Now that we have a Kubernetes cluster, we can deploy the [`TiDB` operator](https://github.com/pingcap/tidb-operator).
TiDB operator is a Kubernetes operator that manages the lifecycle of TiDB clusters deployed to Kubernetes.
You can deploy it following these steps:

1. Install CRDS:

```bash title="CRDS installation"
$ kubectl create -f https://raw.githubusercontent.com/pingcap/tidb-operator/v1.5.0/manifests/crd.yaml
```

2. Install TiDB Operator Helm chart:

```bash title="Helm chart installation"
$ helm repo add pingcap https://charts.pingcap.org
$ helm repo update
$ helm install \
  -n tidb-operator \
  --create-namespace \
  tidb-operator \
  pingcap/tidb-operator \
  --version v1.5.0
```

3. Verify that the pods are running:

```bash title="Verify TiDB operator"
$ kubectl get pods --namespace tidb-operator -l app.kubernetes.io/instance=tidb-operator

NAME                                       READY   STATUS    RESTARTS   AGE
tidb-controller-manager-67d678dc64-qf6p2   1/1     Running   0          60s
tidb-scheduler-68555ffd4-l2ssf             2/2     Running   0          60s
```

## Create TiDB cluster

Now that we have the TiDB Operator running, it's time to define a TiDB Cluster and let the Operator do the rest.

1. Create a local file named `tikv-cluster.yaml` with this content:

```yaml title="TiDB cluster definition"
apiVersion: pingcap.com/v1alpha1
kind: TidbCluster
metadata:
  name: sdb-datastore
spec:
  version: v6.5.0
  timezone: UTC
  configUpdateStrategy: RollingUpdate
  pvReclaimPolicy: Delete
  enableDynamicConfiguration: true
  schedulerName: default-scheduler
  topologySpreadConstraints:
  - topologyKey: topology.kubernetes.io/zone
  helper:
    image: alpine:3.16.0
  pd:
    baseImage: pingcap/pd
    maxFailoverCount: 0
    replicas: 3
    storageClassName: managed-csi-premium
    requests:
      cpu: 500m
      storage: 10Gi
      memory: 1Gi
    config: |
      [dashboard]
        internal-proxy = true
      [replication]
        location-labels = ["topology.kubernetes.io/zone", "kubernetes.io/hostname"]
        max-replicas = 3
    nodeSelector:
      dedicated: pd
    tolerations:
    - effect: NoSchedule
      key: dedicated
      operator: Equal
      value: pd
    affinity:
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
            - key: app.kubernetes.io/component
              operator: In
              values:
              - pd
          topologyKey: kubernetes.io/hostname
  tikv:
    baseImage: pingcap/tikv
    maxFailoverCount: 0
    replicas: 3
    storageClassName: managed-csi-premium
    requests:
      cpu: 1
      storage: 10Gi
      memory: 2Gi
    config: {}
    nodeSelector:
      dedicated: tikv
    tolerations:
    - effect: NoSchedule
      key: dedicated
      operator: Equal
      value: tikv
    affinity:
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
            - key: app.kubernetes.io/component
              operator: In
              values:
              - tikv
          topologyKey: kubernetes.io/hostname
  tidb:
    replicas: 0
```

2. Create the TiDB cluster:

```bash title="Apply TiDB cluster"
$ kubectl apply -f tikv-cluster.yaml
```

3. Check the cluster status and wait until it's ready:

```bash title="Verify TiDB cluster"
$ kubectl get tidbcluster

$ kubectl get pods

NAME                                       READY   STATUS    RESTARTS   AGE
sdb-datastore-discovery-7d7d684d88-4v4ws   1/1     Running   0          4m2s
sdb-datastore-pd-0                         1/1     Running   0          4m2s
sdb-datastore-pd-1                         1/1     Running   0          4m2s
sdb-datastore-pd-2                         1/1     Running   0          4m2s
sdb-datastore-tikv-0                       1/1     Running   0          3m12s
sdb-datastore-tikv-1                       1/1     Running   0          3m12s
sdb-datastore-tikv-2                       1/1     Running   0          3m12s
```

## Deploy SurrealDB

Now that we have a TiDB cluster running, we can deploy SurrealDB using the official Helm chart.
The deployment will use the latest SurrealDB Docker image and make it accessible on internet.

1. Get the TiKV PD service URL:

```bash title="Get service URL"
$ kubectl get service sdb-datastore-pd

NAME               TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
sdb-datastore-pd   ClusterIP   10.0.161.101   <none>        2379/TCP   5m27s

$ export TIKV_URL=tikv://sdb-datastore-pd:2379
```

2. Install the SurrealDB Helm chart with the TIKV_URL defined above and with auth disabled so we can create the initial credentials:

```bash title="SurrealDB Helm chart installation"
$ helm repo add surrealdb https://helm.surrealdb.com
$ helm repo update
$ helm install \
    --set surrealdb.path=$TIKV_URL \
    --set surrealdb.auth=false \
    --set ingress.enabled=false \
    --set service.type=LoadBalancer \
    --set service.port=80 \
    --set service.targetPort=8000 \
    --set image.tag=latest \
    surrealdb-tikv surrealdb/surrealdb
```

3. Wait until the Loadbalancer resource has an <code>EXTERNAL-IP</code> assigned:

```bash title="Wait for Loadbalancer address"
$ kubectl get service surrealdb-tikv

NAME             TYPE           CLUSTER-IP    EXTERNAL-IP    PORT(S)          AGE
surrealdb-tikv   LoadBalancer   10.0.38.191   20.13.45.154   80:30378/TCP   6m34s
```

4. Connect to the cluster and define the initial credentials:

```bash title="Connect and define credentials"
$ export SURREALDB_URL=http://$(kubectl get service surrealdb-tikv -o json | jq -r .status.loadBalancer.ingress[0].ip)

$ surreal sql -e $SURREALDB_URL
> DEFINE USER root ON ROOT PASSWORD 'StrongSecretPassword!' ROLES OWNER;
```

5. Verify you can connect to the database with the new credentials:

```
$ surreal sql -u root -p 'StrongSecretPassword!' -e $SURREALDB_URL
> INFO FOR ROOT
[{ accesses: {  }, namespaces: { ns: 'DEFINE NAMESPACE ns' }, nodes: { "0e87c953-68d7-40e1-9090-3dfc404af25e": 'NODE 0e87c953-68d7-40e1-9090-3dfc404af25e SEEN 1742870304370 ACTIVE' }, system: { available_parallelism: 14, cpu_usage: 5.905298233032227f, load_average: [1.2802734375f, 1.5400390625f, 1.71484375f], memory_allocated: 13492047, memory_usage: 187547648, physical_cores: 14, threads: 32 }, users: { root: "DEFINE USER root ON ROOT PASSHASH '...' ROLES OWNER DURATION FOR TOKEN 1h, FOR SESSION NONE" } }]
```

5. Now that the initial credentials have been created, enable authentication:

```bash title="Update SurrealDB Helm chart"
$ helm upgrade \
    --set surrealdb.path=$TIKV_URL \
    --set surrealdb.auth=true \
    --set ingress.enabled=false \
    --set service.type=LoadBalancer \
    --set service.port=80 \
    --set service.targetPort=8000 \
    --set image.tag=latest \
    surrealdb-tikv surrealdb/surrealdb
```

## Cleanup

Run the following commands to delete the Kubernetes resources and the AKS cluster.

```bash title="Cleanup commands"
$ helm uninstall surrealdb-tikv
$ helm -n tidb-operator uninstall tidb-operator
$ az aks delete --name surrealdb-aks-cluster --resource-group rg-surrealdb-aks
$ az group delete --resource-group rg-surrealdb-aks
```



================================================
FILE: src/content/doc-surrealdb/deployment/google.mdx
================================================
---
sidebar_position: 7
sidebar_label: Deploy on Google GKE
title: Deploy on Google GKE | Deployment
description: How to set up a SurrealDB cluster backed by TiKV on Google Kubernetes Engine.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/google.png";
import DarkLogo from "@img/icon/dark/google.png";

<div class="flag-title">
	<Image
		alt="Google Kubernetes Engine"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Deploy on Google Kubernetes Engine (GKE)
</div>

This article will guide you through the process of setting up a highly available SurrealDB cluster backed by TiKV on a GKE Autopilot cluster.

## What is GKE?

[Google Kubernetes Engine](https://cloud.google.com/kubernetes-engine) is a managed Kubernetes service offered by Google Cloud Platform. In this guide we will create a [GKE Autopilot](https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-overview) cluster, which removes the need to manage the underlying compute nodes.

## What is TiKV?
[TiKV](https://tikv.org/) is a cloud-native transactional key/value store built by PingCAP and that integrates well with Kubernetes thanks to their [TiDB operator](https://github.com/pingcap/tidb-operator).

## Prerequisites

In order for you to complete this tutorial you'll need:

- An account on [Google Cloud Platform](https://cloud.google.com/)
- The [gcloud CLI](https://cloud.google.com/sdk/gcloud) installed and configured
- `kubectl` with gcloud integration for accessing the GKE cluster. Installation [here](https://cloud.google.com/kubernetes-engine/docs/tutorials/cluster-access-for-kubectl)
- `helm` : To install SurrealDB server and TiKV
- [`Surreal CLI`](/install) : To interact with the SurrealDB server

## Create GKE Cluster

1. Choose the target project and region. List them with these commands:

```bash title="List projects and regions"
gcloud projects list

gcloud compute regions list --project PROJECT_ID
```

2. Run the following command to create a cluster replacing the REGION and PROJECT_ID for your desired values:

```bash title="Create new GKE autopilot Cluster"
gcloud container clusters create-auto surrealdb-guide --region REGION --project PROJECT_ID
```

3. After the creation finishes, configure kubectl to connect to the new cluster:

```bash title="kubectl configuration"
gcloud container clusters get-credentials surrealdb-guide --region REGION --project PROJECT_ID
```

## Deploy TiDB operator

Now that we have a Kubernetes cluster, we can deploy the TiDB operator. TiDB operator is a Kubernetes operator that manages the lifecycle of TiDB clusters deployed to Kubernetes.

You can deploy it following these steps:

1. Install CRDS:

```bash title="CRDS installation"
kubectl create -f https://raw.githubusercontent.com/pingcap/tidb-operator/v1.5.0/manifests/crd.yaml
```

2. Install TiDB operator Helm chart:


```bash title="Helm chart installation"
$ helm repo add pingcap https://charts.pingcap.org
$ helm repo update
$ helm install \
	-n tidb-operator \
    --create-namespace \
	tidb-operator \
	pingcap/tidb-operator \
	--version v1.5.0
```
3. Verify that the Pods are running:

```bash title="Get pod status"
kubectl get pods --namespace tidb-operator -l app.kubernetes.io/instance=tidb-operator
NAME                                       READY   STATUS    RESTARTS   AGE
tidb-controller-manager-56f49794d7-hnfz7   1/1     Running   0          20s
tidb-scheduler-8655bcbc86-66h2d            2/2     Running   0          20s
```

## Create TiDB cluster

Now that we have the TiDB Operator running, it’s time to define a TiDB Cluster and let the Operator do the rest.

1. Create a local file named `tikv-cluster.yaml` with this content:

```yaml title="tikv-cluster.yaml"
apiVersion: pingcap.com/v1alpha1
kind: TidbCluster
metadata:
  name: sdb-datastore
spec:
  version: v6.5.0
  timezone: UTC
  configUpdateStrategy: RollingUpdate
  pvReclaimPolicy: Delete
  enableDynamicConfiguration: true
  schedulerName: default-scheduler
  topologySpreadConstraints:
  - topologyKey: topology.kubernetes.io/zone
  helper:
    image: alpine:3.16.0
  pd:
    baseImage: pingcap/pd
    maxFailoverCount: 0
    replicas: 3
    storageClassName: premium-rwo
    requests:
      cpu: 500m
      storage: 10Gi
      memory: 1Gi
    config: |
      [dashboard]
        internal-proxy = true
      [replication]
        location-labels = ["topology.kubernetes.io/zone", "kubernetes.io/hostname"]
        max-replicas = 3
    nodeSelector:
      dedicated: pd
    tolerations:
    - effect: NoSchedule
      key: dedicated
      operator: Equal
      value: pd
    affinity:
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
            - key: app.kubernetes.io/component
              operator: In
              values:
              - pd
          topologyKey: kubernetes.io/hostname
  tikv:
    baseImage: pingcap/tikv
    maxFailoverCount: 0
    replicas: 3
    storageClassName: premium-rwo
    requests:
      cpu: 1
      storage: 10Gi
      memory: 2Gi
    config: {}
    nodeSelector:
      dedicated: tikv
    tolerations:
    - effect: NoSchedule
      key: dedicated
      operator: Equal
      value: tikv
    affinity:
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
            - key: app.kubernetes.io/component
              operator: In
              values:
              - tikv
          topologyKey: kubernetes.io/hostname
  tidb:
    replicas: 0
```

2. Create the TiDB cluster:

```bash title="Apply cluster def"
kubectl apply -f tikv-cluster.yaml
```

3. Check the cluster status and wait until it’s ready:

```bash title="Get status for cluster"
kubectl get tidbcluster
NAME             READY   PD                  STORAGE   READY   DESIRE   TIKV                  STORAGE   READY   DESIRE   TIDB                  READY   DESIRE   AGE
sdb-datastore   True    pingcap/pd:v6.5.0   10Gi      3       3        pingcap/tikv:v6.5.0   10Gi      3       3        pingcap/tidb:v6.5.0           0        5m
```

## Deploy SurrealDB

Now that we have a TiDB cluster running, we can deploy SurrealDB using the official Helm chart.

The deployment will use the latest SurrealDB Docker image and make it accessible on the internet.

1. Get the TiKV PD service URL:

```bash title="get TiKV URL"
kubectl get svc/sdb-datastore-pd
NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
sdb-datastore-pd   ClusterIP   10.96.208.25   <none>        2379/TCP   10h

export TIKV_URL=tikv://sdb-datastore-pd:2379
```
2. Install the SurrealDB Helm chart with the TIKV_URL defined above and with auth disabled so we can create the initial credentials:

```bash title="Install Helm chart"
helm repo add surrealdb https://helm.surrealdb.com
$ helm repo update
$ helm install \
    --set surrealdb.path=$TIKV_URL \
    --set surrealdb.auth=false \
    --set ingress.enabled=true \
    --set image.tag=latest \
    surrealdb-tikv surrealdb/surrealdb
```

3. Wait until the Ingress resource has an `ADDRESS` assigned:

```bash title="Wait for Ingress ADDRESS"
kubectl get ingress surrealdb-tikv
NAME             CLASS    HOSTS   ADDRESS         PORTS   AGE
surrealdb-tikv   <none>   *       34.160.82.177   80      5m
```

4. Connect to the cluster and define the initial credentials:

```bash title="Connect then define user"
$ export SURREALDB_URL=http://$(kubectl get ingress surrealdb-tikv -o json | jq -r .status.loadBalancer.ingress[0].ip)
$ surreal sql -e $SURREALDB_URL
> DEFINE USER root ON ROOT PASSWORD 'StrongSecretPassword!' ROLES OWNER;
```

5. Verify you can connect to the database with the new credentials:

```bash title="Connect as defined user"
$ surreal sql -u root -p 'StrongSecretPassword!' -e $SURREALDB_URL
> INFO FOR ROOT
[{ accesses: {  }, namespaces: {  }, nodes: { "0e87c953-68d7-40e1-9090-3dfc404af25e": 'NODE 0e87c953-68d7-40e1-9090-3dfc404af25e SEEN 1742869518357 ACTIVE' }, system: { available_parallelism: 14, cpu_usage: 4.321133613586426f, load_average: [2.2265625f, 2.2138671875f, 2.044921875f], memory_allocated: 13428527, memory_usage: 154812416, physical_cores: 14, threads: 32 }, users: { root: "DEFINE USER root ON ROOT PASSHASH '...' ROLES OWNER DURATION FOR TOKEN 1h, FOR SESSION NONE" } }]
```

5. Now that the initial credentials have been created, enable authentication:

```bash title="Update SurrealDB Helm chart"
helm upgrade \
    --set surrealdb.path=$TIKV_URL \
    --set surrealdb.auth=true \
    --set ingress.enabled=true \
    --set image.tag=latest \
    surrealdb-tikv surrealdb/surrealdb
```

## Cleanup

Run the following commands to delete the Kubernetes resources and the GKE cluster:

```bash title="Cleanup command"
kubectl delete tidbcluster sdb-datastore
helm uninstall surrealdb-tikv
helm -n tidb-operator uninstall tidb-operator
gcloud container clusters delete surrealdb-guide --region REGION --project PROJECT_ID
```


================================================
FILE: src/content/doc-surrealdb/deployment/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Deployment
title: Deployment
description: Getting started with SurrealDB is quick and easy. Follow these tutorials for deploying SurrealDB in different environments.
---

import Image from "@components/Image.astro";
import Boxes from "@components/boxes/Boxes.astro";
import IconBox from "@components/boxes/IconBox.astro";

import LightFly from "@img/icon/light/fly.png";
import LightHeroku from "@img/icon/light/heroku.png";
import LightRailway from "@img/icon/light/railway.png";
import LightDigitalOcean from "@img/icon/light/digitalocean.png";
import LightKubernetes from "@img/icon/light/kubernetes.png";
import LightGoogle from "@img/icon/light/google.png";
import LightAmazon from "@img/icon/light/amazon.png";
import LightAzure from "@img/icon/light/azure.png";

import LightCloud from '@img/image/cloud/surrealcloud.png';
import DarkCloud from '@img/image/cloud/surrealcloud.png';

import DarkFly from "@img/icon/dark/fly.png";
import DarkHeroku from "@img/icon/dark/heroku.png";
import DarkRailway from "@img/icon/dark/railway.png";
import DarkDigitalOcean from "@img/icon/dark/digitalocean.png";
import DarkKubernetes from "@img/icon/dark/kubernetes.png";
import DarkGoogle from "@img/icon/dark/google.png";
import DarkAmazon from "@img/icon/dark/amazon.png";
import DarkAzure from "@img/icon/dark/azure.png";

# Deployment

Getting started with SurrealDB is quick and easy. All of SurrealDB's functionality for starting a server, and importing and exporting data, is enabled through the [command-line tool](/docs/surrealdb/cli), packaged and distributed as a single executable file, which can be downloaded, installed, or run from within Docker.

<Boxes>
    <IconBox
        title="SurrealDB Cloud "
        description="Learn how to deploy a single-node instance of SurrealDB on SurrealDB Cloud ."
        href="/docs/surrealdb/deployment/surreal-cloud"
        status="available"
        icon={{
          light: LightCloud,
          dark: DarkCloud,
        }}
    />
    <IconBox
        title="Kubernetes"
        description="Learn how to deploy a multi-node instance of SurrealDB on Kubernetes."
        href="/docs/surrealdb/deployment/kubernetes"
        status="available"
        icon={{
          light: LightKubernetes,
          dark: DarkKubernetes,
        }}
    />
    <IconBox
        title="Google EKS"
        description="Learn how to deploy a multi-node instance of SurrealDB on Google Cloud Platform."
        href="/docs/surrealdb/deployment/google"
        status="available"
        icon={{
          light: LightGoogle,
          dark: DarkGoogle,
        }}
    />
    <IconBox
        title="Amazon EKS"
        description="Learn how to deploy a multi-node instance of SurrealDB on Amazon Web Services."
        href="/docs/surrealdb/deployment/amazon"
        status="available"
        icon={{
          light: LightAmazon,
          dark: DarkAmazon,
        }}
    />
    <IconBox
        title="Azure AKS"
        description="Learn how to deploy a multi-node instance of SurrealDB on Microsoft Azure."
        href="/docs/surrealdb/deployment/azure"
        status="available"
        icon={{
          light: LightAzure,
          dark: DarkAzure,
        }}
    />
</Boxes>



================================================
FILE: src/content/doc-surrealdb/deployment/kubernetes.mdx
================================================
---
sidebar_position: 6
sidebar_label: Deploy on Kubernetes
title: Deploy on Kubernetes | Deployment
description: A guide on the process of deploying SurrealDB to Kubernetes in Docker, with TiKV as the database storage engine.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/kubernetes.png";
import DarkLogo from "@img/icon/dark/kubernetes.png";

<div class="flag-title">
	<Image
		alt="Kubernetes"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Deploy on Kubernetes
</div>

In this guide, we will deploy SurrealDB to KIND (Kubernetes in Docker) using TiKV as the storage engine. TiKV is a cloud-native transactional key/value store that integrates well with Kubernetes thanks to their [TiDB-operator](https://github.com/pingcap/tidb-operator) tool.

At the end, we will run a few experiments using SurrealQL to verify that we can interact with the new cluster and then delete some Kubernetes pods to demonstrate that the data remains available.

## Requirements

For this guide, we need to install:

- [`kubectl`](https://kubernetes.io/docs/tasks/tools/install-kubectl/): To manage the Kubernetes cluster
- [`helm`](https://helm.sh/docs/intro/install/): To install SurrealDB server and TiKV
- [`KIND`](https://kind.sigs.k8s.io/) and [Docker](https://www.docker.com/): To run a local Kubernetes cluster inside a Docker container
- [`Surreal CLI`](/install): To interact with the SurrealDB server

## Create `KIND` Cluster

First, we need to create a [`KIND`](https://kind.sigs.k8s.io/) cluster. KIND is a tool for running local Kubernetes clusters using Docker container “nodes”. It’s a great tool for experimenting with Kubernetes without spending a lot of time creating a full-featured cluster.

### 1. Create a new cluster

Run the following command to create a cluster:

```bash title="Create new cluster"
kind create cluster -n surreal-demo
```

### 2. Verify interaction with cluster

Run the following command to verify that we can interact with the created cluster:

```bash title="Verify cluster"
kubectl config current-context
```

The output of this command should be:

```bash
kind-surreal-demo
```

### 3. Verify that nodes are running

Run the following command to verify that the nodes are running:

```bash
kubectl get ns
```

The output of this command should be:

```bash
NAME                 STATUS   AGE
default              Active   79s
kube-node-lease      Active   79s
kube-public          Active   79s
kube-system          Active   79s
local-path-storage   Active   75s
```

## Deploy TiDB operator

Now that we have a Kubernetes cluster, we can deploy the [`TiDB operator`](https://github.com/pingcap/tidb-operator). TiDB operator is a Kubernetes operator that manages the lifecycle of TiDB clusters deployed to Kubernetes.

You can deploy it following these steps:

1. Install CRDS:

```bash title="CRDS installation"
kubectl create -f https://raw.githubusercontent.com/pingcap/tidb-operator/v1.4.5/manifests/crd.yaml
```

2. Install TiDB Operator Helm chart:

```bash title="Update HELM repositories"
helm repo add pingcap https://charts.pingcap.org
helm repo update
helm install \
	-n tidb-operator \
  --create-namespace \
	tidb-operator \
	pingcap/tidb-operator \
	--version v1.4.5
```

3. Verify that the pods are running:

```bash title="Get pod status"
kubectl get pods --namespace tidb-operator -l app.kubernetes.io/instance=tidb-operator
```

The output of this command should look like this:

```bash
NAME                                       READY   STATUS    RESTARTS   AGE
tidb-controller-manager-56f49794d7-hnfz7   1/1     Running   0          20s
tidb-scheduler-8655bcbc86-66h2d            2/2     Running   0          20s
```

## Create TiDB cluster
Now that we have the TiDB Operator running, it’s time to define a TiDB Cluster and let the Operator do the rest. One of the TiDB Cluster components is the TiKV, which we are interested in.
Given this is a demo, we will use a basic example cluster, but there are several examples in the official GitHub repo in case you need a more production-grade deployment


Run the following commands to deploy the TiKV cluster:

### 1. Create TiDB cluster namespace

Run the following command to create a namespace for the TiDB cluster:

```bash
kubectl create ns tikv
```

### 2. Create TiDB cluster

Run the following command to create the TiDB cluster:

```bash title="TiDB cluster creation"
kubectl apply -n tikv -f https://raw.githubusercontent.com/pingcap/tidb-operator/v1.4.5/examples/basic/tidb-cluster.yaml
```
### 3. Check cluster status

Run the following command to check the cluster status and wait until it’s ready:

```bash title="Verify TiDB cluster"
kubectl get -n tikv tidbcluster
```

The output of this command should look like this:

```bash
NAME    READY   PD                  STORAGE   READY   DESIRE   TIKV   STORAGE   READY   DESIRE   TIDB   READY   DESIRE   AGE
basic   False   pingcap/pd:v6.5.0   1Gi       1       1               1Gi               1                       1        41s
$ kubectl get -n tikv tidbcluster
NAME    READY   PD                  STORAGE   READY   DESIRE   TIKV                  STORAGE   READY   DESIRE   TIDB                  READY   DESIRE   AGE
basic   True    pingcap/pd:v6.5.0   1Gi       1       1        pingcap/tikv:v6.5.0   1Gi       1       1        pingcap/tidb:v6.5.0   1       1        5m
```

## Deploy SurrealDB

Now that we have a TiDB cluster running, we can deploy SurrealDB.
For this guide, we will use the SurrealDB Helm chart. Run the following commands to deploy SurrealDB:

### 1. Add SurrealDB Charts repository

Run the following command to add the SurrealDB Charts repository:

```bash title="Add Helm repository"
helm repo add surrealdb https://helm.surrealdb.com
helm repo update
```

### 2. Get TiKV PD service URL

Run the following command to get the TiKV PD service URL:

```bash title="Get TiKV URL"
kubectl get -n tikv svc/basic-pd
```

The output of this command should look like this:

```bash
NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
basic-pd   ClusterIP   10.96.208.25   <none>        2379/TCP   10h
```

Then set the TIKV_URL variable to the PD service URL:

```bash title="Set TIKV_URL var"
export TIKV_URL=tikv://basic-pd.tikv:2379
```

### 3. Install SurrealDB Helm chart to create initial credentials

Now we can install the SurrealDB Helm chart with `TIKV_URL` defined above and auth disabled so that we can create the initial credentials:

```bash title="Install SurrealDB HELM chart"
helm install --set surrealdb.path=$TIKV_URL --set surrealdb.unauthenticated=true --set image.tag=latest surrealdb-tikv surrealdb/surrealdb
```

### 4. Connect to cluster and define initial credentials

We can then connect to the cluster and define the initial credentials (see the section below to connect):

```bash
surreal sql -e http://...
> DEFINE USER root ON ROOT PASSWORD 'StrongSecretPassword!' ROLES OWNER;
```

Verify you can connect to the database with the new credentials:

```bash
surreal sql -u root -p 'StrongSecretPassword!' -e http://...
> INFO FOR ROOT
[{ accesses: {  }, namespaces: {  }, nodes: { "0e87c953-68d7-40e1-9090-3dfc404af25e": 'NODE 0e87c953-68d7-40e1-9090-3dfc404af25e SEEN 1742869518357 ACTIVE' }, system: { available_parallelism: 14, cpu_usage: 4.321133613586426f, load_average: [2.2265625f, 2.2138671875f, 2.044921875f], memory_allocated: 13428527, memory_usage: 154812416, physical_cores: 14, threads: 32 }, users: { root: "DEFINE USER root ON ROOT PASSHASH '...' ROLES OWNER DURATION FOR TOKEN 1h, FOR SESSION NONE" } }]
```

### 5. Enable authentication

Authentication can be enabled now that the initial credentials have been created:

```bash title="Update SurrealDB Helm Chart"
helm upgrade --set surrealdb.path=$TIKV_URL --set image.tag=latest surrealdb-tikv surrealdb/surrealdb
```

## Run SurrealDB experiments

Now that we have SurrealDB running, we can run some experiments to verify that everything is working as expected.
For this guide, we will use the Surreal CLI. Run the following commands to run some experiments:

### 1. Start port forwarding to the SurrealDB service

```bash
kubectl port-forward svc/surrealdb-tikv 8000
```

```bash title="Output"
Forwarding from 127.0.0.1:8000 -> 8000
Forwarding from [::1]:8000 -> 8000
```

### 2. Connect to the SurrealDB server

Use the following command to connect to the SurrealDB server using the CLI from another shell:

```bash
surreal sql --conn 'http://localhost:8000' --user root --pass surrealdb
```

### 3. Create a SurrealDB database

Use the following to create a SurrealDB database and try out a few queries:

```bash
surreal sql --conn 'http://localhost:8000' --user root --pass surrealdb
> USE NS ns DB db;

ns/db> CREATE record;
{ id: record:wbd69kmc81l4fbee7pit }
ns/db> CREATE record;
{ id: record:vnyfsr22ovhmmtcm5y1t }
ns/db> CREATE record;
{ id: record:se49petzb7c4bc7yge0z }
ns/db> SELECT * FROM record;
[{ id: record:se49petzb7c4bc7yge0z }, { id: record:vnyfsr22ovhmmtcm5y1t }, { id: record:wbd69kmc81l4fbee7pit }]
ns/db>
```

The data created above has been persisted to the TiKV cluster. Let’s verify it by deleting the SurrealDB server and let Kubernetes recreate it.

We will first use `get pod` to get the names of the existing pods:

```bash title="Get pod"
kubectl get pod
```

The output of this command should look like this:

```bash
NAME                              READY   STATUS    RESTARTS   AGE
surrealdb-tikv-7488f6f654-lsrwp   1/1     Running   0          13m
```

We can then grab the name and use `delete pod` to delete it.

```bash
kubectl delete pod surrealdb-tikv-7488f6f654-lsrwp
```

A `get pod` command shows us that the pod has been recreated under a different name.

```bash
kubectl get pod
```

```bash title="Output"
NAME                              READY   STATUS    RESTARTS   AGE
surrealdb-tikv-7488f6f654-bnkjz   1/1     Running   0          4s
```

We can now connect again and verify the data is still there (you may need to re-run the port-forwarding command):

```bash
surreal sql --conn 'http://localhost:8000' --user root --pass surrealdb
> USE NS ns DB db;

ns/db> SELECT * FROM record;
[{ id: record:se49petzb7c4bc7yge0z }, { id: record:vnyfsr22ovhmmtcm5y1t }, { id: record:wbd69kmc81l4fbee7pit }]
ns/db>
```

> [!NOTE]
> Given we are using KIND, we use `port-forwarding` for demonstration purposes.
> In a full-featured Kubernetes cluster, you could set `ingress.enabled=true` when installing the SurrealDB Helm Chart and it would create a Load Balancer in front of the SurrealDB server pods.


## Conclusion
This guide demonstrated how to deploy SurrealDB on Kubernetes using TiKV as a datastore. From here, you could try and deploy to [`EKS`](https://aws.amazon.com/eks/), [`GKE`](https://cloud.google.com/kubernetes-engine) or [`AKS`](https://azure.microsoft.com/en-us/products/kubernetes-service), and play with the different configurations for the TiKV cluster.



================================================
FILE: src/content/doc-surrealdb/deployment/surreal cloud.mdx
================================================
---
sidebar_position: 1
sidebar_label: Deploy on SurrealDB Cloud 
title: Deploy on SurrealDB Cloud | Deployment
description: This tutorial provides a guide to the process of deploying SurrealDB using SurrealDB Cloud .
---

import Image from "@components/Image.astro";

import NamespaceDatabaseLight from '@img/image/cloud/namespace-database.png';
import NamespaceDatabaseDark from '@img/image/cloud/namespace-database.png';

import LightCloud from '@img/image/cloud/surrealcloud.png';
import DarkCloud from '@img/image/cloud/surrealcloud.png';

import OpenInSDK from '@img/image/cloud/open-in-sdk.png';

import OpenInSurrealistLight from '@img/image/cloud/open-in-surrealist.png';
import OpenInSurrealistDark from '@img/image/cloud/open-in-surrealist.png';

import QueryingInstanceLight from '@img/image/cloud/querying-instance.png';
import QueryingInstanceDark from '@img/image/cloud/querying-instance.png';

import OpenInHTTPCurlLight from '@img/image/cloud/open-in-http.png';
import OpenInHTTPCurlDark from '@img/image/cloud/open-in-http.png';

import CreateAnInstanceLight from '@img/image/cloud/create-an-instance.png';
import CreateAnInstanceDark from '@img/image/cloud/create-an-instance.png';

<div class="flag-title">
	<Image
		alt="SurrealDB Cloud "
		width={42}
		height={42}
		src={{
			light: LightCloud,
			dark: DarkCloud,
		}}
	/>
	# Deploy on SurrealDB Cloud 
</div>

## What is SurrealDB Cloud ?

SurrealDB Cloud is a fully managed database service that provides a seamless deployment experience for SurrealDB. It's designed to be lightweight, leveraging the open-source SurrealDB product as much as possible. Its features are intended to complement those of the open-source version and offer you a seamless deployment experience.

In this guide, we'll walk through the process and options to deploy SurrealDB using [SurrealDB Cloud ](/docs/cloud). 

## Requirements

To get [started with SurrealDB Cloud ](/docs/cloud/getting-started), you'll need to have an account. If you don't have one, you can sign up for a free account by [downloading Surrealist](https://github.com/surrealdb/surrealist/releases) or using the [Surrealist web app](https://app.surrealdb.com/cloud). 


## Create an Instance

To create an Instance in Surrealist, click on the **SurrealDB Cloud ** tab and select **Continue**. This will prompt you to the authentication page. If you don't have an account, you'll be asked to [sign up](/docs/cloud/getting-started/create-an-account) with an email address, Google, or GitHub.

After you've signed up, you'll be redirected to the SurrealDB Cloud dashboard. Here, you can create an Instance by clicking on the **Create Instance** button. 

<Image
alt="Querying Instance"
src={{
	light: CreateAnInstanceLight,
	dark: CreateAnInstanceDark,
	}}
/>

### Configure your Instance

While creating an Instance, you'll be asked to provide a few details about your Instance. These include:

- **Instance Name**: Easily distinguish and manage your Instance in the SurrealDB Cloud dashboard by assigning it a unique and meaningful name. This ensures seamless identification across your projects.
- **SurrealDB Version**: Stay up-to-date with the latest innovations! The Beta program ensures you're always using the most recent version of SurrealDB.
- **Instance Region**: Optimize performance by selecting a deployment region close to your location. This minimizes latency, resulting in faster and smoother interactions.
- **Instance Size**: Tailor your Instance to meet your workload requirements. For free plans, you start with **0.25 vCPU** and **512.00 MB** of memory on a single-node setup—perfect for lightweight applications or experimenting.
- **Instance Category**: Choose the perfect fit for your use case:
    - **Production**: Built for high-performance and high-availability applications. Ideal for mission-critical projects.
    - **Development**: A cost-effective option designed for testing, prototyping, and building.
    - **Free**: Perfect for learners and hobbyists to experiment and explore the capabilities of SurrealDB without any cost. In addition to getting your own instance, even free instances include access to [Surreal Sidekick](/sidekick), SurrealDB Cloud 's built-in AI helper.

> [!NOTE]
> Both Production and Development categories are paid plans and allows you to further customize your Instance vCPU and memory. To use them, you'll need to upgrade to a paid plan by adding billing information. In this guide, we'll be using the free category which has a **0.25 vCPU and 512.00MB** of memory on a single node. You can also upgrade your instance as it grows by updating your instance size.

After you've provided the required information, click on the **Create** button. This will start the Instance provisioning process.

## Query your Instance

### Query via Surrealist

You can connect to your Instance using [Surrealist, the SurrealDB CLI, or the SurrealDB SDKs](/docs/cloud#what-can-you-do). In this guide, we'll be using Surrealist as our client.

In the connect dropdown, select the **Open in Surrealist** option. This will open the [query view](/docs/surrealist/concepts/sending-queries) in Surrealist. Before you can start querying your Instance, you'll need to create a namespace and a database. 

<Image
alt="Open in Surrealist"
src={{
	light: OpenInSurrealistLight,
	dark: OpenInSurrealistDark,
	}}
/>

To create a [namespace](/docs/surrealdb/introduction/concepts/namespace), click on the **Create Namespace** button. This will open a modal to input the name of the namespace. Once you've input the name, click on the **Create** button. 

> [!NOTE]
> You can create multiple namespaces in your Instance. If you previously created a namespace, you'll see it in the dropdown and then the option will be to select the namespace.

<Image
alt="Namespace and Database"
src={{
	light: NamespaceDatabaseLight,
	dark: NamespaceDatabaseDark,
	}}
/>

To create a [database](/docs/surrealdb/introduction/concepts/database), click on the **Create Database** button. This will open a modal to input the name of the database. Once you've input the name, click on the **Create** button. This will create the database.

After you've created a namespace and a database, you can start querying your Instance. For example, make a table called `users` and insert a record into it.

```surql title="Create a user table and insert a record into it"
-- Create schemaless user table.
DEFINE TABLE user SCHEMALESS;

-- Define some fields.
DEFINE FIELD firstName ON TABLE user TYPE string;
DEFINE FIELD lastName ON TABLE user TYPE string;
DEFINE FIELD email ON TABLE user TYPE string
  ASSERT string::is_email($value);
DEFINE INDEX userEmailIndex ON TABLE user COLUMNS email UNIQUE;

-- SEE IT IN ACTION - Example 1
-- 1: Add a user with all required fields and an undefined one.
CREATE user CONTENT { 
	firstName = 'Tobie', 
	lastName = 'Hitchcock', 
	email = 'Tobie.Hitchcock@surrealdb.com',
};

-- Query the data
SELECT * FROM user;
```

<Image
alt="Write queries in Surrealist"
src={{
	light: QueryingInstanceLight,
	dark: QueryingInstanceDark,
	}}
/>


## Additional Querying Options

You can also query your Instance using the SurrealDB CLI and the SurrealDB SDKs. They work similarly by providing a connection string to your Instance. The only difference is that with the CLI, you'll be provided an authentication token to use with your Instance.

With the SDKs, you'll use the `connect` method to connect to your Instance and then provide the namespace and database you want to work in.  Lets take a look at some examples of how these work.


### Connect via CLI

In your Instances dashboard, you'll see a **Connect** button, select the **Connect via CLI** option. This will provide you with a connection string to your Instance. You can then copy the connection string and use it to connect to your Instance using the SurrealDB CLI.

> [!IMPORTANT]
> To connect via CLI, you'll need to have the SurrealDB CLI installed. You can install the CLI by following the instructions [in the installation guide](/docs/surrealdb/cli).

Open your terminal and run the copied command, it should follow the following format:

```bash title="Connect via CLI example"
surreal sql --endpoint <connection-string> --token <token>
```
This will connect you to your Instance and you can start writing queries to your Instance.

### Connect via SDKs

In addition to the first two methods, you can also connect to your Instance using the SurrealDB SDKs. The SurrealDB SDKs are available for a variety of languages, including [JavaScript / TypeScript](/docs/sdk/javascript), [Python](/docs/sdk/python), [Rust](/docs/sdk/rust), [Go](/docs/sdk/golang), and [Java](/docs/sdk/java). 

To use this method, you'll need to have the SurrealDB SDK for your language installed. Once you've installed the SDK, you can use the `connect` method to connect to your Instance. 

From the SurrealDB Cloud dashboard, you'll see a **Connect** button, select the **Connect via SDK** option. This will provide you modal to carry out the following steps:

1. Select the language of the SDK you want to use.
2. Specify the Namespace and Database to connect to.
3. Add authentication details for your Instance.
4. Copy the code snippet to your project.

<Image
alt="Open in SDK"
src={{
	light: OpenInSDK,
	dark: OpenInSDK,
	}}
/>

Once you've completed these steps, you can use the SDK to connect to your Instance and start querying your Instance.

### Connect via HTTP

You can also connect to your Instance using the HTTP API. This allows you to connect to your Instance using any HTTP client. To get started, select the **Connect** button on your Instance. Then select **HTTP cURL**. 

This will open a modal to fill in your credentials for **Namespace** and **Database** and authentication before you can copy the URL.

<Image
alt="Open in HTTP cURL"
src={{
	light: OpenInHTTPCurlLight,
	dark: OpenInHTTPCurlDark,
	}}
/>

## Conclusion

In this guide, we've shown you how to deploy SurrealDB using SurrealDB Cloud . We've also shown you how to query your Instance using Surrealist, the SurrealDB CLI, and the SurrealDB SDKs. For more information on SurrealDB Cloud , you can visit the [SurrealDB Cloud documentation](/docs/cloud) or the [SurrealDB Cloud Landing Page](/cloud).




================================================
FILE: src/content/doc-surrealdb/embedding/dotnet.mdx
================================================
---
sidebar_position: 7
sidebar_label: Embedding SurrealDB in .NET
title: Embedding SurrealDB in .NET
description: The documentation for embedding SurrealDB within .NET has not yet been released.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/dotnet.png";
import DarkLogo from "@img/icon/dark/dotnet.png";

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

<div class="flag-title">
	<Image
		alt=".NET"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Embedding in .NET
</div>

SurrealDB is designed to be run in many different ways, and environments.
Due to the [separation of the storage and compute](/docs/surrealdb/introduction/architecture) layers, SurrealDB can be run in embedded mode, from within a number of different language environments.
In .NET, SurrealDB can be run as an [in-memory database](#memory-provider), or it can persist data using a [file-based storage engine](#file-providers). 

## Memory provider

The memory provider is a simple in-memory database that is useful in some contexts.
It can be extremely useful for testing scenarios, or for small applications that do not require persistence.

```bash
dotnet add package SurrealDb.Embedded.InMemory
```

### Consume the provider as-is

The simplest way to use an in-memory database instance of SurrealDB is to create an instance of the `SurrealDbMemoryClient` class.

```csharp
// highlight-next-line
using var db = new SurrealDbMemoryClient();

const string TABLE = "person";

var person = new Person
{
    Title = "Founder & CEO",
    Name = new() { FirstName = "Tobie", LastName = "Morgan Hitchcock" },
    Marketing = true
};
var created = await db.Create(TABLE, person);
Console.WriteLine(ToJsonString(created));
```

### Consume the provider via Dependency Injection

Following the .NET Dependency Injection pattern, you can register the in-memory provider using the `AddInMemoryProvider` extension method.
This will allow the `SurrealDbClient` to resolve the `mem://` endpoint.

```csharp
var builder = WebApplication.CreateBuilder(args);

var services = builder.Services;
var configuration = builder.Configuration;

// highlight-start
services
  .AddSurreal("Endpoint=mem://")
  .AddInMemoryProvider();
// highlight-end
```

Learn more about [Dependency Injection with SurrealDB in .NET](/docs/sdk/dotnet/core/dependency-injection) in the SDK documentation.


Once the memory provider is configured, you can use the .NET SDK the same way you would with a remote database.
Please refer to the [.NET client SDK](/docs/sdk/dotnet) documentation to get started with SurrealDB for .NET.

## File providers

The file provider is a more advanced storage engine that can be used to persist data to disk.

<Tabs groupId="file-embedded-modes">
  <TabItem value="rocksdb" label="RocksDB" default>

```bash
dotnet add package SurrealDb.Embedded.RocksDb
```

  </TabItem>
  <TabItem value="surrealkv" label="SurrealKV">

```bash
dotnet add package SurrealDb.Embedded.SurrealKv
```

  </TabItem>
</Tabs>

### Consume the provider as-is

<Tabs groupId="file-embedded-modes">
  <TabItem value="rocksdb" label="RocksDB" default>

The simplest way to use a file-backed database instance of SurrealDB is to create an instance of the `SurrealDbRocksDbClient` class.
Note that the `path` to the storage is mandatory.

```csharp
// highlight-next-line
using var db = new SurrealDbRocksDbClient("data.db");

const string TABLE = "person";

var person = new Person
{
    Title = "Founder & CEO",
    Name = new() { FirstName = "Tobie", LastName = "Morgan Hitchcock" },
    Marketing = true
};
var created = await db.Create(TABLE, person);
Console.WriteLine(ToJsonString(created));
```

  </TabItem>
  <TabItem value="surrealkv" label="SurrealKV">

The simplest way to use a file-backed database instance of SurrealDB is to create an instance of the `SurrealDbKvClient` class.
Note that the `path` to the storage is mandatory.

```csharp
// highlight-next-line
using var db = new SurrealDbKvClient("data.db");

const string TABLE = "person";

var person = new Person
{
    Title = "Founder & CEO",
    Name = new() { FirstName = "Tobie", LastName = "Morgan Hitchcock" },
    Marketing = true
};
var created = await db.Create(TABLE, person);
Console.WriteLine(ToJsonString(created));
```

  </TabItem>
</Tabs>

### Consume the provider via Dependency Injection

<Tabs groupId="file-embedded-modes">
  <TabItem value="rocksdb" label="RocksDB" default>

Following the .NET Dependency Injection pattern, you can register the file provider using the `AddRocksDbProvider` extension method.
This will allow the `SurrealDbClient` to resolve the `rocksdb://` endpoint.

```csharp
var builder = WebApplication.CreateBuilder(args);

var services = builder.Services;
var configuration = builder.Configuration;

// highlight-start
services
  .AddSurreal("Endpoint=rocksdb://data.db")
  .AddRocksDbProvider();
// highlight-end
```

  </TabItem>
  <TabItem value="surrealkv" label="SurrealKV">

Following the .NET Dependency Injection pattern, you can register the file provider using the `AddSurrealKvProvider` extension method.
This will allow the `SurrealDbClient` to resolve the `surrealkv://` endpoint.

```csharp
var builder = WebApplication.CreateBuilder(args);

var services = builder.Services;
var configuration = builder.Configuration;

// highlight-start
services
  .AddSurreal("Endpoint=surrealkv://data.db")
  .AddSurrealKvProvider();
// highlight-end
```

  </TabItem>
</Tabs>

Learn more about [Dependency Injection with SurrealDB in .NET](/docs/sdk/dotnet/core/dependency-injection) in the SDK documentation.

### Next step

Once the file provider is configured, you can use the .NET SDK the same way you would with a remote database.
Please refer to the [.NET client SDK](/docs/sdk/dotnet) documentation to get started.


================================================
FILE: src/content/doc-surrealdb/embedding/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Embedding
title: Embedding SurrealDB
description: In this section, you will find detailed instructions on how to embed SurrealDB into your application depending on your programming language.
---

# Embedding SurrealDB

In this section, you will find detailed instructions on how to embed SurrealDB into your application depending on your programming language.

The purpose of this section is to guide you through the process of embedding SurrealDB, ensuring that you have all the necessary dependencies and configurations in place to start using SurrealDB effectively.

Whether you are a beginner getting started with SurrealDB or an experienced user looking to set up SurrealDB in a new environment, this section will provide you with step-by-step instructions and best practices to ensure a smooth embedding process.

## Embedding languages

The following languages are supported:

- [Rust](/docs/surrealdb/embedding/rust)
- [JavaScript](/docs/surrealdb/embedding/javascript)
- [Python](/docs/surrealdb/embedding/python)
- [.NET](/docs/surrealdb/embedding/dotnet)






================================================
FILE: src/content/doc-surrealdb/embedding/javascript.mdx
================================================
---
sidebar_position: 3
sidebar_label: Embedding SurrealDB in JavaScript
title: Embedding SurrealDB in JavaScript
description: The documentation for embedding SurrealDB within JavaScript has not yet been released.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/javascript.png";
import DarkLogo from "@img/icon/dark/javascript.png";

<div class="flag-title">
	<Image
		alt="JavaScript"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Embedding in JavaScript
</div>

SurrealDB is designed to be run in many different ways, and environments. Due to the [separation of the storage and compute](/docs/surrealdb/introduction/architecture) layers, SurrealDB can be run in embedded mode, from within your JavaScript environments. 

You can embed SurrealDB in both browser and server environments. In browser environments using the [Wasm engine](/docs/sdk/javascript/engines/wasm), SurrealDB can be run as an in-memory database, or it can persist data using IndexedDB. In server environments using the [Node.js engine](/docs/sdk/javascript/engines/node), SurrealDB can be run as an embedded database, backed by either an in-memory engine or [SurrealKV](/docs/surrealkv).

In this document, we will cover how to embed SurrealDB in both browser and server environments.

## Browser
In browser environments, using the [Wasm engine](/docs/sdk/javascript/engines/wasm), you can run SurrealDB in-memory or with IndexedDB persistence.

For more information on how to embed SurrealDB in browser environments, please see the [Wasm engine](/docs/sdk/javascript/engines/wasm) documentation.

## Server

In server environments, you can use the [Node.js engine](/docs/sdk/javascript/engines/node) to run SurrealDB as an embedded database. 

For more information on how to embed SurrealDB in server environments, please see the [Node.js engine](/docs/sdk/javascript/engines/node) documentation.



================================================
FILE: src/content/doc-surrealdb/embedding/python.mdx
================================================
---
sidebar_position: 6
sidebar_label: Embedding SurrealDB in Python
title: Embedding SurrealDB in Python
description: The documentation for embedding SurrealDB within Python has not yet been released.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/python.png";
import DarkLogo from "@img/icon/dark/python.png";

<div class="flag-title">
	<Image
		alt="Python"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Embedding in Python
</div>

SurrealDB is designed to be run in many different ways, and environments. Due to the [separation of the storage and compute](/docs/surrealdb/introduction/architecture) layers, SurrealDB can be run in embedded mode, from within a number of different language environments. 

In Python, SurrealDB can be run as an in-memory database, or it can persist data using a file-based storage engine.

> [!IMPORTANT]
> The current version of the SurrealDB Python SDK does not support embedding. In the meantime, please refer to the [Python client SDK](/docs/sdk/python) documentation to get started with connecting to SurrealDB from Python.



================================================
FILE: src/content/doc-surrealdb/embedding/rust.mdx
================================================
---
sidebar_position: 2
sidebar_label: Embedding SurrealDB in Rust
title: Embedding SurrealDB in Rust
description: In Rust, SurrealDB can be run as an in-memory database, it can persist data using a file-based storage engine, or on a distributed cluster.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/rust.png";
import DarkLogo from "@img/icon/dark/rust.png";
import Label from "@components/shared/Label.astro";

<div class="flag-title">
	<Image
		alt="Rust"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Embedding in Rust
</div>

SurrealDB is designed to be run in many different ways, and environments. Due to the [separation of the storage and API layers](/docs/surrealdb/introduction/architecture), SurrealDB can be run in embedded mode, from within a number of different language environments. In Rust, SurrealDB can be run as an in-memory database, it can persist data using a file-based storage engine, or on a distributed cluster.

## Install the SDK

First, create a new project using `cargo new` and add the SurrealDB crate to your dependencies, enabling the key-value store you need:

```sh
# For an in memory database
cargo add surrealdb --features kv-mem

# For a RocksDB file
cargo add surrealdb --features kv-rocksdb

# For a TiKV cluster (TiKV and other dependencies must be installed)
cargo add surrealdb --features kv-tikv
```

You will need to add the following additional dependencies:

```bash
cargo add serde --features derive
cargo add tokio --features macros,rt-multi-thread
```

<br />

## Connect to SurrealDB

Open `src/main.rs` and replace everything in there with the following code to try out some basic operations using the SurrealDB SDK with an embedded database. Look at [integrations to connect to a database](/docs/sdk/rust).

```rust
use serde::{Deserialize, Serialize};
use surrealdb::RecordId;
use surrealdb::Surreal;

// For an in memory database
use surrealdb::engine::local::Mem;

// For a RocksDB file
// use surrealdb::engine::local::RocksDb;

#[derive(Debug, Serialize)]
struct Name<'a> {
    first: &'a str,
    last: &'a str,
}

#[derive(Debug, Serialize)]
struct Person<'a> {
    title: &'a str,
    name: Name<'a>,
    marketing: bool,
}

#[derive(Debug, Serialize)]
struct Responsibility {
    marketing: bool,
}

#[derive(Debug, Deserialize)]
struct Record {
    #[allow(dead_code)]
    id: RecordId,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    // Create database connection in memory
    let db = Surreal::new::<Mem>(()).await?;
    
    // Create database connection using RocksDB
    // let db = Surreal::new::<RocksDb>("path/to/database-folder").await?;

    // Select a specific namespace / database
    db.use_ns("test").use_db("test").await?;

    // Create a new person with a random id
    let created: Option<Record> = db
        .create("person")
        .content(Person {
            title: "Founder & CEO",
            name: Name {
                first: "Tobie",
                last: "Morgan Hitchcock",
            },
            marketing: true,
        })
        .await?;
    dbg!(created);

    // Update a person record with a specific id
    let updated: Option<Record> = db
        .update(("person", "jaime"))
        .merge(Responsibility { marketing: true })
        .await?;
    dbg!(updated);

    // Select all people records
    let people: Vec<Record> = db.select("person").await?;
    dbg!(people);

    // Perform a custom advanced query
    let groups = db
        .query("SELECT marketing, count() FROM type::table($table) GROUP BY marketing")
        .bind(("table", "person"))
        .await?;
    dbg!(groups);

    Ok(())
}
```

Run your program from the command line with:

```sh
cargo run
```

<br />

## SDK methods

The Rust SDK comes with a number of built-in functions.

<table>
    <thead>
        <tr>
            <th scope="col">Function</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Function"><a href="#init"><code>Surreal::init()</code></a></td>
            <td scope="row" data-label="Description">Initialises a static database engine</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#connect"><code>db.connect(endpoint)</code></a></td>
            <td scope="row" data-label="Description">Connects to a specific database endpoint, saving the connection on the static client</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#new"><code>{"Surreal::new::<T>(endpoint)"}</code></a></td>
            <td scope="row" data-label="Description">Connects to a local or remote database endpoint</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#use-ns-db"><code>db.use_ns(namespace).use_db(database)</code></a></td>
            <td scope="row" data-label="Description">Switch to a specific namespace and database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#signup"><code>db.signup(credentials)</code></a></td>
            <td scope="row" data-label="Description">Signs up a user using a specific record access method</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#signin"><code>db.signin(credentials)</code></a></td>
            <td scope="row" data-label="Description">Signs this connection in using a specific access method or system user</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#invalidate"><code>db.invalidate()</code></a></td>
            <td scope="row" data-label="Description">Invalidates the authentication for the current connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#authenticate"><code>db.authenticate(token)</code></a></td>
            <td scope="row" data-label="Description">Authenticates the current connection with a JSON Web Token</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#set"><code>db.set(key, val)</code></a></td>
            <td scope="row" data-label="Description">Assigns a value as a parameter for this connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#query"><code>db.query(sql)</code></a></td>
            <td scope="row" data-label="Description">Runs a set of SurrealQL statements against the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#select"><code>db.select(resource)</code></a></td>
            <td scope="row" data-label="Description">Selects all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#create"><code>db.create(resource).content(data)</code></a></td>
            <td scope="row" data-label="Description">Creates a record in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#update-content"><code>db.update(resource).content(data)</code></a></td>
            <td scope="row" data-label="Description">Updates all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#update-merge"><code>db.update(resource).merge(data)</code></a></td>
            <td scope="row" data-label="Description">Modifies all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#update-patch"><code>db.update(resource).patch(data)</code></a></td>
            <td scope="row" data-label="Description">Applies JSON Patch changes to all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#delete"><code>db.delete(resource)</code></a></td>
            <td scope="row" data-label="Description">Deletes all records, or a specific record</td>
        </tr>
    </tbody>
</table>

<br />

## `.init()` {#init}

The DB static singleton ensures that a single database instance is available across very large or complicated applications. With the singleton, only one connection to the database is instantiated, and the database connection does not have to be shared across components or controllers.

```rust title="Method Syntax"
Surreal::init()
```

### Example usage
```rust
static DB: LazyLock<Surreal<Client>> = LazyLock::new(Surreal::init);

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    // Connect to the database
    DB.connect::<Wss>("cloud.surrealdb.com").await?;
    // Select a namespace + database
    DB.use_ns("test").use_db("test").await?;
    // Create or update a specific record
    let tobie: Option<Record> = DB
        .update(("person", "tobie"))
        .content(Person { name: "Tobie" })
        .await?;
    Ok(())
}
```

<br />

## `.connect()` {#connect}

Connects to a local or remote database endpoint.

```rust title="Method Syntax"
db.connect(endpoint)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2">Argument</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Argument">
                <code>endpoint</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database endpoint to connect to.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Connect to a local endpoint
DB.connect::<Ws>("127.0.0.1:8000").await?;
// Connect to a remote endpoint
DB.connect::<Wss>("cloud.surrealdb.com").await?;
```

<br />

## `.new()` {#new}

Connects to a local or remote database endpoint.

```rust title="Method Syntax"
Surreal::new::<T>(endpoint)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>endpoint</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database endpoint to connect to.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;
```

<br />

## `.use_ns()` and `.use_db()` {#use-ns-db}

Switch to a specific namespace and database.

```rust title="Method Syntax"
db.use_ns(ns).use_db(db)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Switches to a specific namespace.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Switches to a specific database.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
db.use_ns("test").use_db("test").await?;
```

<br />

## `.signup()` {#signup}

Signs up using a specific record access method.

```rust title="Method Syntax"
db.signup(credentials)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>credentials</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Variables used in a signup query.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
use serde::Serialize;
use surrealdb::opt::auth::Scope;

#[derive(Serialize)]
struct Credentials<'a> {
    email: &'a str,
    pass: &'a str,
}

let jwt = db.signup(Scope {
    namespace: "test",
    database: "test",
    access: "user",
    params: Credentials {
        email: "info@surrealdb.com",
        pass: "123456",
    },
}).await?;

// ⚠️: It is important to note that the token should be handled securely and protected from unauthorized access.
let token = jwt.as_insecure_token();
```

<br />

## `.signin()` {#signin}

Signs in using a specific access method or system user.

```rust title="Method Syntax"
db.signin(credentials)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>credentials</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Variables used in a signin query.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
use serde::Serialize;
use surrealdb::opt::auth::Scope;

#[derive(Serialize)]
struct Credentials<'a> {
    email: &'a str,
    pass: &'a str,
}

let jwt = db.signin(Scope {
    namespace: "test",
    database: "test",
    access: "user",
    params: Credentials {
        email: "info@surrealdb.com",
        pass: "123456",
    },
}).await?;

// ⚠️: It is important to note that the token should be handled securely and protected from unauthorized access.
let token = jwt.as_insecure_token();
```

<br />

## `.invalidate()` {#invalidate}

Invalidates the authentication for the current connection.

```rust title="Method Syntax"
db.invalidate(credentials)
```

### Example usage
```surql
db.invalidate().await?;
```

<br />

## `.authenticate()` {#authenticate}

Authenticates the current connection with a JWT token.

```rust title="Method Syntax"
db.authenticate(token)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>token</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The JWT authentication token.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
db.authenticate(jwt).await?;
```

<br />

## `.set()` {#set}

Assigns a value as a parameter for this connection.

```rust title="Method Syntax"
db.set(key, val)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>val</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns the value to the variable name.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Assign the variable on the connection
db.set("name", Name {
    first: "Tobie",
    last: "Morgan Hitchcock",
}).await?;
// Use the variable in a subsequent query
db.query("CREATE person SET name = $name").await?;
// Use the variable in a subsequent query
db.query("SELECT * FROM person WHERE name.first = $name.first").await?;
```

<br />

## `.query()` {#query}

Runs a set of SurrealQL statements against the database.

```rust title="Method Syntax"
db.query(sql).bind(vars)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>vars</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Run some queries
let sql = "
    CREATE person;
    SELECT * FROM type::table($table);
";
let mut result = db
    .query(sql)
    .bind(("table", "person"))
    .await?;
// Get the first result from the first query
let created: Option<Person> = result.take(0)?;
// Get all of the results from the second query
let people: Vec<Person> = result.take(1)?;
```

<br />

## `.select()` {#select}

Selects all records in a table, or a specific record, from the database.

```rust title="Method Syntax"
db.select(resource)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>resource</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a record ID to select.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Select all records from a table
let people: Vec<Person> = db.select("person").await?;
// Select a specific record from a table
let person: Option<Person> = db.select(("person", "h5wxrf2ewk8xjxosxtyc")).await?;
```

### Translated query
This function will run the following query in the database:

```surql
SELECT * FROM $resource;
```

<br />

## `.create()` {#create}

Creates a record in the database.

```rust title="Method Syntax"
db.create(resource).content(data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>resource</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Create a record with a random ID
let person: Option<Person> = db.create("person").await?;
// Create a record with a specific ID
let record: Record = db
    .create(("person", "tobie"))
    .content(Person {
        name: "Tobie",
        settings: {
            active: true,
            marketing: true,
       },
    }).await?;
```

### Translated query
This function will run the following query in the database:

```surql
CREATE $resource CONTENT $data;
```

<br />

## `.update().content()` {#update-content}

Updates all records in a table, or a specific record, in the database.

```rust title="Method Syntax"
db.update(resource).content(data)
```

> [!NOTE]
> This function replaces the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>resource</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Update all records in a table
let people: Vec<Person> = db.update("person").await?;
// Update a record with a specific ID
let person: Option<Person> = db
    .update(("person", "tobie"))
    .content(Person {
        name: "Tobie",
        settings: {
            active: true,
            marketing: true,
        },
    }).await?;
```

### Translated query
This function will run the following query in the database:

```surql
UPDATE $resource CONTENT $data;
```

<br />

## `.update().merge()` {#update-merge}

Modifies all records in a table, or a specific record, in the database.

```rust title="Method Syntax"
db.update(resource).merge(data)
```

> [!NOTE]
> This function merges the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>resource</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Update all records in a table
let people: Vec<Person> = db.update("person")
    .merge(Document {
        updated_at: Datetime::default(),
    })
    .await?;
// Update a record with a specific ID
let person: Option<Person> = db.update(("person", "tobie"))
    .merge(Document {
        updated_at: Datetime::default(),
        settings: Settings {
            active: true,
        },
    })
    .await?;
```

### Translated query
This function will run the following query in the database:

```surql
UPDATE $resource MERGE $data;
```

<br />

## `.update().patch()` {#update-patch}

Applies JSON Patch changes to all records, or a specific record, in the database.

```rust title="Method Syntax"
db.update(resource).patch(data)
```

> [!NOTE]
> This function patches the current document / record data with the specified JSON Patch data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>resource</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to modify.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The JSON Patch data with which to modify the records.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Update all records in a table
let people: Vec<Person> = db.update("person")
    .patch(PatchOp::replace("/created_at", Datetime::default()))
    .await?;

// Update a record with a specific ID
let person: Option<Person> = db.update(("person", "tobie"))
    .patch(PatchOp::replace("/settings/active", false))
    .patch(PatchOp::add("/tags", &["developer", "engineer"]))
    .patch(PatchOp::remove("/temp"))
    .await?;
```

### Translated query
This function will run the following query in the database:

```surql
UPDATE $resource PATCH $data;
```

<br />

## `.delete()` {#delete}

Deletes all records in a table, or a specific record, from the database.

```rust title="Method Syntax"
db.delete(resource)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>resource</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a record ID to select.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Delete all records from a table
let people: Vec<Person> = db.delete("person").await?;
// Delete a specific record from a table
let person: Option<Person> = db.delete(("person", "h5wxrf2ewk8xjxosxtyc")).await?;
```

### Translated query
This function will run the following query in the database:

```surql
DELETE FROM $resource RETURN BEFORE;
```



================================================
FILE: src/content/doc-surrealdb/faqs/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: FAQs
title: Frequently Asked Questions
description: The purpose of this document is to provide you with a comprehensive understanding of SurrealDB. Whether you are a beginner getting started with SurrealDB or an experienced user looking for specific information, this overview will serve as a valuable resource.
---

import Version from '@components/Version.astro';

# Frequently Asked Questions

View some of the frequently asked questions regarding SurrealDB, SurrealQL, and SurrealKV. Questions which are frequently asked across our GitHub, Discord and other social platforms will be added here from time-to-time. SurrealDB is currently in version <Version/>.

## Where can I find the latest features?

Once features are released, we document them in our [release notes](/releases) and on our [features page](/features), which is a great place to understand capabilities.

You can also check some of our new features for <Version />:
- [`SurrealLQ`](/features/realtime-data-sync)
- [`SurrealIX`](/features/full-text-search)
- [`SurrealCF`](/features/change-data-capture)
- [`SurrealML`](/features/machine-learning)

## How do I scale SurrealDB?

SurrealDB can be scaled vertically on a single node by adding more compute power and memory to a server instance.

SurrealDB can also be scaled horizontally by sitting in front of and connecting to a [TiKV](https://tikv.org/) to store data. TiKV is a highly scalable, low latency, and easy to use key-value datastore. TiKV supports raw and transaction-based querying with ACID compliance, and support for multiple concurrent readers and writers. The design of TiKV is inspired by distributed systems from Google, such as BigTable, Spanner, and Percolator, and some of the latest achievements in academia in recent years, such as the Raft consensus algorithm.

When running in [FoundationDB](https://www.foundationdb.org/) distributed cluster mode, SurrealDB offloads the storage to the key-value store, operating as an advanced query engine layer. It is then possible to increase the number of SurrealDB nodes as required, in order to handle the query and transaction processing requirements.

> [!WARNING]
> FoundationDB support is deprecated in SurrealDB `3.0`. Please plan to migrate to a supported storage backend.

## What is the license for SurrealDB?

Source code for SurrealDB is variously licensed under a number of different licenses. A copy of each license can be found in [each repository](https://github.com/surrealdb) on GitHub. For more information on the licenses view the license [details page](/license).

## Do I need to purchase a license for development use?

No! SurrealDB is free to use for all development, pre-production and production use.

## Do I need to purchase a license for production use?

No! SurrealDB is free to use for all development, pre-production and production use.

## What does the license restrict you from doing?

You can use and scale SurrealDB to any number of nodes, and can run it as a server or embed it in to your applications (whether you ship those applications to customers or run them as a service). You can even run it as a service internally, to your employees, contractors, and subsidiary companies. The only thing that you are not able to do is offer a commercial, hosted version of SurrealDB as a service (a database-as-a-service) without buying a license.



================================================
FILE: src/content/doc-surrealdb/faqs/known-issues.mdx
================================================
---
sidebar_position: 2
sidebar_label: Known Issues
title: Known Issues
description: The purpose of this document is to highlight some of the known issues with SurrealDB. This will help you to understand the current limitations and issues that are being worked on.
---

# Known Issues

Here are some known bugs and issues with SurrealDB.

## SDKs

### `IF EXISTS` and `IF NOT EXISTS` are not yet available in the `DEFINE` statement

- **Date added:** 2024-05-21
- **Affected versions:** 1.x
- **Fixed versions:** -

Some query functionality is not yet available in the SDKs. Such as `IF EXISTS` and `IF NOT EXISTS` clauses in the [`DEFINE` statement](/docs/surrealql/statements/define). This means that if you used these clauses in your query method (as seen in the example below), the SDK would not be able to parse the query correctly.

```js
await db.query(
    'DEFINE FIELD IF NOT EXISTS email ON TABLE user TYPE string;'
);
```

When using a pre-2.0 version of the Rust SDK, the [`sql2` feature flag](https://docs.rs/crate/surrealdb/1.5.5/features) can be enabled to allow it to recognize newer syntax.

## SurrealQL

### `DELETE ONLY` always returns an error

- **Date added:** 2024-05-21
- **Issue number:** [#3936](https://github.com/surrealdb/surrealdb/issues/3936)
- **Affected versions:** 1.x
- **Fixed versions:** -

In the [`DELETE` statement](/docs/surrealql/statements/delete) the `ONLY` clause doesn't work as expected because it checks for a length of 1 and `DELETE` doesn't return anything by default at this time. So it always gives the following error:

- 'Expected a single result output when using the ONLY keyword'. 

However, adding `RETURN $before` will force `DELETE` to return the deleted record, which will be the expected length of 1.

```surql
CREATE person:one;

// Currently fails
DELETE ONLY person:one;

// Workaround: add RETURN $before
DELETE ONLY person:one RETURN $before;



================================================
FILE: src/content/doc-surrealdb/installation/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Installation
title: Installation
description: In this section, you will explore the robust security features and best practices that SurrealDB offers to protect your data and ensure the integrity of your applications.
---

import { Icon } from "astro-icon/components";
import Version from '@components/Version.astro';
import IconBox from '@components/boxes/IconBox.astro';
import Boxes from '@src/components/boxes/Boxes.astro';

import AppleLightLogo from "@img/icon/light/apple.png";
import AppleDarkLogo from "@img/icon/dark/apple.png";

import WindowsLightLogo from "@img/icon/light/windows.png";
import WindowsDarkLogo from "@img/icon/dark/windows.png";

import LinuxLightLogo from "@img/icon/light/linux.png";
import LinuxDarkLogo from "@img/icon/dark/linux.png";

# Installation

One of the most popular ways to get started with SurrealDB is to install and run it as a standalone database service, allowing any number of clients to connect to it and interact with the data.

Whether you are installing SurrealDB on your local machine for development purposes, or spinning up a production database, this section will guide you through the installation process, ensuring that you have all the necessary dependencies and configurations in place to start using SurrealDB effectively.

While the current stable version of SurrealDB is <a href='/releases'> <Version /> </a>, we currently support all [released versions](/releases) from `1.0.0` onwards.

## Installation Steps

There are multiple ways to install SurrealDB, depending on your operating system and development environment. In this section, we will outline the installation steps for each operating system and development environment, ensuring that you have all the necessary dependencies and configurations in place to start using SurrealDB effectively.

You can install SurrealDB on the following operating systems:

<Boxes wider columns={3} class="pt-2">
	<IconBox
		title="MacOS"
		href="/docs/surrealdb/installation/macos"
		icon={{ light: AppleLightLogo, dark: AppleDarkLogo }}
	/>
	<IconBox
		title="Windows"
		href="/docs/surrealdb/installation/windows"
		icon={{ light: WindowsLightLogo, dark: WindowsDarkLogo }}
	/>
	<IconBox
		title="Linux"
		href="/docs/surrealdb/installation/linux"
		icon={{ light: LinuxLightLogo, dark: LinuxDarkLogo }}
	/>
</Boxes>

## SurrealDB Cloud 

Running and maintaining your own database can be a time consuming task. That's why we offer [SurrealDB Cloud ](/docs/cloud), a fully managed database service that allows you to focus on building your applications without worrying about the underlying infrastructure. 

<a
	href="/docs/cloud/getting-started"
	class="gradient-button group mt-2"
>
	Get started with SurrealDB Cloud 
	<Icon name="fa6-solid:arrow-right" class="w-4 transition-transform group-hover:translate-x-1" />
</a>



================================================
FILE: src/content/doc-surrealdb/installation/linux.mdx
================================================
---
sidebar_position: 3
sidebar_label: Install on Linux
title: Install on Linux
description: Use this tutorial to install SurrealDB on Linux or Unix operating systems using the SurrealDB install script.
---

import Version from "@components/Version.astro";
import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/linux.png";
import DarkLogo from "@img/icon/dark/linux.png";

<div class="flag-title">
	<Image
		alt="Linux"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Install on Linux
</div>

Use this tutorial to install SurrealDB on Linux or Unix operating systems using the SurrealDB [install script](https://github.com/surrealdb/install.surrealdb.com). Both the SurrealDB Database Server and the SurrealDB Command Line Tool are packaged and distributed as a single executable file, which is easy to install, and easy to uninstall.

## Installing SurrealDB using the install script

To get started, you can use the SurrealDB [install script](https://github.com/surrealdb/install.surrealdb.com). This script securely downloads the latest version for the platform and CPU type. It attempts to install SurrealDB into the `/usr/local/bin` folder, falling back to a user-specified folder if necessary.

```bash
curl -sSf https://install.surrealdb.com | sh
```

### Updating SurrealDB

To ensure that you are using the latest version, update SurrealDB to version <Version /> using the following command.

```bash
curl -sSf https://install.surrealdb.com | sh
```

### Checking SurrealDB

Once installed, you can run the SurrealDB command-line tool by using the `surreal` command. To check whether the install was successful run the following command in your terminal.

```bash
surreal help
```

The result should look similar to the output below, confirming that the SurrealDB command-line tool was installed successfully.

```bash
.d8888b.                                             888 8888888b.  888888b.
d88P  Y88b                                            888 888  'Y88b 888  '88b
Y88b.                                                 888 888    888 888  .88P
 'Y888b.   888  888 888d888 888d888  .d88b.   8888b.  888 888    888 8888888K.
	'Y88b. 888  888 888P'   888P'   d8P  Y8b     '88b 888 888    888 888  'Y88b
	  '888 888  888 888     888     88888888 .d888888 888 888    888 888    888
Y88b  d88P Y88b 888 888     888     Y8b.     888  888 888 888  .d88P 888   d88P
 'Y8888P'   'Y88888 888     888      'Y8888  'Y888888 888 8888888P'  8888888P'


SurrealDB command-line interface and server

To get started using SurrealDB, and for guides on connecting to and building applications
on top of SurrealDB, check out the SurrealDB documentation (https://surrealdb.com/docs).

If you have questions or ideas, join the SurrealDB community (/community).

If you find a bug, submit an issue on Github (https://github.com/surrealdb/surrealdb/issues).

We would love it if you could star the repository (https://github.com/surrealdb/surrealdb).

----------

USAGE:
	surreal [SUBCOMMAND]

OPTIONS:
	-h, --help    Print help information

SUBCOMMANDS:
	start      Start the database server
	import     Import a SQL script into an existing database
	export     Export an existing database into a SQL script
	version    Output the command-line tool version information
	sql        Start an SQL REPL in your terminal with pipe support
	help       Print this message or the help of the given subcommand(s)

```



================================================
FILE: src/content/doc-surrealdb/installation/macos.mdx
================================================
---
sidebar_position: 2
sidebar_label: Install on macOS
title: Install on macOS
description: Use this tutorial to install SurrealDB on macOS, using the SurrealDB install script, or using the third-party Homebrew package manager.
---

import Version from '@components/Version.astro';
import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/apple.png";
import DarkLogo from "@img/icon/dark/apple.png";

<div class="flag-title">
	<Image
		alt="MacOS"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Install on macOS
</div>

Use this tutorial to install SurrealDB on macOS using the SurrealDB [install script](https://github.com/surrealdb/install.surrealdb.com), or using the third-party [Homebrew](https://brew.sh/) package manager. Both the SurrealDB Database Server and the SurrealDB Command Line Tool are packaged and distributed as a single executable file, which is easy to install, and easy to uninstall.

## Installing SurrealDB using the install script

To get started, you can use the SurrealDB [install script](https://github.com/surrealdb/install.surrealdb.com). This script securely downloads the latest version for the platform and CPU type. It attempts to install SurrealDB into the `/usr/local/bin` folder, falling back to a user-specified folder if necessary.

```bash
curl -sSf https://install.surrealdb.com | sh
```

### Updating SurrealDB

To ensure that you are using the latest version, update SurrealDB to version <Version /> using the following command.

```bash
curl -sSf https://install.surrealdb.com | sh
```

### Checking SurrealDB

Once installed, you can run the SurrealDB command-line tool by using the `surreal` command. To check whether the install was successful run the following command in your terminal.

```bash
surreal help
```
The result should look similar to the output below, confirming that the SurrealDB command-line tool was installed successfully.

```bash
.d8888b.                                             888 8888888b.  888888b.
d88P  Y88b                                            888 888  'Y88b 888  '88b
Y88b.                                                 888 888    888 888  .88P
 'Y888b.   888  888 888d888 888d888  .d88b.   8888b.  888 888    888 8888888K.
	'Y88b. 888  888 888P'   888P'   d8P  Y8b     '88b 888 888    888 888  'Y88b
	  '888 888  888 888     888     88888888 .d888888 888 888    888 888    888
Y88b  d88P Y88b 888 888     888     Y8b.     888  888 888 888  .d88P 888   d88P
 'Y8888P'   'Y88888 888     888      'Y8888  'Y888888 888 8888888P'  8888888P'


SurrealDB command-line interface and server

To get started using SurrealDB, and for guides on connecting to and building applications
on top of SurrealDB, check out the SurrealDB documentation (https://surrealdb.com/docs).

If you have questions or ideas, join the SurrealDB community (/community).

If you find a bug, submit an issue on Github (https://github.com/surrealdb/surrealdb/issues).

We would love it if you could star the repository (https://github.com/surrealdb/surrealdb).

----------

USAGE:
	surreal [SUBCOMMAND]

OPTIONS:
	-h, --help    Print help information

SUBCOMMANDS:
	start      Start the database server
	import     Import a SQL script into an existing database
	export     Export an existing database into a SQL script
	version    Output the command-line tool version information
	sql        Start an SQL REPL in your terminal with pipe support
	help       Print this message or the help of the given subcommand(s)

```

## Installing SurrealDB using Homebrew

The quickest way to get going with SurrealDB on macOS is to use Homebrew. This will install both the command-line tools, and the SurrealDB server as a single executable. If you don't use Homebrew, follow the instructions for Linux below to install SurrealDB.

```bash
brew install surrealdb/tap/surreal
```

### Updating SurrealDB

To ensure that you are using the latest version, update SurrealDB to version <Version /> using the following command.

```bash
brew upgrade surrealdb/tap/surreal
```

### Checking SurrealDB

Once installed, you can run the SurrealDB command-line tool by using the `surreal` command. To check whether the install was successful run the following command in your terminal.

```bash
surreal help
```

The result should look similar to the output below, confirming that the SurrealDB command-line tool was installed successfully.

```bash
.d8888b.                                             888 8888888b.  888888b.
d88P  Y88b                                            888 888  'Y88b 888  '88b
Y88b.                                                 888 888    888 888  .88P
 'Y888b.   888  888 888d888 888d888  .d88b.   8888b.  888 888    888 8888888K.
	'Y88b. 888  888 888P'   888P'   d8P  Y8b     '88b 888 888    888 888  'Y88b
	  '888 888  888 888     888     88888888 .d888888 888 888    888 888    888
Y88b  d88P Y88b 888 888     888     Y8b.     888  888 888 888  .d88P 888   d88P
 'Y8888P'   'Y88888 888     888      'Y8888  'Y888888 888 8888888P'  8888888P'


SurrealDB command-line interface and server

To get started using SurrealDB, and for guides on connecting to and building applications
on top of SurrealDB, check out the SurrealDB documentation (https://surrealdb.com/docs).

If you have questions or ideas, join the SurrealDB community (/community).

If you find a bug, submit an issue on Github (https://github.com/surrealdb/surrealdb/issues).

We would love it if you could star the repository (https://github.com/surrealdb/surrealdb).

----------

USAGE:
	surreal [SUBCOMMAND]

OPTIONS:
	-h, --help    Print help information

SUBCOMMANDS:
	start      Start the database server
	import     Import a SQL script into an existing database
	export     Export an existing database into a SQL script
	version    Output the command-line tool version information
	sql        Start an SQL REPL in your terminal with pipe support
	help       Print this message or the help of the given subcommand(s)

```



================================================
FILE: src/content/doc-surrealdb/installation/nightly.mdx
================================================
---
sidebar_position: 5
sidebar_label: Install the Nightly
title: Install the Nightly
description: If you prefer developing on the bleeding edge, you can follow this tutorial to install SurrealDB Nightly. The nightly version is built and released every night at midnight.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/surrealdb.png";
import DarkLogo from "@img/icon/dark/surrealdb.png";

<div class="flag-title">
	<Image
		alt="Nightly"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Install the Nightly
</div>

If you prefer developing on the bleeding edge, you can follow this tutorial to install SurrealDB Nightly. The nightly version is built and released every night at midnight, and includes the latest features, and bug fixes. The nightly version is available for macOS, Linux, and Windows operating systems, and can be installed using the [Linux or Unix install script](https://github.com/surrealdb/install.surrealdb.com), or using the [Windows install script](https://github.com/surrealdb/windows.surrealdb.com). Alternatively you can run the nightly version with Docker by using the `nightly` tag.

## Installing SurrealDB Nightly on macOS

To get started, you can use the SurrealDB [install script](https://github.com/surrealdb/install.surrealdb.com). This script securely downloads the latest version for the platform and CPU type. It attempts to install SurrealDB into the `/usr/local/bin` folder, falling back to a user-specified folder if necessary. The following command will attempt to install the nightly version. You can re-run this command daily to ensure you are running the latest build of SurrealDB.

```bash
curl --proto '=https' --tlsv1.2 -sSf https://install.surrealdb.com | sh -s -- --nightly
```

## Installing SurrealDB Nightly on Linux

To get started, you can use the SurrealDB [install script](https://github.com/surrealdb/install.surrealdb.com). This script securely downloads the latest version for the platform and CPU type. It attempts to install SurrealDB into the `/usr/local/bin` folder, falling back to a user-specified folder if necessary. The following command will attempt to install the nightly version. You can re-run this command daily to ensure you are running the latest build of SurrealDB.

```bash
curl --proto '=https' --tlsv1.2 -sSf https://install.surrealdb.com | sh -s -- --nightly
```

## Installing SurrealDB Nightly on Windows

To get started, you can use the SurrealDB [install script](https://github.com/surrealdb/install.surrealdb.com). This script securely downloads the latest version for the platform and CPU type. It installs SurrealDB into the `C:\Program Files\SurrealDB` folder, falling back to a user-specified folder if necessary. The following command will attempt to install the nightly version. You can re-run this command daily to ensure you are running the latest build of SurrealDB.

```bash
iex "& { $(irm https://windows.surrealdb.com) } -Nightly"
```

## Using SurrealDB Nightly with Docker

To use SurrealDB Nightly with Docker, you can use the `nightly` tag. When running the following command, the latest SurrealDB Nightly version will be pulled from Docker Hub.

```bash
docker run --rm --pull always -p 8000:8000 surrealdb/surrealdb:nightly start
```



================================================
FILE: src/content/doc-surrealdb/installation/windows.mdx
================================================
---
sidebar_position: 4
sidebar_label: Install on Windows
title: Install on Windows
description: Use this tutorial to install SurrealDB on Windows using the SurrealDB install script, or using third-party package managers like Chocolatey or Scoop.
---

import Version from '@components/Version.astro';
import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/windows.png";
import DarkLogo from "@img/icon/dark/windows.png";

<div class="flag-title">
	<Image
		alt="Windows"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Install on Windows
</div>

Use this tutorial to install SurrealDB on Windows operating systems using the SurrealDB [install script](/docs/surrealdb/installation/windows#installing-surrealdb-using-the-install-script), or using third-party package managers like [Chocolatey](https://chocolatey.org/) or third-party like [Scoop](https://scoop.sh/). Both the SurrealDB Database Server and the SurrealDB Command Line Tool are packaged and distributed as a single executable file, which is easy to install, and easy to uninstall.

## Installing SurrealDB using the install script

To get started, you can use the SurrealDB [install script](https://github.com/surrealdb/install.surrealdb.com). This script securely downloads the latest version for the platform and CPU type. It installs SurrealDB into the `C:\Program Files\SurrealDB` folder, falling back to a user-specified folder if necessary.

```bash
iwr https://windows.surrealdb.com -useb | iex
```

### Updating SurrealDB

To ensure that you are using the latest version, update SurrealDB to version <Version /> using the following command.

```bash
surreal upgrade
```

### Checking SurrealDB

Once installed, you can run the SurrealDB command-line tool by using the `surreal` command. To check whether the installation was successful run the following command in your terminal.

```bash
surreal help
```

The result should look similar to the output below, confirming that the SurrealDB command-line tool was installed successfully.

```bash
.d8888b.                                             888 8888888b.  888888b.
d88P  Y88b                                            888 888  'Y88b 888  '88b
Y88b.                                                 888 888    888 888  .88P
 'Y888b.   888  888 888d888 888d888  .d88b.   8888b.  888 888    888 8888888K.
	'Y88b. 888  888 888P'   888P'   d8P  Y8b     '88b 888 888    888 888  'Y88b
	  '888 888  888 888     888     88888888 .d888888 888 888    888 888    888
Y88b  d88P Y88b 888 888     888     Y8b.     888  888 888 888  .d88P 888   d88P
 'Y8888P'   'Y88888 888     888      'Y8888  'Y888888 888 8888888P'  8888888P'


SurrealDB command-line interface and server

To get started using SurrealDB, and for guides on connecting to and building applications
on top of SurrealDB, check out the SurrealDB documentation (https://surrealdb.com/docs).

If you have questions or ideas, join the SurrealDB community (/community).

If you find a bug, submit an issue on Github (https://github.com/surrealdb/surrealdb/issues).

We would love it if you could star the repository (https://github.com/surrealdb/surrealdb).

----------

USAGE:
	surreal [SUBCOMMAND]

OPTIONS:
	-h, --help    Print help information

SUBCOMMANDS:
	start      Start the database server
	import     Import a SQL script into an existing database
	export     Export an existing database into a SQL script
	version    Output the command-line tool version information
	sql        Start an SQL REPL in your terminal with pipe support
	help       Print this message or the help of the given subcommand(s)

```

## Installing SurrealDB using Chocolatey

If you use the [chocolatey](https://chocolatey.org/) package manager, then you can quickly install SurrealDB with one command. This will install both the command-line tools, and the SurrealDB server as a single executable. If you don't use Homebrew, follow the instructions for Linux below to install SurrealDB.

```bash
choco install surreal
```

### Updating SurrealDB

To ensure that you are using the latest version, update SurrealDB to version <Version /> using the following command.
```bash
choco update surreal
```


## Installing SurrealDB using Scoop

If you use the [Scoop](https://scoop.sh/) package manager, then you can quickly install SurrealDB with one command. This will install both the command-line tools, and the SurrealDB server as a single executable.

```bash
scoop install surrealdb
```

### Updating SurrealDB

To ensure that you are using the latest version, update SurrealDB to version <Version /> using the following command.

```bash
scoop update surrealdb
```

## Troubleshooting

*Attempting to open the executable at the install location throws errors that the following DLLs are not installed*

If you encounter an error saying that the following DLLs are not installed:
* VCRUNTIME140.dll
* MSVCP140.dll
* VCRUNTIME140_1.dll

Then you may need to install the [Microsoft Visual C++ Redistributable for Visual Studio](https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170#latest-microsoft-visual-c-redistributable-version).



================================================
FILE: src/content/doc-surrealdb/installation/running/docker.mdx
================================================
---
sidebar_position: 1
sidebar_label: Run with Docker
title: Running SurrealDB with Docker
description: Use this tutorial to get started with SurrealDB from within Docker.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/docker.png";
import DarkLogo from "@img/icon/dark/docker.png";

<div class="flag-title">
	<Image
		alt="Docker"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Run with Docker
</div>

Use this tutorial to run SurrealDB from within Docker.

## Running the SurrealDB server using Docker

To get started using Docker, you can use the `latest` tag. To view all the available versions and tags, or to use a specific tag visit the [Docker Hub](https://hub.docker.com/r/surrealdb/surrealdb) page. To start a server use the [`start`](/docs/surrealdb/cli/start) command. In Docker, SurrealDB listens on port `8000` in all interfaces by default so that the host can connect to the container in the default bridge networking mode.

```bash
docker run --rm --pull always -p 8000:8000 surrealdb/surrealdb:latest start
```

> [!IMPORTANT]
> For local development, use the `latest-dev` image variant (i.e., docker run --rm --pull always -p 8000:8000 surrealdb/surrealdb:latest-dev start). This version includes a shell and package manager, allowing you to install tools and interact with the container's internals.

In order to persist data when the Docker instance is restarted or shutdown, specify a Docker folder using the Docker *`-v`* command line argument, and use the on-disk storage engine in SurrealDB using the path prefix chosen as a Docker folder.

```bash
mkdir mydata # Create a directory to store the database, owned by the current user
docker run --rm --pull always -p 8000:8000 --user $(id -u) -v $(pwd)/mydata:/mydata surrealdb/surrealdb:latest start rocksdb:/mydata/mydatabase.db
```

The default logging level for the database server is `info`, resulting in any informational logs to be output to the standard output. To control the logging verbosity, specify the *`--log`* argument. The following command starts the database with `debug` level logging, resulting in more logs being output to the terminal. If extra verbosity is not needed, specify a lower level or simply remove the flag, which will default to the `info` level.

```bash
mkdir mydata # Create a directory to store the database, owned by the current user
docker run --rm --pull always -p 8000:8000 --user $(id -u) -v $(pwd)/mydata:/mydata surrealdb/surrealdb:latest start --log debug rocksdb:/mydata/mydatabase.db
```

### Configuring authentication

Authentication is enabled by default since version `2.0`, using the `--unauthenticated` flag to opt out. In versions of SurrealDB before 2.0, authentication was disabled by default and required an `--auth` flag to enable.

To set up access as an authenticated user, configure your initial root-level user by setting the *`--user`* and *`--pass`* command-line arguments.

The following command starts the database with a top-level user named `root` with a password also set to `root`. The root user will be persisted in storage, which means you don't have to include the command line arguments next time you start SurrealDB.

```bash
docker run --rm --pull always -p 80:8000 -v /mydata:/mydata surrealdb/surrealdb:latest start --user root --pass secret rocksdb:mydatabase.db
```

In order to change the default port that SurrealDB uses for web connections and from database clients you can use the Docker *`-p`* command line argument to tunnel the port to the internal SurrealDB port which SurrealDB is served on. The following command starts the database on port `80`.

```bash
docker run --rm --pull always -p 80:8000 -v /mydata:/mydata surrealdb/surrealdb:latest start --user root --pass secret rocksdb:/mydata/mydatabase.db
```

After running the above command, you should see the SurrealDB server startup successfully.

```bash
docker run --rm --pull always -p 80:8000 -v /local-dir:/container-dir surrealdb/surrealdb:latest start --user root --pass secret rocksdb:/container-dir/mydatabase.db

2023-08-30T15:06:34.788739Z  INFO surreal::dbs: ✅🔒 Authentication is enabled 🔒✅
2023-08-30T15:06:34.788821Z  INFO surrealdb::kvs::ds: Starting kvs store in rocksdb:/container-dir/mydatabase.db
2023-08-30T15:06:34.788859Z  INFO surrealdb::kvs::ds: Started kvs store in rocksdb:/container-dir/mydatabase.db
2023-08-30T15:06:34.789222Z  INFO surrealdb::kvs::ds: Initial credentials were provided and no existing root-level users were found: create the initial user 'root'.
2023-08-30T15:06:35.205123Z  INFO surrealdb::node: Started node agent
2023-08-30T15:06:35.205827Z  INFO surrealdb::net: Started web server on 0.0.0.0:8080
```

For details on the [`start`](/docs/surrealdb/cli/start) command, and all of the available configuration options and arguments, view the [`start command documentation`](/docs/surrealdb/cli/start).

## Using the command-line tools within Docker
The Docker container contains both the server, and the command line tools for importing, exporting, and querying a remote SurrealDB server.

```bash
docker run --rm --pull always surrealdb/surrealdb:latest help
```

The result should look similar to the output below, confirming that the SurrealDB command-line tool was installed successfully.

```bash
.d8888b.                                             888 8888888b.  888888b.
d88P  Y88b                                            888 888  'Y88b 888  '88b
Y88b.                                                 888 888    888 888  .88P
 'Y888b.   888  888 888d888 888d888  .d88b.   8888b.  888 888    888 8888888K.
	'Y88b. 888  888 888P'   888P'   d8P  Y8b     '88b 888 888    888 888  'Y88b
	  '888 888  888 888     888     88888888 .d888888 888 888    888 888    888
Y88b  d88P Y88b 888 888     888     Y8b.     888  888 888 888  .d88P 888   d88P
 'Y8888P'   'Y88888 888     888      'Y8888  'Y888888 888 8888888P'  8888888P'


SurrealDB command-line interface and server

To get started using SurrealDB, and for guides on connecting to and building applications
on top of SurrealDB, check out the SurrealDB documentation (https://surrealdb.com/docs).

If you have questions or ideas, join the SurrealDB community (/community).

If you find a bug, submit an issue on Github (https://github.com/surrealdb/surrealdb/issues).

We would love it if you could star the repository (https://github.com/surrealdb/surrealdb).

----------

USAGE:
	surreal [SUBCOMMAND]

OPTIONS:
	-h, --help    Print help information

SUBCOMMANDS:
	start      Start the database server
	import     Import a SQL script into an existing database
	export     Export an existing database into a SQL script
	version    Output the command-line tool version information
	sql        Start an SQL REPL in your terminal with pipe support
	help       Print this message or the help of the given subcommand(s)

```

For details on the different commands available, visit the [CLI tool documentation](/docs/surrealdb/cli).



================================================
FILE: src/content/doc-surrealdb/installation/running/file.mdx
================================================
---
sidebar_position: 2
sidebar_label: Run a disk based server
title: Running a single-node SurrealDB server
description: For the purposes of getting started with SurrealDB quickly, we will start a RocksDB database which persists data on the filesystem.
---

# Run a single-node, on-disk server

For the purposes of getting started with SurrealDB quickly, we will start a RocksDB database which persists data on the filesystem. This configuration is great for trying out the database and small deployments.

```bash 
surreal start rocksdb:mydatabase.db
```

The default logging level for the database server is `info`, resulting in any informational logs to be output to the standard output. To control the logging verbosity, specify the *`--log`* argument. The following command starts the database with `debug` level logging, resulting in more logs being output to the terminal. If extra verbosity is not needed, specify a lower level or simply remove the flag, which will default to the `info` level.

```bash
surreal start --log debug rocksdb:mydatabase.db
```

In versions of SurrealDB before 2.0.0, anyone would be able to connect to this server to begin running queries. However, SurrealDB since version 2.0.0 runs with authentication by default. In order to disable it, the `--unauthenticated` flag can be passed in.

```bash
surreal start --unauthenticated rocksdb:mydatabase.db
```

However, for anything but simple testing, it is better to configure your initial root-level user by setting the *`--user`* and *`--pass`* command-line arguments. The following command starts the database with a top-level user named root with a password also set to `root`. The root user will be persisted in storage, which means you don't have to include the command line arguments next time you start SurrealDB.

```bash
surreal start --user root --pass secret rocksdb:mydatabase.db
```

In order to change the default port that SurrealDB uses for web connections and from database clients you can use the *`--bind`* argument. The following command starts the database on port `8080`.

```bash
surreal start --user root --pass secret --bind 0.0.0.0:8080 rocksdb://path/to/mydatabase
```
After running the above command, you should see the SurrealDB server startup successfully.

```bash
surreal start --user root --pass secret --bind 0.0.0.0:8080 rocksdb:mydatabase.db
2023-08-30T15:06:34.788739Z  INFO surreal::dbs: ✅🔒 Authentication is enabled 🔒✅
2023-08-30T15:06:34.788821Z  INFO surrealdb::kvs::ds: Starting kvs store in file:mydatabase.db
2023-08-30T15:06:34.788859Z  INFO surrealdb::kvs::ds: Started kvs store in file:mydatabase.db
2023-08-30T15:06:34.789222Z  INFO surrealdb::kvs::ds: Initial credentials were provided and no existing root-level users were found: create the initial user 'root'.
2023-08-30T15:06:35.205123Z  INFO surrealdb::node: Started node agent
2023-08-30T15:06:35.205827Z  INFO surrealdb::net: Started web server on 0.0.0.0:8080
```

For details on the different commands available, visit the [CLI tool documentation](/docs/surrealdb/cli).




================================================
FILE: src/content/doc-surrealdb/installation/running/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Running
title: Running SurrealDB
description: In this section, you will find detailed instructions on how to run SurrealDB on your development environment.
---

# Running SurrealDB

In this section, you will find detailed instructions on how to run SurrealDB on your development environment.

The purpose of this section is to guide you through the process of running SurrealDB, ensuring that you have all the necessary dependencies and configurations in place to start using SurrealDB effectively.

Whether you are a beginner getting started with SurrealDB or an experienced user looking to set up SurrealDB in a new environment, this section will provide you with step-by-step instructions and best practices to ensure a smooth installation process.

You can run SurrealDB in the following ways:

- [Run with Docker](/docs/surrealdb/installation/running/docker)
- [Run a single-node, on-disk server](/docs/surrealdb/installation/running/file)
- [Run a single-node, in-memory server](/docs/surrealdb/installation/running/memory)
- [Run a multi-node, scalable cluster](/docs/surrealdb/installation/running/tikv)


================================================
FILE: src/content/doc-surrealdb/installation/running/memory.mdx
================================================
---
sidebar_position: 3
sidebar_label: Run an in memory server
title: Running an in-memory SurrealDB server
description: For the purposes of getting started with SurrealDB quickly, we will start an in-memory database which does not persist data on shutdown.
---

# Run a single-node, in-memory server

For the purposes of getting started with SurrealDB quickly, we will start an in-memory database which does not persist data on shutdown. This database is great for development and testing.

```bash
surreal start memory
```

SurrealDB will assume `memory` in case this argument is not passed in, so the following command is identical to the above.

```bash
surreal start
```

The default logging level for the database server is `info`, resulting in any informational logs to be output to the standard output. To control the logging verbosity, specify the *`--log`* argument. The following command starts the database with `debug` level logging, resulting in more logs being output to the terminal. If extra verbosity is not needed, specify a lower level or simply remove the flag, which will default to the `info` level.

```bash
surreal start --log debug memory
```

In versions of SurrealDB before `2.0`, anyone would be able to connect to this server to begin running queries. However, SurrealDB since version `2.0` runs with authentication by default. In order to disable it, the `--unauthenticated` flag can be passed in.

```bash
surreal start --unauthenticated memory
```

However, for anything but simple testing, it is better to configure your initial root-level user by setting the *`--user`* and *`--pass`* command-line arguments. The following command starts the database with a top-level user named `root` with a password also set to `root`.

```bash
surreal start --user root --pass secret memory
```

The previous command will bootstrap the server with the provided initial credentials, you can now remove those args and rely on [DEFINE USER](/docs/surrealql/statements/define/user) to change the password or create more users.

```bash
surreal start --user username --pass 123456 memory
```
In order to change the default port that SurrealDB uses for web connections and from database clients you can use the *`--bind`* argument. The following command starts the database on port `8080`.

```bash
surreal start --user root --pass secret --bind 0.0.0.0:8080 memory
```

After running the above command, you should see the SurrealDB server startup successfully.

```bash
surreal start --user root --pass secret --bind 0.0.0.0:8080 memory
2023-08-30T15:06:34.788821Z  INFO surrealdb::kvs::ds: Starting kvs store in memory
2023-08-30T15:06:34.788859Z  INFO surrealdb::kvs::ds: Started kvs store in memory
2023-08-30T15:06:34.789222Z  INFO surrealdb::kvs::ds: Initial credentials were provided and no existing root-level users were found: create the initial user 'root'.
2023-08-30T15:06:35.205123Z  INFO surrealdb::node: Started node agent
2023-08-30T15:06:35.205827Z  INFO surrealdb::net: Started web server on 0.0.0.0:8080
```

For details on the different commands available, visit the [CLI tool documentation](/docs/surrealdb/cli).



================================================
FILE: src/content/doc-surrealdb/installation/running/tikv.mdx
================================================
---
sidebar_position: 4
sidebar_label: Run a multi node server
title: Running a multi-node SurrealDB cluster
description: For highly-available and highly-scalable setups, SurrealDB can be run on top of a TiKV cluster, with the ability to horizontally scale to 100+ terabytes of data.
---

# Run a multi-node, scalable cluster

For highly-available and highly-scalable setups, SurrealDB can be run on top of a [TiKV](https://tikv.org/) cluster, with the ability to horizontally scale to 100+ terabytes of data. In this example, we will start a local TiKV cluster with a single node, for development and testing purposes only. To install TiKV on your development machine, run the following command. This will install the [`tiup`](https://github.com/pingcap/tiup) command-line tool, which enables deploying and managing TiKV clusters of any size.

```bash
curl -sSf https://tiup-mirrors.pingcap.com/install.sh | sh
```

Once installed we shall start up a simple single-node development cluster.

```bash
tiup playground --tag surrealdb --mode tikv-slim --pd 1 --kv 1
```
Once TiKV is up and running, we can start a SurrealDB server instance, specifying the TiKV cluster endpoint as the backing data store.

```bash
surreal start tikv://127.0.0.1:2379
```
The default logging level for the database server is `info`, resulting in any informational logs to be output to the standard output. To control the logging verbosity, specify the *`--log`* argument. The following command starts the database with `debug` level logging, resulting in more logs being output to the terminal. If extra verbosity is not needed, specify a lower level or simply remove the flag, which will default to the `info` level.

```bash
surreal start --log debug tikv://127.0.0.1:2379
```
In order to keep SurrealDB secure, configure your initial root-level user by setting the *`--user`* and *`--pass`* command-line arguments. The following command starts the database with a top-level user named root with a password also set to `root`. The root user will be persisted in storage, which means you don't have to include the command line arguments next time you start SurrealDB.

```bash
surreal start --user root --pass secret tikv://127.0.0.1:2379
```
In order to change the default port that SurrealDB uses for web connections and from database clients you can use the *`--bind`* argument. The following command starts the database on port `8080`.

```bash
surreal start --user root --pass secret --bind 0.0.0.0:8080 tikv://127.0.0.1:2379
```
After running the above command, you should see the SurrealDB server startup successfully.

```bash
surreal start --user root --pass secret --bind 0.0.0.0:8080 tikv://127.0.0.1:2379
2025-02-14T12:16:28.660617Z  INFO surreal::env: Running 2.2.0 for macos on aarch64
2025-02-14T12:16:28.660678Z  INFO surrealdb::core::kvs::ds: Connecting to kvs store at tikv://127.0.0.1:2379
2025-02-14T12:16:28.660825Z  INFO tikv_client::common::security: connect to rpc server at endpoint: "http://127.0.0.1:2379"
2025-02-14T12:16:28.661224Z  INFO tikv_client::common::security: connect to rpc server at endpoint: "http://127.0.0.1:2379"
2025-02-14T12:16:28.662509Z  INFO tikv_client::pd::cluster: All PD endpoints are consistent: ["127.0.0.1:2379"]
2025-02-14T12:16:28.662547Z  INFO tikv_client::common::security: connect to rpc server at endpoint: "http://127.0.0.1:2379"
2025-02-14T12:16:28.662756Z  INFO tikv_client::common::security: connect to rpc server at endpoint: "http://127.0.0.1:2379"
2025-02-14T12:16:28.663523Z  INFO tikv_client::common::security: connect to rpc server at endpoint: "http://127.0.0.1:2379"
2025-02-14T12:16:28.663710Z  INFO tikv_client::common::security: connect to rpc server at endpoint: "http://127.0.0.1:2379"
2025-02-14T12:16:28.664321Z  INFO surrealdb::core::kvs::ds: Connected to kvs store at tikv://127.0.0.1:2379
2025-02-14T12:16:28.665553Z  INFO tikv_client::pd::client: connect to tikv endpoint: "127.0.0.1:20160"
2025-02-14T12:16:28.665568Z  INFO tikv_client::common::security: connect to rpc server at endpoint: "http://127.0.0.1:20160"
2025-02-14T12:16:28.667826Z  WARN surrealdb::core::kvs::ds: Credentials were provided, but existing root users were found. The root user 'root' will not be created
2025-02-14T12:16:28.667832Z  WARN surrealdb::core::kvs::ds: Consider removing the --user and --pass arguments from the server start command
2025-02-14T12:16:28.680059Z  INFO surrealdb::net: Listening for a system shutdown signal.
2025-02-14T12:16:28.680066Z  INFO surrealdb::net: Started web server on 0.0.0.0:8080
```

For details on the different commands available, visit the [CLI tool documentation](/docs/surrealdb/cli).



================================================
FILE: src/content/doc-surrealdb/installation/upgrading/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Upgrading
title: Upgrading | Installation
description: This guide will help you upgrade your current SurrealDB installation to the latest `2.0.0-beta` release.
---

# Upgrading

When moving to a new version of SurrealDB, it is important to follow the upgrade instructions to ensure that your data is migrated correctly. This Page contains information on how to upgrade your SurrealDB installation. 

## Upgrading to `2.x`

If you are upgrading to the `2.x` release of SurrealDB, you will need to follow the steps outlined in the [upgrading to `2.x`](/docs/surrealdb/installation/upgrading/migrating-data-to-2x) guide.



================================================
FILE: src/content/doc-surrealdb/installation/upgrading/migrating-data-to-2.x.mdx
================================================
---
sidebar_position: 1
sidebar_label: Upgrading from 1.x to 2.x
title: Upgrading from 1.x to 2.x | Upgrading | Installation
description: This guide will help you upgrade your current SurrealDB installation to the latest `2.x` release.
---

# Upgrading from `1.x` to `2.x`

The `2.0.0` release of SurrealDB includes [many new features, improvements, and bug fixes](/releases#v2-0-0). However, due to this there are some breaking changes that you should be aware of when upgrading.

This guide will help you upgrade your current SurrealDB installation to the latest `2.x` release.

## Breaking changes

### Datastore
- The underlying approach for storing record ids and ranges has changed
  - [Record IDs now support storing UUIDs instead of strings](https://github.com/surrealdb/surrealdb/pull/4491)
  - [Ranges are now their own value as suppose to being available as just record id ranges](https://github.com/surrealdb/surrealdb/pull/4506)

### SurrealQL
- The `UPDATE` statement no longer creates records if these are missing. Instead, use the new [UPSERT](/docs/surrealql/statements/upsert) statement for this behaviour.
- The `file://` connection protocol has been deprecated in favour of the more explicit `rocksdb://` protocol.
- The `DEFINE SCOPE` statement has been dropped in favor for the new [`DEFINE ACCESS TYPE RECORD`](/docs/surrealql/statements/define/access/record) statement
  - `DEFINE TOKEN` definitions defined under scopes are now integrated into `DEFINE ACCESS TYPE RECORD`.
- Some functions have been renamed for clarity
  - `meta::tb()` -> [`record::tb()`](/docs/surrealql/functions/database/record)
  - `meta::id()` -> [`record::id()`](/docs/surrealql/functions/database/record)
  - `string::endsWith()` -> [`string::ends_with()`](/docs/surrealql/functions/database/string)
  - `string::startsWith()` -> [`string::starts_with()`](/docs/surrealql/functions/database/string)

### Authentication & Headers
- Authentication is now enabled by default as you previously would with `--auth`. The [`--unauthenticated`](/docs/surrealdb/cli/start#unauthenticated-mode) flag is now required in order to provide the previous default behavior.
- Specifying the level on which credentials will be authenticated is now required when connecting to SurrealDB. By default, this level will be root. This can be provided with the `--auth-level` flag in the CLI or the `surreal-auth-ns` and `surreal-auth-db` headers in the HTTP REST API.
- SurrealDB now listens only for connections from the local machine unless another interface (e.g. 0.0.0.0) is provided via the `--bind` command line argument.
- SurrealDB now does not print secrets in response to `INFO` statements. The values of the secrets will appear as `[REDACTED]` to prevent accidental leakage. The export functionality will still print the values of the secrets. An `UNREDACTED` clause will be added soon to provide the previous behavior.
- Headers used to communicated via HTTP with SurrealDB now require the `surreal-` prefix. For example, the legacy `ns` and `db` headers are now `surreal-ns` and `surreal-db`.

## Upgrading your data

A new [`surreal fix`](/docs/surrealdb/cli/fix) command has been implemented to automatically change the format of your stored data. The command is followed by a path to the data. For example:

```bash
# For SurrealKV
surreal fix surrealkv://mydata

# For RocksDB
surreal fix rocksdb:somedatabase
```

### Limitations of the surreal fix command

Although the `surreal fix` command is a quick way to migrate your data, it is not without its drawbacks:

-  If you have used the now deprecated [`DEFINE TOKEN`](/docs/surrealql/statements/define/token) command to define a token on a Scope with the also deprecated [`DEFINE SCOPE`](/docs/surrealql/statements/define/scope) command, you will have to update your access management rules to use the new [`DEFINE ACCESS`](/docs/surrealql/statements/define/access) which supports creating permissions using [TYPE JWT](/docs/surrealql/statements/define/access/jwt) and [TYPE RECORD](/docs/surrealql/statements/define/access/record) rules.

- If you were querying SurrealDB via the HTTP API, the `surreal fix` command will not update the header format for you. You will need to manually update the header format  from `ns` and `db` to `surreal-ns` and `surreal-db` respectively before using the `surreal fix` command. Learn more about this in the [HTTP documentation](/docs/surrealdb/integration/http).


### Upgrading from 2.0.0-alpha

The `surreal fix` command above has been created specifically for 1.x instances. However, data currently on a `2.0.0-alpha` instance can still be manually exported and then reimported into a project running on `2.0.0` via the following steps.

1. Export your current data as a `.surql` (SurrealQL) file. You can do this using the [`surreal export`](/docs/surrealdb/cli/export) command in the terminal:

```bash
# Example export command to export data to a file called `export.surql` in the downloads directory.
surreal export --conn http://localhost:8000 --user root --pass secret --ns test --db test downloads/export.surql
```

2. This will create a file called `export.surql` in the current directory.

3. You can now import this file back into your project running on `2.0.0`.


```bash
surreal import --conn http://localhost:8000 --user root --pass secret --ns test --db test downloads/export.surql
```

## Troubleshooting

### Error when connecting to a `2.x` instance.

If you are trying to connect to a `2.x` instance, and get an error similar to the following, you are likely using an older version of SurrealDB.

```bash
error: Storage version is out-of-date.
```

## Read the full changelog

There have been major improvements to SurrealDB in `2.0.0` release both in alpha and beta. Check out the changes on the [release page](/releases).



================================================
FILE: src/content/doc-surrealdb/integration/cbor.mdx
================================================
---
sidebar_position: 5
sidebar_label: CBOR Protocol
title: CBOR Protocol| Integration 
description: SurrealDB supports a number of methods for connecting to the database and performing data queries.
---

# CBOR Protocol

SurrealDB extends the [CBOR](https://www.rfc-editor.org/rfc/rfc8949.html) protocol with a number of custom tags to support the full range of data types available in SurrealDB. This document provides an overview of the custom tags and their respective values.

## References:
- CBOR Protocol - [RFC 8949](https://www.rfc-editor.org/rfc/rfc8949.html)
- CBOR Official Tags - [Iana](https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml)

## Custom tags

<table>
    <thead>
        <tr>
            <th scope="col">Tag</th>
            <th scope="col">Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 0](#tag-0)
            </td>
            <td scope="row" data-label="Value">
                [Datetime](/docs/surrealql/datamodel/datetimes) ([RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) string)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 6](#tag-6)
            </td>
            <td scope="row" data-label="Value">
                [`NONE`](/docs/surrealql/datamodel/none-and-null#none-values)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 7](#tag-7)
            </td>
            <td scope="row" data-label="Value">
                Table name
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 8](#tag-8)
            </td>
            <td scope="row" data-label="Value">
                [Record ID](/docs/surrealql/datamodel/ids)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 9](#tag-9)
            </td>
            <td scope="row" data-label="Value">
                [UUID](/docs/surrealql/datamodel/uuid) (string)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 10](#tag-10)
            </td>
            <td scope="row" data-label="Value">
                [Decimal](/docs/surrealql/datamodel/numbers#decimal-numbers) (string)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 12](#tag-12)
            </td>
            <td scope="row" data-label="Value">
                [Datetime](/docs/surrealql/datamodel/datetimes) (compact)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 13](#tag-13)
            </td>
            <td scope="row" data-label="Value">
                [Duration](/docs/surrealql/datamodel/datetimes#durations-and-datetimes) (string)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 14](#tag-14)
            </td>
            <td scope="row" data-label="Value">
                [Duration](/docs/surrealql/datamodel/datetimes#durations-and-datetimes) (compact)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 15](#tag-15)
            </td>
            <td scope="row" data-label="Value">
                [Future](/docs/surrealql/datamodel/futures) (compact)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 37](#tag-37)
            </td>
            <td scope="row" data-label="Value">
                [UUID](/docs/surrealql/datamodel/uuid) (binary)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 49](#tag-49)
            </td>
            <td scope="row" data-label="Value">
                [Range](/docs/surrealql/datamodel/ranges)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 50](#tag-50)
            </td>
            <td scope="row" data-label="Value">
                [Included Bound](/docs/surrealql/datamodel/ranges)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 51](#tag-51)
            </td>
            <td scope="row" data-label="Value">
                [Excluded Bound](/docs/surrealql/datamodel/ranges)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 88](#tag-88)
            </td>
            <td scope="row" data-label="Value">
                [Geometry Point](/docs/surrealql/datamodel/geometries#point)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 89](#tag-89)
            </td>
            <td scope="row" data-label="Value">
                [Geometry Line](/docs/surrealql/datamodel/geometries#linestring)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 90](#tag-90)
            </td>
            <td scope="row" data-label="Value">
                [Geometry Polygon](/docs/surrealql/datamodel/geometries#polygon)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 91](#tag-91)
            </td>
            <td scope="row" data-label="Value">
                [Geometry MultiPoint](/docs/surrealql/datamodel/geometries#multipoint)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 92](#tag-92)
            </td>
            <td scope="row" data-label="Value">
                [Geometry MultiLine](/docs/surrealql/datamodel/geometries#multilinestring)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 93](#tag-93)
            </td>
            <td scope="row" data-label="Value">
                [Geometry MultiPolygon](/docs/surrealql/datamodel/geometries#multipolygon)
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Tag">
                [Tag 94](#tag-94)
            </td>
            <td scope="row" data-label="Value">
                [Geometry Collection](/docs/surrealql/datamodel/geometries)
            </td>
        </tr>
    </tbody>
</table>

### Tag 0

A [datetime](/docs/surrealql/datamodel/datetimes) represented in an [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) string.

Adopted from the [Iana Specification](https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml).

**Note:** [Tag 12](#tag-12) is preferred and always sent back by SurrealDB.

### Tag 6

Represents a [`NONE`](/docs/surrealql/datamodel/none-and-null#none-values) value. The value passed to the tagged value is `null`, as it cannot be empty.

### Tag 7

A table name, represented as a string.

### Tag 8

A [Record ID](/docs/surrealql/datamodel/ids), represented as an two-value array, containing a table part (string) and an id part (string, number, object or array).

Instead of an two-value array, SurrealDB also accepts a string with a string-formatted Record ID. A string Record ID will never be sent back from SurrealDB, however.

### Tag 9

A [UUID](/docs/surrealql/datamodel/uuid) represented in a string format.

**Note:** [Tag 37](#tag-37) is preferred and always sent back by SurrealDB.

### Tag 10

A [Decimal](/docs/surrealql/datamodel/numbers#decimal-numbers) represented in a string format.

### Tag 12

A [Datetime](/docs/surrealql/datamodel/datetimes) represented in a two-value array, containing seconds (number) and optionally nanoseconds (number).

### Tag 13

A [Duration](/docs/surrealql/datamodel/datetimes#durations-and-datetimes) represented in a string format.

**Note:** [Tag 14](#tag-14) is preferred and always sent back by SurrealDB.

### Tag 14

A [Duration](/docs/surrealql/datamodel/datetimes#durations-and-datetimes) repesented in a two-value array, containing optionally seconds (number) and optionally nanoseconds (number). An empty array will be considered a duration of 0.

### Tag 15

A [Future](/docs/surrealql/datamodel/futures) represented as a string containing the uncomputed SurrealQL query or expression. The value transported needs to be returned in an `Object` in a `{}`,  this will also be the format you receive it in from SurrealDB this will allow for it to be computed when accedded or used within a query.

### Tag 37

A [UUID](/docs/surrealql/datamodel/uuid) represented in a binary format. Please reference (https://docs.rs/uuid/latest/uuid/struct.Uuid.html#method.as_bytes).

Adopted from the [Iana Specification](https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml).

### Tag 49

A [Range](/docs/surrealql/datamodel/ranges) represented as a two-value array containing optional bounds. Each bound can be either null (for unbounded), or a tagged value using either Tag 50 (included bound) or Tag 51 (excluded bound). 

The bounds follow SurrealQL's range syntax where `..` represents a range, `>..` represents an excluded lower bound, and `..=` represents an included upper bound.

### Tag 50

An included bound value used within [Range](/docs/surrealql/datamodel/ranges) bounds. The tagged value represents an inclusive boundary (equivalent to `..=` for upper bounds in SurrealQL range syntax).

### Tag 51

An excluded bound value used within [Range](/docs/surrealql/datamodel/ranges) bounds. The tagged value represents an exclusive boundary (equivalent to `>..` for lower bounds in SurrealQL range syntax).

### Tag 88

A [Geometry Point](/docs/surrealql/datamodel/geometries#point) represented by a two-value array containing a longitude (float) and latitude (float). 

### Tag 89

A [Geometry Line](/docs/surrealql/datamodel/geometries#linestring) represented by an array with two or more points ([Tag 88](#tag-88)).

### Tag 90

A [Geometry Polygon](/docs/surrealql/datamodel/geometries#polygon) represented by an array with one or more closed lines ([Tag 89](#tag-89)).

If the lines are not closed, meaning that the first and last point are equal, then SurrealDB will automatically suffix the line with it's first point.

### Tag 91

A [Geometry MultiPoint](/docs/surrealql/datamodel/geometries#multipoint) represented by an array with one or more points ([Tag 88](#tag-88)).

### Tag 92

A [Geometry MultiLine](/docs/surrealql/datamodel/geometries#multilinestring) represented by an array with one or more lines ([Tag 89](#tag-89)).

### Tag 93

A [Geometry MultiPolygon](/docs/surrealql/datamodel/geometries#multipolygon) represented by an array with one or more polygons ([Tag 90](#tag-90)).

### Tag 94

A [Geometry Collection](/docs/surrealql/datamodel/geometries) represented by an array with one or more geometry values ([Tag 88](#tag-88), [Tag 89](#tag-89), [Tag 90](#tag-90), [Tag 91](#tag-91), [Tag 92](#tag-92), [Tag 93](#tag-93) or [Tag 94](#tag-94)).



================================================
FILE: src/content/doc-surrealdb/integration/http.mdx
================================================
---
sidebar_position: 3
sidebar_label: HTTP & Rest
title: HTTP Protocol | Integration
description: The HTTP endpoints enable selection and modification of data, along with custom SurrealQL queries, using traditional RESTful HTTP endpoints.
---

import Since from '@components/shared/Since.astro';
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";
import Label from "@components/shared/Label.astro";

# HTTP & Rest

The HTTP endpoints exposed by SurrealDB instances provide a simple way to interact with the database over a traditional RESTful interface. This includes selecting and modifying one or more records, executing custom SurrealQL queries, and managing SurrealML models. 

The endpoints are designed to be simple and easy to use in stateless environments, making them ideal for lightweight applications where a persistent database connection is not required.

## Querying via Postman

The most convenient way to access these endpoints is via SurrealDB's Postman Collection. To do so, follow these steps:

1. Open Postman
2. Clone the [SurrealDB Postman Collection](https://postman.com/surrealdb/workspace/surrealdb/collection/19100500-3da237f3-588b-4252-8882-6d487c11116a)
2. Select the appropriate HTTP method (`GET /health`, `DEL /key/:table`, etc.).
3. Enter the endpoint URL.
4. If the endpoint requires any parameters or a body, make sure to include those in your request.

> [!IMPORTANT]
> Ensure that your URL is set correctly, if running locally, the URL should be `http://localhost:8000`.By default, the URL is set to local. Start your server using the [`surreal start`](/docs/surrealdb/cli/start) command in the CLI or through Surrealist's [local database serving](/docs/surrealist/concepts/local-database-serving) functionality, before querying the endpoints.


## Supported methods

You can use the HTTP endpoints to perform the following actions:

<br />

<table>
    <thead>
        <tr>
            <th scope="col">Function</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Function"><a href="#status"><code>GET /status</code></a></td>
            <td scope="row" data-label="Description">Checks whether the database web server is running</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#health"><code>GET /health</code></a></td>
            <td scope="row" data-label="Description">Checks the status of the database server and storage engine</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#version"><code>GET /version</code></a></td>
            <td scope="row" data-label="Description">Returns the version of the SurrealDB database server</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#import"><code>POST /import</code></a></td>
            <td scope="row" data-label="Description">Imports data into a specific Namespace and Database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#export"><code>POST /export</code></a></td>
            <td scope="row" data-label="Description">Exports all data for a specific Namespace and Database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#signup"><code>POST /signup</code></a></td>
            <td scope="row" data-label="Description">Signs-up as a record user using a specific record access method</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#signin"><code>POST /signin</code></a></td>
            <td scope="row" data-label="Description">Signs-in as a root, namespace, database, or record user</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#get-table"><code>GET /key/:table</code></a></td>
            <td scope="row" data-label="Description">Selects all records in a table from the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#post-table"><code>POST /key/:table</code></a></td>
            <td scope="row" data-label="Description">Creates a record in a table in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#put-table"><code>PUT /key/:table</code></a></td>
            <td scope="row" data-label="Description">Updates all records in a table in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#patch-table"><code>PATCH /key/:table</code></a></td>
            <td scope="row" data-label="Description">Modifies all records in a table in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#delete-table"><code>DELETE /key/:table</code></a></td>
            <td scope="row" data-label="Description">Deletes all records in a table from the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#get-record"><code>GET /key/:table/:id</code></a></td>
            <td scope="row" data-label="Description">Selects the specific record from the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#post-record"><code>POST /key/:table/:id</code></a></td>
            <td scope="row" data-label="Description">Creates the specific record in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#put-record"><code>PUT /key/:table/:id</code></a></td>
            <td scope="row" data-label="Description">Updates the specified record in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#patch-record"><code>PATCH /key/:table/:id</code></a></td>
            <td scope="row" data-label="Description">Modifies the specified record in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#delete-record"><code>DELETE /key/:table/:id</code></a></td>
            <td scope="row" data-label="Description">Deletes the specified record from the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#sql"><code>POST /sql</code></a></td>
            <td scope="row" data-label="Description">Allows custom SurrealQL queries</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#graphql"><code>POST /graphql</code></a></td>
            <td scope="row" data-label="Description">Allows custom GraphQL queries</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#ml-import"><code>POST /ml/import</code></a></td>
            <td scope="row" data-label="Description">Import a SurrealML model into a specific Namespace and Database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#ml-export"><code>GET /ml/export/:name/:version</code></a></td>
            <td scope="row" data-label="Description">Export a SurrealML model from a specific Namespace and Database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#custom"><code>/api/:namespace/:database/:endpoint</code></a></td>
            <td scope="row" data-label="Description">Create a custom API endpoint for any number of HTTP methods (GET, POST, etc.)</td>
        </tr>
    </tbody>
</table>

<br />

## `GET /status` {#status}

This HTTP RESTful endpoint checks whether the database web server is running, returning a 200 status code.

### Example usage

```bash title="Request"
curl -I http://localhost:8000/status
```

```bash title="Sample output"
HTTP/1.1 200 OK
content-length: 0
vary: origin, access-control-request-method, access-control-request-headers
access-control-allow-origin: *
surreal-version: surrealdb-2.0.0+20240910.8f30ee08
server: SurrealDB
x-request-id: 3dedcc96-4d8a-451e-b60d-4eaac14fa3f8
date: Wed, 11 Sep 2024 00:52:49 GMT
```

<br />

## `GET /health` {#health}

This HTTP RESTful endpoint checks whether the database server and storage engine are running.

The endpoint returns a `200` status code on success and a `500` status code on failure.

```bash title="Request"
curl -I http://localhost:8000/health
```

```bash title="Sample output"
HTTP/1.1 200 OK
content-length: 0
vary: origin, access-control-request-method, access-control-request-headers
access-control-allow-origin: *
surreal-version: surrealdb-2.0.0+20240910.8f30ee08
server: SurrealDB
x-request-id: 24a1e675-af50-4676-b8ff-6eee18e9a077
date: Wed, 11 Sep 2024 00:53:22 GMT
```

<br />

## `GET /version` {#version}

This HTTP RESTful endpoint returns the version of the SurrealDB database server.

### Example usage

```bash title="Request"
curl http://localhost:8000/version
```

```bash title="Sample output"
surrealdb-2.0.0+20240910.8f30ee08
```


<br />

## `POST /import` {#import}

This HTTP RESTful endpoint imports a set of SurrealQL queries into a specific Namespace and Database.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the root, namespace, or database authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Header">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Header">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Header">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the root, namespace, or database authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Header">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Header">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Header">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>

</TabItem>
</Tabs>

### Example usage

> [!NOTE]
> The `-u` in the example below is a shorthand used by curl to send an Authorization header.


<Tabs groupId="http-sql">
<TabItem value="V1" label="V1.x">
```bash title="Request"
curl -X POST -u "root:root" \
  -H "ns: mynamespace" \
  -H "db: mydatabase" \
  -H "Accept: application/json" \
  -d path/to/file.surql \
  http://localhost:8000/import
```
</TabItem>
<TabItem value="V2" label="V2.x" default>
```bash title="Request"
curl -X POST -u "root:root" \
  -H "Surreal-NS: mynamespace" \
  -H "Surreal-DB: mydatabase" \
  -H "Accept: application/json" \
  -d path/to/file.surql \
  http://localhost:8000/import
```
</TabItem>

</Tabs>


<br />

## `POST /export` {#export}

This HTTP RESTful endpoint exports all data for a specific Namespace and Database.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Header">
                Sets the root, namespace, or database authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Header">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Header">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Header">
                Sets the root, namespace, or database authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Header">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Header">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>

#### Export options 

<table>
    <thead>
        <tr>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td>
                `only`
                <Label label="optional" />
            </td>
            <td>
                Whether only specific resources should be exported. When provided, only the resources specified will be exported.
            </td>
        </tr>
        <tr>
            <td>
                `users`
                <Label label="optional" />
            </td>
            <td>
                Whether system users should be exported [possible values: true, false].
            </td>
        </tr>
        <tr>
            <td>
                `accesses`
                <Label label="optional" />
            </td>
            <td>
                Whether access methods (Record or JWT) should be exported [possible values: true, false]
            </td>
        </tr>
        <tr>
            <td>
                `params`
                <Label label="optional" />
            </td>
            <td>
                Whether databases parameters should be exported [possible values: true, false]
            </td>
        </tr>
        <tr>
            <td>
                `functions`
                <Label label="optional" />
            </td>
            <td>
                Whether functions should be exported [possible values: true, false]
            </td>
        </tr>
        <tr>
            <td>
                `analyzers`
                <Label label="optional" />
            </td>
            <td>
                Whether analyzers should be exported [possible values: true, false]
            </td>
        </tr>
        <tr>
            <td>
                `tables [tables]`
                <Label label="optional" />
            </td>
            <td>
                Whether tables should be exported, optionally providing a list of tables
            </td>
        </tr>
        <tr>
            <td>
                `versions`
                <Label label="optional" />
            </td>
            <td>
                Whether SurrealKV versioned records should be exported [possible values: true, false]
            </td>
        </tr>
        <tr>
            <td>
                `records`
                <Label label="optional" />
            </td>
            <td>
                Whether records should be exported [possible values: true, false]
            </td>
        </tr>
    </tbody>
</table>

</TabItem>

</Tabs>



### Example usage

> [!NOTE]
> The `-u` in the example below is a shorthand used by curl to send an Authorization header, while `-o` allows the output to be written to a file.

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x">
```bash title="Request"
curl -X GET \
  -u "root:root" \
  -H "ns: mynamespace" \
  -H "db: mydatabase" \
  -H "Accept: application/json" \
  -o path/to/file.surql \
  http://localhost:8000/export
```
</TabItem>

<TabItem value="V2" label="V2.x" default>
```bash title="Request"
curl -X GET \
  -u "root:root" \
  -H "Surreal-NS: mynamespace" \
  -H "Surreal-DB: mydatabase" \
  -H "Accept: application/json" \
  -o path/to/file.surql \
  http://localhost:8000/export
```

```bash title="Exporting specific parameters"
curl -X POST \
  -u "root:root" \
  -H "Surreal-NS: mynamespace" \
  -H "Surreal-DB: mydatabase" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -o path/to/file.surql \
  -d '{
        "users": true,
        "accesses": false,
        "params": false,
        "functions": false,
        "analyzers": false,
        "versions": false,
        "tables": ["usersTable", "ordersTable"],
        "records": true
      }' \
  http://localhost:8000/export
```
</TabItem>

</Tabs>

<br />

## `POST /signin` {#signin}

```json title="Method and URL"
POST /signin
```

This HTTP RESTful endpoint is used to access an existing account inside the SurrealDB database server.

### Headers

<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
     <tr>
            <td colspan="2" scope="row" data-label="Header">
                    <code>Accept</code>
                    <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
    </tbody>
</table>

### Data

<table>
    <thead>
        <tr>
            <th colspan="2">Data</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
    <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required">REQUIRED FOR DB & RECORD</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign in to this is required FOR DB & RECORD users
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required">REQUIRED FOR RECORD</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign in to required for RECORD users
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ac</code>
                <Label label="required">REQUIRED FOR RECORD USER</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The record access method to use for signing in. required for RECORD users
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>user</code>
                <Label label="required">REQUIRED FOR ROOT, NS & DB</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The username of the database user required for ROOT, NS & DB users
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>pass</code>
                <Label label="required">REQUIRED FOR ROOT, NS & DB</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The password of the database user required for ROOT, NS & DB users
            </td>
        </tr>
    </tbody>
</table>


> [!IMPORTANT]
> The `ac` parameter is only required if you are signing in using an [access method](/docs/surrealql/statements/define/access) as a record user. For system users on the database, namespace, and root level, this parameter can be omitted.

### Example with a Record user

```bash title="Request"
curl -X POST -H "Accept: application/json" -d '{"ns":"test","db":"test","ac":"users","user":"john.doe","pass":"123456"}' http://localhost:8000/signin
```

```json title="Response"
{
	"code": 200,
	"details": "Authentication succeeded",
	"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```

### Example with Namespace user

```bash title="Request"
curl -X POST -H "Accept: application/json" -d '{"ns":"test","user":"john.doe","pass":"123456"}' http://localhost:8000/signin
```

```json title="Response"
{
	"code": 200,
	"details": "Authentication succeeded",
	"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```

### Example with Root user

```bash title="Request"
curl -X POST -H "Accept: application/json" -d '{"user":"john.doe","pass":"123456"}' http://localhost:8000/signin
```

```json title="Response"
{
	"code": 200,
	"details": "Authentication succeeded",
	"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```

### Example usage via Postman

After you have defined the users permissions for the record user, you can use the `POST /signin` endpoint to sign in as a user.

Using the [user credentials](/docs/surrealdb/security/authentication#record-users) created add the following to the request body:
```json
{
    "ns": "test",
    "db": "test",
    "ac": "account",
    "email": "",
    "pass": "123456"
}
```



<br />

## `POST /signup` {#signup}

This HTTP RESTful endpoint is used to create an account inside the SurrealDB database server.

### Header

<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
    </tbody>
</table>

### Data

<table>
    <thead>
        <tr>
            <th colspan="2">Data</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required"></Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign up to. This data is `REQUIRED FOR DB & RECORD`
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required"></Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign up to. This data is `REQUIRED FOR RECORD`
            </td>
        </tr>
                <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>access</code>
                <Label label="required"></Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The record access method to use for signing up. This data is `REQUIRED FOR RECORD`
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>user</code>
                <Label label="required"></Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The username of the database user. This data is `REQUIRED FOR ROOT, NS & DB`
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>pass</code>
                <Label label="required"></Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The password of the database user. This data is `REQUIRED FOR ROOT, NS & DB`
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```bash title="Request"
curl -X POST -H "Accept: application/json" -d '{"ns":"test","db":"test","ac":"users","user":"john.doe","pass":"123456"}' http://localhost:8000/signup
```

```json title="Response"
{
	"code": 200,
	"details": "Authentication succeeded",
	"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```
### Example usage via Postman

Before you sign up a new [record user](/docs/surrealdb/security/authentication#record-users), you must first [define a record access method](/docs/surrealql/statements/define/access/record) for the user. To do so, follow these steps:

> [!NOTE]
> You can also define [system users](/docs/surrealdb/security/authentication#system-users) and [user](/docs/surrealql/statements/define/user) credentials using the [`POST /sql`](/docs/surrealdb/integration/http#sql) endpoint.

1. Navigate to the `POST /sql` endpoint in Postman.
2. Enter the following query in the body of the request:
```surql
-- Enable authentication directly against a SurrealDB record
DEFINE ACCESS account ON DATABASE TYPE RECORD
    SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
    SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
    DURATION FOR SESSION 24h
;
```
The above query defines a record access method called `account` that allows users to sign up and sign in. The access method also defines the session duration to be 24 hours.

3. Click `Send` to send the request to the SurrealDB database server.
4. Navigate to the `POST /signup` endpoint in Postman.
5. Enter the following query in the body of the request:
```json
{
    "ns": "test",
    "db": "test",
    "ac": "account",
    "email": "",
    "pass": "123456"
}
```
6. In the header of the request, set the following key-value pairs:
    - `Accept: application/json`
    - namespace: `test`
    - database: `test`
    - access: `account`
6. Click `Send` to send the request to the SurrealDB database server. You will get back a

```json
{
    "code": 200,
    "details": "Authentication succeeded",
    "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MDY2MTA4MDMsIm5iZiI6MTcwNjYxMDgwMywiZXhwIjoxNzA2Njk3MjAzLCJpc3MiOiJTdXJyZWFsREIiLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJBQyI6Imh1bWFuIiwiSUQiOiJ1c2VyOjZsOTl1OWI0bzVoa3h0NnY3c3NzIn0.3jR8PHgS8iLefZDuPHBFcdUFNfuB3OBNqQtqxLVVzxAIxVj1RAkD5rCEZHH2QaPV-D2zNwYO5Fh_a8jD1l_cqQ"
}
```


<br />

## `GET /key/:table` {#get-table}

This HTTP RESTful endpoint selects all records in a specific table in the database.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

</Tabs>


### Translated query
```surql
SELECT * FROM type::table($table);
```
<br />

## `POST /key/:table` {#post-table}

This HTTP RESTful endpoint creates a record in a specific table in the database.

> [!NOTE]
> This HTTP endpoint expects the HTTP body to be a JSON or SurrealQL `object`.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

</Tabs>

### Translated query
```surql
CREATE type::table($table) CONTENT $body;
```

<br />

## `PUT /key/:table` {#put-table}

This HTTP RESTful endpoint updates all records in a specific table in the database.

> [!NOTE]
> This HTTP endpoint expects the HTTP body to be a JSON or SurrealQL object.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

</Tabs>

### Translated query
```surql
UPDATE type::table($table) CONTENT $body;
```

<br />

## `PATCH /key/:table` {#patch-table}

This HTTP RESTful endpoint modifies all records in a specific table in the database.

> [!NOTE]
> This HTTP endpoint expects the HTTP body to be a JSON or SurrealQL object.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

</Tabs>

### Translated query
```surql
UPDATE type::table($table) MERGE $body;
```

<br />

## `DELETE /key/:table` {#delete-table}

This HTTP RESTful endpoint deletes all records from the specified table in the database.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

</Tabs>

### Translated query
```surql
DELETE FROM type::table($table);
```

<br />

## `GET /key/:table/:id` {#get-record}

This HTTP RESTful endpoint selects a specific record from the database.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>
</Tabs>

### Translated query

```surql
SELECT * FROM type::record($table, $id);
```

<br />

## `POST /key/:table/:id` {#post-record}

This HTTP RESTful endpoint creates a specific record in a table in the database.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

</Tabs>

### Translated query

```surql
CREATE type::record($table, $id) CONTENT $body;
```

<br />

## `PUT /key/:table/:id` {#put-record}

This HTTP RESTful endpoint updates a specific record in a table in the database.

> [!NOTE]
> This HTTP endpoint expects the HTTP body to be a JSON or SurrealQL object.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

</Tabs>

### Translated query

```surql
UPDATE type::record($table, $id) CONTENT $body;
```

<br />

## `PATCH /key/:table/:id` {#patch-record}

This HTTP RESTful endpoint modifies a specific record in a table in the database.

> [!NOTE]
> This HTTP endpoint expects the HTTP body to be a JSON or SurrealQL object.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

</Tabs>

### Translated query

```surql
UPDATE type::record($table, $id) MERGE $body;
```

<br />

## `DELETE /key/:table/:id` {#delete-record}

This HTTP RESTful endpoint deletes a single specific record from the database.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

</Tabs>

### Translated query

```surql
DELETE FROM type::record($table, $id);
```

<br />

## `POST /sql` {#sql}

The SQL endpoint enables use of SurrealQL queries.

> [!NOTE]
> This HTTP endpoint expects the HTTP body to be a set of SurrealQL statements.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

</Tabs>


### Parameters

Query parameters can be provided via URL query parameters. These parameters will securely replace any parameters that are present in the query. This practise is known as prepared statements or parameterised queries, and [should be used](/docs/surrealdb/reference-guide/security-best-practices#query-safety) whenever untrusted inputs are included in a query to prevent injection attacks.

### Example usage

> [!NOTE]
> The `-u` in the example below is a shorthand used by curl to send an Authorization header.

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x">
```bash title="Request"
curl -X POST -u "root:root" -H "ns: mynamespace" -H "db: mydatabase" -H "Accept: application/json" \
  -d 'SELECT * FROM person WHERE age > $age' http://localhost:8000/sql?age=18
```
</TabItem>

<TabItem value="V2" label="V2.x" default>
```bash title="Request"
curl -X POST -u "root:root" -H "Surreal-NS: mynamespace" -H "Surreal-DB: mydatabase" -H "Accept: application/json" \
  -d 'SELECT * FROM person WHERE age > $age' http://localhost:8000/sql?age=18
```
</TabItem>

<TabItem value="V2 - Token" label="V2.x with token" default>
```bash title="Request"
curl -X POST -H "Bearer: YourToken" -H "Surreal-NS: mynamespace" -H "Surreal-DB: mydatabase" -H "Accept: application/json" \
  -d 'SELECT * FROM person WHERE age > $age' http://localhost:8000/sql?age=18
```
</TabItem>

</Tabs>

```json title="Response"
[
	{
		"time": "14.357166ms",
		"status": "OK",
		"result": [
			{
				"age": "23",
				"id": "person:6r7wif0uufrp22h0jr0o"
				"name": "Simon",
			},
			{
				"age": "28",
				"id": "person:6r7wif0uufrp22h0jr0o"
				"name": "Marcus",
			},
		]
	}
]
```

<br />

## `POST /graphql` {#graphql}

<Since v="v2.0.0" />

The GraphQL endpoint enables use of GraphQL queries to interact with your data.

> [!NOTE]
> This HTTP endpoint expects the HTTP body to be a GraphQL query.

### Headers

<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries
            </td>
        </tr>
    </tbody>
</table>

### Example usage

> [!NOTE]
> The `-u` in the example below is a shorthand used by curl to send an Authorization header.

<Tabs groupId="http-sql">

<TabItem value="V2" label="V2.x" default>
```bash title="Request"
curl -X POST \
  -u "root:root" \
  -H "Surreal-NS: mynamespace" \
  -H "Surreal-DB: mydatabase" \
  -H "Accept: application/json" \
  -d '{
    "query": "{ 
      person(filter: {age: {age_gt: 18}}) {
        id
        name
        age
      }
    }"
  }' \
  http://localhost:8000/graphql
```
</TabItem>

</Tabs>

```json title="Response"
[
	{
		"time": "14.357166ms",
		"status": "OK",
		"result": [
			{
				"age": "23",
				"id": "person:6r7wif0uufrp22h0jr0o"
				"name": "Simon",
			},
			{
				"age": "28",
				"id": "person:6r7wif0uufrp22h0jr0o"
				"name": "Marcus",
			},
		]
	}
]
```

<br />

## `POST /ml/import` {#ml-import}

This HTTP RESTful endpoint imports a SurrealML machine learning model into a specific Namespace and Database. It expects the file to be a SurrealML file packaged in the `.surml` file format. As machine learning files can be large, the endpoint expects a chunked HTTP request.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

</Tabs>

### Example usage

> [!NOTE]
> The `-u` in the example below is a shorthand used by curl to send an Authorization header.

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x">
```bash title="Request"
curl -X POST \
  -u "root:root" \
  -H "ns: mynamespace" \
  -H "db: mydatabase" \
  -H "Accept: application/json" \
  -d path/to/file.surml \
  http://localhost:8000/ml/import
```
</TabItem>

<TabItem value="V2" label="V2.x" default>
```bash title="Request"
curl -X POST \
  -u "root:root" \
  -H "Surreal-NS: mynamespace" \
  -H "Surreal-DB: mydatabase" \
  -H "Accept: application/json" \
  -d path/to/file.surml \
  http://localhost:8000/ml/import
```
</TabItem>

</Tabs>

### Usage in Python

When using Python, the [surreaml](https://github.com/surrealdb/surrealml) package can be used to upload the model with the following code:

```python
from surrealml import SurMlFile

url = "http://0.0.0.0:8000/ml/import"
SurMlFile.upload("./linear_test.surml", url, 5)
```

<br />

## `GET /ml/export/:name/:version` {#ml-export}

This HTTP RESTful endpoint exports a SurrealML machine learning model from a specific Namespace and Database. The output file with be a SurrealML file packaged in the `.surml` file format. As machine learning files can be large, the endpoint outputs a chunked HTTP response.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the root, namespace, or database authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the root, namespace, or database authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

</Tabs>

### Example usage

> [!NOTE]
<em> Note: </em> The `-u` in the example below is a shorthand used by curl to send an Authorization header, while `-o` allows the output to be written to a file.


<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x">
```bash title="Request"
curl -X GET \
  -u "root:root" \
  -H "ns: mynamespace" \
  -H "db: mydatabase" \
  -H "Accept: application/json" \
  -o path/to/file.surml \
  http://localhost:8000/ml/export/prediction/1.0.0
```
</TabItem>

<TabItem value="V2" label="V2.x" default>
```bash title="Request"
curl -X GET \
  -u "root:root" \
  -H "Surreal-NS: mynamespace" \
  -H "Surreal-DB: mydatabase" \
  -H "Accept: application/json" \
  -o path/to/file.surml \
  http://localhost:8000/ml/export/prediction/1.0.0
```
</TabItem>

</Tabs>

## Custom endpoint at `/api/:ns/:db/:endpoint` {#custom}

<Since v="v2.2.0" />
> [!CAUTION]
> Currently, this is an experimental feature as such, it may be subject to breaking changes and may present unidentified security issues. Do not rely on this feature in production applications. To enable this, set the `SURREAL_CAPS_ALLOW_EXPERIMENTAL` [environment variable](/docs/surrealdb/cli/start) to `define_api`.


A custom endpoint can be set using a [`DEFINE API`](/docs/surrealql/statements/define/api) statement. The possible HTTP methods (GET, PUT, etc.) are set using the statement itself. The path begins with `/api`, continues with the namespace and database, and ends with a custom endpoint that can include both static and dynamic path segments.

### Headers

<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
                <Label label="optional" >OPTIONAL</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the root, namespace, or database authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Surreal-DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```bash title="Request"
curl http://localhost:8000/api/my_namespace/my_database/test_endpoint \
  -H "Surreal-NS: ns" -H "Surreal-DB: db" \
  -H "Accept: application/json"
```



================================================
FILE: src/content/doc-surrealdb/integration/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Integration
title: Integration
description: In this section, you will explore the various integration options and techniques available to seamlessly incorporate SurrealDB into your existing development ecosystem.
---

# Integration

In this section, you will explore the various integration options and techniques available to seamlessly incorporate SurrealDB into your existing development ecosystem.

## Introduction

SurrealDB is designed to be flexible and compatible with a wide range of technologies and frameworks. This section will guide you through the process of integrating SurrealDB into your projects, whether you are working directly from code, or integrating with one of our supported network protocols.

## API Reference

To facilitate the integration process, SurrealDB provides a comprehensive API reference that documents the available methods, classes, and interfaces. This reference will serve as a valuable resource when working with SurrealDB in your code, providing you with detailed information on how to interact with the database and utilize its features.

## Community Support

If you encounter any challenges or have questions during the integration process, we encourage you to reach out to the SurrealDB community on [Discord](https://discord.gg/surrealdb). The SurrealDB community is a vibrant and supportive community of developers who are eager to help and share their experiences. You can find resources such as forums, chat channels, and documentation feedback options to connect with the community and get the assistance you need.



================================================
FILE: src/content/doc-surrealdb/integration/rpc.mdx
================================================
---
sidebar_position: 4
sidebar_label: RPC Protocol
title: RPC Protocol | Integration
description: The RPC protocol allows for easy bidirectional communication with SurrealDB.
---

import Since from '@components/shared/Since.astro'
import Label from "@components/shared/Label.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# RPC Protocol

The RPC protocol allows for network-protocol agnostic communication with SurrealDB. It is used internally by our client SDKs, and supports both HTTP and WebSocket based communication. Combined with the power of our [CBOR protocol](./cbor) specification, the RPC protocol provides a fully type-safe and efficient way to interact with SurrealDB over the network.

> [!NOTE]
>Version 2 of the RPC protocol significantly enhances data manipulation and retrieval methods by adding an optional object parameter. This enables direct control over statement clauses like [`WHERE`](/docs/surrealql/clauses/where), [`LIMIT`](/docs/surrealql/clauses/limit), [`TIMEOUT`](/docs/surrealql/statements/select#the-timeout-clause), and more, previously only available through direct SQL execution.

> [!IMPORTANT]
> **Method Consolidation:**  The `merge`, `patch`, and `insert_relation` methods from version 1 have been consolidated into the `update` and `insert` methods respectively.

## Session Variables 

SurrealDB's session variables provide a robust mechanism for managing session-specific data. Think of them as temporary storage tied directly to a user's active connection, ideal for tasks like maintaining application state, storing user preferences, or holding temporary data relevant only to the current session.

A key characteristic of session variables is their scope: they are strictly confined to the individual connection. This isolation ensures that one user's session data remains private and does not interfere with others, allowing for personalized experiences within a multi-user environment.
You can interact with session variables in the following ways:

1.  **Explicit Session-Wide Management:**
    *   Use the [`let`](#let-) method to define a new variable or update an existing one within the current session. This variable will persist for the duration of the connection.
    *   Use the [`unset`](#unset-) method to remove a previously defined variable from the session.
    *   The [`reset`](#reset) method, in addition to its other functions, clears *all* currently defined session variables, restoring the session's variable state.

2.  **Implicit Request-Scoped Management:** 
    *   Methods [`query`](#query), [`select`](#select), [`insert`](#insert), [`create`](#create), [`upsert`](#upsert), [`update`](#update), [`relate`](#relate), and [`delete`](#delete), accept an optional `vars` parameter. This parameter is an object containing key-value pairs, where each key represents the variable name (without the leading `$`) and the value is the data to be assigned.
    *   Variables passed via this parameter are defined *only* for the execution context of that specific method call. They temporarily override any session-wide variable with the same name for that request but do not permanently alter the session state. These variables are automatically discarded once the method execution completes.

To utilize a session variable within a query or method, prefix its name with a dollar sign (`$`), for example, `$user_id`.
## Supported methods

You can use the RPC protocol to perform the following actions:

<table>
    <thead>
        <tr>
            <th scope="col">Function</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Function"><a href="#authenticate"><code>authenticate [ token ]</code></a></td>
            <td scope="row" data-label="Description">Authenticate a user against SurrealDB with a token</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#create"><code>create [ thing, data ]</code></a></td>
            <td scope="row" data-label="Description">Create a record with a random or specified ID</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#delete"><code>delete [ thing ]</code></a></td>
            <td scope="row" data-label="Description">Delete either all records in a table or a single record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#graphql"><code>graphql [ query, options? ]</code></a></td>
            <td scope="row" data-label="Description">Execute GraphQL queries against the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#info"><code>info</code></a></td>
            <td scope="row" data-label="Description">Returns the record of an authenticated record user</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#insert"><code>insert [ thing, data ]</code></a></td>
            <td scope="row" data-label="Description">Insert one or multiple records in a table</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#insert_relation"><code>insert_relation [ table, data ]</code></a></td>
            <td scope="row" data-label="Description">Insert a new relation record into a specified table or infer the table from the data</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#invalidate"><code>invalidate</code></a></td>
            <td scope="row" data-label="Description">Invalidate a user's session for the current connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#kill-"><code>kill [ queryUuid ]</code></a></td>
            <td scope="row" data-label="Description">Kill an active live query</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#let-"><code>let [ name, value ]</code></a></td>
            <td scope="row" data-label="Description">Define a variable on the current connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#live-"><code>live [ table, diff ]</code></a></td>
            <td scope="row" data-label="Description">Initiate a live query</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#merge"><code>merge [ thing, data ]</code></a></td>
            <td scope="row" data-label="Description">Merge specified data into either all records in a table or a single record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#patch"><code>patch [ thing, patches, diff ]</code></a></td>
            <td scope="row" data-label="Description">Patch either all records in a table or a single record with specified patches</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#ping"><code>ping</code></a></td>
            <td scope="row" data-label="Description">Sends a ping to the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#query"><code>query [ sql, vars ]</code></a></td>
            <td scope="row" data-label="Description">Execute a custom query with optional variables</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#relate"><code>relate [ in, relation, out, data? ]</code></a></td>
            <td scope="row" data-label="Description"> Create graph relationships between created records </td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#reset"><code>reset</code></a></td>
            <td scope="row" data-label="Description">Resets all attributes for the current connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#run"><code>run [ func_name, version, args ]</code></a></td>
            <td scope="row" data-label="Description">Execute built-in functions, custom functions, or machine learning models with optional arguments.</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#select"><code>select [ thing ]</code></a></td>
            <td scope="row" data-label="Description">Select either all records in a table or a single record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#signin"><code>signin [NS, DB, AC, ... ]</code></a></td>
            <td scope="row" data-label="Description">Signin a root, NS, DB or record user against SurrealDB</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#signup"><code>signup [ NS, DB, AC, ... ]</code></a></td>
            <td scope="row" data-label="Description">Signup a user using the SIGNUP query defined in a record access method</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#unset-"><code>unset [ name ]</code></a></td>
            <td scope="row" data-label="Description">Remove a variable from the current connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#update"><code>update [ thing, data ]</code></a></td>
            <td scope="row" data-label="Description">Modify either all records in a table or a single record with specified data if the record already exists</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#upsert"><code>upsert [ thing, data ]</code></a></td>
            <td scope="row" data-label="Description">Replace either all records in a table or a single record with specified data</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#use"><code>use [ ns, db ]</code></a></td>
            <td scope="row" data-label="Description">Specifies or unsets the namespace and/or database for the current connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#version"><code>version</code></a></td>
            <td scope="row" data-label="Description">Returns version information about the database/server</td>
        </tr>
    </tbody>
</table>

<br />

## `authenticate`
This method allows you to authenticate a user against SurrealDB with a token.

<Tabs>
<TabItem label="RPC v1 & v2">
```json title="Method Syntax"
authenticate [ token ]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>token</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The token that authenticates the user
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "authenticate",
    "params": [ "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJTdXJyZWFsREIiLCJpYXQiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwiZXhwIjoxODM2NDM5MDIyLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJTQyI6InVzZXIiLCJJRCI6InVzZXI6dG9iaWUifQ.N22Gp9ze0rdR06McGj1G-h2vu6a6n9IVqUbMFJlOxxA" ]
}
```

```json title="Response"
{
    "id": 1,
    "result": null
}
```
</TabItem>
</Tabs>

<br />

## `create`

This method creates a record either with a random or specified ID.

<Tabs>
<TabItem label="RPC v1">
```json title="Method Syntax"
create [ thing, data ]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The thing (Table or Record ID) to create. Passing just a table will result in a randomly generated ID
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The content of the record
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "create",
    "params": [
        "person",
        {
            "name": "Mary Doe"
        }
    ]
}
```

```json title="Response"
{
    "id": 1,
    "result": [
        {
            "id": "person:s5fa6qp4p8ey9k5j0m9z",
            "name": "Mary Doe"
        }
    ]
}
```
</TabItem>

<TabItem label="RPC v2">
```json title="Method Syntax"
create [ 
    thing, 
    data?, 
    {
        only?: boolean, 
        output?: "none" | "null"| "diff" | "before" | "after",
        timeout?: duration, 
        version?: datetime, 
        vars?: object
    }?
]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>only</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`ONLY`](/docs/surrealql/statements/create#only) of the `CREATE` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>output</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`RETURN`](/docs/surrealql/statements/create#return-values) of the `CREATE` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>timeout</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`TIMEOUT`](/docs/surrealql/statements/create#timeout) of the `CREATE` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>version</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`VERSION`](/docs/surrealql/statements/create#version) of the `CREATE` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>vars</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                [`Session Variables`](#session-variables)
            </td>
        </tr>
    </tbody>
</table>

### Example usage

This section is under development. The functionality is closely aligned with the `CREATE` statement. For more details, refer to the [`CREATE` statement documentation](/docs/surrealql/statements/create).
</TabItem>
</Tabs>

<br />

## `delete`

This method deletes either all records in a table or a single record.

<Tabs>
<TabItem label="RPC v1">

```json title="Method Syntax"
delete [ thing ]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The thing (Table or Record ID) to delete
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "delete",
    "params": [ "person:8s0j0bbm3ngrd5c9bx53" ]
}
```

Notice how the deleted record is being returned here

```json title="Response"
{
    "id": 1,
    "result": {
        "active": true,
        "id": "person:8s0j0bbm3ngrd5c9bx53",
        "last_updated": "2023-06-16T08:34:25Z",
        "name": "John Doe"
    }
}
```
</TabItem>

<TabItem label="RPC v2">
```json title="Method Syntax"
create [ 
    thing,
    {
        only?: boolean, 
        output?: "none" | "null"| "diff" | "before" | "after",
        timeout?: duration, 
        vars?: object
    }? 
]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>only</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
               A boolean, stating where we want to select or affect only a single record.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>output</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                By default, the delete method returns nothing. To change what is returned, we can use the output option, specifying either "none", "null", "diff", "before", "after".
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>timeout</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`TIMEOUT`](/docs/surrealql/statements/delete#using-timeout-duration-records-based-on-conditions) of the `DELETE` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>vars</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                [`Session Variables`](#session-variables)
            </td>
        </tr>
    </tbody>
</table>

### Example usage

This section is under development. The functionality is closely aligned with the `DELETE` statement. For more details, refer to the [`DELETE` statement documentation](/docs/surrealql/statements/delete).
</TabItem>

</Tabs>

<br />

## `graphql`

<Since v="v2.0.0" />

This method allows you to execute GraphQL queries against the database.

<Tabs>
<TabItem label="RPC v1 & v2">
```json title="Method Syntax"
graphql [ query, options? ]
```

### Parameters

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>query</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                A GraphQL query string or an object containing the query, variables, and operation name.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>options</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                An object specifying options such as the output format and pretty-printing.
            </td>
        </tr>
    </tbody>
</table>

#### `query` Parameter

The `query` parameter can be either:

- A **string** containing the GraphQL query. For example:

```json
{ "query": "{ author { id name } }" }
```

- An **object** with the following fields:
  - `query` (**required**): The GraphQL query string.
  - `variables` or `vars` (**optional**): An object containing variables for the query.
  - `operationName` or `operation` (**optional**): The name of the operation to execute.

**Example:**
```json
{
    "query": "query GetUser($id: ID!) { user(id: $id) { id name } }",
    "variables": { "id": "user:1" },
    "operationName": "GetUser"
}
```

#### `options` Parameter

The `options` parameter is an object that may include:

- `pretty` (**optional**, default `false`): A boolean indicating whether the output should be pretty-printed.
- `format` (**optional**, default `"json"`): The response format. Currently, only `"json"` is supported.

**Example:**
```json
{
    "pretty": true,
    "format": "json"
}
```

### Example Usage

#### Executing a Simple GraphQL Query

```json title="Request"
{
    "id": 1,
    "method": "graphql",
    "params": [ "{ users { id name } }" ]
}
```

```json title="Response"
{
    "id": 1,
    "result": {
        "data": {
            "users": [
                { "id": "user:1", "name": "Alice" },
                { "id": "user:2", "name": "Bob" }
            ]
        }
    }
}
```

#### Executing a GraphQL Query with Variables and Operation Name

```json title="Request"
{
    "id": 1,
    "method": "graphql",
    "params": [
        {
            "query": "query GetUser($id: ID!) { user(id: $id) { id name } }",
            "variables": { "id": "user:1" },
            "operationName": "GetUser"
        }
    ]
}
```

```json title="Response"
{
    "id": 1,
    "result": {
        "data": {
            "user": { "id": "user:1", "name": "Alice" }
        }
    }
}
```

#### Executing a GraphQL Query with Options

```json title="Request"
{
    "id": 1,
    "method": "graphql",
    "params": [
        "{ users { id name } }",
        { "pretty": true }
    ]
}
```

```json title="Response"
{
    "id": 1,
    "result": "{\n    \"data\": {\n        \"users\": [\n            { \"id\": \"user:1\", \"name\": \"Alice\" },\n            { \"id\": \"user:2\", \"name\": \"Bob\" }\n        ]\n    }\n}"
}
```

### Notes

- **GraphQL Support:** This method requires GraphQL support to be enabled in the database configuration. If not enabled, you will receive a `MethodNotFound` error.
- **Format Options:** Currently, only the `"json"` format is supported. Using `"cbor"` will result in an error.
- **Pretty Output:** Setting `pretty` to `true` formats the JSON response with indentation for readability.

> [!IMPORTANT]
> Ensure that your GraphQL queries and variables are correctly formatted to avoid parsing errors.

</TabItem>
</Tabs>

<br />

## `info`

This method returns the record of an authenticated record user.

<Tabs>
<TabItem label="RPC v1 & v2">

```json title="Method Syntax"
info
```

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "info"
}
```

The result property of the response is likely different depending on your schema and the authenticated user. However, it does represent the overall structure of the responding message.

```json title="Response"
{
    "id": 1,
    "result": {
        "id": "user:john",
        "name": "John Doe"
    }
}
```

</TabItem>
</Tabs>

<br />

## `insert`

This method creates a record either with a random or specified ID.

<Tabs>
<TabItem label="RPC v1">

```json title="Method Syntax"
insert [ thing, data ]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The table to insert in to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            One or multiple record(s)
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```json title="Request"
{
    "id": 1,
    "method": "insert",
    "params": [
        "person",
        {
            "name": "Mary Doe"
        }
    ]
}
```

```json title="Response"
{
    "id": 1,
    "result": [
        {
            "id": "person:s5fa6qp4p8ey9k5j0m9z",
            "name": "Mary Doe"
        }
    ]
}
```

### Bulk insert

```json title="Request"
{
    "id": 1,
    "method": "insert",
    "params": [
        "person",
        [
            {
                "name": "Mary Doe"
            },
            {
                "name": "John Doe"
            }
        ]
    ]
}
```

```json title="Response"
{
    "id": 1,
    "result": [
        {
            "id": "person:s5fa6qp4p8ey9k5j0m9z",
            "name": "Mary Doe"
        },
        {
            "id": "person:xtbbojcm82a97vus9x0j",
            "name": "John Doe"
        }
    ]
}
```
</TabItem>

<TabItem label="RPC v2">

```text title="Method Syntax"
insert [ 
    thing, 
    data, 
    {
        data_expr?: "content" | "single",
        relation?: boolean, 
        output?: "none" | "null"| "diff" | "before" | "after",
        timeout?: duration, 
        version?: datetime, 
        vars?: object
    }?
]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>data</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>data_expr</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies how the `data` parameter is interpreted.
                <ul>
                    <li><code>content</code> (default): The `data` parameter should be a single object representing one record, or an array of objects representing multiple records.</li>
                     <li><code>single</code>: The `data` parameter should be a object where keys represent field names and values are arrays of the same length. The records are constructed by combining the elements at the same index from each array.</li>
                </ul>
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>relation</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                A boolean indicating whether the inserted records are relations.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>output</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`RETURN`](/docs/surrealql/statements/insert#return-values) of the `INSERT` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>timeout</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                A duration, stating how long the statement is run within the database before timing out.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>version</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                If you are using SurrealKV as the storage engine with versioning enabled, when creating a record you can specify a version for each record.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>vars</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                [`Session Variables`](#session-variables)
            </td>
        </tr>
    </tbody>
</table>

### Example usage

This section is under development. The functionality is closely aligned with the `INSERT` statement. For more details, refer to the [`INSERT` statement documentation](/docs/surrealql/statements/insert).
</TabItem>
</Tabs>

<br />

## `insert_relation`

This method inserts a new relation record into the database. You can specify the relation table to insert into and provide the data for the new relation.

```json title="Method Syntax"
insert_relation [ table, data ]
```

### Parameters

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>table</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The name of the relation table to insert into. If `null` or `none`, the table is determined from the `id` field in the `data`.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>data</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            An object containing the data for the new relation record, including `in`, `out`, and any additional fields.
            </td>
        </tr>
    </tbody>
</table>

### Example Usage

**Inserting a Relation into a Specified Table**

```json title="Request"
{
    "id": 1,
    "method": "insert_relation",
    "params": [
        "likes",                   // (relation table)
        {                          // data
            "in": "user:alice",
            "out": "post:123",
            "since": "2024-09-15T12:34:56Z"
        }
    ]
}
```

```json title="Response"
{
    "id": 1,
    "result": {
        "id": "likes:user:alice:post:123",
        "in": "user:alice",
        "out": "post:123",
        "since": "2024-09-15T12:34:56Z"
    }
}
```

**Inserting a Relation Without Specifying the Table**

If you do not specify the `table` parameter (i.e., set it to `null` or `none`), the relation table is inferred from the `id` field within the `data`.

```json title="Request"
{
    "id": 2,
    "method": "insert_relation",
    "params": [
        null,                      // relation table is null
        {                          // data
            "id": "follows:user:alice:user:bob",
            "in": "user:alice",
            "out": "user:bob",
            "since": "2024-09-15T12:34:56Z"
        }
    ]
}
```

```json title="Response"
{
    "id": 2,
    "result": {
        "id": "follows:user:alice:user:bob",
        "in": "user:alice",
        "out": "user:bob",
        "since": "2024-09-15T12:34:56Z"
    }
}
```

### Notes

- **`table` Parameter:**
  - Specifies the relation table into which the new relation record will be inserted.
  - If `table` is `null` or `none`, the method expects the `data` to contain an `id` from which it can infer the relation table.

- **`data` Parameter:**
  - Must include at least the `in` and `out` fields, representing the starting and ending points of the relation.
  - Can include additional fields to store more information within the relation.

- **Relation IDs:**
  - If an `id` is provided in the `data`, it will be used as the identifier for the new relation record.
  - If no `id` is provided, the system may generate one based on the `table`, `in`, and `out` fields.

- **Single vs. Multiple Inserts:**
  - The method primarily handles single relation inserts.
  - The `one` variable in the code determines if the `table` parameter refers to a single item.

### Error Handling

- **Invalid Parameters:**
  - If you provide fewer than two parameters or incorrect parameter types, you will receive an `InvalidParams` error.
  - The method expects exactly two parameters: `table` and `data`.

**Example of Invalid Parameters:**

```json title="Request with missing parameters"
{
    "id": 3,
    "method": "insert_relation",
    "params": [
        "likes"  // Missing the data parameter
    ]
}
```

```json title="Response"
{
    "id": 3,
    "error": {
        "code": -32602,
        "message": "Invalid parameters"
    }
}
```

### Best Practices

- **Include `in` and `out` Fields:**
  - Always provide the `in` and `out` fields in your `data` to define the relation endpoints.

- **Specifying the Relation Table:**
  - If possible, specify the `table` parameter to clearly indicate the relation table.
  - If not specified, ensure that the `id` in `data` correctly reflects the desired relation table.

- **Providing an `id` in `data`:**
  - If you want to control the `id` of the relation, include it in the `data`.
  - This is especially important when `table` is `null` or `none`.

### Additional Examples

**Inserting a Relation with Auto-Generated ID**

```json title="Request"
{
    "id": 4,
    "method": "insert_relation",
    "params": [
        "friendship",              // table (relation table)
        {                          // data
            "in": "user:alice",
            "out": "user:bob",
            "since": "2024-09-15"
        }
    ]
}
```

```json title="Response"
{
    "id": 4,
    "result": {
        "id": "friendship:user:alice:user:bob",
        "in": "user:alice",
        "out": "user:bob",
        "since": "2024-09-15"
    }
}
```

**Notes:**

- The `id` is generated based on the `table`, `in`, and `out` fields.
- The relation is inserted into the `friendship` table.

The `insert_relation` method is a powerful way to insert new relation records into your database, allowing you to specify the relation table and include detailed data for each relation. By understanding the parameters and how the method operates, you can effectively manage relationships between records in your database.

> [!NOTE]
> This method is particularly useful in databases that support graph-like relations, enabling complex data modeling and querying capabilities.

<br />

## `invalidate`

This method will invalidate the user's session for the current connection.

<Tabs>
<TabItem label="RPC v1 & v2">
```json title="Method Syntax"
invalidate
```

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "invalidate"
}
```

```json title="Response"
{
    "id": 1,
    "result": null
}
```
</TabItem>
</Tabs>

<br />

<Tabs>
<TabItem label="RPC v1 & v2">

## `kill` <Label label="websocket only" />

This method kills an active live query

```json title="Method Syntax"
kill [ queryUuid ]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>queryUuid</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The UUID of the live query to kill
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "kill",
    "params": [ "0189d6e3-8eac-703a-9a48-d9faa78b44b9" ]
}
```

```json title="Response"
{
    "id": 1,
    "result": null
}
```

</TabItem>
</Tabs>

<br />

## `let` <Label label="websocket only" />

This method stores a variable on the current connection.

```json title="Method Syntax"
let [ name, value ]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>name</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The name for the variable without a prefixed $ character
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>value</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The value for the variable
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "let",
    "params": [ "website", "https://surrealdb.com/" ]
}
```

```json title="Response"
{
    "id": 1,
    "result": null
}
```

<br />

## `live` <Label label="websocket only" />

This methods initiates a live query for a specified table name.

<Tabs>
<TabItem label="RPC v1 & v2">

```json title="Method Syntax"
live[ table ]
```

> [!IMPORTANT]
> For more advanced live queries where filters are needed, use the Query method to initiate a custom live query.

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>table</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table to initiate a live query for
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>diff</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                If set to true, live notifications will contain an array of [JSON Patches](https://jsonpatch.com) instead of the entire record
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "live",
    "params": [ "person" ]
}
```

```json title="Response"
{
    "id": 1,
    "result": "0189d6e3-8eac-703a-9a48-d9faa78b44b9"
}
```

### Live notification
For every creation, update or deletion on the specified table, a live notification will be sent. Live notifications do not have an ID attached, but rather include the Live Query's UUID in the result object.

```json
{
    "result": {
        "action": "CREATE",
        "id": "0189d6e3-8eac-703a-9a48-d9faa78b44b9",
        "result": {
            "id": "person:8s0j0bbm3ngrd5c9bx53",
            "name": "John"
        }
    }
}
```

</TabItem>
</Tabs>

<br />

## `merge`

This method merges specified data into either all records in a table or a single record.

```json title="Method Syntax"
merge [ thing, data ]
```

> [!NOTE]
> This function merges the current document / record data with the specified data. If no merge data is passed it will simply trigger an update.

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The thing (Table or Record ID) to merge into
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The content of the record
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "merge",
    "params": [
        "person",
        {
            "active": true
        }
    ]
}
```

```json title="Response"
{
  "id": 1,
  "result": [
      {
          "active": true,
          "id": "person:8s0j0bbm3ngrd5c9bx53",
          "name": "John Doe"
      },
      {
          "active": true,
          "id": "person:s5fa6qp4p8ey9k5j0m9z",
          "name": "Mary Doe"
      }
  ]
}
```

<br />

## `patch`

This method patches either all records in a table or a single record with specified patches.

```json title="Method Syntax"
patch [ thing, patches, diff ]
```

> [!NOTE]
> This function patches the current document / record data with the specified [JSON Patch](https://jsonpatch.com) data.

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The thing (Table or Record ID) to patch
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>patches</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            An array of patches following the [JSON Patch specification](https://jsonpatch.com)
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>diff</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            A boolean representing if just a diff should be returned.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "patch",
    "params": [
        "person",
        [
            { "op": "replace", "path": "/last_updated", "value": "2023-06-16T08:34:25Z" }
        ]
    ]
}
```

```json title="Response"
{
    "id": 1,
    "result": [
        [
            {
                "op": "add",
                "path": "/last_updated",
                "value": "2023-06-16T08:34:25Z"
            }
        ],
        [
            {
                "op": "add",
                "path": "/last_updated",
                "value": "2023-06-16T08:34:25Z"
            }
        ]
    ]
}
```

<br />

## `ping`

<Tabs>
<TabItem label="RPC v2">
```json title="Method Syntax"
ping
```

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "ping",
}
```

```json title="Response"
{
  "id": 1,
  "result": null
}
```
</TabItem>
</Tabs>

<br />

## `query`

This methods sends a custom SurrealQL query.

<Tabs>
<TabItem label="RPC v1 & v2">

```json title="Method Syntax"
query [ sql, vars ]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2">Parameter</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The query to execute against SurrealDB
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>vars</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                A set of variables used by the query
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "query",
    "params": [
        "CREATE person SET name = 'John'; SELECT * FROM type::table($tb);",
        {
            "tb": "person"
        }
    ]
}
```

```json title="Response"
{
  "id": 1,
  "result": [
      {
          "status": "OK",
          "time": "152.5µs",
          "result": [
              {
                  "id": "person:8s0j0bbm3ngrd5c9bx53",
                  "name": "John"
              }
          ]
      },
      {
          "status": "OK",
          "time": "32.375µs",
          "result": [
              {
                  "id": "person:8s0j0bbm3ngrd5c9bx53",
                  "name": "John"
              }
          ]
      }
  ]
}
```

</TabItem>
</Tabs>

## `relate`

<Since v="v1.5.0" />
This method relates two records with a specified relation.

<Tabs>
<TabItem label="RPC v1">

```json title="Method Syntax"
relate [ in, relation, out, data? ]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>in</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The record to relate to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>relation</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The relation table
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>out</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The record to relate from
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The content of the record
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "relate",
    "params": [
        "person:12s0j0bbm3ngrd5c9bx53",
        "knows",
        "person:8s0j0bbm3ngrd5c9bx53"
    ]
}
```

```json title="Response"
{
    "id": 1,
    "result": {
        "id": "knows:12s0j0bbm3ngrd5c9bx53:8s0j0bbm3ngrd5c9bx53",
        "in": "person:12s0j0bbm3ngrd5c9bx53",
        "out": "person:8s0j0bbm3ngrd5c9bx53"
    }
}
```

### Creating a Relation With Additional Data

```json title="Request"
{
    "id": 2,
    "method": "relate",
    "params": [
        "person:john_doe",          // in
        "knows",                    // relation
        "person:jane_smith",        // out
        { "since": "2020-01-01" }   // data
    ]
}
```

```json title="Response"
{
    "id": 2,
    "result": {
        "id": "knows:person:john_doe:person:jane_smith",
        "in": "person:jane_smith",
        "out": "person:john_doe",
        "since": "2020-01-01"
    }
}
```

</TabItem>

<TabItem label="RPC v2">

```json title="Method Syntax"
relate [
    in,
    relation,
    out,
    data?,
    {
        unique?: boolean,
        only?: boolean,
        output?: "none" | "null"| "diff" | "before" | "after",
        timeout?: duration,
        version:? datetime,
        vars?: object
    }?
]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>in</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The record to relate from
            </td>
        </tr>
         <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>relation</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The relation table
            </td>
        </tr>
         <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>out</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The record to relate to
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>unique</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                A boolean, stating wether the relation we are inserting needs to be unique.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>only</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`ONLY`](/docs/surrealql/statements/relate#creating-a-single-relation-with-the-only-keyword) of the `RELATE` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>output</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`RETURN`](/docs/surrealql/statements/relate#modifying-output-with-the-return-clause) of the `RELATE` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>timeout</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`TIMEOUT`](/docs/surrealql/statements/relate#using-the-timeout-clause) of the `RELATE` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>vars</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                [`Session Variables`](#session-variables)
            </td>
        </tr>
    </tbody>
</table>

### Example usage

This section is under development. The functionality is closely aligned with the `RELATE` statement. For more details, refer to the [`RELATE` statement documentation](/docs/surrealql/statements/relate).

</TabItem>
</Tabs>

<br />

## `reset`

This method will reset all attributes for the current connection. reset your authentication (much like invalidate) unsets the selected NS/DB, unsets any defined connection params, and aborts any active live queries.

<Tabs>
<TabItem label="RPC v1 & v2">
```json title="Method Syntax"
reset
```

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "reset"
}
```

```json title="Response"
{
    "id": 1,
    "result": null
}
```
</TabItem>
</Tabs>

<br />

## `run`

This method allows you to execute built-in functions, custom functions, or machine learning models with optional arguments.

<Tabs>
<TabItem label="RPC v1 & v2">
```json title="Method Syntax"
run [ func_name, version?, args? ]
```

### Parameters

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>func_name</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The name of the function or model to execute. Prefix with `fn::` for custom functions or `ml::` for machine learning models.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>version</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The version of the function or model to execute.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>args</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The arguments to pass to the function or model.
            </td>
        </tr>
    </tbody>
</table>


### Executing a built-in function

```json title="Request"
{
    "id": 1,
    "method": "run",
    "params": [ "time::now" ]
}
```

```json title="Response"
{
    "id": 1,
    "result": "2024-09-15T12:34:56Z"
}
```

### Executing a custom function

```json title="Request"
{
    "id": 1,
    "method": "run",
    "params": [ "fn::calculate_discount", null, [ 100, 15 ] ]
}
```

```json title="Response"
{
    "id": 1,
    "result": 85
}
```

### Executing a machine learning model

```json title="Request"
{
    "id": 1,
    "method": "run",
    "params": [ "ml::image_classifier", "v2.1", [ "image_data_base64" ] ]
}
```

```json title="Response"
{
    "id": 1,
    "result": "cat"
}
```

> [!IMPORTANT]
> When using a machine learning model (prefixed with `ml::`), the `version` parameter is **required**.

</TabItem>
</Tabs>

<br />

## `select`

This method selects either all records in a table or a single record.

<Tabs>
<TabItem label="RPC v1">

```json title="Method Syntax"
select [ thing ]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The thing (Table or Record ID) to select
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "select",
    "params": [ "person" ]
}
```

```json title="Response"
{
    "id": 1,
    "result": [
        {
            "id": "person:8s0j0bbm3ngrd5c9bx53",
            "name": "John"
        }
    ]
}
```
</TabItem>

<TabItem label="RPC v2">

```json title="Method Syntax"
select [ 
    thing,  
    {
        fields?: string,
        only?: boolean, 
        start?: number,
        limit?: number,
        cond?: string,
        timeout?: duration, 
        version?: datetime, 
        vars?: object
    }?
]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>fields</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                
            </td>
        </tr>
         <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>only</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`ONLY`](/docs/surrealql/statements/select#the-only-clause) of the `SELECT` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>start</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                A number, stating how many records to skip in a selection.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>limit</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`LIMIT`](/docs/surrealql/statements/select#the-limit-clause) of the `SELECT` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>cond</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`WHERE`](/docs/surrealql/statements/select#numeric-ranges-in-a-where-clause) of the `SELECT` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>timeout</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`TIMEOUT`](/docs/surrealql/statements/select#the-timeout-clause) of the `SELECT` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>version</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`VERSION`](/docs/surrealql/statements/select#the-version-clause) of the `SELECT` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>vars</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                [`Session Variables`](#session-variables)
            </td>
        </tr>
    </tbody>
</table>

### Example usage

This section is under development. The functionality is closely aligned with the `SELECT` statement. For more details, refer to the [`SELECT` statement documentation](/docs/surrealql/statements/select).

</TabItem>
</Tabs>

<br />

## `signin`

This method allows you to sign in as a root, namespace, or database user, or with a record access method.

> [!IMPORTANT]
> Unlike v1, v2 returns an object containing a `token` property and an optional `refresh` property.

<Tabs>
<TabItem label="RPC v1 & v2">
```json title="Method Syntax"
signin [ NS, DB, AC, ... ]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>NS</code>
                <Label label="required"></Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The namespace to sign in to. Only required for `DB & RECORD` authentication
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>DB</code>
                <Label label="required"></Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database to sign in to. Only required for `RECORD` authentication
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>AC</code>
                <Label label="required"></Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the access method. Only required for `RECORD` authentication
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>user</code>
                <Label label="required">REQUIRED FOR ROOT, NS & DB</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            	The username of the database user. Only required for `ROOT, NS & DB` authentication
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>pass</code>
                <Label label="required">REQUIRED FOR ROOT, NS & DB</Label>
            </td>
            <td colspan="2" scope="row" data-label="Description">
            	The password of the database user. Only required for `ROOT, NS & DB` authentication
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>...</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies any variables to pass to the `SIGNIN` query. Only relevant for `RECORD` authentication
            </td>
        </tr>
    </tbody>
</table>

### Example with Root user

```json title="Request"
{
    "id": 1,
    "method": "signin",
    "params": [
        {
            "user": "tobie",
            "pass": "3xtr3m3ly-s3cur3-p@ssw0rd"
        }
    ]
}
```

```json title="Response"
{
    "id": 1,
    "result": null
}
```

### Example with Record user

```json title="Request"
{
    "id": 1,
    "method": "signin",
    "params": [
        {
            "NS": "surrealdb",
            "DB": "docs",
            "AC": "commenter",

            "username": "johndoe",
            "password": "SuperStrongPassword!"
        }
    ]
}
```

```json title="Response"
{
    "id": 1,
    "result": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJTdXJyZWFsREIiLCJpYXQiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwiZXhwIjoxODM2NDM5MDIyLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJTQyI6InVzZXIiLCJJRCI6InVzZXI6dG9iaWUifQ.N22Gp9ze0rdR06McGj1G-h2vu6a6n9IVqUbMFJlOxxA"
}
```

</TabItem>
</Tabs>

<br />

## `signup`

This method allows you to sign a user up using the `SIGNUP` query defined in a record access method.

> [!IMPORTANT]
> Unlike v1, v2 returns an object containing an optional `token` property and an optional `refresh` property.

<Tabs>
<TabItem label="RPC v1 & v2">

```json title="Method Syntax"
signup [ NS, DB, AC, ... ]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the namespace of the record access method
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the database of the record access method
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>AC</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the access method
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>...</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies any variables used by the SIGNUP query of the record access method
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "signup",
    "params": [
        {
            "NS": "surrealdb",
            "DB": "docs",
            "AC": "commenter",

            "username": "johndoe",
            "password": "SuperStrongPassword!"
        }
    ]
}
```

```json title="Response"
{
  "id": 1,
  "result": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJTdXJyZWFsREIiLCJpYXQiOjE1MTYyMzkwMjIsIm5iZiI6MTUxNjIzOTAyMiwiZXhwIjoxODM2NDM5MDIyLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJTQyI6InVzZXIiLCJJRCI6InVzZXI6dG9iaWUifQ.N22Gp9ze0rdR06McGj1G-h2vu6a6n9IVqUbMFJlOxxA"
}
```

</TabItem>
</Tabs>

<br />

## `unset` <Label label="websocket only" />

This method removes a variable from the current connection.

<Tabs>
<TabItem label="RPC v1 & v2">

```json title="Method Syntax"
unset [ name ]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>name</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The name of the variable without a prefixed $ character
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "unset",
    "params": [ "website" ]
}
```

```json title="Response"
{
    "id": 1,
    "result": null
}
```

</TabItem>
</Tabs>

<br />

## `update`

This method replaces either all records in a table or a single record with specified data.

```json title="Method Syntax"
update [ thing, data ]
```

> [!NOTE]
> This function replaces the current document / record data with the specified data if that document / record has already been created. If no document has been created this will return an empty array. Also, if no replacement data is passed it will simply trigger an update.

<Tabs>
<TabItem label="RPC v1">

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The thing (Table or Record ID) to update
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The content of the record
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "update",
    "params": [
        "person:8s0j0bbm3ngrd5c9bx53",
        {
            "name": "John Doe"
        }
    ]
}
```

```json title="Response"
{
    "id": 1,
    "result": {
        "id": "person:8s0j0bbm3ngrd5c9bx53",
        "name": "John Doe"
    }
}
```

</TabItem>

<TabItem label="RPC v2">

```json title="Method Syntax"
insert [ 
    thing, 
    data?, 
    {
        data_expr?: "content" | "merge" | "replace" | "patch",
        only?: boolean,
        cond?: string,
        output?: "none" | "null"| "diff" | "before" | "after",
        timeout?: duration, 
        vars?: object
    }? 
]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>data_expr</code>
                <Label label="optional" />
            </td>
            <td>
                <ul>
                    <li><code>content</code>: corresponds to [`CONTENT`](/docs/surrealql/statements/update#content-clause) of the `UPDATE` statement</li>
                    <li><code>merge</code>: corresponds to [`MERGE`](/docs/surrealql/statements/update#merge-clause) of the `UPDATE` statement</li>
                    <li><code>replace</code>: corresponds to [`REPLACE`](/docs/surrealql/statements/update#replace-clause) of the `UPDATE` statement</li>
                    <li><code>patch</code>: corresponds to [`PATCH`](/docs/surrealql/statements/update#patch-clause) of the `UPDATE` statement</li>
                </ul>
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>only</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                A boolean, stating where we want to select or affect only a single record.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>cond</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`WHERE`](/docs/surrealql/statements/update#conditional-update-with-where-clause) of the `UPDATE` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>output</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`RETURN`](/docs/surrealql/statements/update#alter-the-return-value) of the `UPDATE` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>timeout</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`TIMEOUT`](/docs/surrealql/statements/update#using-a-timeout) of the `UPDATE` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>vars</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                [`Session Variables`](#session-variables)
            </td>
        </tr>
    </tbody>
</table>

### Example usage
This section is under development. The functionality is closely aligned with the `UPDATE` statement. For more details, refer to the [`UPDATE` statement documentation](/docs/surrealql/statements/update).

</TabItem>

</Tabs>

<br />

## `upsert`

<Tabs>
<TabItem label="RPC v1">

```json title="Method Syntax"
upsert [ thing, data ]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The thing (Table or Record ID) to upsert
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            The content of the record
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```json title="Request"
{
    "id": 1,
    "method": "upsert",
    "params": [
        "person:12s0j0bbm3ngrd5c9bx53",
        {
            "name": "John Doe",
            "job": "Software developer",
        }
    ]
}
```

```json title="Response"
{
    "id": 1,
    "result": {
        "id": "person:12s0j0bbm3ngrd5c9bx53",
        "name": "John Doe",
        "job": "Software developer"
    }
}
```

</TabItem>

<TabItem label="RPC v2">

```json title="Method Syntax"
upsert [ 
    thing, 
    data?, 
    {
        data_expr?: "content" | "merge" | "replace" | "patch",
        only?: boolean,
        cond?: string,
        output?: "none" | "null"| "diff" | "before" | "after",
        timeout?: duration, 
        vars?: object
    } 
]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>thing</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>data</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>data_expr</code>
                <Label label="optional" />
            </td>
            <td>
                <ul>
                    <li><code>content</code>: corresponds to [`CONTENT`](/docs/surrealql/statements/upsert#content-clause) of the `UPSERT` statement</li>
                    <li><code>merge</code>: corresponds to [`MERGE`](/docs/surrealql/statements/upsert#merge-clause) of the `UPSERT` statement</li>
                    <li><code>replace</code>: corresponds to [`REPLACE`](/docs/surrealql/statements/upsert#replace-clause) of the `UPSERT` statement</li>
                    <li><code>patch</code>: corresponds to [`PATCH`](/docs/surrealql/statements/upsert#patch-clause) of the `UPSERT` statement</li>
                </ul>
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>only</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`ONLY`](/docs/surrealql/statements/upsert#using-the-only-clause) of the `UPSERT` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>cond</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`WHERE`](/docs/surrealql/statements/upsert#using-the-where-clause) of the `UPSERT` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>output</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                corresponds to [`RETURN`](/docs/surrealql/statements/upsert#alter-the-return-value) of the `UPSERT` statement
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>timeout</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                A duration, stating how long the statement is run within the database before timing out.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Parameter">
                <code>vars</code>
                <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                [`Session Variables`](#session-variables)
            </td>
        </tr>
    </tbody>
</table>

### Example usage
This section is under development. The functionality is closely aligned with the `UPSERT` statement. For more details, refer to the [`UPSERT` statement documentation](/docs/surrealql/statements/upsert).

</TabItem>

</Tabs>

<br />

## `use`

This method specifies or unsets the namespace and/or database for the current connection.

<Tabs>
<TabItem label="RPC v1 & v2">

```json title="Method Syntax"
use [ ns, db ]
```

### Parameters
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Parameter</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Function">
                <code>NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Function">
                <code>DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries
            </td>
        </tr>
    </tbody>
</table>

### Accepted values

For either the namespace or database, a string will change the value, `null` will unset the value, and `none` will cause the value to not be affected.

### Example usage

```json title="Request"
{
    "id": 1,
    "method": "use",
    "params": [ "surrealdb", "docs" ]
}
```

```json title="Response"
{
    "id": 1,
    "result": null
}
```

```surql title="Example Combinations"
[none, none]     -- Won't change ns or db
["test", none]   -- Change ns to test
[none, "test"]   -- Change db to test
["test", "test"] -- Change ns and db to test

[none, null]     -- Will only unset the database
[null, none]     -- Will throw an error, you cannot unset only the database
[null, null]     -- Will unset both ns and db
["test", null]   -- Change ns to test and unset db
```

</TabItem>
</Tabs>

<br />

## `version`

This method returns version information about the database/server.

<Tabs>
<TabItem label="RPC v1 & v2">

```json title="Method Syntax"
version
```

### Parameters

This method does not accept any parameters.

### Example Usage

```json title="Request"
{
    "id": 1,
    "method": "version"
}
```

```json title="Response"
{
    "id": 1,
    "result": {
        "version": "2.0.0-beta.2",
        "build": "abc123",
        "timestamp": "2024-09-15T12:34:56Z"
    }
}
```

### Notes

- **Parameters:** Providing any parameters will result in an `InvalidParams` error.
- **Result Fields:**
  - `version`: The version number of the database/server.
  - `build`: The build identifier.
  - `timestamp`: The timestamp when the version was built or released.


> [!NOTE]
> The actual values in the response will depend on your specific database/server instance.

</TabItem>
</Tabs>

<br />




================================================
FILE: src/content/doc-surrealdb/integration/sdks.mdx
================================================
---
sidebar_position: 2
sidebar_label: SDKs
title: SDKs | Integration
description: SurrealDB supports a number of methods for connecting to the database and performing data queries.
---

import Boxes from "@components/boxes/Boxes.astro";
import IconBox from "@components/boxes/IconBox.astro";
import Image from "@components/Image.astro";

import LightDotnet from "@img/icon/light/dotnet.png";
import LightGolang from "@img/icon/light/golang.png";
import LightJava from "@img/icon/light/java.png";
import LightJavaScript from "@img/icon/light/javascript.png";
import LightNodejs from "@img/icon/light/nodejs.png";
import LightPhp from "@img/icon/light/php.png";
import LightPython from "@img/icon/light/python.png";
import LightRust from "@img/icon/light/rust.png";
import LightTypescript from "@img/icon/light/typescript.png";
import LightWasm from "@img/icon/light/webassembly.png";

import DarkDotnet from "@img/icon/dark/dotnet.png";
import DarkGolang from "@img/icon/dark/golang.png";
import DarkJava from "@img/icon/dark/java.png";
import DarkJavaScript from "@img/icon/dark/javascript.png";
import DarkNodejs from "@img/icon/dark/nodejs.png";
import DarkPhp from "@img/icon/dark/php.png";
import DarkPython from "@img/icon/dark/python.png";
import DarkRust from "@img/icon/dark/rust.png";
import DarkTypescript from "@img/icon/dark/typescript.png";
import DarkWasm from "@img/icon/dark/webassembly.png";

# SDKs

SurrealDB supports numerous client SDKs for connecting to the database and performing data queries. These SDKs are designed to simplify the integration process and provide developers with the tools they need to interact with SurrealDB from their preferred programming languages.

<Boxes>
    <IconBox
        title="Rust"
        status="available"
        href="/docs/sdk/rust"
        icon={{
                light: LightRust,
                dark: DarkRust,
        }}
    />
    <IconBox
        title="JavaScript"
        status="available"
        href="/docs/sdk/javascript"
        icon={{
                light: LightJavaScript,
                dark: DarkJavaScript,
        }}
    />
    <IconBox
        title="TypeScript"
        status="available"
        href="/docs/sdk/javascript"
        icon={{
                light: LightTypescript,
                dark: DarkTypescript,
        }}
    />
    <IconBox
        title="Node.js"
        status="available"
        href="/docs/sdk/javascript/engines/node"
        icon={{
                light: LightNodejs,
                dark: DarkNodejs,
        }}
    />
    <IconBox
        title="WebAssembly"
        status="available"
        href="/docs/sdk/javascript/engines/wasm"
        icon={{
                light: LightWasm,
                dark: DarkWasm,
        }}
    />
    <IconBox
        title="Java"
        status="available"
        href="/docs/sdk/java"
        icon={{
                light: LightJava,
                dark: DarkJava,
        }}
    />
    <IconBox
        title="Golang"
        status="available"
        href="/docs/sdk/golang"
        icon={{
                light: LightGolang,
                dark: DarkGolang,
        }}
    />
    <IconBox
        title="Python"
        status="available"
        href="/docs/sdk/python"
        icon={{
                light: LightPython,
                dark: DarkPython,
        }}
    />
    <IconBox
        title=".NET"
        status="available"
        href="/docs/sdk/dotnet"
        icon={{
                light: LightDotnet,
                dark: DarkDotnet,
        }}
    />
    <IconBox
        title="PHP"
        status="available"
        href="/docs/sdk/php"
        icon={{
                light: LightPhp,
                dark: DarkPhp,
        }}
    />
</Boxes>



================================================
FILE: src/content/doc-surrealdb/introduction/architecture.mdx
================================================
---
sidebar_position: 7
sidebar_label: Architecture
title: Architecture | Introduction
description: This page aims to give details about some of the core architecture choices of SurrealDB, including details about the different layers which make up a SurrealDB instance, or SurrealDB cluster.
---

import Image from "@components/Image.astro";
import LightArchitecture from "@img/image/light/storage-cluster.png";
import DarkArchitecture from "@img/image/light/storage-cluster.png";

# Architecture

This page aims to give details about some of the core architecture choices of SurrealDB, including details about the different layers which make up a SurrealDB instance, or SurrealDB cluster. SurrealDB is built using a layered approach, with compute separated from the storage. This allows us, if necessary, to scale up the compute layer, and the storage layer independently from each other.

## Query layer

The SurrealDB query layer (otherwise known as the compute layer) handles queries from the client, analyzing which records need to be selected, created, updated, or deleted. To begin with, the query engine runs the SurrealQL query through a `parser`, returning a parsed query definition. The parsed query is then run through the `executor` which breaks up each statement within the query, managing those transactions which should be run within the same transaction. Next, each statement is run through the `iterator` which determines which data should be fetched from the key-value storage engine, and handles index query planning, grouping, ordering, and limiting. Finally, each record is passed through the `document` processor, processing permissions, and determining which data is merged, altered, and stored on disk.

## Storage layer

The storage layer handles the storage of the data for the query layer. Each storage layer implementation stores data in an ordered list, handling storage on disk, or sharding across a cluster. SurrealDB can use a number of underlying storage engines - some support concurrent readers, and some support concurrent readers and writers. Each storage engine must support a transaction-based approach, with the ability to support reading and writing of individual keys, and key ranges within each transaction.

## RocksDB

In embedded mode, SurrealDB uses [RocksDB](https://rocksdb.org/) to store data on disk. RocksDB is a high performance embedded database for key-value data. It is originally a fork of Google's LevelDB optimized to exploit many CPU cores, and make efficient use of fast storage, such as solid-state drives and high-speed disk drives. It is based on a log-structured merge-tree data structure.

## TiKV

In distributed mode, SurrealDB can be configured to use [TiKV](https://tikv.org/) to store data. TiKV is a highly scalable, low latency, and easy to use key-value datastore. TiKV supports raw and transaction-based querying with ACID compliance, and support for multiple concurrent readers and writers. The design of TiKV is inspired by distributed systems from Google, such as BigTable, Spanner, and Percolator, and some of the latest achievements in academia in recent years, such as the Raft consensus algorithm.

## IndexedDB

When running in a web browser, SurrealDB can be configured to use [IndexedDB](https://web.dev/indexeddb/) to store and persist data within the web browser. SurrealDB first serializes both keys and values into a Uint8Array, utilizing IndexedDB as a binary key-value store - offering good performance, and with the ability to offer all of the functionality and features that SurrealDB offers when running in alternative ways.

## Deployment architecture with TiKV 

When you have deployed an HA cluster (High Availability), you will have a deployment that resembles the following configuration:

<Image
    alt="Storage_Cluster"
    src={{
        light: LightArchitecture,
        dark: DarkArchitecture,
    }}
/>

The HA deployment of your storage layer (TiKV) is the stateful part of the system.
The rules governing the availability guarantees are covered in the documentation of those systems.
SurrealDB clusters do not have state at the time of writing.
Any necessary communication is either avoided by design, or communicated via the storage layer which maintains consistency.
This makes deploying SurrealDB really convenient, since your fault tolerance is equal to the number of replicas (minus 1, the bare minimum number of instances).
Even though we do have bootstrapping, by design nodes can come and go as they please without much interference.



================================================
FILE: src/content/doc-surrealdb/introduction/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Introduction
title: Introduction
description: The purpose of this document is to provide you with a comprehensive understanding of SurrealDB. Whether you are a beginner getting started with SurrealDB or an experienced user looking for specific information, this overview will serve as a valuable resource.
---

# Introduction

SurrealDB is a [multi-model database](/blog/what-are-multi-model-databases) built in Rust designed to unify multiple data models into a single, powerful engine. It combines [document](/docs/surrealdb/models/document), [graph](/docs/surrealdb/models/graph), [time-series](/docs/surrealdb/models/time-series), [relational](/docs/tutorials/define-a-schema), [geospatial](/docs/surrealdb/models/geospatial) and key-value data types into one query language, [SurrrealQL](/docs/surrealql), with powerful search and retrieval ([vector](/docs/surrealdb/models/vector), [full-text](/docs/surrealdb/models/full-text-search), hybrid), and real-time and event-driven capabilities, enabling developers to build applications faster and more efficiently.

Common SurrealDB use cases include AI agents, knowledge graphs, real-time apps (e.g. recommendation engines, fraud detection systems), and any other type of application requiring multiple data types. SurrealDB can also be used as a backend-as-a-service thanks to its support for direct user authentication. Given that it’s a single Rust binary, SurrealDB can also run embedded (in‐app), in the browser (via WebAssembly), in the edge, as single backend node, or in a distributed cluster.

SurrealDB is open-source (see our [GitHub](https://github.com/surrealdb/surrealdb) page) and is also available as a cloud managed service through [SurrealDB Cloud](/cloud).

## Differentiators
- **Native multi-model:** combines document, graph, time-series, relational, geospatial and key-value data models natively into SurrealQL, without workarounds or added complexity.
- **AI native data layer:** purpose-built for AI and context-aware applications with integrated search and retrieval (vector, full-text, hybrid) that blend semantic, graph, and relational intelligence.
- **Real-time and event-driven:** built-in real-time subscriptions, event triggers, and streaming updates power reactive, real-time experiences - no need for Kafka, WebSockets, or extra layers.
- **Powerful developer experience:** SurrealQL is intuitive and combines the best ideas from SQL, NoSQL and graph within a single native syntax. Start schemaless and go schemafull.
- **Rust-powered performance:** high efficiency, memory safety, and compliance with government security standards with a single Rust binary.
- **Native ACID compliance:** guarantees strong data consistency natively, without additional workarounds.
- **Deployment flexibility:** single Rust binary and storage/compute separation allow SurrealDB to run embedded (in‐app), in the browser (via WebAssembly) or as a traditional back-end in a single node or in a highly-scalable distributed cluster.
- **Secure by design:** built-in security with RBAC, record-level permissions, fine-grained access controls, JWT authentication, multi-tenant isolation and built-in compliance (SOC 2, ISO 27001) keep data protected by default.

More information can be found in our [features page](/features).

## Enterprise case studies 

SurrealDB is being used at scale in production by large organisations such as:

- **Saks Fifth Avenue:** uses SurrealDB for real-time product recommendations and AI-based personalized experiences.
- **Vodafone:** AI-powered assistant delivering real-time technical support to 10,000 field technicians.
- **Samsung Ads:** utilizing SurrealDB for knowledge graphs in advertising analytics.
- **Tencent** using SurrealDB for infrastructure monitoring, having consolidated 9 tools into one.

More information can be found in our [enterprise case studies page](/casestudies).

## Use cases 

SurrealDB is ideal for any application, in particular data intensive applications that require multiple data systems, such as:

- **AI agents:** building Generative AI systems leveraging a single unstructured and structured data layer with vector, graph and real-time capabilities for RAG, Graph RAG, and agent memory.
- **Knowledge graphs:** turning unstructured data into structured, queryable data with a flexible multi-model approach including support for graph relationships.
- **Real-time analytics:** such as fraud detection systems, recommendation engines and log analytics.
- **Embedded & edge computing:** SurrealDB is a single lightweight Rust binary and can be embedded in industrial environments, run in-memory or in browser.
- **Backend-as-a-Service:** with support for end-user authentication, SurrealDB can also be used as a BaaS for web applications, if desired.



================================================
FILE: src/content/doc-surrealdb/introduction/start.mdx
================================================
---
sidebar_position: 1
sidebar_label: Getting started
title: Getting started with SurrealDB
description: In this guide, you will learn about the various ways you can start using SurrealDB, whether you are using SurrealDB in-memory or on-disk via an SDK, CLI, or Surrealist.

---

import { Icon } from 'astro-icon/components';
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";
import SurrealistMini from "@components/SurrealistMini.astro";
import IconBox from '@components/boxes/IconBox.astro';
import IconLink from '@components/boxes/IconLink.astro';
import LightDotnet from '@img/icon/light/dotnet.png';
import LightGolang from '@img/icon/light/golang.png';
import LightJava from '@img/icon/light/java.png';
import LightJavascript from '@img/icon/light/javascript.png';
import LightNodejs from '@img/icon/light/nodejs.png';
import LightPhp from '@img/icon/light/php.png';
import LightPython from '@img/icon/light/python.png';
import LightRust from '@img/icon/light/rust.png';
import LightWasm from '@img/icon/light/webassembly.png';

import DarkDotnet from '@img/icon/dark/dotnet.png';
import DarkGolang from '@img/icon/dark/golang.png';
import DarkJava from '@img/icon/dark/java.png';
import DarkJavascript from '@img/icon/dark/javascript.png';
import DarkNodejs from '@img/icon/dark/nodejs.png';
import DarkPhp from '@img/icon/dark/php.png';
import DarkPython from '@img/icon/dark/python.png';
import DarkRust from '@img/icon/dark/rust.png';
import DarkWasm from '@img/icon/dark/webassembly.png';

# Getting started

Welcome to SurrealDB! In this guide, you will learn about the various ways you can start using SurrealDB with interactive examples. Before we dive in, let's cover some basics.

## Running queries in SurrealDB

Much like any other database, you can communicate with SurrealDB by executing queries.

Queries are written using [SurrealQL](/docs/surrealql), SurrealDB's powerful and flexible query language. While SurrealQL takes inspiration from traditional SQL, it is designed to be more expressive and flexible, allowing you to query your data in a variety of ways.

Let's take a look at some of the basic queries you can run in SurrealDB.

{/* There are two main ways to use SurrealQL:

1. **Surrealist**: A graphical user interface (GUI) that can be accessed via a web browser or used as a desktop application.
2. **SurrealDB CLI**: A command-line interface that allows you to interact with SurrealQL directly from the terminal.

For more information, you can visit [Surrealist](https://Surrealist.app) and the [SurrealDB CLI documentation](/docs/surrealdb/cli/). */}

{/* <Tabs groupId="running-surrealql">
  <TabItem value="npm" label="Using Surrealist" default>

Once you have your database running, head over to [Surrealist](https://Surrealist.app). Surrealist offers a simple interface to run SurrealQL queries. You can run queries, view the results, and even save your queries for later use. To start running queries, you can either [set up a connection using your database credentials](/docs/surrealist/getting-started#creating-a-connection) or [use a sandbox](/docs/surrealist/getting-started#using-the-sandbox) which uses the default credentials.

For the sake of this guide, we recommend using a sandbox connection. Once you have set up your connection, you can run your queries in the query editor.

</TabItem>
<TabItem value="CLI" label="Using CLI">
Once you have your [database running](/docs/surrealdb/cli/start), you can use the [SurrealDB CLI](/docs/surrealdb/cli/) to run your queries. To do so, run the following commands:

1. Running without relying on an external server

```bash
surreal sql --endpoint memory --ns namespace --db database --pretty
```

2. Running with a specific endpoint, username, and password, and namespace, and database, run the following command:

```bash
surreal sql --endpoint http://localhost:8000 --username root --password root --namespace test --database test
```


> [!NOTE]
> The `--endpoint` flag is the URL of your SurrealDB instance. The `--username` and `--password` flags are the credentials you set when you started the database. The `--namespace` and `--database` flags are the namespace and database you want to connect to. The values above can be set to your preference. Learn more about this in the [Start command](/docs/surrealdb/cli/start) documentation.


Once you see the `>`character you can type your SurrealQL query, followed by the enter key. The command has support for `↑` and `↓` arrows for selecting previous SurrealQL statements, and stores the statement history in a history.txt file. To exit the REPL use the `ctrl + c` or `ctrl + d` key combinations.
</TabItem>
</Tabs> */}




{/* ## Start the database

First ensure that your database is set up correctly. To do so, run:

```bash
surreal version
```
To start your database, run the start command specific to your machine.

### macOS or Linux

```bash
surreal start memory -A --user root --pass secret
```
### Windows

```shell
surreal.exe start memory -A --user root --pass secret
```

Here's what each segment of this command does:

- `surreal start`: This initiates the process of starting the SurrealDB database server.
- `-A`: Enable all capabilities.
- `--user root --pass secret`: These flags set the initial username and password to access the database. Here both are set as root. Once the initial credentials are created, they are persisted in the datastore, which means you don't have to include the command line arguments next time you start SurrealDB. Instead, they should be securely stored in [environment variables](/docs/surrealdb/cli/env) or some form of secret management system.
- `memory`: This argument indicates that the database should be run in memory. Databases run in memory can have quicker data access times because they're not reading and writing from disk, but the data will be lost when the server is restarted. 
*/}

### Creating data with CREATE

Before we can start querying data, we need to create some records. This can be done using the [CREATE statement](/docs/surrealql/statements/create), which is used to add new records to the database.

The following example demonstrates how to create a record in the `category` table, initialized with a `name` field and a `created_at` field. Press the *"Run query"* button to execute the query and view the response.

<br /> 

<SurrealistMini
	resultMode="single"
	query={`
		CREATE category SET
			name = 'Technology',
			created_at = time::now();
	`}
/>

After executing this statement, the `category` record is created in the database, and a randomly generated unique id known as a [Record ID](/docs/surrealql/datamodel/ids) is assigned to it. This ID represents the primary key of our record, and can be used to reference the record in future queries.

When creating records, you can also explicitly set the record ID. This can be useful when you want to reference a specific record in your queries. In the following example, we create a person record with the ID `john`, and set the `name`, `age`, `admin`, and `signup_at` fields.

<br />

<SurrealistMini
	resultMode="single"
	query={`
		CREATE person:john SET
			name.first = 'John',
			name.last = 'Adams',
			name.full = string::join(' ', name.first, name.last),
			age = 29,
			admin = true,
			signup_at = time::now();
	`}
/>

One of the many powerful features of SurrealDB is the ability to write subqueries, which in the following example is used to populate the `category` field of the `article` record with the ID of the `Technology` category.

<br />

<SurrealistMini
	resultMode="single"
	setup={`
		CREATE category SET name = 'Technology', created_at = time::now();
		CREATE person:john SET
			name.first = 'John',
			name.last = 'Adams',
			name.full = string::join(' ', name.first, name.last),
			age = 29,
			admin = true,
			signup_at = time::now();
	`}
	query={`
		CREATE article SET
			created_at = time::now(),
			author = person:john,
			title = 'Lorem ipsum dolor',
			text = 'Donec eleifend, nunc vitae commodo accumsan, mauris est fringilla.',
			category = (SELECT VALUE id FROM ONLY category WHERE name = 'Technology' LIMIT 1);
	`}
/>

### Querying data with SELECT

After inserting records into your database, you can now use the [SELECT statement](/docs/surrealql/statements/select) to retrieve data. This statement will be familiar to anyone who has used traditional SQL before, however SurrealDB's SELECT statement includes additional powerful features inspired by NoSQL databases.

For example, in addition to selecting records from a single table, you can also select records from multiple tables, or select specific records by their Record ID.

<br />

<SurrealistMini
	setup={`
		CREATE category SET name = 'Technology', created_at = time::now();
		CREATE person:john SET
			name.first = 'John',
			name.last = 'Adams',
			name.full = string::join(' ', name.first, name.last),
			age = 29,
			admin = true,
			signup_at = time::now();
		CREATE article SET
			created_at = time::now(),
			author = person:john,
			title = 'Lorem ipsum dolor',
			text = 'Donec eleifend, nunc vitae commodo accumsan, mauris est fringilla.',
			category = (SELECT VALUE id FROM ONLY category WHERE name = 'Technology' LIMIT 1);
	`}
	query={`
		-- Select all records from a table
		SELECT * FROM article;

		-- Select records from multiple tables
		SELECT * FROM category, person;

		-- Selecting specific records
		SELECT * FROM person:john;
	`}
/>

The [SELECT statement](/docs/surrealql/statements/select) offers a variety of different features, such as the ability to filter on fields, fetch and resolve record id contents, and the ability to access data directly from Record IDs without the need of JOINs or complex queries.

The following query combines multiple of such features:
- **Filtering**: We use the `WHERE` clause to only include records where the author's age is less than 30.
- **Fetching**: We can use the `FETCH` clause to replace record ids with their actual record values.
- **Specific fields**: We only want to retrieve the title and author fields from the article table.
- **Record links**: We use `author.name.full` to directly access the full name of the author.

<SurrealistMini
	resultMode="single"
	setup={`
		CREATE category SET name = 'Technology', created_at = time::now();
		CREATE person:john SET
			name.first = 'John',
			name.last = 'Adams',
			name.full = string::join(' ', name.first, name.last),
			age = 29,
			admin = true,
			signup_at = time::now();
		CREATE article SET
			created_at = time::now(),
			author = person:john,
			title = 'Lorem ipsum dolor',
			text = 'Donec eleifend, nunc vitae commodo accumsan, mauris est fringilla.',
			category = (SELECT VALUE id FROM ONLY category WHERE name = 'Technology' LIMIT 1);
	`}
	query={`
		SELECT title, category, author.name.full AS author_name FROM article
		WHERE author.age < 30
		FETCH category;
	`}
/>

### Modifying data with UPDATE

{/* Similar to other databases, SurrealDB allows you to update records using the [`UPDATE` statement](/docs/surrealql/statements/update). You can also update specific IDs, for example say you wanted to update the first name of a specific person you can simply run: */}

Records can be updated using the [UPDATE](/docs/surrealql/statements/update) statement, which allows you to modify the contents of existing records.

Much like the `SELECT` statement, you can pass both table names and individual record IDs to the `UPDATE` statement. This allows you to update specific records, or update multiple records at once.

<SurrealistMini
	resultMode="single"
	setup={`
		CREATE category SET name = 'Technology', created_at = time::now();
		CREATE person:john SET
			name.first = 'John',
			name.last = 'Adams',
			name.full = string::join(' ', name.first, name.last),
			age = 29,
			admin = true,
			signup_at = time::now();
		CREATE article SET
			created_at = time::now(),
			author = person:john,
			title = 'Lorem ipsum dolor',
			text = 'Donec eleifend, nunc vitae commodo accumsan, mauris est fringilla.',
			category = (SELECT VALUE id FROM ONLY category WHERE name = 'Technology' LIMIT 1);
	`}
	query={`
		UPDATE person:john SET
			name.first = 'David',
			name.full = string::join(' ', name.first, name.last);
	`}
/>

The `UPDATE` statement offers a variety of features to further filter down records, and apply different update strategies. The following example demonstrates how we can merge new data into records matching a specific condition.

<br />

<SurrealistMini
	resultMode="single"
	setup={`
		CREATE category SET name = 'Technology', created_at = time::now();
		CREATE person:john SET
			name.first = 'David',
			name.last = 'Adams',
			name.full = string::join(' ', name.first, name.last),
			age = 29,
			admin = true,
			signup_at = time::now();
		CREATE article SET
			created_at = time::now(),
			author = person:john,
			title = 'Lorem ipsum dolor',
			text = 'Donec eleifend, nunc vitae commodo accumsan, mauris est fringilla.',
			category = (SELECT VALUE id FROM ONLY category WHERE name = 'Technology' LIMIT 1);
	`}
	query={`
		UPDATE person MERGE {
			age: 30,
			admin: false
		}
	`}
/>

In addition to the `UPDATE` statement, SurrealDB also offers an [UPSERT statement](/docs/surrealql/statements/upsert), which has the added functionality of creating a record if it does not already exist. This can be useful when you want to update a record if it exists, or create it if it does not.

### Deleting data with DELETE

Finally, you can delete records from your database using the [DELETE statement](/docs/surrealql/statements/delete). This statement allows you to remove records from your database, either by specifying the record ID, or by using specific conditions.

The following example demonstrates the use of the `RETURN` clause, which instructs SurrealDB to return the records before they are deleted.

<br />

<SurrealistMini
	resultMode="single"
	setup={`
		CREATE category SET name = 'Technology', created_at = time::now();
		CREATE person:john SET
			name.first = 'David',
			name.last = 'Adams',
			name.full = string::join(' ', name.first, name.last),
			age = 29,
			admin = true,
			signup_at = time::now();
		CREATE article SET
			created_at = time::now(),
			author = person:john,
			title = 'Lorem ipsum dolor',
			text = 'Donec eleifend, nunc vitae commodo accumsan, mauris est fringilla.',
			category = (SELECT VALUE id FROM ONLY category WHERE name = 'Technology' LIMIT 1);
	`}
	query={`
		DELETE article WHERE author.name.first = 'David' RETURN BEFORE;
	`}
/>

Congratulations, you're now on your way to database and API simplicity! For the next steps, we will explore the different ways to integrate SurrealDB into your applications.

## Integrating SurrealDB

SurrealDB is built to be flexibile and versatile. This means it can be integrated into your applications in a variety of ways, depending on your needs and requirements. Let's explore some of the different ways you can start using SurrealDB.

### Getting started via SurrealDB Cloud 

{/* [SurrealDB Cloud ](/docs/cloud) transforms the database experience, providing the power and versatility of SurrealDB without the complexity of managing infrastructure. Whether you’re building for passion projects or enterprise-scale applications offers the scalability, resilience, and innovation you need to stay ahead.

Enjoy a fully managed solution that takes the hassle out of infrastructure operations. With SurrealDB’s ACID compliance, you can confidently run transactions at scale across multiple environments, ensuring data integrity and reliability.

To get started with SurrealDB Cloud , head over to the [SurrealDB Cloud Dashboard](https://app.surrealdb.com/Signup) on Surrealist our management dashboard and sign up for a free account. You can also refer to the [SurrealDB Cloud documentation](/docs/cloud) for more information on how to get started with your free Instance. */}

[SurrealDB Cloud ](/docs/cloud) is the easiest way to get up and running with SurrealDB. It provides a fully managed solution that takes the hassle out of infrastructure operations, allowing you to focus on building your application.

To get started with SurrealDB Cloud , you can [sign up for a free account](https://app.surrealdb.com/cloud) and create a free instance. Once you have created your account, you can effortlessly provision your first Cloud Instance and integrate it into your application.

<a
	href="/docs/cloud/getting-started"
	class="gradient-button group mt-2 mb-6"
>
	Get started with SurrealDB Cloud 
	<Icon name="fa6-solid:arrow-right" class="w-4 transition-transform group-hover:translate-x-1" />
</a>

#### Additional resources

- [Create a Cloud Account](/docs/cloud/getting-started/create-an-account)
- [Create a Cloud Instance](/docs/cloud/getting-started/create-an-instance)
- [Connect to your Cloud Instance](/docs/cloud/connect)

### Getting started via an SDK 

SurrealDB offers SDKs for a variety of programming languages, allowing you to interact with SurrealDB from your application.
Depending on the language you are using, you can also use SDKs to embed SurrealDB directly in your application, either running as an in-memory database, or persisting data to disk.

Each SDK has its own set of methods and features, so be sure to refer to the documentation for the language you are using.
Follow the links below to learn more about integrating SurrealDB in your desired programming language:

<div class="flex gap-4 pt-2 pb-2 flex-wrap">
	<IconLink
		href="/docs/sdk/rust/setup"
		icon={{ light: LightRust, dark: DarkRust }}
	/>
	<IconLink
		href="/docs/sdk/javascript/start"
		icon={{ light: LightJavascript, dark: DarkJavascript }}
	/>
	<IconLink
		href="/docs/sdk/javascript/engines/node"
		icon={{ light: LightNodejs, dark: DarkNodejs }}
	/>
	<IconLink
		href="/docs/sdk/javascript/engines/wasm"
		icon={{ light: LightWasm, dark: DarkWasm }}
	/>
	<IconLink
		href="/docs/sdk/java/start"
		icon={{ light: LightJava, dark: DarkJava }}
	/>
	<IconLink
		href="/docs/sdk/golang/start"
		icon={{ light: LightGolang, dark: DarkGolang }}
	/>
	<IconLink
		href="/docs/sdk/python"
		icon={{ light: LightPython, dark: DarkPython }}
	/>
	<IconLink
		href="/docs/sdk/dotnet/start"
		icon={{ light: LightDotnet, dark: DarkDotnet }}
	/>
	<IconLink
		href="/docs/sdk/php/setup"
		icon={{ light: LightPhp, dark: DarkPhp }}
	/>
</div>

#### Additional resources

- [SDKs](/docs/surrealdb/integration/sdks)
- [Querying via SDKs](/docs/surrealdb/querying/sdks)

### Getting started by installing SurrealDB

One of the most popular ways to get started with SurrealDB is to install and run it as a standalone database service, allowing any number of clients to connect to it and interact with the data.
When starting SurrealDB through the command line, you can fully customize the database to your needs.

<a
	href="/docs/surrealdb/installation"
	class="gradient-button mt-2 mb-6"
>
	Install SurrealDB
	<Icon name="fa6-solid:download" class="w-4" />
</a>

After you have installed SurrealDB, you can start the database using the [`surreal start`](/docs/surrealdb/cli/start) command provided by the [SurrealDB CLI](/docs/surrealdb/cli).

When you start the database, you must specify which storage engine to use. This can be done by providing the engine as as the connection URL protocol. The following examples demonstrate how to start SurrealDB using different storage engines.

<Tabs groupId="node-package-manager">
  <TabItem value="memory" label="In-Memory">
    ```bash
    surreal start memory
    ```
  </TabItem>
  <TabItem value="surrealkv" label="Single Node On-Disk SurrealKV" default>
    ```bash
	# Without versioning (temporal queries)
    surreal start -u root -p root surrealkv://mydb

	# With versioning
	surreal start -u root -p root surrealkv+versioned://mydb
    ```
  </TabItem>
  <TabItem value="rocksdb" label="Single Node On-Disk rocksDB">
    ```bash
    surreal start -u root -p root rocksdb://mydb
    ```
  </TabItem>
  <TabItem value="tikv" label="Multi-Node Scalable Cluster">
    ```bash
   surreal start tikv://127.0.0.1:2379
    ```
  </TabItem>
</Tabs>

> [!NOTE]
> The `-u` and `-p` flags are used to set the username and password for the database. The username and password are set to `root` by default if not specified.

#### Additional resources
- [Running Disk based](/docs/surrealdb/installation/running/file)
- [Running Multi-Node Scalable Cluster](/docs/surrealdb/installation/running/tikv)
- [Running In-Memory](/docs/surrealdb/installation/running/memory)
- [Running with Docker](/docs/surrealdb/installation/running/docker)

## Continue learning

By completing this guide you have successfully learnt the basics of SurrealQL and started your journey integrating SurrealDB into your application. To continue learning about SurrealDB, visit [SurrealDB University](/learn/fundamentals), and for more examples and guides, refer to the [SurrealQL documentation](/docs/surrealql). 

<a
	href="/learn"
	class="gradient-button group mt-2 mb-6"
>
	Explore SurrealDB University
	<Icon name="fa6-solid:arrow-right" class="w-4 transition-transform group-hover:translate-x-1" />
</a>



================================================
FILE: src/content/doc-surrealdb/introduction/concepts/database.mdx
================================================
---
sidebar_position: 2
sidebar_label: Database
title: Database | Root
description: This page aims to give details about some of the core concepts of SurrealDB, including the intended usecases, design choices, and overarching features.
---

# Database

A database within SurrealDB is contained within a [namespace](/docs/surrealdb/introduction/concepts/namespace) and is the primary unit where data is stored. Databases hold the actual data tables, indexes, and other data structures. Each database can have its own schema, settings, and permissions. The database is where you perform most of the data operations like CRUD (Create, Read, Update, Delete) operations, queries, and transactions.

## Database structure

Databases are defined using the [`DEFINE DATABASE`](/docs/surrealql/statements/define/database) statement in SurrealQL. The statement requires a unique name for the database and can optionally include a comment for additional context. The following is the syntax for defining a database:

```syntax title="SurrealQL Syntax"
DEFINE DATABASE [ OVERWRITE | IF NOT EXISTS ] @name [ COMMENT @string ]
```

You can also view the list of databases in your SurrealDB instance using the [`INFO`](/docs/surrealql/statements/info) statement. This statement provides information about the accesses, analyzers, functions, params, tables and users present in the current database instance.

```surql
{
	analyzers: {},
	functions: {},
	models: {},
	params: {},
	scopes: {},
	tables: {},
	tokens: {},
	users: {}
}
```

## Requirements

- You must be authenticated as a root, namespace, or database user before you can use the `DEFINE DATABASE` statement.

## Learn more

To learn more about databases and how to use them in SurrealDB, refer to the [`DEFINE DATABASE`](/docs/surrealql/statements/define/database).



================================================
FILE: src/content/doc-surrealdb/introduction/concepts/index.mdx
================================================
---
sidebar_position: 4
sidebar_label: Concepts
title: Concepts | Introduction
description: This page aims to give details about some of the core concepts of SurrealDB, including the intended usecases, design choices, and overarching features.
---

# Concepts

This page aims to give details about some of the core concepts of SurrealDB, including the intended usecases, design choices, and overarching features.

## Traditional database or backend layer
SurrealDB can be used either as a traditional database platform, with backend languages and frameworks including Golang, Python, Rust, C, Java, .NET, Node.js, and PHP. Alternatively, you can use SurrealDB as a complete backend platform, connecting directly to it from frontend languages and frameworks including JavaScript, [WebAssembly](https://webassembly.org/), [React.js](https://react.dev/), [Next.js](https://nextjs.org/), and [Ember.js](https://emberjs.com/). In this mode, permissions can be defined on a table, record, and field level, allow for granular data access patterns for multiple different types of users.

## Relational, document, or graph
SurrealDB is, at its core, a document database. Each record is stored on an underlying key-value store storage engine, with the ability to store arbitrary arrays, objects, and many other types of data. However, SurrealDB isn't just a document database. Because of the way that SurrealDB handles Record IDs and the fetching of individual records from the underlying key-value storage engine, it can be used to store time-series ordered data, and highly-connected graph data. With the addition of an SQL-like query language (named [SurrealQL](/docs/surrealql)), it is easy to create, update, and read data from across the database.

## Single-node or distributed
SurrealDB is designed to be run in many different ways, and environments. Due to the [separation of the storage and compute layers](/docs/surrealdb/introduction/architecture), SurrealDB can be run in embedded mode, as a vertically-scalable, single-node database server, or as a horizontally-scalable, multi-node, distributed cluster. In embedded mode, SurrealDB can be run with an in-memory storage engine, in a web browser it can persist data using [IndexedDB](https://web.dev/indexeddb/), or it can persist data using the file-based [RocksDB](https://rocksdb.org/) storage engine. As a database server, SurrealDB can currently be configured to store data using [RocksDB](https://rocksdb.org/) or [TiKV](https://tikv.org/) in distributed mode.

## System structure
SurrealDB works similarly to other traditional relational databases, and document databases, with a few slight differences. SurrealDB is designed and developed to be a multi-tenant database platform with a high-level [`namespace`](/docs/surrealql/statements/define/namespace) layer designed as a separation for each organisations, department, or development team. There is no limit to the number of namespaces on SurrealDB. Below this, the [`databases`](/docs/surrealql/statements/define/database) layer is similar to databases in other database management systems. There is no limit to the number of databases on each namespace. Within each database, data can be stored within [`table`](/docs/surrealql/statements/define/table) definitions, otherwise known as collections in other database management systems. In SurrealDB each row or document is called a [`record`](/docs/surrealql/datamodel/ids) and columns are called [`fields`](/docs/surrealql/statements/define/field). While you can [`define`](/docs/surrealql/statements/define):

- [`namespace`](/docs/surrealql/statements/define/namespace)
- [`databases`](/docs/surrealql/statements/define/database)
- [`table`](/docs/surrealql/statements/define/table)
- [`fields`](/docs/surrealql/statements/define/field)

You cannot define [`records`](/docs/surrealql/datamodel/ids), you can only [create](/docs/surrealql/statements/create), read, [update](/docs/surrealql/statements/update) and [delete](/docs/surrealql/statements/delete) them.

Multiple [access](/docs/surrealql/statements/define/access) methods can be defined on `namespace` and `database`. The [record](/docs/surrealql/statements/define/access/record) access method allows for custom authentication across tables, records, and fields.



================================================
FILE: src/content/doc-surrealdb/introduction/concepts/namespace.mdx
================================================
---
sidebar_position: 1
sidebar_label: Namespace
title: Namespace | Root
description: This page aims to give details about some of the core concepts of SurrealDB, including the intended usecases, design choices, and overarching features.
---

import SurrealistMini from "@components/SurrealistMini.astro";

# Namespace

A namespace in SurrealDB acts as a higher-level container that can hold multiple databases. It is primarily used for organizing and isolating databases within the same SurrealDB instance. This is particularly useful in multi-tenant environments where different applications or groups might need to operate independently within the same server or cluster.

Namespaces help in managing permissions and access at a broader level than individual databases.
There is no limit to the number of namespaces on SurrealDB and each namespace can have its own set of databases, tables, and records.

## Namespace structure

Namespaces are defined using the [`DEFINE NAMESPACE`](/docs/surrealql/statements/define/namespace) statement in SurrealQL. The statement requires a unique name for the namespace and can optionally include a comment for additional context. The following is the syntax for defining a namespace:

```syntax title="SurrealQL Syntax"
DEFINE NAMESPACE [ OVERWRITE | IF NOT EXISTS ] @name [ COMMENT @string ]
```

You can also view the list of namespaces in your SurrealDB instance using the [`INFO`](/docs/surrealql/statements/info) statement. This statement provides information about the accesses, databases, and users present in the current SurrealDB instance.

Using the [`NAMESPACE`](/docs/surrealql/statements/info) or [`NS`](/docs/surrealql/statements/info) keyword.

```syntax title="SurrealQL Syntax"
INFO FOR [ NS | NAMESPACE ];
```


By running the command above, you will get info ONLY about the current namespace in your SurrealDB instance.
```surql
{
	databases: {},
	accesses: {},
	users: {}
}
```

Once a namespace has been defined, the command below you will get a list of all the namespaces in your SurrealDB instance. We are still using the [`INFO`](/docs/surrealql/statements/info) statement, but we are asking for the info for [`ROOT`](/docs/surrealql/statements/info). The output will include the namespace name, a list of root users, and various other high-level info.

```syntax title="SurrealQL Syntax"
INFO FOR ROOT;
```

```surql
[
	{
		accesses: {},
		namespaces: {},
		nodes: {
			"0e87c953-68d7-40e1-9090-3dfc404af25e": 'NODE 0e87c953-68d7-40e1-9090-3dfc404af25e SEEN 1742869518357 ACTIVE'
		},
		system: {
			available_parallelism: 14,
			cpu_usage: 4.321133613586426f,
			load_average: [
				2.2265625f,
				2.2138671875f,
				2.044921875f
			],
			memory_allocated: 13428527,
			memory_usage: 154812416,
			physical_cores: 14,
			threads: 32
		},
		users: {
			root: "DEFINE USER root ON ROOT PASSHASH '...' ROLES OWNER DURATION FOR TOKEN 1h, FOR SESSION NONE"
		}
	}
];
```

Let's go ahead and list info about the SurrealDB instance and also about the current namspace from the [`demo dataset`](/docs/surrealql/demo).



<SurrealistMini url='https://app.surrealdb.com/mini?query=INFO%20FOR%20ROOT%3B%0A%0AINFO%20FOR%20NAMESPACE%3B%0A--%20or%0A--%20INFO%20FOR%20NS%3B%0A%0A%0A%0A%0A%0A&dataset=surreal-deal-store&orientation=horizontal'/>


Let's go ahead and create our own namespace called `acme` using the [`DEFINE NAMESPACE`](/docs/surrealql/statements/define/namespace) and list the namespaces in the SurrealDB instance.


<SurrealistMini url='https://app.surrealdb.com/mini?query=--%20Creating%20Namespace%0ADEFINE%20NAMESPACE%20acme%3B%0A%0A--%20Listing%20the%20Root%0AINFO%20FOR%20ROOT%3B%0A%0A%0A%0A%0A%0A&dataset=surreal-deal-store&orientation=horizontal'/>


Now that we have the `acme` namespace in the SurrealDB instance we can now switch to use that namespace using the [`USE`](/docs/surrealql/statements/use).


<SurrealistMini url='https://app.surrealdb.com/mini?query=--%20Creating%20Namespace%0ADEFINE%20NAMESPACE%20acme%3B%0A%0A--%20Use%20the%20Namespace%0AUSE%20NAMESPACE%20acme%3B%0A%0A--%20Listing%20the%20Namespace%0AINFO%20FOR%20NAMESPACE%3B%0A%0A%0A%0A%0A%0A&dataset=surreal-deal-store&orientation=horizontal'/>


Since we just created the new `acme` namespace, it is empty and does not have any databases, tokens, or users. You can now create databases, tokens, and users within the `acme` namespace.

## Requirements

- You must be authenticated as a root or namespace user before you can use the `DEFINE NAMESPACE` statement.

## Learn more

To learn more about namespaces and how to use them in SurrealDB, refer to the [SurrealQL documentation](/docs/surrealql/statements/define/namespace).



================================================
FILE: src/content/doc-surrealdb/migrating/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Migrating from
title: Migrating from
description: "Migrating from"
---

# Migrating from other databases and data types to SurrealDB

This section details how to map data, queries and concepts you may know from other databases into SurrealDB.

## Pages

Each of these pages provides some examples of equivalent or similar SurrealQL queries and patterns to those you may already know from another database.

* [Migrating from Neo4J to SurrealDB](/docs/surrealdb/migrating/neo4j)
* [Migrating from PostgreSQL to SurrealDB](/docs/surrealdb/migrating/postgresql)

## Surreal Sync

The [Surreal Sync](/docs/integrations/data-management/surreal-sync) tool allows you to automatically import data from JSON lines, MongoDB, or Neo4J into a running SurrealDB instance.


================================================
FILE: src/content/doc-surrealdb/migrating/neo4j.mdx
================================================
---
sidebar_position: 2
sidebar_label: Neo4J
title: Migrating from Neo4J to SurrealDB
description: "How to map existing data and concepts from Neo4J to SurrealDB"
---

# Migrating from Neo4J to SurrealDB

This mapping guide focuses on the syntax that most closely resembles the Cypher query language.

To automatically migrate Neo4J data to SurrealDB, see the [Neo4J page](/docs/integrations/data-management/surreal-sync/neo4j) for the Surreal Sync tool.

## Concept mapping

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Neo4j</th>
            <th colspan="2" scope="col">SurrealDB</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Neo4j">
                database
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                database
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Neo4j">
                node label
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                table
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Neo4j">
                node
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                record
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Neo4j">
                node property
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                field
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Neo4j">
                index
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                index
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Neo4j">
                id
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                record id
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Neo4j">
                transactions
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                transactions
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Neo4j">
                relationships
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                record links, embedding and graph relations
            </td>
        </tr>
    </tbody>
</table>

## Syntax mapping

The following shows some CRUD examples using SurrealQL syntax.

### Create

As Neo4j is schemaless, only the SurrealQL schemaless approach is shown below. For a schemafull option see the [`DEFINE TABLE`](/docs/surrealql/statements/define/table) page.

For more SurrealQL examples, see the [`CREATE`](/docs/surrealql/statements/create), [`INSERT`](/docs/surrealql/statements/insert) and [`RELATE`](/docs/surrealql/statements/relate) pages.

Simple create/insert operations:

```surql
// Cypher
CREATE (John:Person {name:‘John’}), (Jane:Person {name: ‘Jane’})

// SurrealQL
// Table implicitly created if it doesn't exist
INSERT INTO person [ {id: “John”, name: “John”}, {id: “Jane”, name: “Jane”} ] 
```

Graph relations via the [RELATE](/docs/surrealql/statements/relate) statement:

```surql
// Cypher
MATCH (p:Person {name:‘Jane’}), (pr:Product {name:‘iPhone’}) CREATE (p)-[:ORDER]->(pr)

// SurrealQL
RELATE person:Jane->order->product:iPhone
```

Defining an index:

```surql
// Cypher
CREATE INDEX personNameIndex FOR (p:Person) ON (p.name)

// SurrealQL
DEFINE INDEX idx_name ON TABLE person COLUMNS name
```

### Read

For more SurrealQL examples, see the [`SELECT`](/docs/surrealql/statements/select), [`LIVE SELECT`](/docs/surrealql/statements/live) and [`RETURN`](/docs/surrealql/statements/return) pages.

Returning all the fields of a table:

```surql
// Cypher
MATCH (p:Person) RETURN p

// SurrealQL
SELECT * FROM person
```

Returning a single field of a table:

```surql
// Cypher
MATCH (p:Person) RETURN p.name

// SurrealQL
SELECT name FROM person
```

Using the `WHERE` clause to return certain records:

```surql
// Cypher
MATCH (p:Person) WHERE p.name = “Jane” RETURN p.name

// SurrealQL
SELECT name FROM person WHERE name = “Jane”
```

Using `EXPLAIN` to detail the query plan used:

```surql
// Cypher
EXPLAIN MATCH (p:Person) WHERE p.name = "Jane" RETURN p.name

// SurrealQL
SELECT name FROM person WHERE name = "Jane" EXPLAIN
```

Grouping and counting the number of records returned:

```surql
// Cypher
MATCH (p:Person) RETURN count(*) as person_count

// SurrealQL
SELECT count() AS person_count FROM person GROUP ALL
```

See all distinct values for a field among the records of a table:

```surql
// Cypher
MATCH (p:Person) RETURN distinct p.name

// SurrealQL
SELECT array::distinct(name) FROM person GROUP ALL
```

Returning up to a certain number of records:

```surql
// Cypher
MATCH (p:Person) RETURN p LIMIT 10

// SurrealQL
SELECT * FROM person LIMIT 10
```

See which `person` records have ordered a `product` via the `order` graph edge:

```surql
// Cypher
MATCH (p:Person)-[:ORDER]->(pr:Product) RETURN p.name, pr.name

// SurrealQL
SELECT name, ->order->product.name FROM person
```

### Update

For more SurrealQL examples, see the [`UPDATE`](/docs/surrealql/statements/update) page.

Conditionally updating records that have a certain value for a field:

```surql
// Cypher
MATCH (p:Person)  WHERE p.name = "Jane"  SET p.last_name = 'Doe'  RETURN p

// SurrealQL
UPDATE person SET last_name = "Doe" WHERE name = "Jane"
```

Unsetting (removing) the value of a field for certain records:

```surql
// Cypher
MATCH (p:Person)   WHERE p.name = "Jane"   REMOVE p.last_name RETURN p

// SurrealQL
UPDATE person UNSET last_name WHERE name = "Jane"
```

### Delete

For more SurrealQL examples, see the [`DELETE`](/docs/surrealql/statements/delete) and [`REMOVE`](/docs/surrealql/statements/remove) pages.

Conditionally deleting records based on the value of a field:

```surql
// Cypher
MATCH (p:Person)  WHERE p.name = "Jane"  DELETE p

// SurrealQL
DELETE person WHERE name = "Jane"
```

Deleting all records for a table (SurrealQL: table still exists):

```surql
// Cypher
MATCH (p:Person)  DELETE p

// SurrealQL
DELETE person
```

Deleting all records and table definition for a table:

```surql
// Cypher
MATCH (p:Person)  DELETE p

// SurrealQL
REMOVE TABLE person
```

## Resources

- [Neo4J page on Surreal Sync](/docs/integrations/data-management/surreal-sync/neo4j), a tool to automatically import existing data into a running SurrealDB instance
- [`RELATE` statement documentation](/docs/surrealql/statements/relate)


================================================
FILE: src/content/doc-surrealdb/migrating/postgresql.mdx
================================================
---
sidebar_position: 3
sidebar_label: PostgreSQL
title: Migrating from PostgreSQL to SurrealDB
description: "How to map existing data and concepts from PostgreSQL to SurrealDB"
---

# Migrating from PostgreSQL to SurrealDB

This page details some common PostgreSQL patterns and their SurrealQL equivalents.

## Inserting data

```surql
// PostgreSQL
INSERT INTO product
    (name, description, price, category, images, options)
    VALUES
    ("Shirt", "Slim fit", 6, "clothing", ARRAY['image1.jpg', 'image2.jpg', 'image3.jpg'])
;

// SurrealQL
CREATE product CONTENT {
    name: 'Shirt',
    id: 'shirt',
    description: 'Slim fit',
    price: 6,
    category: 'clothing',
    images: ['image1.jpg', 'image2.jpg', 'image3.jpg']
};
```

## Defining a schemafull table

A table in PostgreSQL might be defined as follows.

```surql
CREATE TABLE product (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    price NUMERIC(8,2),
    category TEXT,
    images TEXT[]
);
```

In SurrealQL, a table does not by default need to be defined before it can be used. However, the following statements will produce a strict schema similar to the PostgreSQL one above.

```surql
DEFINE TABLE product SCHEMAFULL;
DEFINE FIELD name ON TABLE product TYPE string;
DEFINE FIELD description ON TABLE product TYPE string;
DEFINE FIELD price ON TABLE product 
    TYPE number 
    // Only show two digits after decimal point
    VALUE math::fixed($value, 2) 
    // Price must be within this range
    ASSERT $value IN 0..=99999999;
DEFINE FIELD category ON TABLE product TYPE string;
DEFINE FIELD images ON TABLE product TYPE array<string>;
```

One difference between this and the PostgreSQL schema above is that a `product` will have a randomly generated ID as opposed to an incrementing one.

```surql
CREATE product SET 
    name = 'Shirt', 
    description = 'Nice shirt', 
    price = 20.449, 
    category = 'Clothing', 
    images = ["some_img.ping", "another_img.png"];

-- Output
[
	{
		category: 'Clothing',
		description: 'Nice shirt',
		id: product:1j29aq5q0do48k6xvyem,
		images: [
			'some_img.ping',
			'another_img.png'
		],
		name: 'Shirt',
		price: 20.45f
	}
]
```

### Selecting data

Selecting records using an ID:

```surql
// PostgreSQL
SELECT * FROM product WHERE id=1;

// SurrealQL
SELECT * FROM product:shirt;
```

Selecting multiple specific records:

```surql
// PostgreSQL
SELECT * FROM product WHERE id IN (1, 2, 3);

// SurrealQL
SELECT * FROM [product:1, product:2, product:3];
```

Counting the number of records in a table:

```surql
// PostgreSQL
SELECT COUNT(*) FROM product;

// SurrealQL
SELECT count() FROM product GROUP ALL;
```

### Queries with identical syntax

As the SurrealQL is inspired by SQL, many queries between it and PostgreSQL are identical.

```surql
SELECT * FROM product LIMIT 5;
SELECT name, price FROM product;
SELECT * FROM product ORDER BY price DESC;
SELECT * FROM order_item WHERE quantity = 2;
```

### Using record ID instead of the `WHERE` clause

If a record ID is known, be sure to query by the record ID itself instead of using a `WHERE` clause in SurrealQL. This will avoid a full table scan if the field is not indexed.

```surql
// PostgreSQL
SELECT * FROM product WHERE id = 1;

// This works in SurrealQL too...
SELECT * FROM product WHERE id = 1;
// But accessing the record directly will
// take a fraction of the time
product:1.*;
```

### Joining and querying related tables

Take the following query with joins in PostgreSQL:

```surql
SELECT p.id AS product_id, p.name AS product_name
FROM product p
JOIN order_item oi ON p.id = oi.product_id
JOIN customer_order co ON oi.order_id = co.order_id
JOIN customer c ON co.customer_id = c.customer_id
WHERE c.name = 'Pratim'
ORDER BY p.id;
```

In SurrealQL, tables can be joined to each other via edges, such as the `bought` edge in this example.

```surql
// Relate a 'customer' to a 'product' via 'bought'
RELATE customer:tobie->bought->product:iphone CONTENT {
    option: { Size: 'M', Color: 'Max' },
    quantity: 1,
    total: 600,
    status: 'Pending',
    created_at: time::now()
};
```

Once the tables have been related (joined), they can be queried with this syntax.

```surql
SELECT * FROM customer:tobie->bought;
```

An example of more complex query with joins to return all people who bought the same products as a certain customer (including the original customer).

```surql
// PostgreSQL
SELECT DISTINCT c.*
FROM customer c
JOIN customer_order co ON c.customer_id = co.customer_id
JOIN order_item oi ON co.order_id = oi.order_id
JOIN product p ON oi.product_id = p.id
WHERE p.id IN (
    -- Subquery: Get all product IDs bought by Tobie
    SELECT p2.id
    FROM product p2
    JOIN order_item oi2 ON p2.id = oi2.product_id
    JOIN customer_order co2 ON oi2.order_id = co2.order_id
    JOIN customer c2 ON co2.customer_id = c2.customer_id
    WHERE c2.name = 'Tobie'
)

// SurrealQL
customer:tobie->bought->product<-bought<-customer.*;
```


================================================
FILE: src/content/doc-surrealdb/models/document.mdx
================================================
---
sidebar_position: 1
sidebar_label: Document
title: Using SurrealDB as a Document Database | Data Models
description: In this guide, you will learn how to “think” in a document model database and show how SurrealDB helps you implement these concepts seamlessly.
---

import SurrealistMini from "@components/SurrealistMini.astro";
import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/mongodb.png";
import DarkLogo from "@img/icon/dark/mongodb.png";


# Using SurrealDB as a Document Database

One of the most popular models of database is the document model database. It provides a flexible way to store data, allowing for nested structures and relationships to be stored within a single document.

In a document database, data is stored in the form of documents—which usually resemble JSON objects—rather than in rows and columns. 

This model offers a level of simplicity and flexibility that can be especially appealing when your data does not naturally fit into a strict tabular format or when the structure of your data frequently changes. 

Over the last decade, we have seen a surge of NoSQL databases such as [MongoDB](https://www.mongodb.com/), [CouchDB](https://couchdb.apache.org/), and [DynamoDB](https://aws.amazon.com/dynamodb/), all of which are in the broad category of document stores (although with varying specific features). 

But how do you “think” in a document model database? Thinking in a document model means orienting your data design around the entities as you naturally represent them in your applications, rather than forcing your data into normalized or heavily structured relational schemas. 

For example, you have a table called `users` in your application, the document model database will store user data (e.g., name, age, addresses) in a single JSON-like document. 

<SurrealistMini
	query={`CREATE users CONTENT {
    name: "Alice Smith",
    email: "alice@example.com",
    age: 29,
    addresses: [
        {
            type: "home",
            address_line: "123 Maple St",
            city: "Springfield",
            country: "USA"
        },
        {
            type: "work",
            address_line: "456 Oak Ave",
            city: "Metropolis",
            country: "USA"
        }
    ]
};`}
/>

By clicking the **Run query** button, you will see the following result:

```json
[
    {
        "id": "users:a2ndbh1hsquvkvthws09", 
        "name": "Alice Smith",
        "email": "alice@example.com",
        "age": 29,
        "addresses": [
            {
                "type": "home",
                "address_line": "123 Maple St",
                "city": "Springfield",
                "country": "USA"
            },
            {
                "type": "work",
                "address_line": "456 Oak Ave",
                "city": "Metropolis",
                "country": "USA"
            }
        ]
    }
]
```

You may notice that the `id` field has a `users:` prefix. This is because SurrealDB uses a [id](/docs/surrealql/datamodel/ids) to uniquely identify each record and the combination of the table name and the record id is used as the [record link](/docs/surrealql/datamodel/records).

In this guide, we will explore how to think in a document model database, in **SurrealDB**. We will also explore CRUD statements and how to query data in SurrealDB.


## What are the key features of a document model database?

Document model databases are designed to store data in a flexible, nested structure. They are often used for applications that require high performance, scalability, and flexibility.

1. **Data Organization**: Data is contained in self-describing documents, typically in JSON or a similar format. Relationships, can be done within the document itself (embedding) or references using [record links](/docs/surrealql/datamodel/records) to other documents.

2. **Schema Flexibility**: Schemas are often flexible, allowing for documents of varying shapes in the same collection (or table-like structure).

For example, if you wanted to associate a `person` with an `article` they wrote, you could do this by assigning the person's ID to the `author` field of the article document. This binds the `person` and `article` together, allowing you to query the `article` by the `person`'s ID.

<SurrealistMini
	url="https://app.surrealdb.com/mini?query=CREATE+article+SET%0A%09created_at+%3D+time%3A%3Anow%28%29%2C%0A%09author+%3D+person%3Ajohn%2C%0A%09title+%3D+%27Lorem+ipsum+dolor%27%2C%0A%09text+%3D+%27Donec+eleifend%2C+nunc+vitae+commodo+accumsan%2C+mauris+est+fringilla.%27%3B%0A%0ACREATE+person%3Ajohn+SET%0A%09name.first+%3D+%27John%27%2C%0A%09name.last+%3D+%27Adams%27%2C%0A%09name.full+%3D+string%3A%3Ajoin%28%27+%27%2C+name.first%2C+name.last%29%2C%0A%09age+%3D+29%2C%0A%09admin+%3D+true%2C%0A%09signup_at+%3D+time%3A%3Anow%28%29%0A%3B"
/>

## Concepts mapping

When thinking in a document model database, you will often find that the concepts are similar to those in SurrealDB. Below is a mapping of the most common concepts between a document model database and SurrealDB.

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Document Model</th>
            <th colspan="2" scope="col">SurrealDB</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="MongoDB">
              database
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                database
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MongoDB">
                collection
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                table
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MongoDB">
                document
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                record
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MongoDB">
                field
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                field
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MongoDB">
                index
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                index
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MongoDB">
                Objectid
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                record id
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MongoDB">
                transactions
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                transactions
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MongoDB">
                reference and embedding
            </td>
            <td colspan="2" scope="row" data-label="SurrealDB">
                record links, embedding and graph relations
            </td>
        </tr>
    </tbody>
</table>

## Benefits of using a document model database

1. **Flexibility**: You don’t need to define rigid schemas in advance. Changes to data structure are often just changes in the JSON object itself.

2. **Natural Data Representation**: Since you’re working with JSON-like objects, document databases align well with modern programming languages that manipulate data as objects or dictionaries.

3. **Simplicity of Application Code**: Because you can embed everything related to an entity in a single document, you often have fewer JOINs (or complex queries) and simpler code for retrieving complete objects.

4. **Easier Horizontal Scaling**: Many document databases are built for horizontal partitioning (sharding), making them easier to scale for large workloads.


## Creating and Managing Documents in SurrealDB

In SurrealDB, you can create a database and then store collections of documents (often referred to as “tables”) without strict schema definitions. Let’s walk through an example.

This is conceptually similar to creating a table in a relational database, but in SurrealDB you don’t necessarily need to define all columns upfront. Instead, you can just insert JSON-like objects.

### Adding a Document

```surql
CREATE users CONTENT {
    name: "Alice Smith",
    email: "alice@example.com",
    age: 29,
    addresses: [
        {
            type: "home",
            address_line: "123 Maple St",
            city: "Springfield",
            country: "USA"
        },
        {
            type: "work",
            address_line: "456 Oak Ave",
            city: "Metropolis",
            country: "USA"
        }
    ]
};
```

Here, we’ve created a user document with nested objects (`addresses`) in the same record. Notice how flexible this is: we can add as many nested objects or properties as we want, without having to modify any schema.

### Retrieving Documents

```surql
SELECT * FROM users;
```

The above query returns all documents in the `users` table, much like a traditional SQL `SELECT` statement. Because SurrealDB is multi-model, the returned data might look like:

```json
[
    {
        "id": "users:xyz123", 
        "name": "Alice Smith",
        "email": "alice@example.com",
        "age": 29,
        "addresses": [
            {
                "type": "home",
                "address_line": "123 Maple St",
                "city": "Springfield",
                "country": "USA"
            },
            {
                "type": "work",
                "address_line": "456 Oak Ave",
                "city": "Metropolis",
                "country": "USA"
            }
        ]
    }
]
```

SurrealDB automatically generates a unique [`id`](/docs/surrealql/datamodel/ids) for the document. You can also specify your own custom IDs if you prefer more human-readable or domain-specific identifiers.


## Using MongoDB Syntax as a reference

As a multi-model database, SurrealDB offers a lot of flexibility. Our SQL-like query language SurrealQL is a good example of this, where we often have more than one way to achieve the same result, depending on developer preference. In this mapping guide, we will focus on the syntax that most closely resembles the MongoDB query language (MQL).

## Syntax mapping

Let's get you up to speed with SurrealQL syntax with some CRUD examples.

### Create

As MongoDB is schemaless, only the SurrealQL schemaless approach is shown below. For a schemafull option see the [`DEFINE TABLE`](/docs/surrealql/statements/define/table) page.

For more SurrealQL examples, see the [`CREATE`](/docs/surrealql/statements/create) and [`INSERT`](/docs/surrealql/statements/insert) pages.

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">MQL</th>
            <th colspan="2" scope="col">SurrealQL</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.createCollection("person")
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                CREATE person
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.person.insertMany([&#123; name: "John" &#125;, &#123; name: "Jane" &#125;])
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                INSERT INTO person [ &#123;name: "John"&#125;, &#123;name: "Jane"&#125; ]
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.person.createIndex(&#123; name: 1 &#125;)
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                DEFINE INDEX idx_name ON TABLE person COLUMNS name
            </td>
        </tr>
    </tbody>
</table>

### Read

For more SurrealQL examples, see the [`SELECT`](/docs/surrealql/statements/select), [`LIVE SELECT`](/docs/surrealql/statements/live) and [`RETURN`](/docs/surrealql/statements/return) pages.

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">MQL</th>
            <th colspan="2" scope="col">SurrealQL</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.person.find()
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                SELECT * FROM person
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.person.find(&#123;&#125;, &#123; _id: 0, name: 1 &#125;)
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                SELECT name FROM person
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.person.find(&#123; name: "Jane" &#125;, &#123; _id: 0, name: 1 &#125;)
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                SELECT name FROM person WHERE name = "Jane"
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.person.find(&#123; name: "Jane" &#125;, &#123; _id: 0, name: 1 &#125;).explain()
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                SELECT name FROM person WHERE name = "Jane" EXPLAIN
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.person.aggregate([&#123; $count: "personCount" &#125;])
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                SELECT count() AS person_count FROM person GROUP ALL
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.person.aggregate([&#123; $group: &#123; _id: "$name" &#125; &#125;])
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                SELECT array::distinct(name) FROM person GROUP ALL
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.person.find().limit(10)
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                SELECT * FROM person LIMIT 10
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.review.aggregate([&#123; "$lookup": &#123; "from": "person", "localField": "person", "foreignField": "_id", "as": "person_detail" &#125; &#125;])
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                SELECT *, person.name as reviewer FROM review
            </td>
        </tr>
    </tbody>
</table>

### Update

For more SurrealQL examples, see the [`UPDATE`](/docs/surrealql/statements/update) page.

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">MQL</th>
            <th colspan="2" scope="col">SurrealQL</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.person.updateMany(&#123; name: "Jane" &#125;, &#123; $set: &#123; last_name: "Doe" &#125; &#125;)
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                UPDATE person SET last_name = "Doe" WHERE name = "Jane"
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.person.updateMany(&#123; name: "Jane" &#125;, &#123; $unset: &#123; last_name: 1 &#125; &#125;)
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                UPDATE person UNSET last_name WHERE name = "Jane"
            </td>
        </tr>
    </tbody>
</table>

### Delete

For more SurrealQL examples, see the [`DELETE`](/docs/surrealql/statements/delete) and [`REMOVE`](/docs/surrealql/statements/remove) pages.

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">MQL</th>
            <th colspan="2" scope="col">SurrealQL</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.person.deleteMany(&#123; name: "Jane" &#125;)
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                DELETE person WHERE name = "Jane"
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.person.deleteMany(&#123;&#125;)
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                DELETE person
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="MQL">
                db.person.drop()
            </td>
            <td colspan="2" scope="row" data-label="SurrealQL">
                REMOVE TABLE person
            </td>
        </tr>
    </tbody>
</table>


## Resources

- [`CREATE` statement](/docs/surrealql/statements/create)
- [`SELECT` statement](/docs/surrealql/statements/select)
- [`UPDATE` statement](/docs/surrealql/statements/update)
- [`DELETE` statement](/docs/surrealql/statements/delete)
- [`RELATE` statement](/docs/surrealql/statements/relate)
- [SurrealQL documentation](/docs/surrealql)
- [SurrealDB University](/learn)



================================================
FILE: src/content/doc-surrealdb/models/full-text-search.mdx
================================================
---
sidebar_position: 4
sidebar_label: Full Text Search
title: Using SurrealDB as a Full Text Search Database | Data Models
description: In this guide you will learn how to “think” in a full-text search model and show how SurrealDB helps you implement these concepts seamlessly.
---

> [!NOTE]
> Before SurrealDB version 3.0.0-alpha.8, the `FULLTEXT ANALYZER` clause used the syntax `SEARCH ANALYZER`.

# Using SurrealDB as a Full Text Search Database

A full-text search database is designed to index and retrieve text-based data (like articles, messages, or comments) based on the meaning and structure of the text itself, rather than exact, literal matches. This allows you to:

* Find documents containing certain keywords.
* Search for phrases or words with variants (e.g., “run,” “runs,” “running”).
* Rank results by relevance, not just by literal string matches.

Traditional relational databases have some limited text search capabilities (with varying degrees of support for text indexes), but more specialized systems—like Elasticsearch or Lucene-based solutions—excel at performing complex, scalable full-text queries.

As a new multi-model database, SurrealDB has developed integrated full-text search capabilities so that you can store your data (as documents, graphs, or tables) and query it with advanced text search features. This guide will explain how to “think” in a full-text search model and show how SurrealDB helps you implement these concepts seamlessly.

## Core Concepts of Full-Text Search

- **Analyzers**: In a robust full-text search system, analyzers define how the text is processed. An analyzer typically includes tokenizers (which split text) and filters (which modify tokens). Different languages or data types need different analyzers.

- **Tokenization**: Splits text into smaller units (“tokens”). Depending on your use case, tokens may be entire words, word stems, or even n-grams. For example, tokenizing the sentence “The quick brown fox.” might produce ["the", "quick", "brown", "fox"].

- **Filtering**: After splitting text into tokens, these tokens can be converted to lowercase, stripped of punctuation, or transformed (e.g., removing accents). Additional filters can include stemming or lemmatization, which reduce words to a base form (“running” -> “run”).

- **Indexing**: Full-text search engines build specialized data structures (inverted indexes, suffix arrays, etc.) to let you quickly locate documents containing certain tokens. These indexes often store frequency, position, and other details that enable relevance scoring.


- **Ranking / Scoring**: Once matches are found, an FTS engine ranks them to show the most relevant results first. Algorithms such as BM25 or TF-IDF look at how often terms appear in a document, or whether those terms appear in the title vs. the body, etc.

- **Highlighting** : A good search experience shows where in the text the matches occur, often by wrapping matched terms in HTML tags or otherwise emphasizing them.

## How Full-Text Search Differs from Keyword Matching

In traditional databases, you might do something like:

```surql
SELECT * FROM articles WHERE 'fox' IN title;
```

This approach:

- Doesn’t rank results by relevance—just returns every article containing “fox.”
- Ignores language variations, e.g., “Foxes,” “FoX,” or synonyms like “vixen.”
- Tends to scan entire columns, making it slower for large datasets.

Full-text search, by contrast, uses an inverted index or other specialized structures for fast lookups and can handle a variety of linguistic transformations. It can highlight results and rank them by how relevant or frequent the terms are.


## SurrealDB as a Full-Text Search Database
SurrealDB combines multi-model data storage (document, graph, vector, etc.) with an integrated full-text search engine. This means you can:

- Store your text in a SurrealDB table or document.
- Define analyzers that specify how SurrealDB will tokenize and filter your text.
- Define indexes that use those analyzers for full-text search, optionally with advanced features like BM25 scoring and highlighting.

## Advantages of SurrealDB for FTS

- **Unified Model**: You can keep your data, relationships, and search logic in a single engine.
- **Flexible Schema**: SurrealDB can be schemaless, so adding new fields or text columns doesn’t require schema migrations.
- **Powerful Query Language**: SurrealQL blends SQL-like syntax with searching syntax (the [`@@` matching operator](/docs/surrealql/operators#matches) for FTS queries, advanced indexing features, etc.).
- **Real-Time Updates**: SurrealDB can handle real-time changes, so newly inserted or updated text becomes searchable quickly.


### Creating and Managing Full-Text Search in SurrealDB
Below is an example of how you might define a table for “articles,” define an analyzer that lowercases and removes accents, and create a full-text index on the “title” and “body” fields:

```surql
USE NAMESPACE myapp DB content;

-- Create a table for articles (schemaless or define fields explicitly)
CREATE TABLE articles SCHEMALESS;

-- Define a custom analyzer
DEFINE ANALYZER my_custom_analyzer
  TOKENIZERS class
  FILTERS lowercase, ascii;

-- Create a full-text search index
-- Full-text search indexes are defined on a single field
DEFINE INDEX ml_title 
  ON TABLE article 
  FIELDS title 
  FULLTEXT ANALYZER my_analyzer 
  HIGHLIGHTS BM25;

DEFINE INDEX ml_body 
  ON TABLE article 
  FIELDS body 
  FULLTEXT ANALYZER my_analyzer 
  HIGHLIGHTS BM25;
```
With this setup:

- `my_custom_analyzer` splits text by Unicode class changes (letters, digits, punctuation) and then lowercases and removes accents, turning the string `"Look! Full-Text-Search"` for example into the final tokens `['look', '!', 'full', '-', 'text', '-', 'search' ]`.
- SurrealDB uses these tokens from the analyzer to build an inverted index over both the title and body fields.
- The BM25 scoring function is used to rank documents.
- `HIGHLIGHTS` are enabled, which allows SurrealDB to highlight matched terms in queries.

### Querying Full-Text Data

Assume you want to search for articles about “machine learning”, SurrealDB syntax might look like:

```surql
SELECT *,
  search::highlight("**", "**", 1) AS body,
  search::highlight("##", "", 0) AS title,
  search::score(0) + search::score(1) AS score
FROM article
WHERE title @0@ "machine"
   OR body @1@ "machine learning"
ORDER BY score DESC
LIMIT 10;
```

Explanation:

- `search::highlight(...)`: SurrealDB can highlight the matched terms in the text.
- `search::score()` works with the `BM25` ranking function to return the relevance score for the matched document.
- `@@ "machine learning"`: SurrealDB will check if the tokens “machine” and “learning” appear in the title field’s FTS index. The number in between the two characters of the operator lets the database know in the above functions which part of the query to highlight and calculate a score for. If no search functions are used, this operator will be used as `@@` without a number (e.g. `WHERE title @@ "machine" OR body @@ "machine learning").

## Resources 

- [Full Text Search reference guide](/docs/surrealdb/reference-guide/full-text-search), including comparison of Full Text Search to other methods
- [`DEFINE INDEX`](/docs/surrealql/statements/define/indexes)
- [`DEFINE ANALYZER`](/docs/surrealql/statements/define/analyzer)
- [Search functions](/docs/surrealql/functions/database/search)
    - `search::highlight`: Highlights the matching keywords for the predicate reference number.
    - `search::offsets`: Returns the position of the matching keywords for the predicate reference number.
    - `search::score`: Helps with scoring and ranking the search results based on their relevance to the search terms.
    - `search::analyze`: Used to test the output of a defined search analyzer.



================================================
FILE: src/content/doc-surrealdb/models/geospatial.mdx
================================================
---
sidebar_position: 6
sidebar_label: Geospatial
title: Using SurrealDB as a Geospatial Database | Data Models
description: In this guide, you will learn how to “think” in a geospatial model and show how SurrealDB helps you implement these concepts seamlessly.
---

# Using SurrealDB as a Geospatial Database

A geospatial database is specifically designed (or extended) to store and query data related to the Earth’s surface. Rather than just focusing on numeric or textual data, these systems handle coordinates, polygons, linestrings, and other spatial objects that define locations and shapes. Queries typically revolve around spatial relationships—like finding points within a boundary, measuring distances, or detecting intersections between shapes.

Historically, geospatial capabilities were mostly the domain of specialized systems such as PostGIS (an extension of PostgreSQL) or dedicated GIS software.  SurrealDB, offers geospatial features to unify location-related data with other data models (relational, document, graph, vector, etc.) under one roof.

In this guide, you’ll learn how to think like a geospatial database user. Rather than forcing location data into conventional numeric fields, you’ll represent it with geometry or geography types, index it in specialized structures, and leverage advanced queries (e.g., “Find all customers within 5 km of a store”). 


## Core Concepts of Geospatial Data

- **Coordinate Reference Systems (CRS)**
Geospatial coordinates can be stored in different projections. A popular one is WGS84 for latitude/longitude (EPSG:4326), used by GPS. Others exist for local or projected coordinate systems.

- **Geometry Types**

    - **Point**: Represents a single X/Y (or lon/lat) location.
    - **LineString**: Represents a line made of multiple coordinates.
    - **Polygon**: Represents an area boundary. May include holes (interior rings).
    - **MultiPoint, MultiLineString, MultiPolygon**: Collections of the above geometry types.

- **Spatial Relationships**
Common geospatial operations revolve around relationships like contains, intersects, within, touches, or disjoint.

- **Distance and Buffer**

    - **Distance**: The shortest path between two geometries (commonly in meters or kilometers for Earth-based coordinates).
    - **Buffer**: Expanding a geometry outward by a certain distance.

    - **Geohashes & Tiles**
    Some systems approximate location with geohash or tile-based indexing. This is especially useful for bounding box queries or hierarchical location lookups.


## Resources 

- [Geospatial Data Types](/docs/surrealql/datamodel/geometries)
- [Geospatial Functions](/docs/surrealql/functions/database/geo)
- [SurrealDB University](/learn/book/chapter-10)




================================================
FILE: src/content/doc-surrealdb/models/graph.mdx
================================================
---
sidebar_position: 2
sidebar_label: Graph / Record links
title:  Using SurrealDB as a Graph Database | Data Models
description: In this guide you will learn how to “think” in a graph database model and show how SurrealDB helps you implement these concepts seamlessly.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/neo4j.png";
import DarkLogo from "@img/icon/dark/neo4j.png";


# Using SurrealDB as a Graph Database

A graph database is specifically designed to store data as nodes and edges (relationships between nodes). With this model, connections are front and center, making it easier (and often faster) to query highly connected datasets—like [social networks](/blog/using-surrealdb-to-expose-organised-influence-campaigns), [planning and supply chain relationships](/docs/surrealdb/reference-guide/sample-industry-schemas#project-planning), recommendation engines, or [fraud detection graphs](/blog/fraud-detection-with-surrealdb).

When using SurrealDB as a graph database, we typically care about both the entities in a system and how they relate to each other. It might be a user that “follows” another user, a product that “belongs” to a category, or a web page that “links to” another page. These relationships are first-class citizens, rather than just foreign keys or nested objects. This can enable powerful, intuitive traversal-based queries that more accurately reflect real-world systems.

But how do you “think” in a graph database? Instead of focusing on how to break data into tables (relational) or embed data in documents (document model), you concentrate on expressing data as nodes and defining the edges that describe relationships. This mindset puts the connections at the core of your design: each data point is a node with properties, and edges hold properties too, representing the context or metadata about those relationships.

## Core Concepts of Graph-Oriented Modeling

In any graph database, you deal with three fundamental elements:

- **Nodes (Vertices)**: Represent main entities or “things”. In a social network for example, nodes might be people. In a knowledge graph, nodes might be concepts. In a product recommendation engine, nodes might be items or customers.

- **Edges**: Represent relationships between nodes. These could be `follows`, `buys`, `likes`, `friend_of`, `in_category`, etc. They often include properties like timestamps or weights.

- **Properties**: Both nodes and edges can contain key-value pairs (properties). For a `user` node, properties might be `name` or `age`. For a `likes` edge, a property might be `strength` to indicate how strong the affinity between users is.

When you think in a graph, the modeling process shifts toward identifying the main entities in your application (the nodes) and how they relate to one another (the edges). Rather than flattening these relationships into foreign keys or embedding them in nested structures, you give them explicit representation and, often, explicit properties.

## Modelling data as a graph

How this works in practice in most graph databases, is through semantic triples, which is a way to describe a graph in a three-part structure: 

- `subject -> predicate -> object`

OR

- `node -> edge -> node`

Another way to think about this is in terms of nouns connected by verbs, such that it forms a sentence.

- `noun -> verb -> noun`

OR

- `person -> order -> product`

## Creating Nodes and Edges in SurrealDB

### Creating Nodes

In SurrealDB, nodes are typically just records in a table—like users, posts, companies, etc. SurrealDB introduces a new statement called [`RELATE`](/docs/surrealql/statements/relate) using this three-part structure. 

Using the `RELATE` statement, we can create our primary relationships based on the major actions a person using our e-commerce store would take: wish list, cart, order and review. These will serve as our edge tables.

```surql
RELATE person:billy->wishlist->product:01HGAR7A0R9BETTCMATM6SSXPT;
RELATE person:vanessa->cart->product:01GXRS3FZG8Y8SDBNHMC14N25X;
RELATE person:loki->order->product:tesseract;
RELATE person:u1cczojntb5kvos2ugue->review->product:8g8ftj1mblza2vikm680;
```

Here, we are taking existing record IDs from the `person` and `product` tables. The edge tables stand in the middle of these, which will be newly created via these `RELATE` statements.

Once we run the `RELATE` statement, we’ll see two new fields on the edge tables: `in` and `out`. The `in` field contains the ID of the record on the left side of the statement, and `out` the ID of the record on the right. Another way of looking at the semantic triple is in thus in this three part structure:

- `in -> id -> out`

Where the first node is called `in`, the edge is the id, and the second node is `out`.

### Adding data to edge tables using `SET`  and `CONTENT`

What really sets SurrealDB apart from graph-only databases is that edges are also real tables, and thus allow you to store information in them.

```surql
RELATE person:j151lkm3k1dytd53y0i5->wishlist-> product:r5pgmgjmr57kjvm2j1g1
  SET time.created_at = time::now();

CREATE product:crystal_cave SET name = "The Crystal Cave", price = 5;
CREATE person:brian SET address = "555 Brian Street";
RELATE person:brian->order-> product:crystal_cave
  SET quantity = 2;
```

We can both create our `order` relationship and use it at the same time to fetch connected data from both the `product` and `person` tables.

```surql
SELECT 
    quantity, 
    out.name AS product_name,
    out.price * quantity AS price,
    in.address AS shipping_address
FROM order;
```

```surql title="Output"
[
  { 
    price: 10, 
    product_name: 'The Crystal Cave', 
    quantity: 2, 
    shipping_address: '555 Brian Street' 
  }
]
```

The final query above demonstrates how to access fields directly from an edge table. However, there is also a graph syntax that allows such queries to take place in between nodes and edges, even when starting from a node.

### Querying Graph Data in SurrealDB

Graph queries in SurrealDB use SurrealQL, which supports traversing relationships with special syntax. For example:

```surql
SELECT ->wrote->post.* AS userPosts
  FROM users:alice;
```

In this query:

FROM `users:alice` starts at the node identified by users:alice.
`->wrote->posts.*` instructs SurrealDB to traverse the wrote edge from alice to any posts node, returning the post(s) as userPosts. The `.*` at the end retrieves all the fields of linked `post` records.

You can also traverse in the reverse direction. If you’re starting from a post, you can see which user wrote it:

```surql
SELECT <-wrote<-author AS authors
  FROM post:helloworld;
```

Here, `<-wrote<-author` means “traverse any node that has a wrote edge pointing to this post”, effectively giving you the authors.

## When to use graph relations

The first item to take into account when using graph relations is whether they are the right solution in the first place, because graph edges are not the only way to link one record to another.

SurrealDB has two main ways to create relations between one record and another: record links, and graph relations.

A record link is a simple pointer from one record to another, a link that exists any time a record holds the record ID of another record. Record links are extremely efficient because record IDs are direct pointers to the data of a record, and do not require a table scan.

Take the following example that creates one `user` who has written two `comment`s.

```surql
LET $new_user = CREATE ONLY user SET name = "User McUserson";
-- Create a new comment, use the output to update the user
UPDATE $new_user SET comments += (CREATE ONLY comment SET 
    text = "I learned something new!", 
    created_at = time::now())
    .id;
UPDATE $new_user SET comments += (CREATE ONLY comment SET
    text = "I don't get it, can you explain?",
    created_at = time::now())
    .id;
```

Querying a record link is easy as the link by default is unidirectional with nothing in between. In this case, the linked comments are simply a field on a `user` record and accessing them is as simple as any other field on a `user` record.

```surql
SELECT 
    name, 
    comments.{ created_at, text }
FROM user;
```

```surql title="Output"
[
	{
		comments: [
			{
				created_at: d'2024-12-12T02:39:07.644Z',
				text: 'I learned something new!'
			},
			{
				created_at: d'2024-12-12T02:39:07.645Z',
				text: "I don't get it, can you explain?"
			}
		],
		name: 'User McUserson'
	}
]
```

In earlier versions of SurrealDB, record links were strictly unidirectional. The only way to query in the other direction was by using a subquery, which made graph edges the only easy option for bidirectional links.

```surql
SELECT 
    *,
    -- Check the `user` table's `comments` field
    -- for the id of the current comment
    (SELECT id, name FROM user WHERE $parent.id IN comments) AS author
FROM comment;

-- Equivalent graph query is much easier
-- to read and write
SELECT 
	*,
	<-wrote<-author
FROM comment;
```

```surql
[
	{
		author: [
			{
				id: user:f3t90z8uvns76sr3nxrd,
				name: 'User McUserson'
			}
		],
		created_at: d'2024-12-12T02:39:07.645Z',
		id: comment:gj1vtsd9d19z9afrc14j,
		text: "I don't get it, can you explain?"
	},
	{
		author: [
			{
				id: user:f3t90z8uvns76sr3nxrd,
				name: 'User McUserson'
			}
		],
		created_at: d'2024-12-12T02:39:07.644Z',
		id: comment:zhnbfopxspekknsi6vx6,
		text: 'I learned something new!'
	}
]
```

Since version 3.0.0-alpha.8, a record link can be bidirectional by [defining a field](/docs/surrealql/statements/define/field) with the `REFERENCE` clause, allowing referenced records to define a field or use a query to track incoming references.

```surql
DEFINE FIELD comments ON user TYPE option<array<record<comment>>> REFERENCE;
DEFINE FIELD author ON comment COMPUTED <~user;

LET $new_user = CREATE ONLY user SET name = "User McUserson";
-- Create a new comment, use the output to update the user
UPDATE $new_user SET comments += (CREATE ONLY comment:one SET 
    text = "I learned something new!", 
    created_at = time::now())
    .id;
UPDATE $new_user SET comments += (CREATE ONLY comment:two SET
    text = "I don't get it, can you explain?",
    created_at = time::now())
    .id;

-- 'author' field is populated with the 'user' who wrote the comment
SELECT * FROM ONLY comment:one;

-- Regular queries on incoming references work too
SELECT text, <~user.id[0] AS commenter FROM comment;
```

```surql title="Output"
-------- Query --------

{
	author: [
		user:igi77zrlewsqemgjz4zi
	],
	created_at: d'2025-09-02T02:56:03.408Z',
	id: comment:one,
	text: 'I learned something new!'
}

-------- Query --------

[
	{
		commenter: user:igi77zrlewsqemgjz4zi,
		text: 'I learned something new!'
	},
	{
		commenter: user:igi77zrlewsqemgjz4zi,
		text: "I don't get it, can you explain?"
	}
]
```

If your use case involves bidirectional links, consider the following items to make a decision.

Record links are preferred if:

* Performance is of the utmost importance.
* You don't need to put complex queries together.
* You want to specify in the schema what behaviour should take place when a linked record is deleted (cascade delete, refuse to delete, ignore, etc.).

Graph links are preferred if:

* You want to quickly create links without touching the database schema, or among multiple record types. For example, a single `RELATE person:one->wrote->[blog:one, book:one, comment:one]` is enough to create links between a `person` and three other record types, whereas using record links may be a more involved process involving several `DEFINE FIELD` statements.
* You want to put together complex queries that take advantage of SurrealQL's expressive arrow syntax, like `->wrote->comment<-wrote<-person->wrote->comment FROM person`.
* You want to visualize your schema using Surrealist's designer view.

Finally, graph links are not just preferred but almost certainly necessary if you need to keep metadata about the context in which a link is created. Take the following metadata for the examples above involving a user and its comments which contains information about a user's current location, operating system, and mood. Where does this data belong?

```surql
{
    location: "Arizona",
    os: "Windows 11",
    current_mood: "Happy"
}
```

This metadata isn't information about the user as a whole, nor the comment itself. It's information about the moment in time in which the `user` and `comment` were linked, and thus is best stored in a separate table.

Or you might have some information about the link itself, which would also belong nowhere else but inside a graph table.

```surql
{
	friends_since: d'2024-12-31T06:43:21.981Z',
	friendship_strength: 0.4
}
```

Graph links also excel when it comes to weighting relations. This can be done through a field on the graph table...

```surql
-- Create 4 'npc' records
CREATE |npc:1..5|;

FOR $npc IN SELECT * FROM npc {
    -- Give each npc 20 random interactions
    FOR $_ IN 0..20 {
      -- Looks for a random NPC, use array::complement to filter out self
      LET $counterpart = rand::enum(array::complement((SELECT * FROM npc), [$npc]));
      -- See if they have a relation yet
      LET $existing = SELECT * FROM knows WHERE in = $npc.id AND out = $counterpart.id;
      -- If relation exists, increase 'greeted' by one
      IF !!$existing {
        UPDATE $existing SET greeted += 1;
      -- Otherwise create the relation and set 'greeted' to 1
      } ELSE {
        RELATE $npc->knows->$counterpart SET greeted = 1;
      }  
    };
};

SELECT 
	id, 
	->knows.{ like_strength: greeted, with: out } AS relations
	FROM npc;
```

```surql title="Which NPC each NPC likes the most"
[
	{
		id: npc:1,
		relations: [
			{
				like_strength: 8,
				with: npc:3
			},
			{
				like_strength: 8,
				with: npc:4
			},
			{
				like_strength: 4,
				with: npc:2
			}
		]
	},
	{
		id: npc:2,
		relations: [
			{
				like_strength: 10,
				with: npc:1
			},
			{
				like_strength: 4,
				with: npc:3
			},
			{
				like_strength: 6,
				with: npc:4
			}
		]
	},
	{
		id: npc:3,
		relations: [
			{
				like_strength: 6,
				with: npc:2
			},
			{
				like_strength: 3,
				with: npc:4
			},
			{
				like_strength: 11,
				with: npc:1
			}
		]
	},
	{
		id: npc:4,
		relations: [
			{
				like_strength: 7,
				with: npc:1
			},
			{
				like_strength: 6,
				with: npc:3
			},
			{
				like_strength: 7,
				with: npc:2
			}
		]
	}
]
```

...or through counting the number of edges.

```surql
-- Create 4 'npc' records
CREATE |npc:1..5|;

FOR $npc IN SELECT * FROM npc {
    -- Give each npc 20 random interactions
    FOR $_ IN 0..20 {
      -- Looks for a random NPC, use array::complement to filter out self
      LET $counterpart = rand::enum(array::complement((SELECT * FROM npc), [$npc]));
      RELATE $npc->greeted->$counterpart;
    };
};

SELECT 
	count() AS like_strength, 
	in AS npc, 
	out AS counterpart
FROM greeted
GROUP BY npc, counterpart;
```

```surql title="Which NPC each NPC likes the most"
[
	{
		counterpart: npc:2,
		like_strength: 6,
		npc: npc:1
	},
	{
		counterpart: npc:3,
		like_strength: 9,
		npc: npc:1
	},
	{
		counterpart: npc:4,
		like_strength: 5,
		npc: npc:1
	},
	{
		counterpart: npc:1,
		like_strength: 9,
		npc: npc:2
	},
	{
		counterpart: npc:3,
		like_strength: 6,
		npc: npc:2
	},
	{
		counterpart: npc:4,
		like_strength: 5,
		npc: npc:2
	},
	{
		counterpart: npc:1,
		like_strength: 10,
		npc: npc:3
	},
	{
		counterpart: npc:2,
		like_strength: 7,
		npc: npc:3
	},
	{
		counterpart: npc:4,
		like_strength: 3,
		npc: npc:3
	},
	{
		counterpart: npc:1,
		like_strength: 6,
		npc: npc:4
	},
	{
		counterpart: npc:2,
		like_strength: 4,
		npc: npc:4
	},
	{
		counterpart: npc:3,
		like_strength: 10,
		npc: npc:4
	}
]
```

If this sort of metadata or weighting is necessary, then a graph table is the ideal solution.

### Creating a graph relation

The following example is similar to the one above, except that this time the `user` record does not have a `comments` field, leaving it seemingly separate from the `comment` created on the next line. Instead, this time a `RELATE` statement is used to create a graph edge called `wrote` joining the two of them, and this is the table that holds the metadata mentioned above.

```surql
LET $new_user = CREATE ONLY user SET name = "User McUserson";
LET $new_comment = CREATE ONLY comment SET 
    text = "I learned something new!", 
    created_at = time::now();

RELATE $new_user->wrote->$new_comment SET
	location = "Arizona",
	os = "Windows 11",
	mood = "happy";
```

Now that a graph edge has been established, the arrow operator can be used to traverse this path. The versatility of this operator is one of the key advantages of using graph edges, as they can be traversed forward, backward, recursively, and more.

```surql
-- Go through each user and find comment(s) it wrote
SELECT ->wrote->comment FROM user;
-- Go through each comment and find the user(s) that wrote it
SELECT <-wrote<-user FROM comment;
-- Go through each comment, find the user(s) that wrote it,
-- and then find all of their comments
SELECT <-wrote<-user->wrote->comment FROM comment;
```

### Other sources on querying graph relations

The arrow operator used to traverse graph edges is an intuitive way to visualize the direction(s) in which a query is traversing. As this page is devoted to an overview of when and how best to use graph relations, it does not go into the details of queries themselves. Many reference pages already exist in the SurrealDB documentation to learn this, including:

* The [`RELATE` statement](/docs/surrealql/statements/relate#querying-graphs)
* The [page on idioms](/docs/surrealql/datamodel/idioms)
* The [SurrealDB Fundamentals course](/learn/fundamentals)
* [Aeon's Surreal Renaissance](/learn/book), chapters 5 to 8 in particular

## Tips and best practices with graph relations

The following sections detail some tips and best practices when using graph relations.

### Define a table as a relation for better type safety and visual output

Defining a table as `TYPE RELATION` ensures that it can only be created in the context of a relation between two records.

Adding `TYPE RELATION` to a `DEFINE TABLE` statement is enough to ensure this behaviour.

```surql
DEFINE TABLE likes TYPE RELATION;
```

Specifying the record types at the `in` and `out` fields of a graph table will ensure that no other records can be joined to each other in this way.

```surql
DEFINE TABLE likes TYPE RELATION IN person OUT blog_post | book;
```

One other advantage to strictly defining a relation table is that this information can be picked up by [Surrealist](/docs/surrealist) to be displayed in its Designer view.

Take the following queries that create some records and relate them to each other.

```surql
CREATE person:one, book:one, blog_post:one;
RELATE person:one->likes->book:one;
RELATE person:one->likes->blog_post:one;
```

As the `likes` table is not yet defined as a relation, Surrealist is unable to determine anything about the table besides the fact that it exists, leading to the following view.

![Surrealist designer view showing four schemaless tables without a specified connection between them.](schema1.png)

Defining the table as a `TYPE RELATION` will improve the layout somewhat by making it clear that `likes` is a graph table.

```surql
DEFINE TABLE likes TYPE RELATION;
CREATE person:one, book:one, blog_post:one;
RELATE person:one->likes->book:one;
RELATE person:one->likes->blog_post:one;
```

![Surrealist designer view showing three schemaless tables together with a likes table that has been defined as a relation.](schema2.png)

If the `in` and `out` fields are specified, however, Surrealist will now be able to graphically display the relation between all these records through the `likes` table.

```surql
DEFINE TABLE likes 
	TYPE RELATION
	IN person 
	OUT blog_post | book;
CREATE person:one, book:one, blog_post:one;
RELATE person:one->likes->book:one;
RELATE person:one->likes->blog_post:one;
```

![Surrealist designer view showing four schemafull tables: three regular tables and one relation table linking them.](schema3.png)

### Create a unique index if the graph relation is between equals

While most examples involve a clear subject and object relation, sometimes a graph edge represents a relation such as friendship, a partnership, sister cities, etc. in which this is not clear.

```surql
CREATE person:one, person:two;

-- Relate them like this?
RELATE person:one->friends_with->person:two;
-- Or like this?
RELATE person:two->friends_with->person:one;
```

To ensure that this relation cannot be established more than once, define a field made of the sorted `in` and `out` fields of the graph table, and define an index on it with a unique constraint.

```surql
DEFINE FIELD key ON TABLE friends_with VALUE <string>array::sort([in, out]);
DEFINE INDEX only_one_friendship ON TABLE friends_with FIELDS key UNIQUE;
```

With this constraint in place, no second `friends_with` can be initiated from the other side.

```surql
CREATE person:one, person:two;
RELATE person:one->friends_with->person:two;
RELATE person:two->friends_with->person:one;
```

```surql title="Output of RELATE statements"
-------- Query --------

[
	{
		id: friends_with:dblidwpc44qqz5bvioiu,
		in: person:one,
		key: '[person:one, person:two]',
		out: person:two
	}
]

-------- Query --------

"Database index `only_one_friendship` already contains '[person:one, person:two]',
with record `friends_with:dblidwpc44qqz5bvioiu`"
```

### Querying a graph relation between equals

In a relation between equals like in the example above, it is never certain whether a specific `person` is friends with another due to a `RELATE` statement where it is the subject of the statement, or the object of the statement.

The `<->` operator can be used in this case to traverse both the `in` and `out` fields of the `friends_with` table.

```surql
SELECT *, <->friends_with<->person AS friends FROM person;
```

This will now show each of the records involved in the relation, regardless of whether they are located at the `in` or `out` field of the `friends_with` graph table.

```surql
[
	{
		friends: [
			person:one,
			person:two
		],
		id: person:one
	},
	{
		friends: [
			person:one,
			person:two
		],
		id: person:two
	}
]
```

To complete this query to ensure that a record's own ID does not show up inside the list of `friends`, the [`array::complement()`](/docs/surrealql/functions/database/array#arraycomplement) function can be used.

```surql
SELECT *, array::complement(<->friends_with<->person, [id]) AS friends FROM person;
```

```surql title="Output"
[
	{
		friends: [
			person:two
		],
		id: person:one
	},
	{
		friends: [
			person:one
		],
		id: person:two
	}
]
```

For further details on this pattern, see [this section](/docs/surrealql/statements/relate#bidirectional-relation-querying) in the page on the `RELATE` statement and [this section](/learn/book/chapter-07#bidirectional-querying-when-a-relationship-is-equal) of Chapter 7 of Aeon's Surreal Renaissance.

### Traverse directly from a record instead of using SELECT

As graph traversal takes place between records, the same syntax can be used directly from one or more record IDs without needing to use a `SELECT` statement. Take the following setup that once again creates a record linked to a comment:

```surql
CREATE ONLY user:mcuserson SET name = "User McUserson";
CREATE ONLY comment:one SET 
    text = "I learned something new!", 
    created_at = time::now();
CREATE ONLY cat:pumpkin SET name = "Pumpkin";

RELATE user:mcuserson->wrote->comment:one SET
	location = "Arizona",
	os = "Windows 11",
	mood = "happy";

RELATE user:mcuserson->likes->cat:pumpkin;
```

These graph edges can be traversed simply using the record name and the arrow syntax.

```surql
-- Equivalent to:
-- SELECT VALUE <-wrote<-user FROM ONLY comment:one;
comment:one<-wrote<-user;

-- Equivalent to:
-- SELECT VALUE ->likes->cat FROM ONLY user:mcuserson;
user:mcuserson->likes->cat;
```

```surql title="Output"
-------- Query --------

[
	user:mcuserson
]

-------- Query --------

[
	cat:pumpkin
]
```

To include various fields in a query that begins from a record ID, the destructuring operator can be used.

```surql
-- Equivalent to:
-- SELECT name, ->likes->cat AS cats FROM ONLY user:mcuserson;
user:mcuserson.{ name, cats: ->likes->cat };
```

### Automatic flattening in graph queries

Automatic flattening is one of the nice features when using graph query syntax, and happens when two lookups follow each other or when a filter is used after a lookup. This can be seen in the following query that checks to see who an employee works for, followed by who that person works for, and then back down the same way.

```surql
CREATE 
	// One president
	person:president, 
	// Two managers
	person:manager1, person:manager2,
	// Four employees
	person:employee1, person:employee2, person:employee3, person:employee4;

// Employees work two to a manager, managers work two to a president
RELATE [person:manager1, person:manager2]->works_for->person:president;
RELATE [person:employee1, person:employee2]->works_for->person:manager1;
RELATE [person:employee3, person:employee4]->works_for->person:manager2;

[person:employee1, person:employee2, person:employee3, person:employee4]->works_for->person->works_for->person<-works_for<-person<-works_for<-person;
```

The output shows four arrays, each with four employees. Each employee has gone up the path to the president, and then back down from the president to return the employees that the president works for.

```surql
[
	[
		person:employee4,
		person:employee3,
		person:employee2,
		person:employee1
	],
	[
		person:employee4,
		person:employee3,
		person:employee2,
		person:employee1
	],
	[
		person:employee4,
		person:employee3,
		person:employee2,
		person:employee1
	],
	[
		person:employee4,
		person:employee3,
		person:employee2,
		person:employee1
	]
]
```

This can be done manually by doing a `SELECT` from the `works_for` table, returning the `out` value for the record if the `in` record matches. Each result can be mapped, after which the same query is called again.

However, because the first level returns an array for each record, each time this is called it will return an array that is further nested than the previous one.

```surql
[person:employee1, person:employee2, person:employee3, person:employee4]
	// Each $p is a single record: an array<record>
    .map(|$p| SELECT VALUE out FROM works_for WHERE in = $p.id)
	// Each $p is an array, so now you have to map each item inside that
    .map(|$p| $p.map(|$p| SELECT VALUE out FROM works_for WHERE in = $p.id))
    // Now an array<array<array<record>>>
	.map(|$p| $p.map(|$p| $p.map(|$p| SELECT VALUE in FROM works_for WHERE out = $p.id)))
    // Now an array<array<array<array<record>>>>
	.map(|$p| $p.map(|$p| $p.map(|$p| $p.map(|$p| SELECT VALUE in FROM works_for WHERE out = $p.id))));
```

The final result still shows the same employees, but not flattened into a single array as would be the case using the graph syntax.

```surql
[
	[
		[
			[
				[
					person:employee4,
					person:employee3
				],
				[
					person:employee2,
					person:employee1
				]
			]
		]
	],
	[
		[
			[
				[
					person:employee4,
					person:employee3
				],
				[
					person:employee2,
					person:employee1
				]
			]
		]
	],
	[
		[
			[
				[
					person:employee4,
					person:employee3
				],
				[
					person:employee2,
					person:employee1
				]
			]
		]
	],
	[
		[
			[
				[
					person:employee4,
					person:employee3
				],
				[
					person:employee2,
					person:employee1
				]
			]
		]
	]
]
```

The flattening in graph queries should be thought of as a maintaining of the original structure as opposed to a flattening that takes place after a query is executed. We can see this by calling `flatten()` at every step of the way instead of going further down into nested mapping.

```surql
[person:employee1, person:employee2, person:employee3, person:employee4]
	// Each $p is a single record: an array<record>
    .map(|$p| SELECT VALUE out FROM works_for WHERE in = $p.id).flatten()
	// Each $p is an array, so now you have to map each item inside that
    .map(|$p| SELECT VALUE out FROM works_for WHERE in = $p.id).flatten()
    // Now an array<array<array<record>>>
	.map(|$p| SELECT VALUE in FROM works_for WHERE out = $p.id).flatten()
    // Now an array<array<array<array<record>>>>
	.map(|$p| SELECT VALUE in FROM works_for WHERE out = $p.id).flatten();
```

The result is a true post-query flattening that removes all the nesting encountered along the way, placing each record encountered during each query inside a single array.

```surql
[
	person:employee3,
	person:employee4,
	person:employee2,
	person:employee1,
	person:employee3,
	person:employee4,
	person:employee2,
	person:employee1,
	person:employee3,
	person:employee4,
	person:employee2,
	person:employee1,
	person:employee3,
	person:employee4,
	person:employee2,
	person:employee1
]
```

### Graph paths in schemas

While most examples in the documentation show how to traverse graph paths inside a `SELECT` statement, they can just as easily be defined as a field on a table.

```surql
DEFINE FIELD employers ON TABLE person VALUE SELECT VALUE <-employs<-company FROM ONLY $this;

CREATE person:1, person:2, company:1;
RELATE company:1->employs->person:1;
person:1.*;
```

However, note that the output of the query above shows an empty array for the `employers` field, as it was calculated at the point that `person:1` was created, not when the `RELATE` statement was executed. The `VALUE` clause will only recalculate if a record is updated.

```surql
UPDATE person:1;
```

```surql title="Output"
[
	{
		employers: [
			company:1
		],
		id: person:1
	}
]
```

A [`computed field`](/docs/surrealql/statements/define/field#computed-fields) makes more sense in this case, as a computed field is calculated each time a record is queried, not just whenever it is created or updated.

```surql
DEFINE FIELD employers ON TABLE person COMPUTED <-employs<-company;

CREATE person:1, person:2, company:1;
RELATE company:1->employs->person:1;
person:1.*;
```

```surql title="Output"
{
	employers: [
		company:1
	],
	id: person:1
}
```

### Using Surrealist to understand graph edges

Surrealist has an [Explorer view](/docs/surrealist/concepts/explore-database-records) that allows users to not just view records and their fields, but also traverse their relations one step at a time. This can be an effective tool to understand the internals of graph edges and queries on them.

Take the following example similar to the ones above, except that the `user` this time has two graph relations instead of one.

```surql
CREATE user:mcuserson SET name = "User McUserson";
CREATE comment:one SET 
    text = "I learned something new!", 
    created_at = time::now();
CREATE cat:pumpkin SET name = "Pumpkin";

RELATE user:mcuserson->wrote->comment:one SET
	location = "Arizona",
	os = "Windows 11",
	mood = "happy";

RELATE user:mcuserson->likes->cat:pumpkin;
```

The Explorer view inside Surrealist can then be used to understand a query like `SELECT ->wrote->comment FROM user` and what the database sees at each and every step of the way.

* Click on `user` (this is the `FROM user` part), then the individual `user:mcuserson` record.
* Click on the `Relations` tab. This has two outgoing relations, outgoing being the `->` direction.
* The path in the query above then goes into `wrote`, so click on that to move into the single `wrote` record.
* At its Outgoing relations is a `comment`, which matches the `->comment` part of the path.
* Clicking on this will lead to the `comment` the user wrote, finishing the query.

Reversing the process by beginning with the Explorer view is a good way to build up a query one step at a time when you are still getting used to the syntax.

### RELATE can be used before records to relate exist

One characteristic of graph tables is that they can be created before the two records in question exist.

```surql
-- Works fine
RELATE person:one->likes->person:two;
-- Returns []
person:one->likes->person;
-- Finally create the 'person' records
CREATE person:one, person:two;
-- Now it returns [ person:two ]
person:one->likes->person;
```

If this is not desirable, the `ENFORCED` keyword can be added to a `DEFINE TABLE` statement.

```surql
DEFINE TABLE likes TYPE RELATION IN person OUT person ENFORCED;
```

```surql title="Output"
"The record 'person:one' does not exist"
```

However, certain patterns might make it desirable to use `RELATE` before creating a record. For example, a street in a city might have a set of addresses registered with a predictable record ID (such as an ID composed of a street number and name) but no houses at the location yet. A `DEFINE FIELD` statement can be used here that contains the path from the `house` to the `street` that will be calculated once the `house` is finally created.

```surql
DEFINE FIELD street ON house VALUE $this<-contains<-street;
CREATE street:frankfurt_road;
RELATE street:frankfurt_road->contains->[
    house:["Frankfurt Road", 200], 
    house:["Frankfurt Road", 205],
    house:["Frankfurt Road", 210],
];

-- Twelve months later once the house is built and size is known...
CREATE house:["Frankfurt Road", 200] SET sq_m = 110.5;
```

```surql title="Output"
[
	{
		id: house:[
			'Frankfurt Road',
			200
		],
		sq_m: 110.5f,
		street: [
			street:frankfurt_road
		]
	}
]
```

### Using recursive queries

[Recursive queries](/docs/surrealql/datamodel/idioms#recursive-paths) allow traversal of a path down to a specific depth.

Take the following `person` records that are connected to each other via the `child_of` path.

```surql
CREATE |person:1..16|;
-- parents of person:1
RELATE person:1->child_of->[person:2, person:3];
-- grandparents of person:1
RELATE person:2->child_of->[person:4, person:5];
RELATE person:3->child_of->[person:6, person:7];
-- great-grandparents of person:1
RELATE person:4->child_of->[person:8, person:9];
RELATE person:5->child_of->[person:10, person:11];
RELATE person:6->child_of->[person:12, person:13];
RELATE person:7->child_of->[person:14, person:15];
```

Following the `person:1` record down three depths (parents, grandparents, great-grandparents) can be done manually by repeating the `->child_of->person` path as many times as required.

```surql
SELECT 
    ->child_of->person AS parents,
    ->child_of->person->child_of->person AS grandparents,
    ->child_of->person->child_of->person->child_of->person AS great_grandparents
FROM ONLY person:1;
```

The recursive syntax can be used in this case to repeat a path as many times as desired instead of manually typing.

```surql
SELECT 
    @.{1}->child_of->person AS parents,
    @.{2}->child_of->person AS grandparents,
    @.{3}->child_of->person AS grandparents
FROM ONLY person:1;
```

However, the recursive syntax goes beyond simply saving keystrokes on a regular graph query. It can also be used to return a single nested object that recurses a number of times as instructed down an indicated path.

```surql
-- Range to start at a depth of one, try to go down to depth of three
SELECT @.{3}.{
    id,
	-- At each depth, use this path to reach the next one
    parents: ->child_of->person.@
} FROM person:1;
```

```surql
person:1.{3}.{
    id,
    parents: ->child_of->person.@
};
```

While developed for graph relations in particular, this path can be used in any context.

For more details on SurrealDB's recursive syntax, see the following pages:

* [Idioms: recursive paths](/docs/surrealql/datamodel/idioms#recursive-paths)
* [Chapter 8 of Aeon's Surreal Renaissance](/learn/book/chapter-08#longer-relational-queries)

### When links are deleted

As mentioned above, record links since version 2.2.0 have the ability to specify what behaviour should take place when a referencing link is deleted. Graph links have a simpler behaviour in which they will be deleted if at least of the linked records is deleted.

```surql
-- likes record created without problems
RELATE person:one->likes->person:two;
CREATE person:one, person:two;
DELETE person:one;
-- 'likes' record is now gone
SELECT * FROM likes;
```

A record link allows for more complex behaviour such as the following in which a linked record is removed from the `comments` field if it is deleted, but also adds the record ID to a field called `deleted_comments` for record keeping. For more information on these `ON DELETE` clauses, see the [page on record references](/docs/surrealql/datamodel/references).

```surql
DEFINE FIELD comments ON person TYPE option<array<record<comment>>> REFERENCE ON DELETE THEN {
    UPDATE $this SET
        deleted_comments += $reference,
        comments -= $reference;
};
```


================================================
FILE: src/content/doc-surrealdb/models/index.mdx
================================================
---
sidebar_position: 2
sidebar_label: Multi-model
title: Multi-model | Data Models
description: The purpose of this document is to provide you with a comprehensive understanding of how SurrealDB can be used as a multi-model database. Whether you are a beginner getting started with SurrealDB or an experienced user looking for specific information, the following sections will serve as a valuable resource.
---

# Multi-model

When you think of a database, you probably think of a table. A table is a collection of rows and columns, where each row represents a record and each column represents a field. In a relational database, these tables are connected by foreign keys, which are columns that reference the primary key of another table.

SurrealDB is a multi-model database, which means that it can store data in different formats. This flexibility allows you to choose the most appropriate data model for your use case, whether you are storing [graph](/docs/surrealdb/models/graph), [document](/docs/surrealdb/models/document), [time-series](/docs/surrealdb/models/time-series), [vector](/docs/surrealdb/models/vector), [full-text search](/docs/surrealdb/models/full-text-search), or [geospatial](/docs/surrealdb/models/geospatial) data.

Throughout this section, you will explore the different data models that SurrealDB supports and how they can be achieved using SurrealQL. You will also learn about how to think in SurrealDB whether you are a SQL, NoSQL, or graph developer. 

## Resources

- [Document](/docs/surrealdb/models/document)
- [Graph](/docs/surrealdb/models/graph)
- [Vector](/docs/surrealdb/models/vector)
- [Time-series](/docs/surrealdb/models/time-series)
- [Geospatial](/docs/surrealdb/models/geospatial)



================================================
FILE: src/content/doc-surrealdb/models/time-series.mdx
================================================
---
sidebar_position: 5
sidebar_label: Time Series
title: Using SurrealDB as a Time Series Database | Introduction
description: In this guide, you will learn how to “think” in a time-series database and show how SurrealDB helps you implement these concepts seamlessly.
---

# Using SurrealDB as a Time Series Database (TSDB)

A time series database is optimized for storing, querying, and managing time-stamped data. Rather than treating the timestamp as just another attribute, TSDBs place time at the forefront of data modeling, indexing, retention, and query optimization. The queries in time series workloads often include:

* Finding or aggregating values over time windows (e.g., last 5 minutes, last 30 days).
* Detecting patterns or anomalies (peaks, troughs, rolling averages).
* Combining real-time and historical data for a holistic view of a system’s behavior.

Although several specialized TSDB solutions exist (e.g., InfluxDB, TimescaleDB), many multi-model databases—SurrealDB included—are introducing features to handle time series workloads efficiently. This guide will help you understand how to think like a time series database user, and how SurrealDB can accommodate these needs.

## Core Concepts of Time Series Modeling

- **Timestamp**: Every record includes at least one timestamp field, typically indicating when the data was created, measured, or observed.

- **Measurement / Metrics**: Time series data often revolves around measurements—like temperature, CPU usage, stock prices. Each measurement can have multiple fields or tags.

- **Tags (or Labels)**: Extra dimensions that categorize data. For instance, a sensor reading might have a `location` or a `device_id` tag. These tags help you filter or group data.

- **Aggregations**: Because time series data can be massive (think thousands of data points per second), it’s common to store or generate aggregated values (e.g., hourly averages or daily sums) for faster analytics.

- **Retention Policies**: Time series datasets can grow exponentially. Many TSDBs support retention policies that drop or downsample older data while keeping recent data at high granularity.

- **Time Buckets**: It’s typical to group data into buckets (e.g., 1-minute, 5-minute, or 1-day intervals) for analytics.


## Benefits of Using Time Series Databases

- **Efficient Ingestion**: TSDBs are optimized for high write throughput, as time series data often arrives in large bursts or continuous streams.

- **Fast Time-Based Queries**: Data structures are specialized for retrieving data over specific time windows or intervals.

- **Built-In Aggregation and Downsampling**: Many TSDBs offer native functions to summarize data by minute, hour, or other intervals.

- **Scalability**: Time partitioning or sharding strategies make it easier to handle large volumes of time series data.

- **Retention Control**: You can automatically expire older data or keep only aggregated versions to save storage.


## Modelling time series data in SurrealDB

Now that we’ve established a common understanding of time series data, let’s explore a practical example using IoT sensor data.

### Modelling events
The normal way of modelling data in SurrealDB would be as fields in a record, such as `coordinates` or `location`.

```surql
CREATE sensor:ARF8394AAA SET coordinates = (-2.2743, 51.1857);
CREATE location:Longleat_House SET built = d'1580-01-01';

CREATE sensor_readings CONTENT {
    timestamp: time::now(),
    location: location:Longleat_House,
    sensor: sensor:ARF8394AAA,
    temperture_celsius: 28.4,
    humidity_percent: 55
};
```

### Complex record IDs

A more optimised way of working with the `sensor_readings` table in a time series context would however be using an array-based record ID, otherwise known as a complex record ID.

```surql
-- Array-based record IDs
CREATE sensor_readings:[
	location:Longleat_House,
	sensor:ARF8394AAA,
    time::now(),
    28.4
];
```

Storing the same information as a record or as part of the ID might look similar at first glance, but under the hood, it’s optimised for efficient range selection, through the magic of [range queries](/docs/surrealql/datamodel/ids#record-ranges) on record IDs. As all values in SurrealDB can be [compared and sorted](/docs/surrealql/datamodel/values#comparing-and-ordering-values), putting the most crucial information into the record ID itself allows you to query only a range of record IDs instead of a whole table.

This effectively means fewer worries about selecting the right indexes or partitions since the ID field already does that naturally in your data as you scale with the performance of a key-value lookup regardless of size!

```surql
-- Select all the temperature readings from the start until now 
-- from a specific sensor
SELECT 
    id[0] AS location,
    id[2] AS at,
    id[3] AS temperature_celsius
FROM sensor_readings:[
	location:Longleat_House,
    sensor:ARF8394AAA,
    time::now() - 1d
]..=[
    location:Longleat_House,
    sensor:ARF8394AAA,
	time::now(),
];
```

```surql title="Output"
[
	{
		at: d'2025-04-17T04:04:54.842Z',
		location: location:Longleat_House,
		temperature_celsius: 28.4f
	}
]
```

This is however not the only way of doing it, you can have the metadata in the ID and sensor data in the record itself, like in the example below. Now the record ID only contains the fields useful in a range query, while the remaining fields are kept in the record itself.

```surql
CREATE sensor_readings:[
	location:Longleat_House,
	sensor:ARF8394AAA,
    time::now()
] CONTENT {
    temperature_celsius: 28.4,
    humidity: 55
};

-- Select all the temperature readings from the start until now 
-- from a specific sensor
SELECT 
    id[0] AS location,
    id[2] AS at,
    temperature_celsius
FROM sensor_readings:[
	location:Longleat_House,
    sensor:ARF8394AAA,
    time::now() - 1d
]..=[
    location:Longleat_House,
    sensor:ARF8394AAA,
	time::now(),
];
```

```surql title="Output"
[
	{
		at: d'2025-04-17T05:25:00.030Z',
		location: location:Longleat_House,
		temperature_celsius: 28.4f
	}
]
```

### IDs inside IDs
The last thing to note here is that we’ve actually been using record IDs inside our complex record IDs! This is known as a [record link](/docs/surrealql/datamodel/records), which allows us to reduce the fields in our main time series table to only the necessary ones by offloading most of the metadata to connected tables.

In our case we have:

- `location:Longleat_House`, which refers to the `Longleat_House` ID in the `location` table. There we put all the metadata about the location itself such as [geo coordinates](/docs/surrealql/datamodel/geometries).
- `sensor:ARF8394AAA`, which refers to the `ARF8394AAA` ID on the `sensor` table. There we could put all the metadata about the sensor such as location, firmware, when it was bought and when it needs maintenance.

It’s very easy and performant to get the connected data, since you don’t have to do any table scans for that either since it links directly to a specific record on a specific table! In the example below, with time for the sensor readings set exactly to the hour (`2024-08-13T05:00:00`), the record ID is easy to predict.

```surql
CREATE sensor:ARF8394AAA SET coordinates = (-2.2743, 51.1857);
CREATE location:Longleat_House SET built = d'1580-01-01';

-- location + sensor + easy to predict timestamp
CREATE sensor_readings:[
	location:Longleat_House,
	sensor:ARF8394AAA,
    d'2024-08-13T05:00:00Z'
] CONTENT {
    temperature_celsius: 28.4,
    humidity: 55
};

-- Select all fields in the ID and the coordinates field from the sensor table
SELECT id, id[1].coordinates AS sensor_coordinates
FROM sensor_readings:[
	location:Longleat_House,
	sensor:ARF8394AAA,
    d'2024-08-13T05:00:00Z'
];
```

```surql title="Output"
[
	{
		id: sensor_readings:[
			location:Longleat_House,
			sensor:ARF8394AAA,
			d'2024-08-13T05:00:00Z'
		],
		sensor_coordinates: (-2.2743, 51.1857)
	}
]
```

Now that we’ve explored a bit how to store and query event data, let’s turn this data into metrics.

### Modelling metrics
For doing metrics in SurrealDB you can choose one or combine:

- **Pre-computed table views**
- **Live Queries**
- **Drop tables**
- **Custom events**

#### Pre-computed table views
Our [pre-computed table views](/docs/surrealql/statements/define/table#pre-computed-table-views) are most similar to event-based, incrementally updating, materialised views. Practically, this means our downsampled metrics will always be up to date as it incrementally updates in near real-time when we add more records to the sensor_readings table.

```surql
-- Define a table view which aggregates data from the sensor_readings table
DEFINE TABLE daily_measurements_by_location AS
	SELECT
    id[0] AS location,
		time::day(id[2]) AS day,
		math::mean(temperature_celsius) AS avg_temperture_celsius,
		math::mean(humidity) AS avg_humidity_percent
	FROM sensor_readings
	GROUP BY id[0];

SELECT * FROM daily_measurements_by_location;
```

```surql title="Output"
[
	{
		avg_humidity_percent: 55dec,
		avg_temperture_celsius: 28.4dec,
		day: 13,
		id: daily_measurements_by_location:[
			location:Longleat_House
		],
		location: location:Longleat_House
	}
]
```

For real-time visualisation of our metrics we can then use [Live Queries](/docs/surrealql/statements/live) to stream real-time updates to our client, such as a BI dashboard or embedded analytics code.

```surql
LIVE SELECT * FROM daily_measurements_by_location;
```

#### Drop tables

[Drop tables](/docs/surrealql/statements/define/table#example-usage) are pretty unique tables that drop all writes once they have been written.

```surql
-- Drop all writes to the sensor_readings table.
-- We don't need every these readings and can view them
-- via daily_measurements_by_location instead
DEFINE TABLE sensor_readings DROP;
```

These tables can be very useful in a time series context if you want to capture very high-frequency data but only care about storing the aggregated downsampled metrics. They are typically used in combination with either the table views or custom events, such that the metrics are calculated then the underlying data is automatically dropped.

When combining drop tables, table views and live queries, you have a very easy-to-set up, event-based and real-time solution from capturing events, creating metrics, dropping stale data and live selects for visualisation.

#### Custom events
If you have something even more bespoke in mind, you can even [create your own event triggers](/docs/surrealql/statements/define/event) based on when a record is created, updated or deleted. You can include any valid SurrealQL inside the event.

For example, we can create a simple real-time anomaly detection and notification solution using just SurrealQL events and functions in 5 steps.

1. Define a event to trigger when a record is added to the sensor_readings table.
2. Get the desired time range you want to track.
3. Calculate both the upper and lower threshold for an outlier, using the standard Q1 - 1.5 * IQR formula for the low outliers and Q3 + 1.5 * IQR formula for the high outliers.
4. Check if the current temperature is a low or high outlier.
5. Send an [http::post](/docs/surrealql/functions/database/http#httppost) request with the outlier details.

```surql
-- Trigger the event on when a record is created
DEFINE EVENT sensor_anomaly_notification ON sensor_readings WHEN $event = 'CREATE'
THEN {
    -- Get the desired time range you want to track
    -- here we're grabing just the past hour
    LET $location = $after[0];
    LET $sensor = $after[1];
    LET $temp_past_hour = (
            SELECT VALUE temperature_celsius FROM sensor_readings:[
                $location,
                $sensor,
                time::now() - 1h,
                ]..=[
                $location,
                $sensor,
                time::now()
            ]);
    -- Calculate both the upper and lower threshold for an outlier
    -- using the standard Q1 - 1.5 * IQR formula for the low outliers
    LET $low_outliers = (
        RETURN math::percentile($temp_past_hour, 25) - 1.5 * math::interquartile($temp_past_hour)
    );
    -- Q3 + 1.5 * IQR formula for the high outliers
    LET $high_outliers = (
        RETURN math::percentile($temp_past_hour, 75) + 1.5 * math::interquartile($temp_past_hour)
    );
    
    -- If a low outlier is found send a http post request
    -- with the outlier details
    IF $after.temperature_celsius < $low_outliers {
        http::post('https://dummyjson.com/comments/1', {
            id: rand::ulid(),
            outlier: $after,
            message: 'Outlier Detected: low temperature'
        });
    };

    -- If a high outlier is found send a http post request
    -- with the outlier details
    IF $after.temperature_celsius > $high_outliers {
        http::post('https://dummyjson.com/comments/1', {
            id: rand::ulid(),
            outlier: $after,
            message: 'Outlier Detected: high temperature'
        });
    };
};
```

## SurrealDB vs specialised time series databases
There are many specialised time series databases out there, so where does SurrealDB fit in?

The advantages SurrealDB has over specialised time series databases are:

- That you can combine our time series functionality with the rest of our multi-model database features. For example, doing full-text search and vector search on your log data.
- No need to learn another query language just for time series. SurrealDB has a unified query language for all its features.

- Connect and enrich your metrics easily, instead of having them being siloed in a separate system. You can have all your data in one place with zero ETL for your various use cases. Whether you’re doing transactional, analytical, ML and AI applications, SurrealDB covers a lot of the use cases a modern application needs.

- SurrealDB will soon also become a native bi-temporal database, with the introduction of new data structure for our new SurrealKV storage engine.

The advantages specialised time series databases have over SurrealDB currently are:

- More advanced time series features such as custom data retention policies and better data compression.

Whether you pick SurrealDB for your time series use cases depends mostly on whether you are looking to lower your total system complexity or if you are looking for another specialised solution.



================================================
FILE: src/content/doc-surrealdb/models/vector.mdx
================================================
---
sidebar_position: 3
sidebar_label: Vector
title: Using SurrealDB as a Vector Database | Introduction
description: In this guide, you will learn about the basics of vector databases, how they differ from other data models, and how SurrealDB—a multi-model database—can store and query vector data alongside documents, graphs, and more.
---

import Image from "@components/Image.astro";
import SurrealistMini from "@components/SurrealistMini.astro";

import ImageLead from "@img/lead.png";

import LightImageVc from "@img/image/light/VC.png";
import LightDistanceMetrics from "@img/image/light/distance-metrics.png";

import DarkImageVc from "@img/image/dark/VC.png";
import DarkDistanceMetrics from "@img/image/dark/distance-metrics.png";

# Using SurrealDB as a Vector Database

A vector database is specialized for storing high-dimensional vectors and for efficiently performing queries on them. Rather than searching on exact values or text-based queries, vector databases let you search based on semantic similarity. For instance, in a text embedding scenario, you can find documents that are semantically similar to a given query, even if they do not share the same keywords.

This allows for usage in areas such as:

- Recommendation systems: Suggest items (movies, products, etc.) similar to what a user has liked based on learned embeddings.
- Image or audio search: Identify images or audio clips semantically similar to a given sample.
- Clustering and classification: Perform unsupervised clustering of data points or quickly identify which category a vector is close to.

With SurrealDB’s SurrealQL you can define vector fields, store numeric arrays as embeddings, create indexes, and perform similarity queries. SurrealDB’s approach unifies these features to allow you to move from multiple data stores (a dedicated vector database plus separate document database and finally a graph database to stitch them together) to a single source of truth.

But how do you “think” in a vector database? Unlike relational or document models, where the focus is on well-defined schemas and relationships, vector databases revolve around embeddings—numerical representations of objects (like text, images, audio snippets, etc.) in a continuous vector space. This allows you to design data structures and queries to exploit these embeddings for similarity search or AI-driven retrieval.

## Core concepts of vector-oriented modeling

Vector search is a search mechanism that goes beyond traditional keyword matching and text-based search methods to capture deeper characteristics and similarities between data.

Vector search isn't new to the world of data science. [Gerard Salton](https://en.wikipedia.org/wiki/Gerard_Salton), known as the Father of Information Retrieval, introduced the Vector Space Model, cosine similarity, and TF-IDF  for information retrieval around 1960.

It converts data such as text, images, or sounds into numerical vectors, called vector embeddings. You can think of vector embeddings as cells. In the same way that cells form the basic structural and biological unit of all known living organisms, vector embeddings serve as the basic units of data representation in vector search.

In practice, embeddings are typically dense vectors of real numbers that capture the semantic or contextual meaning of data. For instance, in Natural Language Processing (NLP), a word or sentence can be transformed into a vector of length 128, 256, 768, or even more dimensions. The idea is that similar objects (in meaning) end up having similar vector representations, making it possible to compute how close they are in the vector space.

Embeddings themselves are not generated by the database. Instead, they depend on which model is used to generate them. Various companies such as OpenAI and Mistral have both free and paid models, while many other [free models](/docs/integrations/embeddings/fastembed) exist to generate embeddings.

Inside a database they will be stored in this sort of manner.

```surql
[
	{
		embedding: [
			0.0007022718782536685,
			0.004178352188318968,
			0.009888353757560253,
            // and so on for 128, 256, 768, or even more numbers
		],
		text: "To be, or not to be: that is the question."
	},
	{
		embedding: [
			-0.027426932007074356,
			0.0008020889363251626,
			-0.02949262224137783
		],
		text: "All the world’s a stage, and all the men and women merely players."
	},
	{
		embedding: [
			-0.05859993398189545,
			-0.011999601498246193,
			-0.06185592710971832
		],
		text: "The course of true love never did run smooth."
	}
]
```

To store vectors in SurrealDB, you typically define a field within your data schema dedicated to holding the vector data. These vectors represent space data points and can be used for various applications, from recommendation systems to image recognition. Below is an example of how to create records with vector embeddings:

```surql
CREATE Document:1 CONTENT {
   items: [
    {
      content: "apple",
      embedding: [0.00995, -0.02680, -0.01881, -0.08697]
    }
  ]
};
```

There are no strict rules or limitations regarding the length of the embeddings, and they can be as large as needed. Just keep in mind that larger embeddings lead to more data to process and that can affect performance and query times based on your physical hardware.

In fact, embeddings retrieved from a model can be cut down to any length you prefer if the accuracy is still acceptable for your use case.

## Vector search vs full-text search

SurrealDB supports [full-text search](/docs/surrealdb/models/full-text-search) and Vector Search. Full-text search (FTS) involves indexing documents using the [FTS index](/docs/surrealql/statements/define/indexes#full-text-search-index) and breaking down the content of the document into smaller tokens with the help of [analyzers](/docs/surrealql/statements/define/analyzer) and [tokenizers](/docs/surrealql/statements/define/analyzer#tokenizers).

<Image
    alt="Google search for the word 'lead'"
    src={ImageLead}
/>

The image above is a Google search for the word “lead”, a word with more than one definition (and pronunciation!). Lead can mean 'taking initiative', as well as the chemical element with the symbol 'Pb'.

Let's consider this in the context of a database of liquid samples which note down harmful chemicals that are found in them.

In the example below, we have a table called `liquids` with a `sample` field and a `content` field.  Next, we can doefine a [full-text index](/docs/surrealql/statements/define/indexes#full-text-search-index) on the `content` field by first defining an analyzer called `liquid_analyzer`. We can then [define an index](/docs/surrealql/statements/define/indexes) on the content field in the liquid table and set our [custom analyzer](/docs/surrealql/statements/define/analyzer) (`liquid_analyzer`)to search through the index.

Then, using the select statement to retrieve all the samples containing the chemical lead will also bring up samples that mention the word `lead`.

<SurrealistMini
	url="https://app.surrealdb.com/mini?query=--+Insert+a+sample+%26+content+field+into+a+liquids+table%0A%0AINSERT+INTO+liquids+%5B%0A++++%7Bsample%3A%27Sea+water%27%2C+content%3A+%27The+sea+water+contains+some+amount+of+lead%27%7D%2C%0A++++%7Bsample%3A%27Tap+water%27%2C+content%3A+%27The+team+lead+by+Dr.+Rose+found+out+that+the+tap+water+in+was+potable%27%7D%2C%0A++++%7Bsample%3A%27Sewage+water%27%2C+content%3A+%27High+amounts+of+a+were+found+in+Sewage+water%27%7D%0A%5D%3B%0A%0A--+Define+an+analyzer+for+the+liquid+table+and+an+index+on+the+content+field+with+the+analyzer%0A%0ADEFINE+ANALYZER+liquid_analyzer+TOKENIZERS+blank%2Cclass%2Ccamel%2Cpunct+FILTERS+snowball%28english%29%3B%0ADEFINE+INDEX+liquid_content+ON+liquids+FIELDS+content+SEARCH+ANALYZER+liquid_analyzer+BM25+HIGHLIGHTS%3B%0A%0A--+Retrieve+all+the+samples+containing+the+chemical+lead+will+also+bring+up+samples+that+simply+mention+the+word+lead%0A%0ASELECT%0A++sample%2C%0A++content%0AFROM+liquids%0AWHERE+content+%400%40+%27lead%27%3B&orientation=horizontal"
/>

If you read through the content of the tap water sample, you’ll notice that it does not contain any lead in it but it has the mention of the word `lead` under “The team lead by Dr. Rose…” which means that the team was guided by Dr. Rose.

The search pulled up both the records although the tap water sample had no lead in it. This example shows us that while full-text search does a great job at matching query terms with indexed documents, on its own it may not be the best solution for use cases where the query terms have deeper context and scope for ambiguity.

## Vector search in SurrealDB

<Image
  alt="What is Vector Search"
  src={{
    light: LightImageVc,
    dark: DarkImageVc,
  }}
/>

The vector search feature of SurrealDB will help you do more and dig deeper into your data. This can be used in place of, or together with full-text search.

For example, still using the same `liquids` table, you can store the chemical composition of the liquid samples in a vector format.

```surql
-- Insert a sample & content field into a liquids table
INSERT INTO liquidsVector [
    {
        sample:'Sea water', 
        content: 'The sea water contains some amount of lead', 
        embedding: [0.1, 0.2, 0.3, 0.4] },
    {
        sample:'Tap water', 
        content: 'The team lead by Dr. Rose found out that the tap water in was potable', 
        embedding:[1.0, 0.1, 0.4, 0.3]
    },
    {
        sample:'Sewage water', 
        content: 'High amounts of a were found in Sewage water', 
        embedding : [0.4, 0.3, 0.2, 0.1]
    }
];
```
Notice that we have added an `embedding` field to the table. This field will store the vector embeddings of the content field so we can perform vector searches on it.

<SurrealistMini url="https://app.surrealdb.com/mini?setup=--+Insert+a+sample+%26+content+field+into+a+liquids+table%0AINSERT+INTO+liquidsVector+%5B%0A++++%7Bsample%3A%27Sea+water%27%2C+content%3A+%27The+sea+water+contains+some+amount+of+lead%27%2C+embedding%3A+%5B0.1%2C+0.2%2C+0.3%2C+0.4%5D+%7D%2C%0A++++%7Bsample%3A%27Tap+water%27%2C+content%3A+%27The+team+lead+by+Dr.+Rose+found+out+that+the+tap+water+in+was+potable%27%2C+embedding%3A%5B1.0%2C+0.1%2C+0.4%2C+0.3%5D%7D%2C%0A++++%7Bsample%3A%27Sewage+water%27%2C+content%3A+%27High+amounts+of+a+were+found+in+Sewage+water%27%2C+embedding+%3A+%5B0.4%2C+0.3%2C+0.2%2C+0.1%5D%7D%0A%5D%3B&query=--+Add+embeddings+for+what+lead+as+a+harmful+substance+should+be.+%0ALET+%24lead_harmful+%3D+%5B0.15%2C+0.25%2C+0.35%2C+0.45%5D%3B%0A%0A--+Define+a+vector+index+on+the+liquidsVector+table+for+embedding+field+%0ADEFINE+INDEX+mt_pts+ON+liquidsVector+FIELDS+embedding+HNSW+DIMENSION+4+DIST+COSINE+TYPE+F32%3B%0A%0A--+Select+the+sample+and+content+from+the+liquids+table+with+cosine+similarity+%0ASELECT+sample%2C+content%2C+vector%3A%3Asimilarity%3A%3Acosine%28embedding%2C+%24lead_harmful%29+AS+dist+FROM+liquidsVector+WHERE+embedding+%3C%7C2%7C%3E+%24lead_harmful%3B&orientation=horizontal"/>


In the example above you can see that the results are more accurate. The search pulled up only the `Sea water` sample which contains the harmful substance `lead` in it. This is the advantage of using vector search over full-text Search.

Another use case for vector search is in the field of facial recognition. For example, if you wanted to search for an actor or actress who looked like you from an extensive dataset of movie artists, you would first use an ML model to convert the artist's images and details into vector embeddings and then use SurrealQL to find the artist with the most resemblance to your face vector embeddings. The more characteristics you decide to include in your vector embeddings, the higher the dimensionality of your vector will be, potentially improving the accuracy of the matches but also increasing the complexity of the vector search.

## Computation on vectors: "vector::" package of functions

SurrealDB provides [vector functions](/docs/surrealql/functions/database/vector) for most of the major numerical computations done on vectors. They include functions for element-wise addition, division and even normalisation.

They also include similarity and distance functions, which help in understanding how similar or dissimilar two vectors are.
Usually, the vector with the smallest distance or the largest cosine similarity value (closest to 1) is deemed the most similar to the item you are trying to search for.

<Image
  alt="Vector functions available in SurrealDB"
  src={{
    light: LightDistanceMetrics,
    dark: DarkDistanceMetrics,
  }}
/>

The choice of distance or similarity function depends on the nature of your data and the specific requirements of your application.

In the liquids examples, we assumed that the embeddings represented the harmfulness of lead (as a substance). We used the [`vector::similarity::cosine`](/docs/surrealql/functions/database/vector#vectorsimilaritycosine) function because cosine similarity is typically preferred when absolute distances are less important, but proportions and direction matter more.

## Vector Indexes

When it comes to search, you can always use brute force.
In SurrealDB, you can use the [brute force approach](/docs/surrealql/statements/define/indexes#brute-force-method) to search through your vector embeddings and data.

Brute force search compares a query vector against all vectors in the dataset to find the closest match. As this is a brute-force approach, you do not create an index for this approach.

The brute force approach for finding the nearest neighbour is generally preferred in the following use cases:

- Small Datasets / Limited Query vectors: For applications with small datasets, the overhead of building and maintaining an index might outweigh its benefits. In such cases, the brute force approach is optimal.

- Guaranteed Accuracy: Since the brute force method compares the query vector against every vector in the dataset, it guarantees finding the exact nearest vectors based on the chosen distance metric (like Euclidean, Manhattan, etc.).

- Benchmarking Models: The Brute force approach can be used as a reference, and help benchmark the performance of other approximate alternatives like HNSW

While brute force can give you exact results, it's computationally expensive for large datasets.

In most cases, you do not need a 100% exact match, and you can give it up for faster, high-dimensional searches to find the approximate nearest neighbour to a query vector.

This is where Vector indexes come in.

In SurrealDB, you can perform a vector search using a [Hierarchical Navigable Small World](https://en.wikipedia.org/wiki/Hierarchical_navigable_small_world) (HNSW) index, a state-of-the-art algorithm for approximate nearest neighbour search in high-dimensional spaces. It is a [proximity graph-based index](/docs/surrealql/statements/define/indexes#hnsw-hierarchical-navigable-small-world) that offers a balance between search efficiency and accuracy.

By design, HNSW currently operates as an "in-memory" structure. Introducing persistence to this feature, while beneficial for retaining index states, is an ongoing area of development. Our goal is to balance the speed of data ingestion with the advantages of persistence.

You can also use the [`REBUILD` statement](/docs/surrealql/statements/rebuild), which allows for the manual rebuilding of indexes as needed. This approach ensures that while we explore persistence options, we maintain the optimal performance that users expect from HNSW, providing flexibility and control over the indexing process.

## Filtering through vector search

The [`vector::distance::knn()`](/docs/surrealql/functions/database/vector#vectordistanceknn) function from SurrealDB returns the distance computed between vectors by the KNN operator. This operator can be used to avoid recomputation of the distance in every `select` query.

Consider a scenario where you’re searching for actors who look like you but they should have won an Oscar. You set a flag, which is true for actors who’ve won the golden trophy.

Let’s create a dataset of actors and define an HNSW index on the embeddings field.

```surql
-- Create a dataset of actors with embeddings and flags
CREATE actor:1 SET name = 'Actor 1', embedding = [0.1, 0.2, 0.3, 0.4], flag = true;
CREATE actor:2 SET name = 'Actor 2', embedding = [0.2, 0.1, 0.4, 0.3], flag = false;
CREATE actor:3 SET name = 'Actor 3', embedding = [0.4, 0.3, 0.2, 0.1], flag = true;
CREATE actor:4 SET name = 'Actor 4', embedding = [0.3, 0.4, 0.1, 0.2], flag = true;

-- Define an embbedding to represent a face
LET $person_embedding = [0.15, 0.25, 0.35, 0.45];

-- Define an HNSW index on the actor table
DEFINE INDEX hnsw_pts ON actor FIELDS embedding HNSW DIMENSION 4;

-- Select actors who look like you and have won an Oscar
SELECT id, flag, vector::distance::knn() AS distance FROM actor WHERE flag = true AND embedding <|2,40|> $person_embedding ORDER BY distance;
```

```surql
[
	[
		{
			distance: 0.09999999999999998f,
			flag: true,
			id: actor:1
		},
		{
			distance: 0.412310562561766f,
			flag: true,
			id: actor:4
		}
	]
];
```

`actor:1` and `actor:2` have the closest resemblance with your query vector and also have won an Oscar.

## Hybrid search functions

As mentioned above, full-text search and vector search can both be used in SurrealDB. In addition, some functions exist inside the [`search::`](/docs/surrealql/functions/database/search) that take both full-text and vector arguments in order to produce a single unified output.

Here is an example of one of them called [`search::rrf()`](/docs/surrealql/functions/database/search#searchrrf) which does this using an algorithm called reciprocal rank fusion.

```surql
-- Sample data --
CREATE test:1 SET text = "Graph databases are great.", embedding = [0.10, 0.20, 0.30];
CREATE test:2 SET text = "Relational databases store tables.", embedding = [0.05, 0.10, 0.00];
CREATE test:3 SET text = "This document mentions graphs.", embedding = [0.20, 0.10, 0.25];

-- Analyzer used by the full‑text index
DEFINE ANALYZER simple TOKENIZERS class, punct FILTERS lowercase, ascii;

-- Full‑text index
DEFINE INDEX idx_text ON TABLE test FIELDS text FULLTEXT ANALYZER simple BM25;

-- Vector index (HNSW) on a 3‑dimensional embedding, using cosine distance
DEFINE INDEX idx_embedding ON TABLE test FIELDS embedding HNSW DIMENSION 3 DIST COSINE;

-- Query vector (whatever your embedding model produced for "graph databases")
LET $qvec = [0.12, 0.18, 0.27];

-- Vector search: top 2 nearest neighbours
LET $vs = SELECT id FROM test  WHERE embedding <|2,100|> $qvec;

-- Full‑text search: top 2 lexical matches
LET $ft = SELECT id, search::score(1) as score FROM test
          WHERE text @1@ 'graph' ORDER BY score DESC LIMIT 2;

-- Fuse with Reciprocal Rank Fusion (k defaults to 60 if omitted)
search::rrf([$vs, $ft], 2, 60);
```

## Vector search cheat sheet

- HNSW: efficient approximation for high dimensions or large datasets
- Brute force: when you don’t define an index, or you want exact nearest neighbours, or when you provide a distance function to the query

### HNSW Index

| Parameter     | Default   | Options                 | Description   |
| ------------- | --------- | ----------------------- | ------------- |
| DIMENSION     |           |                         | Size of the vector
| DIST          | EUCLIDEAN | EUCLIDEAN, COSINE, MANHATTAN | Distance function
| TYPE          | F64       | F64, F32, I64, I32, I16 | Vector type
| EFC           | 150       |                         | EF construction
| M             | 12        |                         | Max connections per element
| M0            | 24        |                         | Max connections in the lowest layer
| LM            | 0.40242960438184466f |              | Multiplier for level generation. This value is automatically calculated with a value considered as optimal.

Examples:

```surql
-- User statement:
DEFINE INDEX hnsw_idx ON pts FIELDS point HNSW DIMENSION 4;
-- Defaults to:
DEFINE INDEX hnsw_idx ON pts FIELDS point HNSW DIMENSION 4 DIST EUCLIDEAN TYPE F64 EFC 150 M 12 M0 24 LM 0.40242960438184466f;
-- Users are strongly suggested not to set an LM value, as it is computed based on other parameters. Only users completely versed in the field should manually set it
```

For more details, see the [`DEFINE INDEX` statement](/docs/surrealql/statements/define/indexes#hnsw-hierarchical-navigable-small-world) documentation.

### Querying

```surql
DEFINE INDEX hnsw_idx ON pts FIELDS point HNSW DIMENSION 4;

LET $vector = [2,3,4];
SELECT
    id,
    vector::distance::knn() as dist  -- distance from $vector
                                     -- knn reuses the value computed during
                                     -- the query, in this case the euclidean
                                     -- distance
FROM pts
WHERE point
    <|2|>  -- return 2, in this case using the distance function defined in the
           -- index: euclidean
    $vector;
```

| SELECT Functions                                 |     |
| ------------------------------------------------ | --- |
| `vector::distance::knn()`                        | reuses the value computed during the query
| `vector::distance::chebyshev(point, $vector)`    |
| `vector::distance::euclidean(point, $vector)`    |
| `vector::distance::hamming(point, $vector)`      |
| `vector::distance::manhattan(point, $vector)`    |
| `vector::distance::minkowski(point, $vector, 3)` | third param is [𝑝](#notes)
| `vector::similarity::cosine(point, $vector)`     |
| `vector::similarity::jaccard(point, $vector)`    |
| `vector::similarity::pearson(point, $vector)`    |

**WHERE statement**

| Query                   | HNSW index |
| ----------------------- | ---------- |
| `<\|2\|>`               | uses distance function defined in index
| `<\|2, EUCLIDEAN\|>`    | brute force methood
| `<\|2, COSINE\|>`       | brute force method
| `<\|2, MANHATTAN\|>`    | brute force method
| `<\|2, MINKOWSKI, 3\|>` | brute force method (third param is [𝑝](#notes))
| `<\|2, CHEBYSHEV\|>`    | brute force method
| `<\|2, HAMMING\|>`      | brute force method
| `<\|2, 10\|>`           | second param is effort*

*effort: Tells HNSW how far to go in trying to find the exact response. HNSW is approximate, and may miss some vectors.

### Notes

- Verify index utilization in queries using the [`EXPLAIN FULL` clause](/docs/surrealql/statements/select#the-explain-clause). E.g: `SELECT id FROM pts WHERE point <|10|> [2,3,4,5] EXPLAIN FULL;`
- 𝑝 values: (more about 𝑝 in [Minkowski distance](https://en.wikipedia.org/wiki/Minkowski_distance))
  - 2<sup>0</sup> = 1 → manhattan/diamond ◇
  - 2<sup>1</sup> = 2 → euclidean/circle ○
  - 2<sup>2</sup> = 4 → squircle ▢
  - 2<sup>∞</sup> = ∞ → square □




## Conclusion

Vector search does not need to be complicated and overwhelming. Once you have your embeddings available, you can try out different vector functions in combination with your query vector to see what works best for your use case. As discussed in the reference guide, you have 3 options to perform Vector Search in SurrealDB. Based on the complexity of your data and accuracy expectations, you can choose between them. You can design your `select` statements to query your search results along with filters and conditions. In order to avoid recalculation of the KNN distance for every single query, you also have the [`vector::distance::knn()`](/docs/surrealql/functions/database/vector#vectordistanceknn).

Due to [GenAI](https://en.wikipedia.org/wiki/Generative_artificial_intelligence), most applications today deal with intricate data with layered meanings and characteristics. Vector search plays a big role in analyzing such data to find what you’re looking for or to make informed decisions.

You can start using Vector Search in SurrealDB by [installing SurrealDB](/docs/surrealdb/installation) on your machines or by using [Surrealist](/surrealist). And if you’re looking for a [quick video explaining Vector Search](https://www.youtube.com/watch?v=MqddPmgKSCs), check out our [YouTube channel](https://www.youtube.com/@SurrealDB).

If you’re interested in understanding Vector search in depth, checkout this academic paper on [Vector Retrieval](https://arxiv.org/abs/2401.09350) written by Sebastian Bruch.

## Resources

- [Vector Search Cheat Sheet](docs/surrealdb/models/vector#vector-search-cheat-sheet)
- [SurrealDB Vector Search](docs/surrealdb/models/vector)
- [Vector Functions](/docs/surrealql/functions/database/vector#vector-functions)
- [Youtube](https://www.youtube.com/watch?v=MqddPmgKSCs)
- [Vector search indexes](/docs/surrealql/statements/define/indexes#vector-search-indexes)


================================================
FILE: src/content/doc-surrealdb/querying/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Querying
title: Querying | SurrealQL | GraphQL
description: In this section, you will explore methods to query data in SurrealDB using SurrealQL, GraphQL or any of the available SDKs. This allows you to retrieve, filter, and manipulate data efficiently and effectively and in the best way for your use case.
---

import Since from '@components/shared/Since.astro';
import Image from "@components/Image.astro";
import LightQl from "@img/icon/light/surrealql.png";
import DarkQl from "@img/icon/dark/surrealql.png";
import LightGql from "@img/icon/light/gql.png";
import DarkGql from "@img/icon/dark/gql.png";

# Querying Data in SurrealDB

In this section, you will explore some of the ways you can query data in SurrealDB using [SurrealQL](/docs/surrealdb/querying/surrealql), [GraphQL](/docs/surrealdb/querying/graphql) or via any of the [available SDKs](/docs/surrealdb/querying/sdks). Regardless of the method you choose, SurrealDB provides powerful querying capabilities that allow you to retrieve, filter, and manipulate data efficiently and effectively.

Now, let's explore the different methods to query data in SurrealDB.

<div class="flag-title mt-14">
	<Image
		alt="SurrealQL"
		width={42}
		height={42}
		src={{
			light: LightQl,
			dark: DarkQl,
		}}
	/>
	# SurrealQL
</div>

[SurrealQL](/docs/surrealql) is our powerful database query language that closely resembles traditional SQL but comes with unique differences and improvements.

Designed to provide developers with a seamless and intuitive way to interact with SurrealDB, SurrealQL offers a familiar syntax and supports various statement types, allowing you to perform complex database operations efficiently.

To get started with SurrealQL, explore the [SurrealQL documentation](/docs/surrealql) to learn about the [statements](/docs/surrealql/statements) available. These statements enable you to perform a wide range of database operations, from querying data to modifying records and managing database structures.

Additionally, SurrealQL provides a rich set of [database functions](/docs/surrealql/functions/database) that enhance its capabilities. These functions allow you to perform advanced operations and leverage the full potential of SurrealDB's features. Whether you are working with data retrieval, manipulation, or complex computations, SurrealQL's functions offer the tools you need to build robust and scalable applications.


### Getting Started

The easiest way to get started with SurrealQL is to use [Surrealist](https://app.surrealdb.com/). This interactive environment allows you to experiment with SurrealQL statements and see the results in a tabular format. You can either set up a sandbox instance, a remote or local instance.



You can use Surrealist to learn about the syntax and features of SurrealQL and to develop your queries and scripts.

To familiarize yourself with SurrealQL, explore the various [statement](/docs/surrealql/statements) and their syntax. The statements pages provides comprehensive examples and explanations for each statement type, helping you understand how to construct queries and interact with SurrealDB effectively.

SurrealQL empowers you to leverage the full potential of SurrealDB and enables you to build robust and scalable applications. Let's dive into the world of SurrealQL and unlock the capabilities of SurrealDB together!

### Querying Options

When using SurrealQL, there are several options available to interact with your database instance depending on your environment and needs.

- **Surrealist (Recommended)**: [Surrealist](https://app.surrealdb.com/) is an interactive environment that allows you to experiment with SurrealQL statements and see the results in a tabular format. It is a great tool for learning about the syntax and features of SurrealQL and for developing your queries and scripts.

- **CLI**: The SurrealDB Command Line Interface (CLI) provides a powerful way to [interact with the database directly from your terminal](/docs/surrealdb/cli). You can execute SurrealQL queries, manage database structures, and perform administrative tasks using the CLI.

- **WebSocket**: SurrealDB supports WebSocket connections, allowing you to execute SurrealQL queries in real-time. This option is ideal for applications that require low-latency communication and real-time updates.

- **HTTP**: You can send HTTP requests to the [`/sql` endpoint](/docs/surrealdb/integration/http#sql) to execute SurrealQL queries. This method is useful for integrating SurrealDB with web applications and services that communicate over HTTP.
  - **Postman**: Using [Postman](https://www.postman.com/) or any other HTTP client, you can send a `POST` request to the `/sql` endpoint with your SurrealQL query in the body. This method provides flexibility and can be useful for testing and automation purposes.

- **RPC**: SurrealDB also supports RPC, allowing you to interact with the database programmatically over a network.

#### Using RPC

SurrealDB also supports RPC, allowing you to interact with the database programmatically over a network.

1. **Set up an RPC client**: Depending on your programming language, you can use various libraries to create an RPC client. Here is an example using JavaScript with the `node-fetch` library:

   ```javascript
   const fetch = require('node-fetch');

   async function querySurrealDB() {
     // Create a new person record
     await fetch('http://localhost:8000/rpc', {
       method: 'POST',
       headers: {
         'Content-Type': 'application/json',
       },
       body: JSON.stringify({
         method: 'query',
         params: ['CREATE person SET name = "John Doe"; SELECT * FROM person;'],
       }),
     });

     const data = await response.json();
   }

   querySurrealDB();
   ```

2. **Execute the RPC call**: Run your script to send the RPC request and receive the response from SurrealDB.

<div class="flag-title mt-14">
	<Image
		alt="GraphQL"
		width={42}
		height={42}
		src={{
			light: LightGql,
			dark: DarkGql,
		}}
	/>
	# GraphQL
</div>

<Since v="v2.0.0" />

SurrealDB also supports GraphQL, allowing you to interact with the database using the familiar syntax. Currently, you can use the [GraphQL integration via Surrealist](/docs/surrealdb/querying/graphql/surrealist), our intuitive user interface specifically designed for SurrealDB, or [over HTTP](/docs/surrealdb/querying/graphql/http) via a GraphQL Client such as [GraphiQL](https://github.com/graphql/graphiql) or [Postman](/docs/surrealdb/querying/graphql/http#postman) at the `localhost:8000/graphql` endpoint.

With Surrealist, you can easily connect to any SurrealDB instance, execute queries in real time, explore your tables, and design your schemas - all in one place.

The GraphQL view allows you to define and retrieve only the data you need, giving you more control and efficiency in how you interact with your database.

### Getting Started

To get started with GraphQL, you can use the GraphQL integration in Surrealist. Once you have connected to your SurrealDB instance, you can explore your tables, execute queries, and manage your data in a user-friendly interface.

### Querying Options

When using GraphQL, there are several options available to interact with your database instance depending on your environment and needs.

- **Surrealist**: [Surrealist](https://app.surrealdb.com/) is an interactive environment that allows you to experiment with SurrealQL statements and see the results in a tabular format. It is a great tool for learning about the syntax and features of SurrealQL and for developing your queries and scripts.

- **HTTP**: You can [send HTTP requests to the `/graphql` endpoint](/docs/surrealdb/querying/graphql/http) to execute GraphQL queries. This method is useful for integrating SurrealDB with web applications and services that communicate over HTTP.


## SDKs

Another way to interact with SurrealDB is to use one of the available SDKs. The SDKs provide a convenient way to query data, insert records, and manage database operations programmatically.

SurrealDB offers a variety of SDKs that allow you to interact with the database programmatically. These SDKs provide a convenient and efficient way to query data, insert records, and manage database operations using your preferred programming language.

### Available SDKs

SurrealDB supports SDKs for several popular programming languages, including:

- **JavaScript/TypeScript**: The [JavaScript/TypeScript SDK](/docs/sdk/javascript/core/create-a-new-connection) allows you to interact with SurrealDB from web applications, Node.js environments, and other JavaScript-based platforms. It provides a comprehensive set of methods to perform queries, manage records, and handle database transactions.

- **Python**: The [Python SDK](/docs/sdk/python) offers a seamless way to integrate SurrealDB with your Python applications. Whether you are building web applications, data analysis tools, or automation scripts, the Python SDK provides the necessary functions to interact with the database efficiently.

- **.NET**: The [.NET SDK](/docs/sdk/dotnet) allows you to interact with SurrealDB using the .NET framework. It provides a comprehensive set of methods to perform queries, manage records, and handle database transactions, making it suitable for building robust and scalable applications.

- **Rust**: The [Rust SDK](/docs/sdk/rust/setup) leverages the safety and performance features of the Rust programming language. It allows you to interact with SurrealDB in a type-safe manner, ensuring that your database operations are both efficient and reliable.

### Getting Started with SDKs

To get started with any of the SDKs, you need to install the appropriate package for your programming language. Once installed, you can initialize the SDK and connect to your SurrealDB instance. Here is an example of how to get started with the JavaScript SDK:

```javascript
import { Surreal } from 'surrealdb';

const db = new Surreal('http://localhost:8000');

await db.connect('root', 'root');

type Person = {
	id: string;
	name: string;
};

// Assign the variable on the connection
const result = await db.query<[Person[], Person[]]>(
	'CREATE person SET name = "John"; SELECT * FROM type::table($tb);',
	{ tb: 'person' }
);

// Get all of the results from the second query
const people = result[1].result;
```

## Learn More

To learn more about the available options for querying data in SurrealDB, explore the following resources:

- [SurrealQL documentation](/docs/surrealql)
- [Surrealist documentation](/docs/surrealist)



================================================
FILE: src/content/doc-surrealdb/querying/graphql/http.mdx
================================================
---
sidebar_position: 2
sidebar_label: GraphQL via HTTP
title: GraphQL via HTTP | GraphQL
description: In this section, you will explore querying SurrealDB using the GraphQL HTTP endpoint. The HTTP API is designed to be simple and intuitive, with any interface that provides a consistent way to interact with the database.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";
import Since from '@components/shared/Since.astro';
import Label from "@components/shared/Label.astro";

# GraphQL via HTTP

SurrealDB provides a powerful HTTP API that allows you to interact with the database programmatically. This API can be used to perform a wide range of database operations, from querying data to modifying records and managing database structures.

The HTTP API is designed to be simple and intuitive, with a RESTful interface that provides a consistent way to interact with the database. You can use the API to perform a wide range of database operations, from querying data to modifying records and managing database structures.

## Starting a new connection

Before you can start making queries, you need to start SurrealDB with the GraphQL module enabled. You can do this by setting the `SURREAL_CAPS_ALLOW_EXPERIMENTAL` [environment variable](/docs/surrealdb/cli/env) to `graphql` and starting a new instance of SurrealDB with the [`surreal start` command](/docs/surrealdb/cli/start).


<Tabs groupId="start-surreal">
<TabItem value="macOS" label="MacOS">
```bash
# From greater than or equal to V2.2.0
SURREAL_CAPS_ALLOW_EXPERIMENTAL=graphql surreal start --log debug --user root --password root

# From versions lower than V2.2.0
SURREAL_EXPERIMENTAL_GRAPHQL = "true" surreal start --log debug --user root --password root
```
</TabItem>
<TabItem value="Windows" label="Windows">
```bash
# From greater than or equal to V2.2.0
$env:SURREAL_CAPS_ALLOW_EXPERIMENTAL=graphql surreal start --log debug --user root --password root

# From versions lower than V2.2.0
$env:SURREAL_EXPERIMENTAL_GRAPHQL = "true" surreal start --log debug --user root --password root
```
</TabItem>
</Tabs>

In order to allow querying the created table using GraphQL, you will need to explicitly enable GraphQL using the [`DEFINE CONFIG`](/docs/surrealql/statements/define/config) statement. This will allow you to query the table using GraphQL on a per-database basis.

> [!WARNING]
> By running SurrealDB with the GraphQL module enabled, you are opting into an experimental feature. While the GraphQL module is fully functional, it is still considered experimental and may not be as stable as the core SurrealQL module which means we cannot guarantee that it will provide the same security guarantees. It is not recommended for production use. We welcome your feedback and contributions to help improve the feature and make it more robust.


## `POST /sql`

To use the GraphQL API, you first need to enable it using the `DEFINE CONFIG` statement. This will allow you to query the table using GraphQL on a per-database basis.

To do this, you can send a `POST` request to the `/sql` endpoint with a RAW body containing the `DEFINE CONFIG` statement. For example:

```surrealql title="Enabling GraphQL"
DEFINE CONFIG GRAPHQL AUTO;
```


## `POST /graphql`

<Since v="v2.0.0" />

To use the GraphQL API, you can send a `POST` request to the `/graphql` endpoint with a JSON body containing the GraphQL query. For example, to query the `person` table for all records, you can send the following request:

```json
{
  "query": "{ person { name } }"
}
```

You can access this endpoint at `http://localhost:8000/graphql` via Postman or any other HTTP client.



The GraphQL endpoint enables use of GraphQL queries to interact with your data.

### Headers
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>surreal-ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>surreal-db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```bash title="Request"
curl -X POST -u "root:root" -H "surreal-ns: mynamespace" -H "surreal-db: mydatabase" -H "Accept: application/json" -d '{"query": "{ person(filter: {age: {age_gt: 18}}) { id name age } }"}' http://localhost:8000/graphql
```

```json title="Response"
[
	{
		"time": "14.357166ms",
		"status": "OK",
		"result": [
			{
				"age": "23",
				"id": "person:6r7wif0uufrp22h0jr0o"
				"name": "Simon",
			},
			{
				"age": "28",
				"id": "person:6r7wif0uufrp22h0jr0o"
				"name": "Marcus",
			},
		]
	}
]
```



================================================
FILE: src/content/doc-surrealdb/querying/graphql/index.mdx
================================================
---
sidebar_position: 2
sidebar_label: GraphQL
title: GraphQL
description: In this section, you will explore GraphQL, an industry-wide recognised protocol for interacting with your data, allowing you to query your data using any preferred method which offers precision and efficiency in data retrieval.
---

import Image from "@components/Image.astro";
import LightGql from "@img/icon/light/gql.png";
import DarkGql from "@img/icon/dark/gql.png";

<div class="flag-title">
	<Image
		alt="GraphQL"
		width={42}
		height={42}
		src={{
			light: LightGql,
			dark: DarkGql,
		}}
	/>
	# GraphQL
</div>

In this section, you will explore [GraphQL](https://graphql.org/), an industry-wide recognised protocol for interacting with your data, allowing you to query your data using any preferred method which offers precision and efficiency in data retrieval. And in combination with Surrealist, you can now manage your data in a user-friendly environment to simplify complex operations.

In SurrealDB, you can use GraphQL to query your data in Surrealist, a user-friendly interface specifically designed for SurrealDB.

## Key Features

GraphQL offers a number of key features that make it a powerful tool for working with SurrealDB:

- **Declarative Data Fetching**: GraphQL allows you to request exactly the data you need, no more and no less. This reduces over-fetching and under-fetching of data, leading to more efficient queries.

- **Strongly Typed Schema**: GraphQL uses a strong type system to define the capabilities of an API. This schema serves as a contract between the client and the server, ensuring that queries are valid before execution.

- **Hierarchical Structure**: GraphQL queries mirror the shape of the data they return, making it intuitive to work with nested data structures.

- **Single Endpoint**: When using GraphQL over HTTP, it typically uses a single endpoint, simplifying API architecture and reducing network overhead.

- **Ecosystem and Tools**: GraphQL has a rich ecosystem of tools for development, testing, and monitoring, including GraphiQL for query exploration and Apollo Client for state management.


## Getting Started

To start using [GraphQL](https://www.graphql.com/), we recommend using [Surrealist](https://app.surrealdb.com/), our interactive environment that allows you to experiment with GraphQL queries and see the results immediately in the UI.

If you prefer using a GraphQL Client such as GraphiQL or Postman, you can use the GraphQL integration at the `localhost:8000/graphql` endpoint.



================================================
FILE: src/content/doc-surrealdb/querying/graphql/surrealist.mdx
================================================
---
sidebar_position: 1
sidebar_label: GraphQL via Surrealist
title: GraphQL via Surrealist | GraphQL
description: In this section, you will explore interating with your SurrealDB instance using GraphQL queries using Surrealist, the official query editor for SurrealDB. Surrealist is a powerful tool that allows you to write, execute, and visualize GraphQL queries in real-time.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";
import Image from "@components/Image.astro";

import ImageConnection from "@img/image/surrealist/connection.png";
import ImageQuerying from "@img/image/surrealist/graphql-querying-fields.png";
import ImageTypeInference from "@img/image/surrealist/graphql-type-inference.png";


# GraphQL via Surrealist

In this section, you will explore writing GraphQL queries in [Surrealist](https://app.surrealdb.com/query). The GraphQL query view in Surrealist provides a rich set of features, including syntax highlighting, query validation, and query execution. You can see the results of your queries in JSON structure returned by GraphQL.

## Getting Started

Before you can start making queries, you need to start SurrealDB with the GraphQL module enabled. You can do this by setting the `SURREAL_CAPS_ALLOW_EXPERIMENTAL` [environment variable](/docs/surrealdb/cli/env) to `graphql` and starting a new instance of SurrealDB with the [`surreal start` command](/docs/surrealdb/cli/start).

<Tabs groupId="start-surreal">
<TabItem value="macOS" label="MacOS">
```bash
# From greater than or equal to V2.2.0
SURREAL_CAPS_ALLOW_EXPERIMENTAL=graphql surreal start --log debug --user root --password root

# From versions lower than V2.2.0
SURREAL_EXPERIMENTAL_GRAPHQL = "true" surreal start --log debug --user root --password root
```
</TabItem>
<TabItem value="Windows" label="Windows">
```bash
# From greater than or equal to V2.2.0
$env:SURREAL_CAPS_ALLOW_EXPERIMENTAL=graphql surreal start --log debug --user root --password root

# From versions lower than V2.2.0
$env:SURREAL_EXPERIMENTAL_GRAPHQL = "true" surreal start --log debug --user root --password root
```
</TabItem>
</Tabs>

> [!WARNING]
> By running SurrealDB with the GraphQL module enabled, you are opting into an experimental feature. While the GraphQL module is fully functional, it is still considered experimental and may not be as stable as the core SurrealQL module which means we cannot guarantee that it will provide the same security guarantees. It is not recommended for production use. We welcome your feedback and contributions to help improve the feature and make it more robust.

After starting the SurrealDB instance, you can navigate to the Surrealist to start a new connection.

### Start a new connection

In the top left corner of the Surrealist, start a new connection. Ensure that the connection information is the same as the one you used to start the SurrealDB instance. In the example above we have set the user to `root` and the password to `root`.

> [!IMPORTANT]
> In the Surrealist sandbox, querying via GraphQL is not supported.


Learn more about starting a connection in the [Surrealist documentation](/docs/surrealist/getting-started).

### Setting a namespace and database

Before you can start writing queries, you need to set the [namespace](/docs/surrealdb/introduction/concepts/namespace) and [database](/docs/surrealdb/introduction/concepts/database) you want to use. For example you can set the namespace to `test` and the database to `test`. This will set the namespace and database for the current connection.

Additionally, you can start [a serving in Surrealist](/docs/surrealist/concepts/local-database-serving) which also enables GraphQL automatically, which starts a server on `http://localhost:8000` by default for a root user with username and password `root`.

<Image
  alt="Surrealist connection settings"
  src={ImageConnection}
/>

### Preparing your database

Next, use the [SurrealQL query editor](/docs/surrealist/concepts/sending-queries) to create some data. For example, you can create a new `user` table with fields for `firstName`, `lastName`, and `email` and add a new user to the database.

In order to allow querying the created table using GraphQL, you will need to explicitly enable GraphQL using the [`DEFINE CONFIG`](/docs/surrealql/statements/define/config) statement. This will allow you to query the table using GraphQL on a per-database basis.

```surql title="Creating a user table"

DEFINE TABLE user SCHEMAFULL;

-- Enable GraphQL for the user table.
DEFINE CONFIG GRAPHQL AUTO;

-- Define some fields.
DEFINE FIELD firstName ON TABLE user TYPE string;
DEFINE FIELD lastName ON TABLE user TYPE string;
DEFINE FIELD email ON TABLE user TYPE string
  ASSERT string::is_email($value);
DEFINE INDEX userEmailIndex ON TABLE user COLUMNS email UNIQUE;

-- Create a new User
CREATE user CONTENT {
    firstName: 'Jon',
    lastName: 'Doe',
    email: 'Jon.Doe@surrealdb.com',
};
```

> [!IMPORTANT]
> You can only use GraphQL to query data from explicitly defined resources for a given table. That is, you must use the [`DEFINE TABLE` statement](/docs/surrealql/statements/define/table) to define the table, and [`DEFINE FIELD` statement](/docs/surrealql/statements/define/field) to define the fields for the table. As such, in schemaless mode, since the fields are not explicitly defined, you cannot query them using GraphQL.

## Write your first GraphQL query

After you have created some data, you can start writing GraphQL queries. You can use the [Surrealist GraphQL editor](https://app.surrealdb.com/graphql) to write your GraphQL queries.

For example, to query the `person` table for all records, you can write the following GraphQL query:

```graphql
{
    user {
        firstName
        lastName
        email
    }
}
```

<Image
  alt="Surrealist GraphQL query"
  src={ImageQuerying}
/>

and to get the person with the email "Jon.Doe@surrealdb.com", you can write the following GraphQL query:

```graphql
{
    user(filter: {email: {eq: "Jon.Doe@surrealdb.com"}}) {
        firstName
        lastName
    }
}
```

Surrealist will automatically validate the query and provide you with the results.

## Introspection

Surrealist also supports introspection with GraphQL. This means that you can query the database and Surrealist will automatically infer the type of the data you are querying. For example, if you query the `user` table for all records, Surrealist will automatically infer the type of the data to be `user`.

<Image
  alt="Surrealist GraphQL type inference"
  src={ImageTypeInference}
/>

## Learn more

To learn more about the GraphQL view in Surrealist, check out the [Surrealist documentation](/docs/surrealist).



================================================
FILE: src/content/doc-surrealdb/querying/sdks/index.mdx
================================================
---
sidebar_position: 3
sidebar_label: Querying via SDKs
title: SurrealQL via SDKs
description: In this section, you will explore SurrealQL, a powerful database query language that closely resembles traditional SQL but comes with unique differences and improvements.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";
import Boxes from "@components/boxes/Boxes.astro";
import IconBox from "@components/boxes/IconBox.astro";
import Image from "@components/Image.astro";

import LightRust from "@img/icon/light/rust.png";
import LightJavaScript from "@img/icon/light/javascript.png";
import LightTypescript from "@img/icon/light/typescript.png";
import LightPython from "@img/icon/light/python.png";
import LightNodejs from "@img/icon/light/nodejs.png";
import LightDotnet from "@img/icon/light/dotnet.png";
import LightGolang from "@img/icon/light/golang.png";
import LightJava from "@img/icon/light/java.png";
import LightPhp from "@img/icon/light/php.png";

import DarkRust from "@img/icon/dark/rust.png";
import DarkJavaScript from "@img/icon/dark/javascript.png";
import DarkTypescript from "@img/icon/dark/typescript.png";
import DarkPython from "@img/icon/dark/python.png";
import DarkNodejs from "@img/icon/dark/nodejs.png";
import DarkDotnet from "@img/icon/dark/dotnet.png";
import DarkGolang from "@img/icon/dark/golang.png";
import DarkJava from "@img/icon/dark/java.png";
import DarkPhp from "@img/icon/dark/php.png";
import Label from "@components/shared/Label.astro";

# Querying via SDKs

SurrealDB supports a number of methods for connecting to the database and performing data queries. Each SDK has its own set of methods for connecting to the database and performing data queries.

In each SDK, you can connect to the database using a local or remote connection. Once you are connected, you can start performing data queries. Here is a list of all the Supported SDKs:

<Boxes>
    <IconBox
        title="Rust"
        status="available"
        href="/docs/sdk/rust"
        icon={{
                light: LightRust,
                dark: DarkRust,
        }}
    />
    <IconBox
        title="JavaScript"
        status="available"
        href="/docs/sdk/javascript/core/create-a-new-connection"
        icon={{
                light: LightJavaScript,
                dark: DarkJavaScript,
        }}
    />
    <IconBox
        title="TypeScript"
        status="available"
        href="/docs/sdk/javascript/core/create-a-new-connection"
        icon={{
                light: LightTypescript,
                dark: DarkTypescript,
        }}
    />
    <IconBox
        title="Python"
        status="available"
        href="/docs/sdk/python"
        icon={{
                light: LightPython,
                dark: DarkPython,
        }}
    />
    <IconBox
        title="Node.js"
        status="available"
        href="/docs/sdk/javascript/engines/node"
        icon={{
                light: LightNodejs,
                dark: DarkNodejs,
        }}
    />
    <IconBox
        title=".NET"
        status="available"
        href="/docs/sdk/dotnet"
        icon={{
                light: LightDotnet,
                dark: DarkDotnet,
        }}
    />
    <IconBox
        title="Golang"
        status="available"
        href="/docs/sdk/golang"
        icon={{
                light: LightGolang,
                dark: DarkGolang,
        }}
    />
    <IconBox
        title="Java"
        status="available"
        href="/docs/sdk/java"
        icon={{
                light: LightJava,
                dark: DarkJava,
        }}
    />
    <IconBox
        title="PHP"
        status="available"
        href="/docs/sdk/php"
        icon={{
                light: LightPhp,
                dark: DarkPhp,
        }}
    />
</Boxes>

## Writing SurrealQL queries in SDKs

While you can use the other methods provided by the SDKs to perform data queries, you can use the `query` method to run [SurrealQL statements](/docs/surrealql) against the database.


<Tabs groupId="query-methods">
  <TabItem value="JS" label="Javascript" default>

```ts title="Method Syntax"
async db.query<T>(query, vars)
```

#### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>query</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>vars</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
    </tbody>
</table>

#### Example usage
```ts
type Person = {
	id: string;
	name: string;
};

// Assign the variable on the connection
const result = await db.query<[Person[], Person[]]>(
	'CREATE person SET name = "John"; SELECT * FROM type::table($tb);',
	{ tb: 'person' }
);

// Get the first result from the first query
const created = result[0].result[0];

// Get all of the results from the second query
const people = result[1].result;
```

`.query_raw()`

With `.query_raw()`, you will get back the raw RPC response. In contrast to the `.query()` method, this will not throw errors that occur in individual queries, but will rather give those back as a string, and this will include the time it took to execute the individual queries.


</TabItem>
<TabItem value="PHP" label="PHP">

```php title="Method Syntax"
$db->query($query, $vars)
```

#### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>$query</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>$vars</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
    </tbody>
</table>

#### Example usage
```php
// Assign the variable on the connection
$result = db->query(
	'CREATE person SET name = "John"; SELECT * FROM type::table($tb);',
	[ "tb" => "person" ]
);

// Get the first result from the first query
$created = $result[0]->result[0];

// Get all of the results from the second query
$people = $result[1]->result;
```
</TabItem>
<TabItem value="Python" label="Python">

```python title="Method Syntax"
db.query(sql, vars)
```

#### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>vars</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
    </tbody>
</table>

#### Example usage
```python
# Assign the variable on the connection
result = await db.query('CREATE person; SELECT * FROM type::table($tb)', {
	'tb': 'person',
})
# Get the first result from the first query
result[0]['result'][0]
# Get all of the results from the second query
result[1]['result']
```

</TabItem>
<TabItem value="Dotnet" label=".NET">

```csharp title="Method Syntax"
await db.Query(sql)
```

#### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" data-label="Arguments">
                <code>cancellationToken</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="col" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>
<br/>

#### Example usage

```csharp
// Execute query with params
const string table = "person";
var result = await db.Query($"CREATE person; SELECT * FROM type::table({table});");

// Get the first result from the first query
var created = result.GetValue<Person>(0);

// Get all of the results from the second query
var people = result.GetValue<List<Person>>(1);
```

<br />

`.RawQuery()` : Runs a set of SurrealQL statements against the database, based on a raw SurrealQL query.

```csharp title="Method Syntax"
await db.RawQuery(sql, params)
```

#### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="col" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="col" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" data-label="Arguments">
                <code>params</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="col" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="col" data-label="Arguments">
                <code>cancellationToken</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="col" data-label="Description">
                The cancellationToken enables graceful cancellation of asynchronous operations.
            </td>
        </tr>
    </tbody>
</table>

#### Example usage
```csharp
// Assign the variable on the connection
var @params = new Dictionary<string, object> { { "table", "person" } };
var result = await db.RawQuery("CREATE person; SELECT * FROM type::table($table);", @params);

// Get the first result from the first query
var created = result.GetValue<Person>(0);

// Get all of the results from the second query
var people = result.GetValue<List<Person>>(1);
```

</TabItem>
<TabItem value="Golang" label="Golang">

```go title="Method Syntax"
db.Query(sql, vars)
```

#### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>vars</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
    </tbody>
</table>

#### Example usage
```go
// Assign the variable on the connection
result, err := db.Query("CREATE person; SELECT * FROM type::table($tb);", map[string]string{
	"tb": "person"
});
```
</TabItem>
<TabItem value="Rust" label="Rust">

```rust title="Method Syntax"
db.query(sql).bind(vars)
```

#### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>vars</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
    </tbody>
</table>

#### Example usage
```rust
// Run some queries
let sql = "
    CREATE person;
    SELECT * FROM type::table($table);
";
let mut result = db
    .query(sql)
    .bind(("table", "person"))
    .await?;
// Get the first result from the first query
let created: Option<Person> = result.take(0)?;
// Get all of the results from the second query
let people: Vec<Person> = result.take(1)?;
```

</TabItem>
</Tabs>

## Learn more

Learn more about the [SurrealQL query language](/docs/surrealql).



================================================
FILE: src/content/doc-surrealdb/querying/surrealism/examples.mdx
================================================
---
sidebar_position: 3
sidebar_label: Further examples
title: Further examples
description: Further examples of Surrealism, including more CLI commands and sample tests
---

# Further Surrealism examples

More examples of Surrealism in practice can be seen inside the [surrealism repo](https://github.com/surrealdb/surrealdb/tree/main/crates/surrealism). They include a more comprehensive demo of the Rust code, 

## Surrealism Rust code demo

[This demo](https://github.com/surrealdb/surrealdb/tree/main/crates/surrealism/demo) contains more examples of functions and the `#[surrealism]` attribute. For example, it can be used to rename the file on the SurrealDB side:

```rust
#[surrealism(name = "other")]
fn can_drive_bla(age: i64) -> bool {
	age >= 18
}
```

It can be used to make a function the default, allowing it to be called via the module path alone:

```rust
#[surrealism(default)]
fn def(age: i64) -> bool {
	age >= 18
}
```

## CLI examples

[This file](https://github.com/surrealdb/surrealdb/blob/main/crates/surrealism/test/test.sh) shows further usage of how the Surrealism CLI can be used to work with Surrealism functions directly as opposed to through a SurrealDB instance.

```bash
# See function signature
./surrealism sig --fnc can_drive demo.surli

# Run function with argument 
./surrealism run --fnc can_drive --arg 17 demo.surli
```

## Build scripts

[This folder](https://github.com/surrealdb/surrealdb/tree/main/crates/surrealism/test) contains build scripts for the Surrealism CLI and test examples. Cloning the repo and running `full.sh` is enough to build the CLI and run all the test examples.


================================================
FILE: src/content/doc-surrealdb/querying/surrealism/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Surrealism plugins
title: Surrealism plugins
description: Surrealism is a plugin feature that allows users to write code that can then be accessed inside a SurrealDB instance.
---

> [!NOTE]
> Surrealism is currently in active development and is not yet stable. We are looking forward to any and all feedback on the plugin system, either via raising an issue or PR on the SurrealDB repo, or anywhere else in the [SurrealDB community](/community).

# Surrealism

Surrealism is a plugin feature introduced in SurrealDB 3.0 which allows users to write code that can then be compiled to Web Assembly and accessed inside a running SurrealDB instance.

Surrealism was built in order to allow users to extend SurrealDB in ways that benefit them, without needing to make any changes to the code of SurrealDB itself. Some potential use cases are:

* Adding functions to create fake / mock data for testing.
* Accessing functionality in Rust crates that are too specific to merge into SurrealDB itself, such as [language-specific functionality](https://crates.io/crates/hangeul), [custom case conversions](https://docs.rs/convert_case/latest/convert_case/enum.Case.html), or [quantitative finance](https://docs.rs/crate/RustQuant/latest).
* Anything else you have built in your own code that you would like to access inside SurrealDB.

## How Surrealism works

Surrealism works by using the following steps:

* The addition of a `surrealism.toml` file plus the `#[surrealism]` annotation over functions to expose.
* A CLI that compiles this code into a WASM binary.
* Statements inside SurrealDB to [allow access to the file](/docs/surrealql/statements/define/bucket) and to [define a module](/docs/surrealql/statements/define/module) holding the functions.

![A flowchart showing the steps involved to turn regular Rust code into a compiled WASM binary that can be accessed from a running SurrealDB instance.](surrealism_flow.png)

The next page contains a walkthrough to show how this process works.


================================================
FILE: src/content/doc-surrealdb/querying/surrealism/tutorial.mdx
================================================
---
sidebar_position: 2
sidebar_label: Quick tutorial
title: Quick tutorial
description: A quick tutorial showing the steps involved in turning regular Rust code into SurrealDB-accessible WASM functions.
---

## Getting started: regular Rust code

To start, depending on your platform you may need to add this line in your `Cargo.toml` to instruct cargo to generate a .wasm file instead of the standard .rlib file:

```toml
[lib]
crate-type = [ "cdylib" ]
```

With that scaffolding out of the way, lets assume you have a `lib.rs` file that has three functions that you would like to call using SurrealQL.

One is a simple function that returns a bool.

```rust
fn can_drive(age: i64) -> bool {
    age >= 18
}
```

The second returns a `Result`.

```rust
fn parse_number(input: String) -> Result<i64, ParseIntError> {
    input.parse::<i64>()
}
```

And the third returns a `User` struct via a function called `random_user()` which uses the [fake](https://docs.rs/fake/4.4.0/fake/index.html) crate to create a user with a random English first name, French middle name, and German last name. This struct is annotated with the `SurrealValue` trait, allowing its return value to be understood on the SurrealDB side.

```rust
#[derive(Debug, SurrealValue)]
pub struct User {
    first_name: String,
    middle_name: String,
    last_name: String,
	age: i32
}

pub fn random_user() -> User {
    User {
        first_name: FirstName(EN).fake(),
        middle_name: FirstName(FR_FR).fake(),
        last_name: LastName(DE_DE).fake(),
		age: random_range(10..=50)
    }
}
```

Here is all of the code.

```rust
use fake::faker::name::raw::*;
use fake::{Fake, locales::*};
use rand::random_range;
use surrealdb_types::SurrealValue;
use std::num::ParseIntError;

#[derive(Debug, SurrealValue)]
pub struct User {
    first_name: String,
    middle_name: String,
    last_name: String,
	age: i32
}

fn can_drive(age: i64) -> bool {
    age >= 18
}

fn parse_number(input: String) -> Result<i64, ParseIntError> {
    input.parse::<i64>()
}

pub fn random_user() -> User {
    User {
        first_name: FirstName(EN).fake(),
        middle_name: FirstName(FR_FR).fake(),
        last_name: LastName(DE_DE).fake(),
		age: random_range(10..=50)
    }
}
```

## Annotating functions and adding surrealism.toml

To allow these functions to be accessed from SurrealDB, first we can add Surrealism to Cargo. We'll also add `surrealdb-types`, which provides access to the `SurrealValue` trait above. Note that the entire `surrealdb` repo is not necessary!

```toml
surrealism = { git = "https://github.com/surrealdb/surrealdb" }
surrealdb-types = { git = "https://github.com/surrealdb/surrealdb" }
```

The functions that we want to call from inside SurrealQL can now be exposed by adding the `#[surrealism]` annotation.

```rust
use fake::faker::name::raw::*;
use fake::{Fake, locales::*};
use rand::random_range;
use surrealdb_types::SurrealValue;
use surrealism::surrealism;
use std::num::ParseIntError;

#[derive(Debug, SurrealValue)]
pub struct User {
    first_name: String,
    middle_name: String,
    last_name: String,
	age: i32
}

#[surrealism]
fn can_drive(age: i64) -> bool {
    age >= 18
}

#[surrealism]
fn parse_number(input: String) -> Result<i64, ParseIntError> {
    input.parse::<i64>()
}

#[surrealism]
pub fn random_user() -> User {
    User {
        first_name: FirstName(EN).fake(),
        middle_name: FirstName(FR_FR).fake(),
        last_name: LastName(DE_DE).fake(),
		age: random_range(10..=50)
    }
}
```

You also need to add a `surrealism.toml` file. This file currently does not do much but in future versions will be used for function versioning, capabilities, and so on.

```toml
[package]
organisation = "surrealdb"
name = "demo"
version = "1.0.0"

[capabilities]
allow_scripting = true
allow_arbitrary_queries = true
allow_functions = ["fn::test"]
allow_net = ["127.0.0.1:8080"]
```

With this setup done, the Rust code can now be compiled to WASM via the Surrealism CLI. The source code for the CLI is [located here](https://github.com/surrealdb/surrealdb/tree/main/crates/surrealism/surrealism-cli) but it is most conveniently installed via the [`cargo install surrealism-cli`](https://crates.io/crates/surrealism-cli) command.

Once the CLI is installed or built from source, you can use it with the `build` command. This is followed with the `--out` flag and the output file name/path (e.g. `demo.surli`). If you are in a separate folder, you can follow this with the path to the Rust code with the functions to expose.

```bash
surrealism build --out demo.surli /Users/my_name/my_rust_code
```

The file will now be compiled at either your current location or the one specified like in the command above: `/Users/my_name/my_rust_code`.

That's the WASM plugin file that SurrealDB can point to!

## Calling the Surrealism file from SurrealDB

The Surrealism file is ready to be used. All that is left now is to start a database with two environment variables. They are:

* `SURREAL_CAPS_ALLOW_EXPERIMENTAL=files,surrealism`, which allows the [files](/docs/surrealql/statements/define/bucket) and surrealism features to be used in the first place. Files can be used in SurrealDB once a `DEFINE BUCKET` statement has been used to set up the location for the files to be stored.
* `SURREAL_BUCKET_FOLDER_ALLOWLIST="/Users/my_name/my_rust_code/"`, which tells the database that it's okay to access this folder when using the files feature.

Now it's time to [start the database](/docs/surrealdb/cli/start) with the `surreal start` command and these two env vars.

```
SURREAL_CAPS_ALLOW_EXPERIMENTAL=files,surrealism SURREAL_BUCKET_FOLDER_ALLOWLIST="/Users/my_name/my_rust_code/" surreal start --user root --pass strongpassword
```

You can then connect through [surrealist](/surrealist) or the CLI with the [surreal sql](/docs/surrealdb/cli/sql) command:

```
SURREAL_CAPS_ALLOW_EXPERIMENTAL=files,surrealism SURREAL_BUCKET_FOLDER_ALLOWLIST="/Users/mithr/random/" cargo run -- sql --ns ns --db db --user root --pass strongpassword
```

We're almost there! Only two statements left and we can start accessing these functions.

The first is a [DEFINE BUCKET](/docs/surrealql/statements/define/bucket) statement to create a bucket called `test`, linked to the folder that we have allowed the database to access. The "file:/" prefix in this statement tells the `DEFINE BUCKET` statement that this path is to a file, not temporary storage in memory.

```
DEFINE BUCKET test BACKEND "file:/users/my_name/my_rust_code";
```

Now that we have a bucket called `test`, the `demo.surli` file will be available to us at the f"test:/demo.surli" path. The `f` there is an instruction to treat the string as a file path instead of just a regular string.

Then we can [define a module](/docs/surrealql/statements/define/module) which will hold all the tests. We'll call it `mod::test` and use `AS` to connect it to the file.

```
DEFINE MODULE mod::test AS f"test:/demo.surli";
```

And now the magic begins! Let's give the `parse_number()` function a try, now available at the `mod::test::parse_number` path.

```surql
mod::test::parse_number("10");
-- 10
mod::test::parse_number("Hi I'm number");
-- 'Thrown error: WASM function returned error: invalid digit found in string'
```

Next, we can use `random_user()` to create some random users.

```surql
CREATE user CONTENT mod::test::random_user();
-- [{ age: 18, first_name: 'Thomas', id: user:hr8ohmn36zrpv3zthhnf, last_name: 'Meier', middle_name: 'Ninon' }]
CREATE user CONTENT mod::test::random_user();
-- [{ age: 13, first_name: 'Verda', id: user:zg0ucdjizdp71fzq9syc, last_name: 'Schuster', middle_name: 'Clarisse' }]
CREATE user CONTENT mod::test::random_user();
-- [{ age: 45, first_name: 'Zelda', id: user:rulp2bf82twrh94ifhsh, last_name: 'Berger', middle_name: 'Noah' }]
```

That leaves us with one function left to try out, the `can_drive()` function.

```surql
SELECT 
    first_name + ' ' + middle_name + ' ' + last_name AS name, 
    mod::test::can_drive(age) AS can_drive
FROM user;
```

Two of them can drive, but not Verda Clarisse Schuster who is far too young.

```surql
[
    { can_drive: true,  name: 'Thomas Ninon Meier' }, 
    { can_drive: true,  name: 'Zelda Noah Berger' }, 
    { can_drive: false, name: 'Verda Clarisse Schuster' }
]
```


================================================
FILE: src/content/doc-surrealdb/querying/surrealql/cli.mdx
================================================
---
sidebar_position: 3
sidebar_label: SurrealQL via CLI
title: SurrealQL via CLI | SurrealQL
description: In this section, you will explore SurrealQL queries using the SurrealDB CLI. The SurrealDB CLI provides a powerful command-line interface for writing, executing, and visualizing SurrealQL queries in real-time.
---
import Image from "@components/Image.astro";
import ImageStart from "@img/terminal-start.png";
import ImageSql from "@img/terminal-sql.png";

# SurrealQL via CLI

In this section, you will explore writing [SurrealQL](/docs/surrealql) queries using the SurrealDB CLI. To get started, you will need to install the SurrealDB CLI on your local machine. You can do this by following the instructions in the [installation section](/docs/surrealdb/cli).

The CLI provides allows you to write, execute, and visualize [SurrealQL](/docs/surrealql) queries in real-time.

## Getting Started

After installing the SurrealDB CLI, you can start writing SurrealQL queries by running the [`surreal start`](/docs/surrealdb/cli/start) command in your terminal. You can also add the `--help` flag to view the available options and commands.

To start a SurrealDB server, run the surreal start command, using the options below. This example serves the database at the default location (http://localhost:8000), with a username and password.

```bash
surreal start --endpoint http://localhost:8000 --user root --pass secret
```

The server is actively running, and should be left alone until you want to stop hosting the SurrealDB server.

<Image
    alt="Terminal start"
    src={{
        light: ImageStart,
        dark: ImageStart,
    }}
/>

## Running Queries

To run a SurrealQL query, In the new terminal, run the [`surreal sql`](/docs/surrealdb/cli/sql) command followed by the query you would like to execute. For example, to run a simple `SELECT` query, you can run the following command:

```bash title="Start a SurrealDB Shell with local endpoint"
surreal sql --endpoint http://localhost:8000 --ns test --db test
```

```bash title="Start a SurrealDB Shell with memory endpoint"
## Run query in memory
surreal sql --endpoint memory --ns test --db test
```
<Image
    alt="Terminal SQL"
    src={{
        light: ImageSql,
        dark: ImageSql,
    }}
/>

## Learn more

Learn more about the available commands and options in the [SurrealDB CLI documentation](/docs/surrealdb/cli).



================================================
FILE: src/content/doc-surrealdb/querying/surrealql/http.mdx
================================================
---
sidebar_position: 2
sidebar_label: SurrealQL via HTTP
title: SurrealQL via HTTP | SurrealQL
description: In this section, you will explore querying SurrealDB using HTTP. The HTTP API is designed to be simple and intuitive, with a RESTful interface that provides a consistent way to interact with the database.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";
import Label from "@components/shared/Label.astro";

# SurrealQL via HTTP

SurrealDB provides a powerful HTTP API that allows you to interact with the database programmatically. This API can be used to perform a wide range of database operations, from querying data to modifying records and managing database structures.

The HTTP API is designed to be simple and intuitive, with a RESTful interface that provides a consistent way to interact with the database. You can use the API to perform a wide range of database operations, from querying data to modifying records and managing database structures.




## Using curl `POST /sql`

The `/sql` endpoint enables use of SurrealQL queries.


> [!IMPORTANT]
> This HTTP endpoint expects the HTTP body to be a set of SurrealQL statements.

### Headers

<Tabs groupId="http-sql">

<TabItem value="V1" label="V1.x" >
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>NS</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>DB</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>

<TabItem value="V2" label="V2.x" default>
<table>
    <thead>
        <tr>
            <th colspan="2">Header</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Authorization</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
            Sets the root, namespace, database, or record authentication data
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>Accept</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the desired content-type of the response
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>surreal-ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Namespace for queries.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Header">
                <code>surreal-db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Sets the selected Database for queries.
            </td>
        </tr>
    </tbody>
</table>
</TabItem>
</Tabs>


### Example usage


> [!IMPORTANT]
> The `-u` in the example below is a shorthand used by curl to send an Authorization header.

<Tabs groupId="http-sql">
  <TabItem value="V1" label="V1.x">

```bash title="Request"
curl -X POST -u "root:root" -H "NS: mynamespace" -H "DB: mydatabase" -H "Accept: application/json" -d "SELECT * FROM person WHERE age > 18" http://localhost:8000/sql
```

</TabItem>
<TabItem value="V2" label="V2.x" default>
```bash title="Request"
curl -X POST -u "root:root" -H "surreal-ns: mynamespace" -H "surreal-db: mydatabase" -H "Accept: application/json" -d "SELECT * FROM person WHERE age > 18" http://localhost:8000/sql
```
</TabItem>
</Tabs>


```json title="Response"
[
	{
		"time": "14.357166ms",
		"status": "OK",
		"result": [
			{
				"age": "23",
				"id": "person:6r7wif0uufrp22h0jr0o"
				"name": "Simon",
			},
			{
				"age": "28",
				"id": "person:6r7wif0uufrp22h0jr0o"
				"name": "Marcus",
			},
		]
	}
]
```

## Using Postman

Postman is a popular tool for testing APIs. You can use it to send HTTP requests to your SurrealDB instance and perform various database operations.

1. **Set up Postman**: Download and install Postman from the [official website](https://www.postman.com/).

2. **Create a new request**: Open Postman and create a new HTTP request.

3. **Configure the request**:
   - Set the request method to `POST`.
   - Enter the URL of your SurrealDB instance, e.g., `http://localhost:8000/sql`.
   - In the [headers section](#headers), add a `Content-Type` header with the value `application/json`.
   - In the Body section, select `raw` and set the type to `Text`. Enter your SQL query, for example:

     ```json
     INFO for db
     ```

4. **Send the request**: Click the `Send` button to execute the query. You will see the response from SurrealDB in the lower section of the Postman interface.

## Learn more

Learn more about other [HTTP Endpoints](/docs/surrealdb/integration/http) available in SurrealDB. For a more detailed tutorial on using Postman with SurrealDB, refer to the [working with SurrealDB over HTTP via Postman tutorial](/docs/tutorials/working-with-surrealdb-over-http-via-postman).



================================================
FILE: src/content/doc-surrealdb/querying/surrealql/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: SurrealQL
title: SurrealQL
description: In this section, you will explore using SurrealQL, a powerful database query language that closely resembles traditional SQL but comes with unique differences and improvements to query data in SurrealDB.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/surrealql.png";
import DarkLogo from "@img/icon/dark/surrealql.png";
import ImageSurrealist from "@img/image/surrealist/query-new.png";

<div class="flag-title">
	<Image
		alt="SurrealQL"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# SurrealQL
</div>

In this section, you will explore [SurrealQL](/docs/surrealql), a powerful database query language that closely resembles traditional SQL but comes with unique differences and improvements.

[SurrealQL](/docs/surrealql) is designed to provide developers with a seamless and intuitive way to interact with SurrealDB. It offers a familiar syntax and supports various statement types, allowing you to perform complex database operations efficiently.

While SurrealQL shares similarities with traditional SQL, it introduces enhancements and optimizations that make it well-suited for working with SurrealDB's advanced features. Whether you are querying data, modifying records, or managing database structures, SurrealQL provides a comprehensive set of capabilities to meet your needs.


## Getting Started

To start using SurrealQL, [refer to the documentation on the various statement types and their syntax](/docs/surrealql/statements). The statements page provides comprehensive examples and explanations for each statement type, helping you understand how to construct queries and interact with SurrealDB effectively.

We hope that SurrealQL empowers you to leverage the full potential of SurrealDB and enables you to build robust and scalable applications. Let's dive into the world of SurrealQL and unlock the capabilities of SurrealDB together!

## Key Features

SurrealQL offers several key features that make it a powerful tool for working with SurrealDB:

- **Familiar Syntax**: SurrealQL adopts a syntax similar to traditional SQL, making it easy for developers familiar with SQL to transition to SurrealDB seamlessly.

- **Advanced Querying**: SurrealQL supports a wide range of querying capabilities, including filtering, sorting, aggregating, and joining data from multiple tables.

- **Data Manipulation**: With SurrealQL, you can easily insert, update, and delete records in your SurrealDB database, allowing you to manage your data effectively.

- **Graph relationships**: SurrealQL supports graph relationships, allowing you to define and query relationships between records in your database.

- **Schema Management**: SurrealQL provides features for creating and modifying database schemas, allowing you to define the structure of your data and enforce data integrity.

- **Performance Optimization**: SurrealQL incorporates optimizations specific to SurrealDB, ensuring efficient execution of queries and minimizing resource usage.

<Image
  alt="Surrealist query view"
  src={ImageSurrealist}
/>

## Resources

To learn more about SurrealQL and how to use it effectively, check out the following resources:

- [SurrealQL documentation](/docs/surrealql)
- [SurrealQL statements](/docs/surrealql/statements)
- [SurrealQL database functions](/docs/surrealql/functions/database)
- [SurrealQL operators](/docs/surrealql/operators)



================================================
FILE: src/content/doc-surrealdb/querying/surrealql/surrealist.mdx
================================================
---
sidebar_position: 1
sidebar_label: SurrealQL via Surrealist
title: SurrealQL via Surrealist | SurrealQL
description: In this section, you will explore SurrealQL queries using Surrealist, the official query editor for SurrealDB. Surrealist is a powerful tool that allows you to write, execute, and visualize SurrealQL queries in real-time.
---

# SurrealQL via Surrealist

In this section, you will explore writing [SurrealQL](/docs/surrealql) queries using [Surrealist](https://app.surrealdb.com/query), the official query editor for SurrealDB. Surrealist is a powerful tool that allows you to write, execute, and visualize SurrealQL queries in real-time.

The Surrealist query editor provides a rich set of features, including syntax highlighting, query validation, and query execution. You can also view the query results in a tabular format, making it easy to analyze and visualize the data.

test

> [!IMPORTANT]
> Learn more about SurrealQL by exploring the [SurrealQL documentation](/docs/surrealql).

## Getting Started

To get started with SurrealQL in Surrealist, go to the [Surrealist Query Editor](https://app.surrealdb.com/query) and start writing your SurrealQL queries. You can use the query editor to write queries, execute them, and view the results in real-time.


### Setting up a connection

In order to interact with a SurrealDB database you must first create a connection. Connections store the details required to connect to a database, such as the endpoint, namespace, database, and authentication details. When you select an active connection in Surrealist, you will connect to the database and be able to interact with it using the available interface views.

After opening a connection, you can switch to another connection at any time by pressing the connection name in the top left of the interface. This will open the connection list allowing you to switch to another connection, or create a new one.

Within the connection list you will also find a special connection called Sandbox, which is always available and allows you to test and experiment without storing data persistently. This connection is useful for learning SurrealQL, testing queries, and more. The Sandbox connection is designed for simple testing and not for evaluating performance, as it is limited to a single thread within the browser's WebAssembly engine.

You can also create a new custom connection, this will allow you to connect to a remote SurrealDB instance, or a local instance this will also require you to set the namespace and database.


### Setting a namespace and database for connections.

If you are using a connection (local or remote), before you can start writing queries, you need to set the [namespace](/docs/surrealdb/introduction/concepts/namespace) and [database](/docs/surrealdb/introduction/concepts/database) for the connection.

For example you can set the namespace to `test` and the database to `test`. This will set the namespace and database for the current connection.

### Writing a query

Once you have a connection open you can use the SurrealQL query editor to create some data. For example, you can create a new record in the person table.

```surql
CREATE person SET name = "John", age = 30;
```

In the query editor, you can use syntax highlighting, code completion, and validation to help you write your queries more efficiently. To execute a query, press the run query button at the bottom of the query editor.


## Learn more

To learn more about SurrealQL and how to write queries using Surrealist, check out the [Surrealist documentation](/docs/surrealist).



================================================
FILE: src/content/doc-surrealdb/reference-guide/full-text-search.mdx
================================================
---
sidebar_position: 2
sidebar_label: Full Text Search
title: Full Text Search reference guide | Reference guides
description: SurrealDB offers a large variety of ways to work with text, including equality and contains operators, fuzzy searching, and full-text search.
---

> [!NOTE]
> Before SurrealDB version 3.0.0-alpha.8, the `FULLTEXT ANALYZER` clause used the syntax `SEARCH ANALYZER`.

# Full Text Search

SurrealDB offers a large variety of ways to work with text, from simple operators to fuzzy searching, customized ordering, full-text search and more. In this guide, we will cover comparing and sorting text, contains functions and operators, equality and fuzzy equality, regex matching, string functions, and full-text search. 

This will give you a comprehensive overview of the different ways to work with text in SurrealDB and which one to use in your specific use case.

## Comparing and sorting text

### In `SELECT` queries

The following example shows a few records created from an array of strings in an order that is sorted to the human eye: lowest to highest numbers, then A to Z.

```surql
FOR $word IN ['1', '2', '11', 'Ábaco', 'kitty', 'Zoo'] {
	CREATE data SET val = $word;
};
```

Inside a `SELECT` query, an `ORDER BY` clause can be used to order the output by one or more field names. For the above data, an ordered `SELECT` query looks like this.

```surql
SELECT VALUE val FROM data ORDER BY val;
```

However, in the case of strings, sorting is done by Unicode rank which often leads to output that seems out of order to the human eye. The output of the above query shows the following:

```surql title="Output"
[ '1', '11', '2', 'Zoo', 'kitty', 'Ábaco' ]
```

This is because:

* '11' is ordered before '2', because the first character in the string '2' is greater than the first character in the string '1'.
* 'Zoo' is ordered before 'kitty', because the first character in the string 'Zoo' is 'Z', number 0059 in the [list of Unicode characters](https://en.wikipedia.org/wiki/List_of_Unicode_characters#Basic_Latin). A lowercase 'k' is 0076 on the list and thus "greater", while the 'Á', registered as the "Latin Capital letter A with acute", is 0129 on the list.

To sort strings in a more natural manner to the human eye, the keywords [`NUMERIC` and `COLLATE` (or both) can be used](/docs/surrealql/statements/select#sort-records-using-the-order-by-clause). `NUMERIC` will instruct strings that parse into numbers to be treated as such.

```surql
SELECT VALUE val FROM data ORDER BY val NUMERIC;
```

```surql title="Numberic strings now sorted as numbers"
[ '1', '2', '11', 'Zoo', 'kitty', 'Ábaco' ]
```

`COLLATE` instructs unicode strings to sort by alphabetic order, rather than Unicode order.

```surql
SELECT VALUE val FROM data ORDER BY val COLLATE;
```

```surql title="Output"
[ '1', '11', '2', 'Ábaco', 'kitty', 'Zoo' ]
```

And for the data in this example, `COLLATE NUMERIC` is likely what will be desired.

```surql
SELECT VALUE val FROM data ORDER BY val COLLATE NUMERIC;
```

```surql title="Output"
[ '1', '2', '11', 'Ábaco', 'kitty', 'Zoo' ]
```

### Sorting functions

As of SurrealDB `2.2.2`, the functions [`array::sort_natural()`, `array::sort_lexical()`, and `array::sort_lexical_natural()`](/docs/surrealql/functions/database/array) can be used on ad-hoc data to return the same output as the `COLLATE` and `NUMERIC` clauses in a [`SELECT` statement](/docs/surrealql/statements/select).

## Contains functions and operators

The most basic way to see if one string is contained inside another is to use the `IN` operator, or the [`string::contains()` function](/docs/surrealql/functions/database/string#stringcontains).

```surql
-- false
"Umple" IN "Rumplestiltskin";
string::contains("Rumplestiltskin", "Umple");
-- Same function using method syntax
"Rumplestiltskin".contains("Umple");

-- true
"umple" IN "Rumplestiltskin";
string::contains("Rumplestiltskin", "umple");
"Rumplestiltskin".contains("umple");
```

SurrealDB has a number of [operators](/docs/surrealql/operators) to determine if all or some of the values of one array are contained in another, such as `CONTAINSALL` and `CONTAINSANY`, or `ALLINSIDE` and `ANYINSIDE`. The operators with `CONTAINS` and `INSIDE` perform the same behaviour, just in the opposite order.

```surql
-- If 1,2,3 contains each item in 1,2...
[1,2,3] CONTAINSALL [1,2];
-- then each item in 1,2 is inside 1,2,3
[1,2] ALLINSIDE [1,2,3];
```

Because strings are essentially arrays of characters, these operators work with strings as well. 

> [!NOTE]
> The above capability was added in SurrealDB version `2.2.2`.

Both of these queries will return `true`.

```surql
"Rumplestiltskin" CONTAINSALL ["umple", "kin"];
"kin" ALLINSIDE "Rumplestiltskin";
["kin", "someotherstring"] ANYINSIDE "Rumplestiltskin";
```

## Equality and fuzzy equality

SurrealDB offers quite a few algorithms inside the [string functions module](/docs/surrealql/functions/database/string) for distance or similarity comparison. They are:

* `string::distance::damerau_levenshtein()`
* `string::distance::normalized_damerau_levenshtein()`
* `string::distance::hamming()`
* `string::distance::levenshtein()`
* `string::distance::normalized_levenshtein()`
* `string::distance::osa_distance()`

* `string::similarity::jaro()`
* `string::similarity::jaro_winkler()`

Which of these functions to choose depends on your personal use case.

For example, fuzzy similarity and distance scores are not a measure of absolute equality and ordered similarity scores should only be used in comparisons against the same string. Take the following queries for example which return the score for the string "United" and "Unite":

```surql
-- return 131 and 111
string::similarity::fuzzy("United Kingdom", "United");
string::similarity::fuzzy("United Kingdom", "Unite");

-- also return 131 and 111
string::similarity::fuzzy("United", "United");
string::similarity::fuzzy("United", "Unite");
```

While the word "Unite" is clearly closer to the word "United" than it is to "United Kingdom", the algorithm used for this function only considers how much of the second string is found in the first string.

However, the `string::similarity::jaro()` function returns an output that approaches 1 if two strings are equal, making it a more apt solution when the first and second string may be entirely different. Using the same input strings as above shows that "Unite" is clearly the most similar of the strings that are not outright equal to "United".

```surql
-- 0.8095238095238096f
string::similarity::jaro("United Kingdom", "United");
-- 0.7857142857142857f
string::similarity::jaro("United Kingdom", "Unite");
-- 1
string::similarity::jaro("United", "United");
-- 0.9444444444444445f
string::similarity::jaro("United", "Unite");
```

Another example of the large difference between algorithms is the Hamming distance algorithm, which only compares strings of equal length.

```surql
-- Error: strings have different length
string::distance::hamming("United Kingdom", "United");
-- Returns 0
string::distance::hamming("United", "United");
-- Returns 1
string::distance::hamming("United", "Unitéd");
-- Returns 6
string::distance::hamming("United", "uNITED");
```

## Regex matching

The `string::matches()` function can be used to perform regex matching on a string.

```surql
-- true
string::matches("Cat", "[HC]at");
-- Also true
string::matches("Hat", "[HC]at");
```

## Other string functions

SurrealDB has a large number of [string functions](/docs/surrealql/functions/database/string) that can be used manually to refine string searching, such as `string::lowercase()`, `string::starts_with()`, and `string::ends_with()`.

```surql
SELECT 
    $this AS word, 
    $this.lowercase() = "sleek" AS is_sleek
FROM ["sleek", "SLEEK", "Sleek", "sleeek"];
```

```surql title="Output"
[
	{
		is_sleek: true,
		word: 'sleek'
	},
	{
		is_sleek: true,
		word: 'SLEEK'
	},
	{
		is_sleek: true,
		word: 'Sleek'
	},
	{
		is_sleek: false,
		word: 'sleeek'
	}
]
```

For more customized text searching, full-text search can be used.

## Full-text search

Full-Text search supports text matching, proximity searches, result ranking, and keyword highlighting, making it a much more comprehensive solution when precise text searching is required.

It is also [ACID-compliant](https://en.wikipedia.org/wiki/ACID), which ensures data integrity and reliability.

### Defining an analyzer

The first step to using full-text search is to [define an analyzer](/docs/surrealql/statements/define/analyzer) using a `DEFINE ANALYZER` statement. An analyzer is not defined on a table, but a set of tokenizers (to break up text) and filters (to modify text).

The `DEFINE ANALYZER` page contains a detailed explanation of each type of tokenizer and analyzer to choose from. To define the analyzer that most suits your needs, it is recommended to use the [`search::analyze`](/docs/surrealql/functions/database/search#searchanalyze) function which returns the output of an analyzer for an input string.

Take the following analyzer for example, which uses `blank` to split a string by whitespace, and `edgengram(3, 10)` to output all of the instances of the first three to ten letters of a word.

```surql
DEFINE ANALYZER blank_edgengram TOKENIZERS blank FILTERS edgengram(3, 10);
search::analyze("blank_edgengram", "The Wheel of Time turns, and Ages come and pass, leaving memories that become legend.");
```

The output includes strings like 'turns,' and 'legend.', which include punctuation marks.

```surql title="Output"
['The', 'Whe', 'Whee', 'Wheel', 'Tim', 'Time', 'tur', 'turn', 'turns', 'turns,', 'and', 'Age', 'Ages', 'com', 'come', 'and', 'pas', 'pass', 'pass,', 'lea', 'leav', 'leavi', 'leavin', 'leaving', 'mem', 'memo', 'memor', 'memori', 'memorie', 'memories', 'tha', 'that', 'bec', 'beco', 'becom', 'become', 'leg', 'lege', 'legen', 'legend', 'legend.']
```

If this is not desired, some looking through the `DEFINE ANALYZER` page will turn up another tokenizer called `punct` that can be included, now creating an analyzer that splits on whitespace as well as punctuation.

```surql
DEFINE ANALYZER blank_edgengram TOKENIZERS blank, punct FILTERS edgengram(3, 10);
search::analyze("blank_edgengram", "The Wheel of Time turns, and Ages come and pass, leaving memories that become legend.");
```

```surql title="Output"
['The', 'Whe', 'Whee', 'Wheel', 'Tim', 'Time', 'tur', 'turn', 'turns', 'and', 'Age', 'Ages', 'com', 'come', 'and', 'pas', 'pass', 'lea', 'leav', 'leavi', 'leavin', 'leaving', 'mem', 'memo', 'memor', 'memori', 'memorie', 'memories', 'tha', 'that', 'bec', 'beco', 'becom', 'become', 'leg', 'lege', 'legen', 'legend']
```

#### Tokenizers and filters

The available tokenizers and filters are as follows:

* Tokenizers `blank`, `camel`, `punct` to split by whitespace, camelcase, and punctuation. The `class` tokenizer splits when a class change is detected, such as letter to number, space to letter, punctuation to letter, and so on.
* Filters `ascii`, `lowercase`, `uppercase` to change to ASCII, lowercase, and uppercase.

The `ngram` filter is similar to the `edgengram` filter above in that it takes a minimum and maximum length, but instead moves from character to character inside a string as it attempts to find all the possible outputs in between these two lengths.

```surql
DEFINE ANALYZER example_analyzer FILTERS ngram(1,4);
search::analyze("example_analyzer", "cars!");
```

Here is the output modified slightly to show the output of the `ngram` filter at each step of the way.

```surql title="Output"
[
	'c', 'ca', 'car', 'cars',
	'a', 'ar', 'ars', 'ars!',
	'r', 'rs', 'rs!',
	's', 's!',
	'!'
]
```

The `snowball` and `mapper` filters are the most complex and versatile.

#### The `snowball` filter

The snowball filter is used to perform stemming: the reduction of a word to as basic and universal a form as possible. It is available for the languages Arabic, Danish, Dutch, English, Finnish, French, German, Greek, Hungarian, Italian, Norwegian, Portuguese, Romanian, Russian, Spanish, Swedish, Tamil, and Turkish.

Stemming involves using an algorithm to reduce a word, but is unable to incorporate complex changes like the plural and verbal vowel changes in English.

```surql
DEFINE ANALYZER snowball_test TOKENIZERS blank,punct FILTERS snowball(english);
search::analyze("snowball_test", "
    manager managing management
    running ran 
    foot feet
    introspective
    introspection
    introspected
");
```

```surql title="Output"
[
	'manag',
	'manag',
	'manag',
	'run',
	'ran',
	'foot',
	'feet',
	'introspect',
	'introspect',
	'introspect'
]
```

Stemming is particularly useful in languages with complex but regular declension, such as Finnish. In the following example, the snowball filter is able to turn all declined forms of the word "talo" (house) into its root form.

```surql
DEFINE ANALYZER snowball_test TOKENIZERS blank,punct FILTERS snowball(finnish);
search::analyze("snowball_test", "talo talon taloa talossa talostani taloonsa talolla talolta talolle talona taloksi taloin talotta taloineen");
```

```surql title="Output"
['talo', 'talo', 'talo', 'talo', 'talo', 'talo', 'talo', 'talo', 'talo', 'talo', 'talo', 'talo', 'talot', 'talo']
```

#### The `mapper` filter

The `mapper` filter is the most customizable of all, involving a list of strings and the strings they are to be mapped to. This filter requires a path to a text file, inside which each base form is followed by a word to map to it, separated by a tab.

```text title="mapper.txt"
run	ran
foot	feet
```

In the case of the above example, the `mapper` will allow the output to show the base forms of the words "ran" and "feet".

```surql
DEFINE ANALYZER mapper TOKENIZERS blank FILTERS snowball(english),mapper('mapper.txt');
search::analyze("mapper", "
    manager managing management
    running ran 
    foot feet
    introspective
    introspection
    introspected
");
```

```surql
[
	'manag',
	'manag',
	'manag',
	'run',
	'run',
	'foot',
	'foot',
	'introspect',
	'introspect',
	'introspect'
]
```

The word `mapper` was intentionally chosen to be ambiguous, as this feature can be used to map any string to another string. It could be used for example to map cities to provinces, planets to stars, hieroglyphs to English words, and so on.

```text title="mapper.txt"
seated_man	𓀀
man_with_hand_to_mouth	𓀁
seated_woman	𓁐
goddess_with_feather	𓁦
```

```surql
DEFINE ANALYZER mapper TOKENIZERS blank FILTERS mapper('mapper.txt');
search::analyze("mapper", "𓀀 𓁦");
```

```surql title="Output"
[
	'seated_man',
	'goddess_with_feather'
]
```

### Defining a Full-Text index

Once a search analyzer is defined, it can be applied to the fields of a table to make them searchable by [defining an index](/docs/surrealql/statements/define/indexes#full-text-search-index) that uses the `FULLTEXT ANALYZER` clause. Having a full-text index in place makes it possible to use the `@@` operator (the `MATCHES` operator).

```surql
DEFINE ANALYZER my_analyzer
  TOKENIZERS class
  FILTERS lowercase, ascii;

-- Two statements as full-text indexes must be defined on only one field
DEFINE INDEX body_index ON TABLE article FIELDS body FULLTEXT ANALYZER my_analyzer;
DEFINE INDEX title_index ON TABLE article FIELDS title FULLTEXT ANALYZER my_analyzer;

CREATE article SET title = "Machine Learning!", body = "Machine learning, or ML, is all the rage these days. Developers are...";
CREATE article SET title = "History of machines", body = "The earliest 'machine' used by our ancestors was a simple sharpened stone tool. It was...";

SELECT body, title FROM article WHERE body @@ "machine" OR title @@ "machine";
```

```surql title="Output"
[
	{
		body: 'Machine learning, or ML, is all the rage these days. Developers are...',
		title: 'Machine Learning!'
	},
	{
		body: "The earliest 'machine' used by our ancestors was a simple sharpened stone tool. It was...",
		title: 'History of machines'
	}
]
```

To use highlighting and best match scoring on searches, the `BM25` and `HIGHLIGHTS` clauses can be added to the `DEFINE INDEX` statement. These enable you use the [`search::highlight`](/docs/surrealql/functions/database/search#searchhighlight) and [`search::score`](/docs/surrealql/functions/database/search#searchscore) functions.

Inside a query, the `@@` operator takes a number that is matched with the same number passed into one of these functions. In the example below, the `WHERE text @0@ "night"` part of the query will match with `search::highlight("->", "<-", 0)` and `search::score(0) AS text_score`, while `title @1@ "hound"` will match with `search::score(1) AS title_score`.

```surql
DEFINE ANALYZER my_analyzer TOKENIZERS class, blank FILTERS lowercase, ascii;
DEFINE INDEX text_index ON TABLE article FIELDS text FULLTEXT ANALYZER my_analyzer BM25 HIGHLIGHTS;
DEFINE INDEX title_index ON TABLE article FIELDS title FULLTEXT ANALYZER my_analyzer BM25 HIGHLIGHTS;

INSERT INTO article (title, text) VALUES
    ("A Study in Scarlet", "IN the year 1878 I took my degree of Doctor of Medicine of the University of London, and proceeded to Netley to go through the course prescribed for surgeons in the army."),
    ("A Study in Scarlet", "Having completed my studies there, I was duly attached to the Fifth Northumberland Fusiliers as Assistant Surgeon."),
    ("The Sign of the Four", "SHERLOCK HOLMES took his bottle from the corner of the mantel-piece and his hypodermic syringe from its neat morocco case."),
    ("The Hound of the Baskervilles", "MR. SHERLOCK HOLMES, who was usually very late in the mornings, save upon those not infrequent occasions when he was up all night, was seated at the breakfast table."),
    ("The Hound of the Baskervilles", "I stood upon the hearth-rug and picked up the stick which our visitor had left behind him the night before.");

SELECT
    text,
    title,
    search::highlight("->", "<-", 0) AS title,
    search::score(0) AS text_score,
    search::score(1) AS title_score
FROM article
WHERE
    text  @0@ "night" OR
    title @1@ "hound";
```

```surql title="Output"
[
	{
		text: 'MR. SHERLOCK HOLMES, who was usually very late in the mornings, save upon those not infrequent occasions when he was up all night, was seated at the breakfast table.',
		text_score: 0.30209195613861084f,
		title: 'MR. SHERLOCK HOLMES, who was usually very late in the mornings, save upon those not infrequent occasions when he was up all ->night<-, was seated at the breakfast table.',
		title_score: 0.32491400837898254f
	},
	{
		text: 'I stood upon the hearth-rug and picked up the stick which our visitor had left behind him the night before.',
		text_score: 0.35619309544563293f,
		title: 'I stood upon the hearth-rug and picked up the stick which our visitor had left behind him the ->night<- before.',
		title_score: 0.32491400837898254f
	}
]
```

## See also

* [Using SurrealDB as a Full Text Search Database](/docs/surrealdb/models/full-text-search)
* [SurrealDB search functions](/docs/surrealql/functions/database/search)
* [SurrealDB operators](/docs/surrealql/operators)
* Blog post: [Create a Search Engine with SurrealDB Full-Text Search
](/blog/create-a-search-engine-with-surrealdb-full-text-search)



================================================
FILE: src/content/doc-surrealdb/reference-guide/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Reference guides
title: Reference guides
description: In this section, you will find reference guides for SurrealDB and its features.
---

# Reference Guides

In this section, you will find reference guides for SurrealDB and its features.

## Introduction

The purpose of this section is to help you connect the dots between different concepts explained in the documentation. 

It will help you understand how different features and concepts are related to each other and how you can use them together to build powerful applications.

If you are new to SurrealDB, we recommend that you start with the [Getting Started](/docs/surrealdb/introduction/start) section of the documentation or the [SurrealQL](/docs/surrealql).

This section will provide you with a solid foundation of the core concepts and features of SurrealDB.

## Reference Guides

Within this section, you will find a collection of "Reference" guides that cover a wide range of topics related to SurrealDB.

These guides will help you dig deeper into some of the core concepts and features of SurrealDB.

To get started, select a guide from the sidebar or use the search functionality to find a specific topic of interest.

- [Full-Text Search](/docs/surrealdb/reference-guide/full-text-search)
- [Observability](/docs/surrealdb/reference-guide/observability)
- [Security Best Practices](/docs/surrealdb/reference-guide/security-best-practices)
- [Performance Best Practices](/docs/surrealdb/reference-guide/performance-best-practices)
- [Sample Industry Schemas](/docs/surrealdb/reference-guide/sample-industry-schemas)
- [Schema Best Practices](/docs/surrealdb/reference-guide/schema-creation-best-practices)




================================================
FILE: src/content/doc-surrealdb/reference-guide/observability.mdx
================================================
---
sidebar_position: 3
sidebar_label: Observability
title: Observability | Reference guides
description: In SurrealDB, metrics and traces are available if enabled⁠.
---

import Since from "@components/shared/Since.astro";

# Observability

SurrealDB can be monitored by enabling the built in observability.

## Enable observability
To enable observability, the `SURREAL_TELEMETRY_PROVIDER` environment variable has to be set to `otlp`. If set to anything else, no observability will be available.

If enabled, SurrealDB will send metrics and/or traces to an [OpenTelemetry Collector](https://opentelemetry.io/docs/collector/).  Configuration of the collector is done via [environment variables](https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/). The most important one is [OTEL_EXPORTER_OTLP_ENDPOINT](https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/#otel_exporter_otlp_endpoint). By default this is set to localhost. It should be set to the GRPC endpoint of your OTEL collector. For example if your OTEL collector named `my-collector` is running in Kubernetes in the `monitoring` namespace the following can be used: 

```
OTEL_EXPORTER_OTLP_ENDPOINT="http://my-collector.monitoring.svc.cluster.local:4317"
```

Metrics can be disabled (even if `SURREAL_TELEMETRY_PROVIDER` is set to `otlp`) by setting the `SURREAL_TELEMETRY_DISABLE_METRICS` environment variable to `true`. Similarly traces can be disabled by setting `SURREAL_TELEMETRY_DISABLE_TRACING` to `true`.

## Metrics

Metrics are gathered every minute and sent to the collector. The following metrics are present:

<table>
    <thead>
        <tr>
            <th colspan="1" scope="col">Name</th>
            <th colspan="1" scope="col">[Instrument](https://opentelemetry.io/docs/concepts/signals/metrics/#metric-instruments)</th>
            <th colspan="1" scope="col">Explanation</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="1" scope="row" data-label="Metric name">
                rpc.server.duration
            </td>
            <td colspan="1" scope="row" data-label="Type">
                histogram
            </td>
            <td colspan="1" scope="row" data-label="Explanation">
                Measures duration of inbound RPC requests in milliseconds
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Metric name">
                rpc.server.active_connections
            </td>
            <td colspan="1" scope="row" data-label="Type">
                counter
            </td>
            <td colspan="1" scope="row" data-label="Explanation">
                The number of active WebSocket connections
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Metric name">
                rpc.server.response.size
            </td>
            <td colspan="1" scope="row" data-label="Type">
                histogram
            </td>
            <td colspan="1" scope="row" data-label="Explanation">
                Measures the size of HTTP response messages
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Metric name">
                http.server.duration
            </td>
            <td colspan="1" scope="row" data-label="Type">
                histogram
            </td>
            <td colspan="1" scope="row" data-label="Explanation">
                The HTTP server duration in milliseconds
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Metric name">
                http.server.active_requests
            </td>
            <td colspan="1" scope="row" data-label="Type">
                counter
            </td>
            <td colspan="1" scope="row" data-label="Explanation">
                The number of active HTTP requests
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Metric name">
                http.server.request.size
            </td>
            <td colspan="1" scope="row" data-label="Type">
                histogram
            </td>
            <td colspan="1" scope="row" data-label="Explanation">
                Measures the size of HTTP request messages
            </td>
        </tr>
        <tr>
            <td colspan="1" scope="row" data-label="Metric name">
                http.server.response.size
            </td>
            <td colspan="1" scope="row" data-label="Type">
                histogram
            </td>
            <td colspan="1" scope="row" data-label="Explanation">
                Measures the size of HTTP response messages
            </td>
        </tr>
    </tbody>
</table>

The metrics are shown here in the form required by the [OpenTelemetry Metrics Semantic Conventions](https://opentelemetry.io/docs/specs/semconv/general/metrics/) with a `.` separator. When ingested into Prometheus the `.` separator will be [replaced](https://prometheus.io/blog/2024/03/14/commitment-to-opentelemetry/#support-utf-8-metric-and-label-names) with an `_`. For example `rpc.server.active.connections` will be transformed into `rpc_server_active_connections`.

## Tokio console

<Since v="v3.0.0-alpha.7" />

The [tokio console](https://github.com/tokio-rs/console) tool can also be used to observe the low-level async tasks for the database.

To use it, [install the Cargo package manager for Rust](https://doc.rust-lang.org/cargo/getting-started/installation.html), use the command `cargo install --locked tokio-console` to install tokio console, and then `tokio-console` to run it.

![A screenshot of the tokio console showing active SurrealDB tasks.](tokio_console_1.png)

![A screenshot of the tokio console showing poll times by percentile.](tokio_console_2.png)

The following environment variables are used to manage the console:

* `SURREAL_TOKIO_CONSOLE_ENABLED` set to `true` to enable the console
* `SURREAL_TOKIO_CONSOLE_SOCKET_ADDR` to override the default address at `127.0.0.1:6669`
* `SURREAL_TOKIO_CONSOLE_RETENTION` to override the default `6s` (six seconds) value for length of time to [retain data for completed events](https://docs.rs/console-subscriber/0.4.1/console_subscriber/struct.Builder.html#method.retention).

## Log output settings

SurrealDB contains a large number of flags for the [surreal start](/docs/surrealdb/cli/start) command and [environment variables](/docs/surrealdb/cli/env) to modify the output from the database server. A quick overview of some of these flags is as follows:

* Use `--log` to set the logging level (`info`, `warn`, `trace`, etc.).
* Use `--log-format` to set the format (`text` or `json`).
* Use `--log-socket` to send logs to a certain host:port.
* Use `--log-file-enabled` to output logs to a file, followed by `--log-file-path` to specify the path to save logs to to.
* Use `--log-file-rotation` to specify whether to create a new file for logs at a certain interval (`daily`, `hourly`, or `never`).
* Use `--slow-log-threshold` to specify a duration after which a query will be logged as a slow query.
* Use `--slow-log-param-allow` and `--slow-log-param-deny` to indicate which parameters are to be calculated before logging. For example, if `$table_name` has the value "person", allowing `table_name` will change `SELECT * FROM $table_name` to `SELECT * FROM person` in the logs.




================================================
FILE: src/content/doc-surrealdb/reference-guide/performance-best-practices.mdx
================================================
---
sidebar_position: 5
sidebar_label: Performance Best Practices
title: Performance Best Practices | Reference guides
description: This guide outlines some key performance best practices for using SurrealDB 2.0. While SurrealDB offers powerful and flexible features to support you in meeting your desired performance standards, the use that you make of those features will ultimately determine whether or not you meet them.
---

# Performance Best Practices

This guide outlines some key performance best practices for using SurrealDB `v2.x.x`. While SurrealDB offers powerful and flexible features to help you meet your desired performance standards, your use of those features will ultimately determine whether or not you meet them.

To achieve the best performance from SurrealDB, there are a number of configuration options and runtime design choices to be considered which can improve and affect the performance of the database.

The following is a non-exhaustive list of performance best practices you should consider when building services and applications with SurrealDB to help you address common performance challenges while preventing frequent pitfalls.


## SurrealDB architecture

While SurrealDB is a [multi-model database](/blog/what-are-multi-model-databases), at its core, SurrealDB stores data in documents on transactional key-value stores.

This means that SurrealDB is a general-purpose databases optimised for a combination of various workloads such as operational, AI and real-time workloads.

While SurrealDB can perform well with real-time and advanced analytical workloads, its architecture is not columnar based. Therefore its not optimised for large ad-hoc analytical queries in the same way as specialised columnar data warehouses.

SurrealDB is built using a layered approach, with compute separated from the storage. This allows us, if necessary, to scale up the compute layer, and the storage layer independently from each other.

Read more about the [architecture of SurrealDB and the supported storage engines.](/docs/surrealdb/introduction/architecture)

## Running SurrealDB

### Using SurrealDB Cloud 

The easiest way to run SurrealDB is using SurrealDB Cloud , which allows you to focus on building great products while we take care of running and maintaining it in the most performant and scalable way.

Read more about running SurrealDB [using SurrealDB Cloud ](/cloud).

### Running SurrealDB as a server

When starting the SurrealDB server, it is important to run the server using the correct configuration options and
settings. For production environments or for performance benchmarking, the `--log` command-line argument or the
`SURREAL_LOG` environment variable should be set to `error`, `warn`, or `info` (the default option when not specified).

> [!NOTE]
>Other log verbosity levels (such as `debug`, `trace`, or `full`) are only for use in debugging, testing, or development scenarios. The verbosity of the log level impacts the performance by increasing the amount of information being logged for each single operation.

When starting up the SurrealDB binary ensure that the `--log` argument is omitted, or specifically set to the correct
log verbosity level. Additionally, ensure that the `rocksdb` storage engine is used to store data.

```sh
surreal start --log info rocksdb://path/to/mydatabase
```

When starting up the SurrealDB Docker container ensure that the `--log` argument is omitted, or specifically set to the
correct log verbosity level.

```sh
docker run --rm --pull always -p 8000:8000 surrealdb/surrealdb:latest start --log info rocksdb://path/to/mydatabase
```

Read more about running SurrealDB as a [single-node server](/docs/surrealdb/installation/running/file) or [multi-node cluster](/docs/surrealdb/installation/running/tikv).

### Running SurrealDB embedded in Rust

When running SurrealDB as an embedded database within Rust, using the correct release profile and memory allocator can
greatly improve the performance of the database core engine. In addition using an optimised asynchronous runtime
configuration can help speed up concurrent queries and increase database throughput.

In your project's `Cargo.toml` file, ensure that the release profile uses the following configuration:

```toml
[profile.release]
lto = true
strip = true
opt-level = 3
panic = 'abort'
codegen-units = 1
```

In your project's `Cargo.toml` file, ensure that the `allocator` feature is enabled on the `surrealdb` dependency:

```toml
surrealdb = { version = "2", features = ["allocator", "storage-mem", "storage-surrealkv", "storage-rocksdb", "protocol-http", "protocol-ws", "rustls"] }
```

When running SurrealDB within your Rust code, ensure that the asynchronous runtime is configured correctly, making use
of multiple threads, an increased stack size, and an optimised number of threads:

```toml
tokio = { version = "1.41.1", features = ["sync", "rt-multi-thread"] }
```

```rs
fn main() {
	tokio::runtime::Builder::new_multi_thread()
    .enable_all()
    .thread_stack_size(10 * 1024 * 1024) // 10MiB
    .build()
    .unwrap()
    .block_on(async {
      // Your application code
    })
}
```

Read more about [running SurrealDB embedded in Rust.](/docs/surrealdb/embedding/rust)

### Running SurrealDB embedded in Tauri

When running SurrealDB as an embedded database within Rust, default options of Tauri can make SurrealDB run slower, as
it processes and outputs the database information logs. Configuring Tauri correctly, can result in much improved
performance with the core database engine and any queries which are run on SurrealDB.

When building a desktop application with Tauri, ensure that the Tauri plugin log is disabled by configuring the
`tauri.conf.json` file:

```json
{
	"plugins": {
		"logger": {
			"enabled": false
			}
	}
}
```

Alternatively you can disable logs at compile time when building your Tauri app:

```bash
TAURI_LOG_LEVEL=off cargo tauri build
```

## Performing queries

### Selecting single records

Certain queries in SurrealDB can be more efficiently written in certain ways which ensure that full table scans or indexes are not necessary when executing the query.

In traditional SQL, the following query can be used to query for a particular row from a table:

```surql
SELECT *
FROM user
WHERE id = 19374837491;
```

However, currently in SurrealDB this query will perform a scan to find the record, although this is not necessary and you don't need to index the id field when using SurrealDB. Instead the following query can be used to select the specific record without needing to perform any scan:

```surql
SELECT *
FROM user:19374837491;
```

### Selecting multiple records

In traditional SQL, the following queries can be used to query for getting particular rows from a table:

```surql
-- Selecting individual IDs
SELECT *
FROM user
WHERE id = 19374837491
   OR id = 12647931632;
```

```surql
-- Selecting a range of IDs
SELECT *
FROM user
WHERE id >= 12647931632
   AND id <= 19374837491;
```

However, currently in SurrealDB this query will perform a scan to find the record, although this is not necessary and you don't need to index the id field when using SurrealDB. Instead the following query can be used to select the specific record without needing to perform any scan:

```surql
-- Selecing indiviudal IDs
SELECT *
FROM user:19374837491, user:12647931632;
```

```surql
-- Selecting a range of IDs
SELECT *
FROM user:12647931632..=19374837491;
```

### Simplifying logic in `WHERE` clauses

If a `WHERE` clause cannot be avoided, performance can still be improved by optimizing the portion after the `WHERE` clause. As a boolean check is the simplest possible operation, having a boolean field that can be used in a `WHERE` clause can significantly improve performance.

```surql
-- Fill up the database a bit with 10,000 records
CREATE |person:10000| SET
    random_data = rand::string(1000),
    data_length = random_data.len(),
    is_short = data_length < 10 RETURN NONE;
-- Add one outlier
CREATE person:one SET
    random_data = "HI!",
    data_length = random_data.len(),
    is_short = data_length < 10 RETURN NONE;

-- Function call + compare operation: slowest
SELECT * FROM person WHERE random_data.len() < 10;
-- Compare operation: much faster
SELECT * FROM person WHERE data_length < 10;
-- Boolean check: even faster
SELECT * FROM person WHERE is_short;
-- Direct record access: almost instantaneous
SELECT * FROM person:one;
```

## Using indexes

SurrealDB has native built-in support for a number of different index types, without leveraging external libraries or
implementations.

With native support for indexes in the core database engine, SurrealDB leverages indexes where possible within the SurrealQL query language, without pushing queries down to a separate indexing engine. 

In addition, data is indexed in the same way for embedded systems, single-node database servers, and multi-node highly-available clusters, ensuring that the same indexing functionality is available regardless of the SurrealDB deployment model. 

Indexing support in SurrealDB is in active development, with work focusing on increased support for additional operators, compound indexes, additional index types, and overall improved index performance.

> [!NOTE]
> Currently no indexes are used when performing `UPDATE` or `DELETE` queries on large table, even where indexes are defined.
> We'll be adding support for indexes within `UPDATE`, `UPSERT`, and `DELETE` statements in SurrealDB release `v2.3.0`.

In the meantime, you can improve the performance of `UPDATE` and `DELETE` statements by combining these with a `SELECT` statement.

To improve the performance of an `UPDATE` statement, use a `SELECT` statement within a subquery, selecting only the `id`
field. This will use any defined indexes:

```surql
UPDATE (SELECT id FROM user WHERE age < 18)
SET adult = false;
```

To improve the performance of an `DELETE` statement, use a `SELECT` statement within a subquery, selecting only the `id`
field. This will use any defined indexes:

```surql
DELETE (SELECT id FROM user WHERE age < 18);
```

### Index strategies explained

When using `SELECT`, SurrealDB uses a query planner whose role is to identify if it can use the index to speed the
execution of the query.

Without indexes, SurrealDB will operate a `SELECT` query on a table by using the table iterator. It mainly scans every
record of a given table. If there is a condition (`WHERE ...`), an ordering (`ORDER BY ...`), or an aggregation (`GROUP
BY ...`), it will load the value in memory and execute the operation. This process is commonly called a "table full
scan".

```surql
SELECT *
FROM user
WHERE age < 18
EXPLAIN;
```

```surql title="Output"
[
	{
		detail: {
			table: 'user'
		},
		operation: 'Iterate Table'
	},
	{
		detail: {
			type: 'Memory'
		},
		operation: 'Collector'
	}
]
```

Under certain conditions, if an index exists, and the condition or ordering involves exclusively fields that are
indexed, the query planner will suggest an execution plan that involves one or multiple indexes to achieve these
potential optimisations:

- Only collect records that match the condition(s), as opposed to performing a table full scan.
- As the index already stores the records in order, the scanning collects the records pre-ordered, sparing an additional ordering phase.

```surql
DEFINE INDEX idx_user_age ON user FIELDS age;

SELECT age
FROM user
WHERE age > 18
EXPLAIN;
```

```surql title="Output"
[
	{
		detail: {
			plan: {
				from: {
					inclusive: false,
					value: 18
				},
				index: 'idx_user_age',
				to: {
					inclusive: false,
					value: NONE
				}
			},
			table: 'user'
		},
		operation: 'Iterate Index'
	},
	{
		detail: {
			type: 'Memory'
		},
		operation: 'Collector'
	}
]
```

If there are several clauses separated with `OR` operators, the query planner may do several index-based iterations:

```surql
SELECT age
FROM user
WHERE age < 7
   OR age > 77
EXPLAIN;
```

```surql title="Output"
[
	{
		detail: {
			plan: {
				from: {
					inclusive: false,
					value: NONE
				},
				index: 'idx_user_age',
				to: {
					inclusive: false,
					value: 7
				}
			},
			table: 'user'
		},
		operation: 'Iterate Index'
	},
	{
		detail: {
			plan: {
				from: {
					inclusive: false,
					value: 77
				},
				index: 'idx_user_age',
				to: {
					inclusive: false,
					value: NONE
				}
			},
			table: 'user'
		},
		operation: 'Iterate Index'
	},
	{
		detail: {
			type: 'Memory'
		},
		operation: 'Collector'
	}
]
```

### Use `UPSERT` to take advantage of unique indexes

`UPSERT` statements have a unique performance advantage when paired with a unique index.

A unique index on its own is used to prevent more than one record from containing the same data, such as a name or email address.

```surql
DEFINE INDEX email_index ON user FIELDS email UNIQUE;

CREATE user SET email = "bob@bob.com";
CREATE user SET email = "bob@bob.com";
```

```surql title="Output"
"Database index `email_index` already contains 'bob@bob.com', with record `user:g7s070gqvh3lj7fdp26w`"
```

An `UPSERT` statement works like a `CREATE` statement in this case as well, except that if the value for `email` is already present, it will modify the existing record instead of creating a new one. An `UPSERT` will only fail in this case if a user attempts to upsert to a certain record ID (like `user:bob` instead of just the `user` table) when another record holds this value.

The key point here is that in either case, `UPSERT` is using the index to find the record instead of a table scan.

```surql
DEFINE INDEX email_index ON user FIELDS email UNIQUE;

CREATE user SET email = "bob@bob.com";

-- Checks index, finds existing user via email "bob@bob.com", modifies it
UPSERT user SET email = "bob@bob.com", name = "Bob Bobson";

-- Checks index, fails as a new `user:bob` cannot be created with the same email
UPSERT user:bob SET email = "bob@bob.com", name = "Bob Bobson";
```

As such, when updating a single record on a table that contains a unique index, `UPSERT` is much more performant than `UPDATE`.

```surql
DEFINE INDEX email_index ON user FIELDS email UNIQUE;

-- Create 50,000 users to fill up the database
CREATE |user:50000| RETURN NONE;

-- Create Bob
CREATE user SET email = "bob@bob.com";

-- Don't do this: full table scan to find and update a record
UPDATE user SET name = "Bob Bobson" WHERE email = "bob@bob.com";

-- Do this instead: use the index instead to go directly to the record, no table scan
UPSERT user SET name = "Bob Bobson", email = "bob@bob.com";
```

### Index lookup on remote fields

SurrealDB document record IDs store both the table name and the record identifier. This design provides a
straightforward and consistent way to reference records across the database. One particularly powerful feature is the
ability to filter a table based on conditions that relate to a referenced table.

Here is a concrete example, where the statement `SELECT * FROM access WHERE user.role = 'admin'` will retrieve records
from the `access` table for which the referenced record in the `user` table has the `name` field set to 'admin'.

Consider the following example:

```surql
DEFINE FIELD user ON TABLE access TYPE record<user>;

CREATE user:1 SET name = 'foo', role = 'admin';
CREATE user:2 SET name = 'bar', role = 'admin';

CREATE access:A SET user = user:1;
CREATE access:B SET user = user:2;

SELECT *
FROM access
WHERE user.role = 'admin'
```

The query retrieves records from the `access` table whose associated record in the `user` table has the role `field` set
to 'admin'.

```surql title="Output"
[
	{
		id: access:A,
		user: user:1
	},
	{
		id: access:B,
		user: user:2
	}
]
```

To optimize this query, you can create indexes on both the `user.role` field and the `access.user` field.
With these indexes, the query planner can leverage an index-based join strategy:

```surql
DEFINE INDEX idx_user_role ON TABLE user COLUMNS role;
DEFINE INDEX idx_access_user ON TABLE access COLUMNS user;

SELECT *
FROM access
WHERE user.role = 'admin' 
EXPLAIN;
```

```surql title="Output"
[
	{
		detail: {
			plan: {
				index: 'idx_access_user',
				joins: [
					{
						index: 'idx_user_role',
						operator: '=',
						value: 'admin'
					}
				],
				operator: 'join'
			},
			table: 'access'
		},
		operation: 'Iterate Index'
	},
	{
		detail: {
			type: 'Memory'
		},
		operation: 'Collector'
	}
]
```



================================================
FILE: src/content/doc-surrealdb/reference-guide/sample-industry-schemas.mdx
================================================
---
sidebar_position: 7
sidebar_label: Sample Industry Schemas
title: Simple sample schemas by industry to get started
description: Find a sample schema or two for your industry to copy and paste and modify to your own needs.
---

# Sample schemas by industry

This page contains a number of sample schemas, each about 50 lines in length, that can be used to get started on a schema of your own for your own industry.

Have a request for an industry not yet in this page? [Get in touch](/contact) and let us know.

> [!NOTE]
> Many fields in these schemas use [`COMPUTED` fields](/docs/surrealql/statements/define/field#computed-fields), available as of SurrealDB version 3.0.0-alpha.8. For versions before this, a data type called a [`future`](/docs/surrealql/datamodel/futures) was used. To use such fields in a version before 3.0.0-alpha.8, replace `COMPUTED` with `VALUE <future>` and enter an expression to be calculated inside `{}` braces.

### Adding to this page

Have a sample schema of your own that you'd like to add? If it's about 50 lines in length then feel free to [make a PR](https://github.com/surrealdb/docs.surrealdb.com/edit/main/src/content/doc-surrealdb/reference-guide/sample-industry-schemas.mdx) and we'll credit the addition with a link to your profile on a code hosting platform (e.g. GitHub, GitLab, Codeberg).

## Energy and manufacturing

### Project planning

A comprehensive project management schema that demonstrates activity scheduling, milestone tracking, and dependency management using [graph relationships](/docs/surrealdb/models/graph). This schema shows how to model complex project workflows with interdependent tasks and progress tracking using [futures](/docs/surrealql/statements/define/field#futures) for calculated fields.

```surql
-- Activities in a project schedule
DEFINE TABLE activity SCHEMAFULL;
DEFINE FIELD name         ON activity TYPE string;
DEFINE FIELD description  ON activity TYPE option<string>;
DEFINE FIELD start        ON activity TYPE datetime;
DEFINE FIELD end          ON activity TYPE datetime;
DEFINE FIELD duration     ON activity COMPUTED end - start;
DEFINE FIELD progress     ON activity TYPE float ASSERT $value IN 0.0..=1.0;
DEFINE FIELD assigned_to  ON activity TYPE option<record<employee>>;
DEFINE FIELD followed_by  ON activity COMPUTED <-depends_on<-activity;

-- Milestones
DEFINE TABLE milestone SCHEMAFULL;
DEFINE FIELD project      ON milestone TYPE record<project>;
DEFINE FIELD activities   ON milestone TYPE array<record<activity>>;
DEFINE FIELD name         ON milestone TYPE string;
DEFINE FIELD last_updated ON milestone VALUE time::now();
DEFINE FIELD progress     ON milestone COMPUTED math::mean(activities.progress);
DEFINE FIELD is_complete  ON milestone COMPUTED activities.all(|$a| $a.progress > 0.95);

-- Graph-style dependency links
DEFINE TABLE depends_on SCHEMAFULL TYPE RELATION IN activity OUT activity;
DEFINE TABLE activity_of SCHEMAFULL TYPE RELATION IN activity OUT project;

CREATE project:one;

CREATE activity:one SET name = "Project kickoff", start = time::now(), end = time::now() + 2d, progress = 1.0, project = project:one;
CREATE activity:two SET name = "Pour concrete", start = time::now() + 90d, end = time::now() + 100d, progress = 0.0, project = project:one;
CREATE activity:three SET name = "Dry concrete", start = time::now() + 100d, end = time::now() + 107d, progress = 0.0, project = project:two;
CREATE activity:four SET name = "Build on top of concrete", start = time::now() + 107d, end = time::now() + 150d, progress = 0.0, project = project:two;

RELATE activity:two->depends_on->activity:one;
RELATE activity:three->depends_on->activity:two;
RELATE activity:four->depends_on->activity:three;
RELATE [activity:one,activity:two,activity:three, activity:four]->activity_of->project:one;

CREATE milestone:one SET project = project:one, activities = [activity:one], name = "Project start";
CREATE milestone:two SET project = project:one, activities = [activity:two, activity:three, activity:four], name = "Initial construction";

-- See all graph connections between activity and project records
SELECT *, ->?, <-? FROM activity, project;

-- View the current milestones
SELECT * FROM milestone;
```

### SCADA (Oil and Gas)

Industrial monitoring and control system schema for oil and gas operations. Demonstrates real-time sensor data collection, automated alert generation using [events](/docs/surrealql/statements/define/event), and [time-series data management](/docs/surrealdb/models/time-series) with composite keys. Shows how to handle flexible external data integration and [live query monitoring](/docs/surrealql/statements/live).

```surql
DEFINE TABLE sensor SCHEMAFULL;
DEFINE FIELD type ON sensor TYPE array<string> ASSERT $value ALLINSIDE ["pressure", "temperature", "flow", "level"];
DEFINE FIELD location         ON sensor TYPE point;

DEFINE TABLE reading SCHEMAFULL;
DEFINE FIELD id               ON reading TYPE [record<sensor>, datetime];
DEFINE FIELD pressure         ON reading TYPE float;
-- Optional telemetry values
DEFINE FIELD temperature      ON reading TYPE option<float>;
DEFINE FIELD humidity         ON reading TYPE option<float>;
-- Flexible object for weather or external data
DEFINE FIELD weather          ON reading TYPE option<object> FLEXIBLE;

DEFINE TABLE alert SCHEMAFULL;
DEFINE FIELD equipment    ON alert TYPE record<sensor>;
DEFINE FIELD severity     ON alert TYPE string ASSERT $value IN ["critical", "high", "medium", "low", "info"];
DEFINE FIELD message      ON alert TYPE string;
DEFINE FIELD triggered_at ON alert TYPE datetime;

-- Create a sensor
CREATE sensor:one SET type = ["temperature", "pressure"], location = (50.0, 50.0);
-- And a reading for the sensor
CREATE reading:[sensor:one, time::now()] SET 
    pressure = 600,
    -- JSON object sourced from somewhere else, `weather` field is FLEXIBLE so can be any object format
    weather = { "temperature": 17.4, "humidity": 52.0, "wind_speed": 12.8 };

-- Set up event to generate alerts
DEFINE EVENT alert_from_create ON reading WHEN $event = "CREATE" THEN {
    LET $source = $after.id[0];
    LET $time = $after.id[1];
    -- Select everything over the past 15 minutes up to but not including the present reading
    LET $recents_average = math::mean(SELECT VALUE pressure FROM reading:[$source, $time - 15m]..[$source, $time]);
    LET $drop = $recents_average - $after.pressure;
    IF $drop > 15 {
      CREATE alert SET
            equipment = $source,
            severity = "high",
            message = "Pressure drop over 15 PSI: drop of " + <string>$drop,
            triggered_at = time::now();
    };
};

-- Some readings with good values
FOR $_ IN 0..10 {
    -- Sleep to keep timestamp in IDs unique, consider a ULID instead if timestamps may not be unique
    sleep(10ns);
    CREATE reading:[sensor:one, time::now()] SET pressure = 600;
};
-- Pressure has suddenly dropped
CREATE reading:[sensor:one, time::now()] SET pressure = 500;

-- See the alert
SELECT * FROM alert;
-- Or use a LIVE SELECT for alerts: https://surrealdb.com/docs/surrealql/statements/live
LIVE SELECT * FROM alert;
```

### Risk management

Project risk assessment and mitigation tracking schema. Features temporal risk modeling with active/inactive periods, probability-impact calculations, and automated risk scoring using [futures](/docs/surrealql/statements/define/field#futures). Demonstrates [unique constraints](/docs/surrealql/statements/define/indexes#unique-indexes) and complex mathematical aggregations across related records.

```surql
DEFINE TABLE risk SCHEMAFULL;
DEFINE FIELD project        ON risk TYPE record<project> REFERENCE;
DEFINE FIELD description    ON risk TYPE string;
DEFINE FIELD category       ON risk TYPE string; -- e.g. "technical", "commercial", "regulatory"
DEFINE FIELD likelihood     ON risk TYPE float ASSERT $value IN 0.0..=1.0;
DEFINE FIELD maximum_impact ON risk TYPE int; -- in dollars, etc.
DEFINE FIELD start          ON risk TYPE datetime;
DEFINE FIELD end            ON risk TYPE datetime;
-- Use a computed field to calculate value on each SELECT
DEFINE FIELD active         ON risk COMPUTED time::now() IN start..=end;
-- Ensure no duplicate `risk` records exist for each project
DEFINE INDEX risk_name      ON risk FIELDS project, description UNIQUE;

-- See all total_impact
DEFINE FIELD total_risk_impact ON project COMPUTED
    math::sum(<~risk.map(|$risk| $risk.maximum_impact * $risk.likelihood));

-- See risks at the current date
DEFINE FIELD current_risk_impact ON project COMPUTED
    math::sum(<~risk.filter(|$r| $r.active).map(|$risk| $risk.maximum_impact * $risk.likelihood));

CREATE project:one;

CREATE risk SET
    project = project:one,
    description = "Migratory elk",
    category = "regulatory",
    likelihood = 0.9,
    start = d'2025-10-01',
    end = d'2025-12-15',
    maximum_impact = 1000000;

CREATE risk SET
    project = project:one,
    description = "Wildfires",
    category = "technical",
    likelihood = 0.5,
    start = d'2025-06-01',
    end =d'2025-10-15',
    maximum_impact = 10000000;

SELECT * FROM project;
```

### Supply chain and contract management

Vendor relationship and contract lifecycle management schema. Covers contract value tracking with change orders, deliverable management, and automated total commitment calculations using [futures](/docs/surrealql/statements/define/field#futures). Demonstrates complex financial calculations and status tracking across multiple related entities.

```surql
-- Vendors who supply goods or services
DEFINE TABLE vendor SCHEMAFULL;
DEFINE FIELD name ON vendor TYPE string;

-- Contracts awarded under a project
DEFINE TABLE contract SCHEMAFULL;
DEFINE FIELD project        ON contract TYPE record<project>;
DEFINE FIELD vendor         ON contract TYPE record<vendor>;
DEFINE FIELD title          ON contract TYPE string;
DEFINE FIELD original_value ON contract TYPE int;
DEFINE FIELD total_value    ON contract COMPUTED 
    original_value + math::sum(SELECT VALUE amount FROM change_order WHERE contract = $parent.id);
DEFINE FIELD currency ON contract TYPE "dollars" | "euro";
DEFINE FIELD start   ON contract TYPE datetime;
DEFINE FIELD end     ON contract TYPE datetime;

-- Deliverables expected under a contract
DEFINE TABLE deliverable SCHEMAFULL;
DEFINE FIELD contract    ON deliverable TYPE record<contract>;
DEFINE FIELD description ON deliverable TYPE string;
DEFINE FIELD due_date    ON deliverable TYPE datetime;
DEFINE FIELD received    ON deliverable TYPE option<datetime>;
DEFINE FIELD status      ON deliverable COMPUTED IF $parent.received { "complete" } ELSE { "pending" };

-- Change orders during a project
DEFINE TABLE change_order SCHEMAFULL;
DEFINE FIELD contract    ON change_order TYPE record<contract>;
DEFINE FIELD amount      ON change_order TYPE int;
DEFINE FIELD description ON change_order TYPE string;
DEFINE FIELD signed_on   ON change_order TYPE option<datetime>;

-- Total committed value of a project (sum of all contract values)
DEFINE FIELD total_commitment ON project COMPUTED
  math::sum((SELECT VALUE value FROM contract WHERE project = $parent.id));

CREATE project:one;
CREATE vendor:one SET name = "Good vendor";
    CREATE contract:one SET project = project:one, currency = "euro", start = d'2025-12-01', end = d'2026-01-01', original_value = 1000, title = "Services for so-and-so project", vendor = vendor:one;
CREATE change_order SET contract = contract:one, amount = 500, description = "Highway wasn't set up yet";
SELECT * FROM contract;
```

### HSSE (Health, Safety, Security, Environment) incidents

Incident reporting and investigation schema using [graph relationships](/docs/surrealdb/models/graph). Models safety events as edges between employees and projects with severity classification and role identification. Demonstrates graph-style data modeling for complex incident tracking and analysis.

```surql
-- Projects and employees (nodes)
DEFINE TABLE project SCHEMAFULL;
DEFINE TABLE employee SCHEMAFULL;

-- Edges: incident links employee → project
DEFINE TABLE incident SCHEMAFULL TYPE RELATION IN project OUT employee;

DEFINE FIELD severity     ON incident TYPE string ASSERT $value IN ["minor", "moderate", "major", "fatal"];
DEFINE FIELD type         ON incident TYPE string ASSERT $value IN ["safety", "environment", "security", "health"];
DEFINE FIELD description  ON incident TYPE string;
DEFINE FIELD occurred_at  ON incident TYPE datetime;
DEFINE FIELD role         ON incident TYPE string ASSERT $value IN ["witness", "injured", "involved"];

-- Create nodes
CREATE employee:one SET name = "John Doe";
CREATE employee:two SET name = "Sally Lee";
CREATE project:one  SET name = "Pad 3 Expansion";

-- Create incidents as edges with properties
RELATE employee:one->incident->project:one SET 
  severity = "moderate", 
  type = "safety",
  description = "Pinched hand during pipe fitting",
  occurred_at = time::now() - 5d,
  role = "injured";

RELATE employee:two->incident->project:one SET 
  severity = "moderate",
  type = "safety",
  description = "Pinched hand during pipe fitting",
  occurred_at = time::now() - 5d,
  role = "witness";

SELECT id, <-incident[WHERE severity = "moderate"]<-employee FROM project;
```


## Finance

### General bank schema (graph schema)

Multi-currency banking system using [graph relationships](/docs/surrealdb/models/graph). Demonstrates polymorphic account types (JPY, EUR, CAD, USD) with different field structures, customer-bank relationships, and [unique constraint enforcement](/docs/surrealql/statements/define/indexes#unique-indexes). Shows how to model complex financial relationships with type-specific behaviors.

```surql
DEFINE TABLE bank SCHEMAFULL;
DEFINE FIELD name     ON bank TYPE string;

DEFINE TABLE customer SCHEMAFULL;
DEFINE FIELD name ON customer TYPE string;

DEFINE TABLE customer_of TYPE RELATION IN customer OUT bank;
DEFINE FIELD since ON customer_of TYPE datetime VALUE time::now() READONLY;

DEFINE TABLE jpy SCHEMAFULL;
DEFINE FIELD amount ON jpy TYPE int DEFAULT 0;
DEFINE FIELD cent ON jpy TYPE int READONLY VALUE 0;

DEFINE TABLE eur SCHEMAFULL;
DEFINE FIELD amount ON eur TYPE int DEFAULT 0;
DEFINE FIELD cent   ON eur TYPE int ASSERT $value IN 0..=99;
DEFINE FIELD total  ON eur VALUE amount + (<float>$parent.cent / 100);

DEFINE TABLE cad SCHEMAFULL;
DEFINE FIELD amount ON cad TYPE int DEFAULT 0;
DEFINE FIELD cent   ON cad TYPE int ASSERT $value IN 0..=99;
DEFINE FIELD total  ON cad VALUE $parent.amount + (<float>$parent.cent / 100);

DEFINE TABLE usd SCHEMAFULL;
DEFINE FIELD amount ON usd TYPE int DEFAULT 0;
DEFINE FIELD cent   ON usd TYPE int ASSERT $value IN 0..=99;
DEFINE FIELD total  ON usd VALUE $parent.amount + (<float>$parent.cent / 100);

DEFINE TABLE account TYPE RELATION IN customer OUT jpy|eur|cad|usd;
DEFINE FIELD since ON account TYPE datetime VALUE time::now() READONLY;

-- stop the same customer opening two wallets in the same currency
DEFINE INDEX unique_wallet ON account FIELDS in, out UNIQUE;

CREATE bank:one SET name = "Central Bank";
CREATE customer:one SET name = "Billy";
RELATE customer:one->customer_of->bank:one;
RELATE customer:one->account->(CREATE ONLY eur SET amount = 100, cent = 50);
RELATE customer:one->account->(CREATE ONLY jpy SET amount = 10000);

SELECT ->account->eur.total FROM customer:one;
```

### Other bank-customer schema

Traditional bank-customer schema with advanced features including [record references](/docs/surrealql/datamodel/records#record-references), automated cent handling through [events](/docs/surrealql/statements/define/event), and historical interest rate tracking. Demonstrates event-driven data validation, [parameter usage](/docs/surrealql/statements/define/param), and complex relationship management with reference fields.

```surql
DEFINE PARAM $CURRENCIES VALUE ["EUR", "JPY", "USD", "CAD"];

DEFINE TABLE account SCHEMAFULL;
DEFINE FIELD customer ON account TYPE record<customer> REFERENCE;
DEFINE FIELD currency ON account TYPE string ASSERT $value IN $CURRENCIES;
DEFINE FIELD amount   ON account TYPE int;
DEFINE FIELD cent     ON account TYPE option<int>;

DEFINE TABLE customer SCHEMAFULL;
DEFINE FIELD name     ON customer TYPE string;
DEFINE FIELD bank     ON customer TYPE record<bank> REFERENCE;

DEFINE TABLE bank SCHEMAFULL;
DEFINE FIELD name         ON bank TYPE string;
DEFINE FIELD code         ON bank TYPE string;  -- e.g., BIC or internal short code
DEFINE FIELD swift        ON bank TYPE option<string>;
DEFINE FIELD supported_currencies ON bank TYPE set<string> ASSERT $value ALLINSIDE $CURRENCIES;
DEFINE FIELD interest_rate ON bank TYPE float DEFAULT 0.0;
DEFINE FIELD historical_interest_rates ON bank TYPE array<{ rate: float, set_at: datetime }> DEFAULT [];
DEFINE FIELD customers ON bank COMPUTED <~customer;

-- No assert for cent field, but event to update when > 100 or < 0
DEFINE EVENT update_cents ON account WHEN $event = "UPDATE" THEN {
    IF cent > 99 {
        UPDATE $after SET cent -= 100, amount += 1;
    } ELSE IF cent < 0 {
        UPDATE $after SET cent += 100, amount -= 1;
    }
};

-- No assert for cent field, but event to update when > 100 or < 0
DEFINE EVENT update_interest_rate ON bank WHEN $event = "UPDATE" THEN {
    IF $before.interest_rate != $after.interest_rate {
        UPDATE $this SET historical_interest_rates += { rate: $after.interest_rate, set_at: time::now() };
    }
};

CREATE bank:one SET name = "Bank of One", code = "ONEBANK", supported_currencies = ["EUR", "JPY"];
UPDATE bank:one SET interest_rate = 5.0;
CREATE customer:one SET bank = bank:one, name = "Galen Pathwarden";
CREATE account:one SET customer = customer:one, bank = bank:one, currency = "JPY", amount = 10000;

SELECT *, customers.{id, name} FROM bank;
```

### Customers and money transfers

Secure money transfer system with credit-based limits and transaction logging. Features [custom functions](/docs/surrealql/statements/define/function) for atomic transfers, credit level enforcement, and comprehensive audit trails. Demonstrates transaction safety, business rule enforcement, and financial data integrity.

```surql
DEFINE TABLE customer SCHEMAFULL;
-- trusted customers can have greater negative amounts
DEFINE FIELD amount ON customer ASSERT $value >= -1000 * credit_level;
DEFINE FIELD credit_level ON customer TYPE int ASSERT $value IN 0..=5;

-- Logs for money transfers
DEFINE TABLE transfer SCHEMAFULL;
DEFINE FIELD from     ON transfer TYPE record<customer>;
DEFINE FIELD to       ON transfer TYPE record<customer>;
DEFINE FIELD amount   ON transfer TYPE int;
DEFINE FIELD ts       ON transfer TYPE datetime DEFAULT time::now();

DEFINE FUNCTION fn::send_money($from: record<customer>, $to: record<customer>, $amount: int) {
-- Use manual transaction for all statements so all changes are rolled back
-- if something is wrong
    BEGIN;
    If $amount < 1 {
        THROW "Can't send less than 1 ";
    };
    UPDATE $from SET amount -= $amount;
    UPDATE $to SET amount += $amount;
    CREATE transfer SET from = $from, to = $to, amount = $amount;
    COMMIT;
};

CREATE customer:one SET amount = 100, credit_level = 0;
CREATE customer:two SET amount = 500, credit_level = 5;

-- customer:one has bad credit, can't be negative
fn::send_money(customer:one, customer:two, 500);
-- but customer:two can
fn::send_money(customer:two, customer:one, 1000);

SELECT * FROM customer;
SELECT * FROM transfer;
```

### Loans and repayments

Loan management system with automated interest calculations and repayment scheduling. Features [parameterized loan terms](/docs/surrealql/statements/define/param), mathematical payment calculations using [custom functions](/docs/surrealql/statements/define/function), and status tracking. Demonstrates complex financial formulas, temporal data management, and regulatory compliance constraints.

```surql
-- Some government-set maximum term for loans
DEFINE PARAM $MAX_TERM VALUE 84;

DEFINE TABLE loan SCHEMAFULL;
DEFINE FIELD customer      ON loan TYPE record<customer>;
DEFINE FIELD principal     ON loan TYPE int; -- Total borrowed, in cents
DEFINE FIELD interest_rate ON loan TYPE float; -- e.g., 5.5 for 5.5%
DEFINE FIELD issued_at     ON loan TYPE datetime;
-- loans issuable at units of 6 months each
DEFINE FIELD term_months   ON loan TYPE int ASSERT $value % 6 = 0 AND $value <= $MAX_TERM;
DEFINE FIELD balance       ON loan TYPE int; -- Remaining amount to repay
DEFINE FIELD status        ON loan TYPE string ASSERT $value IN ["active", "paid", "defaulted"];

DEFINE TABLE repayment SCHEMAFULL;
DEFINE FIELD loan       ON repayment TYPE record<loan>;
DEFINE FIELD due_date   ON repayment TYPE datetime;
DEFINE FIELD amount     ON repayment TYPE int;
DEFINE FIELD paid       ON repayment TYPE bool DEFAULT false;
DEFINE FIELD paid_at    ON repayment TYPE option<datetime>;
DEFINE FIELD method     ON repayment TYPE option<string>; -- e.g., "auto", "manual"

FOR $loan IN SELECT * FROM loan {
    LET $update_rate = 1 + ($loan.interest_rate / 365);
    UPDATE $loan SET amount = amount * $update_rate;
};

DEFINE FUNCTION fn::repayment_amount($loan: record<loan>) {
    LET $P = $loan.principal;
    LET $annual = $loan.interest_rate / 100;
    LET $r = $annual / 12;              -- Monthly interest rate
    LET $n = $loan.term_months;

    math::round(
        $P * $r / (1 - math::pow(1 + $r, -$n))
    );
};

CREATE customer:one;
CREATE loan:one SET customer = customer:one, principal = 5000000, interest_rate = 5.0, issued_at = time::now(), term_months = 12, balance = 5000000, status = "active";
UPDATE loan:one SET balance -= fn::repayment_amount(loan:one);
```

### Fraud prevention patterns

Anti-fraud detection system using [events](/docs/surrealql/statements/define/event) and temporal analysis. Implements velocity checks, new account restrictions, and suspicious transaction pattern detection. Demonstrates real-time fraud prevention, temporal constraints, and complex business rule enforcement through database events.

```surql
DEFINE FIELD created_at ON account VALUE time::now() READONLY;
DEFINE EVENT cancel_high_volume ON TABLE sends WHEN $event = "CREATE" THEN {
    IF $after.amount > 1000 AND time::now() - $after.in.created_at < 1d {
        THROW "New accounts can only send up to $1000 per transaction";
    }
};

DEFINE FIELD sent_at ON TABLE sends VALUE time::now() READONLY;

DEFINE EVENT cancel_high_volume ON TABLE sends WHEN $event = "CREATE" THEN {
    LET $sender = $after.in;
    LET $receiver = $after.out;
    -- Disallow more than two transactions within a 5 minute period
    LET $recents = 
        $sender->sends[WHERE out = $receiver]
        .filter(|$tx| time::now() - $tx.sent_at < 5m);
    IF $recents.len() > 2 {
        THROW "Can't send that many times within a short period of time";
    };
};
```

### Using Surrealist's graph visualization to see fraudulent activities

For more on these queries and their visual output, see [this dedicated blog post](/blog/fraud-detection-with-surrealdb).

Star pattern: one card used to pay large number of accounts:

```surql
DEFINE FIELD paid_at ON pays DEFAULT time::now();

-- sketchy cards
FOR $card IN CREATE |card:10| {
    FOR $_ IN 0..rand::int(5, 15) {
        LET $payee = UPSERT ONLY account;
        RELATE $card->pays->$payee SET amount = rand::int(100, 1000);    
    };
};

-- regular card
CREATE card:normal;
FOR $_ IN 0..rand::int(5, 15) {
    LET $payee = UPSERT ONLY account;
    RELATE card:normal->pays->$payee SET amount = rand::int(100, 1000), paid_at = time::now() - rand::duration(1d, 100d);
};

SELECT id, ->pays.filter(|$payment| time::now() - $payment.paid_at < 1d).out FROM card;
```

Tight communities that interact mostly among themselves:

```surql
-- Regular community of 200
CREATE |account:200|;
-- Smaller community that interacts among itself
CREATE |account:5| SET is_sketchy = true;

-- The sketchy community interacts only between itself
-- the regular community has more general interactions
-- and sometimes sends money to the sketchy accounts
FOR $account IN SELECT * FROM account {
    FOR $_ IN 0..10 {
        LET $counterpart = IF $account.is_sketchy {
            rand::enum(SELECT * FROM account WHERE is_sketchy)
        } ELSE {
            rand::enum(SELECT * FROM account)
        };
        RELATE $account->sends_to->$counterpart SET amount = rand::int(100, 1000);
    }
};

SELECT id, ->sends_to->account FROM account;
```

Circles showing loops of money returning to its origin:

```surql
CREATE |account:50|;
CREATE |account:1..16| SET is_sketchy = true;

FOR $sketchy IN SELECT * FROM account WHERE is_sketchy {
    LET $counterpart = rand::enum(SELECT * FROM account WHERE is_sketchy AND !<-sent);
    RELATE $sketchy->sent->$counterpart SET amount = rand::int(100, 1000);
};

LET $normal = SELECT * FROM account WHERE !is_sketchy;
FOR $account IN SELECT * FROM account WHERE !is_sketchy {
    LET $counterpart = rand::enum(SELECT * FROM $normal);
    RELATE $account->sent->$counterpart SET amount = rand::int(100, 1000);
};

SELECT id, ->sent->account FROM account;
```

## Gaming

### Characters and quests

RPG game system with character progression, inventory management, and quest tracking. Features polymorphic item effects, character statistics, and complex game state management. Demonstrates flexible data modeling for gaming applications with rich object structures and [relationship tracking](/docs/surrealdb/models/graph).

```surql
-- Characters controlled by players
DEFINE TABLE character SCHEMAFULL;
DEFINE FIELD name     ON character TYPE string;
DEFINE FIELD level    ON character TYPE int DEFAULT 1;
DEFINE FIELD xp       ON character TYPE int DEFAULT 0;
DEFINE FIELD class    ON character TYPE string ASSERT $value IN ["warrior", "mage", "rogue"];
DEFINE FIELD stats    ON character TYPE { str: int, dex: int, int: int };

-- Items in the game world
DEFINE TABLE item SCHEMAFULL;
DEFINE FIELD name     ON item TYPE string;
DEFINE FIELD type     ON item TYPE string ASSERT $value IN ["weapon", "armor", "potion"];
DEFINE FIELD rarity   ON item TYPE string ASSERT $value IN ["common", "rare", "epic", "legendary"];
DEFINE FIELD effects  ON item TYPE array<{ str: int } | { heal: int }>; // etc.

-- Items possessed by characters
DEFINE TABLE owns TYPE RELATION IN character OUT item;
DEFINE FIELD equipped ON owns TYPE bool DEFAULT false;

-- Quests available in the world
DEFINE TABLE quest SCHEMAFULL;
DEFINE FIELD name      ON quest TYPE string;
DEFINE FIELD required_level ON quest TYPE int DEFAULT 1;
DEFINE FIELD rewards   ON quest TYPE { exp: int, items: array<record<item>> };

-- Character quest progress
DEFINE TABLE quest_log TYPE RELATION IN character OUT quest;
DEFINE FIELD status       ON quest_log TYPE string ASSERT $value IN ["active", "completed"];
DEFINE FIELD started_at   ON quest_log TYPE datetime DEFAULT time::now();
DEFINE FIELD completed_at ON quest_log TYPE option<datetime>;

-- Events
DEFINE TABLE character_event SCHEMAFULL;
DEFINE FIELD character  ON character_event TYPE record<character>;
DEFINE FIELD details    ON character_event TYPE 
    { type: "combat", exp: int, against: string, summary: string } |
    { type: "item_used", item: record<item>, summary: string } |
    { type: "quest_update", summary: string };
DEFINE FIELD ts         ON character_event TYPE datetime DEFAULT time::now();

-- Create a new character
CREATE character:aria SET name = "Aria", class = "mage", stats = { str: 4, dex: 6, int: 12 };

-- Give Aria an item
RELATE character:aria->owns->(CREATE ONLY item SET name = "Wand of Sparks", type = "weapon", rarity = "rare", effects = { int: 2 });

-- Start a quest
RELATE character:aria->quest_log->quest:slime_hunt SET status = "active";
```

## Aerospace and astronomy

### Telescopes and observations

Astronomical observation tracking system with instrument management and data collection. Features geospatial telescope locations, flexible observation metadata, and scientific data URL management. Demonstrates [point data types](/docs/surrealql/datamodel/geometries#point), complex temporal relationships, and scientific data organization patterns.

```surql
-- Telescopes (instruments)
DEFINE TABLE telescope SCHEMAFULL;
DEFINE FIELD name        ON telescope TYPE string;
DEFINE FIELD location    ON telescope TYPE point;
DEFINE FIELD aperture_mm ON telescope TYPE int; -- e.g. 200 for 8" scope

-- Astronomical targets
DEFINE TABLE target SCHEMAFULL;
DEFINE FIELD name        ON target TYPE string;
DEFINE FIELD type        ON target TYPE string ASSERT $value IN ["star", "planet", "nebula", "galaxy", "asteroid"];

-- Observation logs
DEFINE TABLE observed SCHEMAFULL TYPE RELATION IN telescope OUT target;
DEFINE FIELD observer        ON observed TYPE record<person>;
DEFINE FIELD observed_at     ON observed TYPE datetime;
DEFINE FIELD observed_until  ON observed TYPE option<datetime>;
DEFINE FIELD exposure_length ON observed VALUE IF observed_until { observed_until - observed_at } ELSE { 0ns };
DEFINE FIELD notes           ON observed TYPE option<string>;
DEFINE FIELD filter          ON observed TYPE option<string> ASSERT $value IN ["B", "V", "R", "I", "H-alpha", "OIII", "IR"];
DEFINE FIELD sky_conditions  ON observed TYPE option<string> ASSERT $value IN ["clear", "thin cloud", "hazy", "overcast"];
DEFINE FIELD data_url        ON observed TYPE option<string>; -- e.g. to FITS file, rendered image, or DOI

CREATE telescope:one SET name = "The one telescope", location = (-68.44, -29.14), aperture_mm = 200;
CREATE target:venus SET type = "planet", name = "Venus";
CREATE person:one;

RELATE telescope:one->observed->target:venus SET 
    observer = person:one,
    observed_at = time::now(),
    observed_until = time::now() + 1h,
    filter = "R",
    seeing = 0.7,
    sky_conditions = "clear",
    data_url = "https://astro.example.org/data/venus-2025.fits";

```

### Launch telemetry

Space launch monitoring system with real-time telemetry data collection. Features component-level tracking, [time-series data management](/docs/surrealdb/models/time-series) with composite keys, and launch lifecycle status tracking. Demonstrates high-frequency data ingestion, temporal range queries, and [live data streaming](/docs/surrealql/statements/live).

```surql
-- A specific launch instance (e.g., Falcon 9 Flight 100)
DEFINE TABLE launch SCHEMAFULL;
DEFINE FIELD name         ON launch TYPE string;
DEFINE FIELD vehicle_name ON launch TYPE option<string>;
DEFINE FIELD scheduled_at ON launch TYPE datetime;
DEFINE FIELD liftoff_at   ON launch TYPE option<datetime>;
DEFINE FIELD status       ON launch TYPE string ASSERT $value IN ["scheduled", "launched", "scrubbed", "failed", "success"] DEFAULT "scheduled";
DEFINE FIELD completed    ON launch TYPE option<datetime>;
 
-- Components involved in the launch
DEFINE TABLE component SCHEMAFULL;
DEFINE FIELD launch     ON component TYPE record<launch>;
DEFINE FIELD name       ON component TYPE string; -- e.g., "first_stage", "engine_1"
DEFINE FIELD type       ON component TYPE string ASSERT $value IN ["stage", "engine", "payload", "fairing"];

-- Time-series telemetry linked to a component
DEFINE TABLE telemetry SCHEMAFULL;
DEFINE FIELD id            ON telemetry TYPE [record<component>, datetime]; -- [component, ulid]
DEFINE FIELD altitude_m    ON telemetry TYPE option<float>;
DEFINE FIELD velocity_mps  ON telemetry TYPE option<float>;
DEFINE FIELD thrust_kN     ON telemetry TYPE option<float>;
DEFINE FIELD pressure_kPa  ON telemetry TYPE option<float>;
DEFINE FIELD temperature_C ON telemetry TYPE option<float>;
DEFINE FIELD status        ON telemetry TYPE option<string>;

CREATE launch:one SET name = "Launch 1", vehicle_name = "Fire rocket", scheduled_at = time::now() - 5s, liftoff_at = time::now() - 1s;
CREATE component:one SET launch = launch:one, name = "Engine 1", type = "engine";
CREATE component:two SET launch = launch:one, name = "Engine 2", type = "engine";

-- Add durations to all datetimes below to simulate passage of time
CREATE telemetry:[component:one, time::now()] SET temperature_c = 30.5, status = "good";
CREATE telemetry:[component:one, time::now() + 1s] SET temperature_c = 30.7, status = "good";
CREATE telemetry:[component:one, time::now() + 2s] SET temperature_c = 30.9, status = "good";
CREATE telemetry:[component:one, time::now() + 3s] SET temperature_c = 35.0, status = "good";
CREATE telemetry:[component:two, time::now()] SET temperature_c = 30.5, status = "good";
CREATE telemetry:[component:two, time::now() + 1s] SET temperature_c = 30.7, status = "good";
CREATE telemetry:[component:two, time::now() + 2s] SET temperature_c = 30.9, status = "good";
CREATE telemetry:[component:two, time::now() + 3s] SET temperature_c = 35.0, status = "good";

UPDATE launch:one SET completed = time::now() + 5s;

-- Get all telemetry for component:two during launch:one
SELECT * FROM telemetry:[component:two, launch:one.liftoff_at]..=[component:two, launch:one.completed];

-- Or LIVE SELECT during the flight
LIVE SELECT * FROM telemetry WHERE id[0] = component:two;
```

## Defense / mission operations

### Missions and tasks

Military mission management system with unit tracking and operational logging. Features hierarchical command structure, real-time status updates, and comprehensive audit trails. Demonstrates complex organizational modeling, [geospatial tracking](/docs/surrealql/datamodel/geometries#point), and mission-critical data management patterns.

```surql
-- Mission-level directive
DEFINE TABLE operation SCHEMAFULL;
DEFINE FIELD name        ON operation TYPE string;
DEFINE FIELD status      ON operation TYPE string ASSERT $value IN ["planned", "active", "complete", "aborted"] DEFAULT "planned";
DEFINE FIELD commander   ON operation TYPE option<record<person>>;
DEFINE FIELD start_time  ON operation TYPE option<datetime>;
DEFINE FIELD end_time    ON operation TYPE option<datetime>;

DEFINE TABLE unit SCHEMAFULL;
DEFINE FIELD members     ON unit TYPE array<record<person>>;
DEFINE FIELD operation   ON unit TYPE record<operation>;
DEFINE FIELD name        ON unit TYPE string; -- e.g., "drone-2", "squad-a"
DEFINE FIELD type        ON unit TYPE string ASSERT $value IN ["drone", "vehicle", "infantry", "support"];
DEFINE FIELD status      ON unit TYPE string ASSERT $value IN ["ready", "deployed", "engaged", "inactive"];

-- Time-stamped unit log (e.g., movement, engagement, report)
DEFINE TABLE log SCHEMAFULL;
DEFINE FIELD id          ON log TYPE [record<unit>, datetime]; -- [unit, timestamp]
DEFINE FIELD message     ON log TYPE string;
DEFINE FIELD status      ON log TYPE option<string>; -- e.g., "engaged", "moving", "waiting"
DEFINE FIELD lonlat      ON log TYPE option<point>;
DEFINE FIELD visibility  ON log TYPE option<string> ASSERT $value IN ["clear", "obscured", "night"];

-- Tasks assigned within a mission
DEFINE TABLE task SCHEMAFULL;
DEFINE FIELD operation   ON task TYPE record<operation>;
DEFINE FIELD name        ON task TYPE string;
DEFINE FIELD objective   ON task TYPE string;
DEFINE FIELD assigned_to ON task TYPE option<array<record<unit>>>;
DEFINE FIELD priority    ON task TYPE string ASSERT $value IN ["high", "medium", "low"];
DEFINE FIELD completed   ON task TYPE bool DEFAULT false;

CREATE operation:alpha SET name = "Operation Alpha", commander = person:one, start_time = time::now();

CREATE unit:squad1 SET operation = operation:alpha, name = "squad-1", type = "infantry", status = "deployed", members = [person:one, person:two];
CREATE unit:drone1 SET operation = operation:alpha, name = "drone-1", type = "drone", status = "ready", members = [person:three, person:four];

CREATE task SET 
  operation = operation:alpha, 
  name = "Secure Ridge", 
  objective = "Clear hilltop sector", 
  assigned_to = [unit:squad1], 
  priority = "high";

-- Log messages (simulate time with + durations)
CREATE log:[unit:squad1, time::now()] SET message = "Entered zone", status = "moving", lonlat = (44.2, 6.3);
CREATE log:[unit:squad1, time::now() + 3m] SET message = "Engaged hostiles", status = "engaged", visibility = "clear";
CREATE log:[unit:drone1, time::now()] SET message = "Recon sweep complete", status = "waiting", lonlat = (44.3, 6.2);
```

## Retail

### People, products and commerce

E-commerce platform schema with customer profiles, product catalog, and shopping cart management. Features flexible address storage, multi-currency support, and comprehensive timestamp tracking. Demonstrates modern e-commerce data modeling with [flexible objects](/docs/surrealql/datamodel/objects#flexible-objects) and relationship management.

```surql
-- Person / customer profile
DEFINE TABLE person SCHEMAFULL;
DEFINE FIELD name     ON person TYPE string;
DEFINE FIELD email    ON person TYPE string ASSERT string::is_email($value);
DEFINE FIELD address  ON person FLEXIBLE TYPE object;
DEFINE FIELD time     ON person TYPE object;
DEFINE FIELD time.created_at ON person TYPE datetime DEFAULT time::now();
DEFINE FIELD time.updated_at ON person TYPE datetime VALUE time::now();

-- Payment method linked to person
DEFINE TABLE payment_details SCHEMAFULL;
DEFINE FIELD person          ON payment_details TYPE record<person>;
DEFINE FIELD stored_cards    ON payment_details FLEXIBLE TYPE array<object>;
DEFINE FIELD time            ON payment_details TYPE object;
DEFINE FIELD time.created_at ON payment_details TYPE datetime DEFAULT time::now();
DEFINE FIELD time.updated_at ON payment_details TYPE datetime VALUE time::now();

-- Seller profile
DEFINE TABLE seller SCHEMAFULL;
DEFINE FIELD name            ON seller TYPE string;
DEFINE FIELD email           ON seller TYPE string ASSERT string::is_email($value);
DEFINE FIELD time            ON seller TYPE object;
DEFINE FIELD time.created_at ON seller TYPE datetime DEFAULT time::now();
DEFINE FIELD time.updated_at ON seller TYPE datetime VALUE time::now();

-- Product listings
DEFINE TABLE product SCHEMAFULL;
DEFINE FIELD name            ON product TYPE string;
DEFINE FIELD price           ON product TYPE number;
DEFINE FIELD currency        ON product TYPE string ASSERT $value IN ["USD", "GBP", "CAD"];
DEFINE FIELD category        ON product TYPE string;
DEFINE FIELD seller          ON product TYPE record<seller>;
DEFINE FIELD time            ON product TYPE object;
DEFINE FIELD time.created_at ON product TYPE datetime DEFAULT time::now();
DEFINE FIELD time.updated_at ON product TYPE datetime VALUE time::now();

-- Wishlist links (person -> product)
DEFINE TABLE wishlist TYPE RELATION FROM person TO product SCHEMAFULL;
DEFINE FIELD colour ON wishlist TYPE string;
DEFINE FIELD size   ON wishlist TYPE string;
DEFINE FIELD time   ON wishlist TYPE object;
DEFINE FIELD time.created_at ON wishlist TYPE datetime DEFAULT time::now();
DEFINE FIELD time.deleted_at ON wishlist TYPE option<datetime>;

-- Cart links (person -> product)
DEFINE TABLE cart TYPE RELATION FROM person TO product SCHEMAFULL;
DEFINE FIELD quantity ON cart TYPE number;
DEFINE FIELD price    ON cart TYPE number;
DEFINE FIELD currency ON cart TYPE string ASSERT $value IN ["CAD", "EUR", "USD"];
DEFINE FIELD time     ON cart TYPE object;
DEFINE FIELD time.created_at ON cart TYPE datetime DEFAULT time::now();
DEFINE FIELD time.updated_at ON cart TYPE datetime VALUE time::now();
```

### Orders, reviews, reports

Order processing and analytics system with review management and business intelligence. Features order lifecycle tracking, automated analytics tables, and [full-text search](/docs/surrealql/statements/define/analyzer) capabilities. Demonstrates complex aggregations, [materialized views](/docs/surrealql/statements/define/table#pre-computed-table-views), and search optimization for e-commerce applications.

```surql

-- Orders placed (person -> product)
DEFINE TABLE order TYPE RELATION FROM person TO product SCHEMAFULL;
DEFINE FIELD quantity          ON order TYPE number;
DEFINE FIELD price             ON order TYPE number;
DEFINE FIELD currency          ON order TYPE string;
DEFINE FIELD order_status      ON order TYPE string ASSERT $value IN ["pending", "processed", "shipped", "cancelled"];
DEFINE FIELD shipping_address  ON order FLEXIBLE TYPE object;
DEFINE FIELD payment_method    ON order TYPE string;
DEFINE FIELD time              ON order TYPE object;
DEFINE FIELD time.created_at   ON order TYPE datetime DEFAULT time::now();
DEFINE FIELD time.updated_at   ON order TYPE datetime VALUE time::now();
DEFINE FIELD time.processed_at ON order TYPE option<datetime>;
DEFINE FIELD time.shipped_at   ON order TYPE option<datetime>;

-- Product reviews
DEFINE TABLE review TYPE RELATION FROM person TO product SCHEMAFULL;
DEFINE FIELD rating       ON review TYPE number ASSERT $value IN 0..=5;
DEFINE FIELD review_text  ON review TYPE string;
DEFINE FIELD time         ON review TYPE object;
DEFINE FIELD time.created_at ON review TYPE datetime DEFAULT time::now();
DEFINE FIELD time.updated_at ON review TYPE datetime VALUE time::now();

-- Indexes and analytics
DEFINE FUNCTION fn::number_of_unfulfilled_orders() {
  RETURN (SELECT count() FROM order WHERE order_status NOTINSIDE ["processed", "shipped"] GROUP ALL);
};

-- Monthly order summary
DEFINE TABLE monthly_sales TYPE NORMAL SCHEMAFULL AS 
  SELECT 
    count() AS number_of_orders, 
    time::format(time.created_at, '%Y-%m') AS month, 
    math::sum(price * quantity) AS sum_sales, 
    currency 
  FROM order 
  GROUP BY month, currency;

-- Average product rating
DEFINE TABLE avg_product_review TYPE NORMAL SCHEMAFULL AS 
  SELECT 
    count() AS number_of_reviews, 
    math::mean(<float> rating) AS avg_review, 
    ->product.id AS product_id, 
    ->product.name AS product_name 
  FROM review 
  GROUP BY product_id, product_name;

-- Full-text search
DEFINE ANALYZER blank_snowball TOKENIZERS blank FILTERS lowercase, snowball(english);
DEFINE INDEX review_content ON review FIELDS review_text FULLTEXT ANALYZER blank_snowball BM25 HIGHLIGHTS;
```

## Medical

### Patient records and encounters

Healthcare management system with patient records, encounter tracking, and clinical data management. Features vital signs [time-series data](/docs/surrealdb/models/time-series), medication tracking, and automated encounter lifecycle management using [events](/docs/surrealql/statements/define/event). Demonstrates healthcare data modeling with temporal data, clinical workflows, and medical record compliance patterns.

```surql
-- Patient record
DEFINE TABLE patient SCHEMAFULL;
DEFINE FIELD name      ON patient TYPE string;
DEFINE FIELD dob       ON patient TYPE datetime;
DEFINE FIELD gender    ON patient TYPE string ASSERT $value IN ["male", "female", "other", "uncertain"];
DEFINE FIELD email     ON patient TYPE option<string> ASSERT string::is_email($value);
DEFINE FIELD created_at ON patient TYPE datetime DEFAULT time::now();

-- One healthcare visit
DEFINE TABLE encounter SCHEMAFULL;
DEFINE FIELD patient     ON encounter TYPE record<patient>;
DEFINE FIELD occurred_at ON encounter TYPE datetime DEFAULT time::now();
DEFINE FIELD type        ON encounter TYPE string ASSERT $value IN ["checkup", "emergency", "followup", "consult"];
DEFINE FIELD reason      ON encounter TYPE option<string>;
DEFINE FIELD location    ON encounter TYPE option<string>;
DEFINE FIELD ongoing    ON encounter TYPE bool DEFAULT true;
DEFINE FIELD ended_at   ON encounter TYPE option<datetime>;

DEFINE EVENT close_encounter ON encounter WHEN $event = "UPDATE" THEN {
    IF $before.ongoing = true AND $after.ongoing = false {
        UPDATE $this SET ended_at = time::now();
    }
};

-- Vital signs time-series (per encounter)
DEFINE TABLE vital_signs SCHEMAFULL;
DEFINE FIELD id        ON vital_signs TYPE [record<encounter>, datetime];
DEFINE FIELD heart_rate     ON vital_signs TYPE option<int> ASSERT $value IN 20..=300;
DEFINE FIELD bp_systolic    ON vital_signs TYPE option<int> ASSERT $value IN 40..=300;
DEFINE FIELD bp_diastolic   ON vital_signs TYPE option<int> ASSERT $value IN 20..=200;
DEFINE FIELD temp_c         ON vital_signs TYPE option<float> ASSERT $value IN 25.0..=45.0;
DEFINE FIELD notes     ON vital_signs TYPE option<string>;

-- Diagnoses made during encounter
DEFINE TABLE diagnosis SCHEMAFULL;
DEFINE FIELD encounter ON diagnosis TYPE record<encounter>;
DEFINE FIELD code      ON diagnosis TYPE string; -- e.g., ICD-10
DEFINE FIELD label     ON diagnosis TYPE string;
DEFINE FIELD confirmed ON diagnosis TYPE bool DEFAULT true;

-- Medications prescribed
DEFINE TABLE medication SCHEMAFULL;
DEFINE FIELD encounter ON medication TYPE record<encounter>;
DEFINE FIELD name      ON medication TYPE string;
DEFINE FIELD dose_mg   ON medication TYPE float;
DEFINE FIELD frequency ON medication TYPE string; -- e.g., "2x daily"
DEFINE FIELD duration  ON medication TYPE string; -- e.g., "7 days"
DEFINE FIELD prn       ON medication TYPE bool DEFAULT false; -- "as needed"

-- Notes written by practitioner
DEFINE TABLE note SCHEMAFULL;
DEFINE FIELD id      ON note TYPE [record<encounter>, datetime];
DEFINE FIELD author  ON note TYPE string;
DEFINE FIELD content ON note TYPE string;
DEFINE FIELD tags    ON note TYPE option<array<string>>;

CREATE patient:one SET name = "Alex Quinn", dob = d'1988-06-12', gender = "male";
CREATE encounter:one SET patient = patient:one, type = "checkup", reason = "Routine annual";

-- Vital signs log
CREATE vital_signs:[encounter:one, time::now()] SET heart_rate = 72, bp_systolic = 120, bp_diastolic = 80, temp_c = 36.8;

-- Diagnosis
CREATE diagnosis SET encounter = encounter:one, code = "E66.9", label = "Obesity, unspecified";

-- Medication
CREATE medication SET encounter = encounter:one, name = "Metformin", dose_mg = 500, frequency = "2x daily", duration = "30 days";

-- Progress note
CREATE note:[encounter:one, time::now()] SET author = "Dr. Leung", content = "Patient reports improved energy since last visit.";
```

## Related SurrealQL statements

- [DEFINE TABLE](/docs/surrealql/statements/define/table)
- [DEFINE FIELD](/docs/surrealql/statements/define/field)
- [RELATE](/docs/surrealql/statements/relate)
- [DEFINE INDEX](/docs/surrealql/statements/define/indexes)
- [DEFINE FUNCTION](/docs/surrealql/statements/define/function)
- [DEFINE EVENT](/docs/surrealql/statements/define/event)
- [DEFINE PARAM](/docs/surrealql/statements/define/param)
- [DEFINE ANALYZER](/docs/surrealql/statements/define/analyzer)



================================================
FILE: src/content/doc-surrealdb/reference-guide/schema-creation-best-practices.mdx
================================================
---
sidebar_position: 6
sidebar_label: Schema Best Practices
title: Schema creation best practices
description: Best practices for creating schemas in SurrealDB.
---

# Schema creation best practices

With SurrealDB, you can create a schema that is as simple or as complex as you need it to be. This page contains a number of best practices for creating schemas that are both easy to understand and easy to maintain.



### Use a `set` for an array of distinct items

The lowly [`set`](/docs/surrealql/datamodel/sets) is a subtype of `array` that doesn't get a great deal of attention, but has the convenience of holding no duplicate items.

```surql
DEFINE FIELD ordered_unique ON stuff TYPE set VALUE $value.sort();

CREATE ONLY stuff SET ordered_unique = [8,7,8,8,8,8,6,45,3] RETURN VALUE ordered_unique;
-- Returns this:
[ 3, 6, 7, 8, 45 ]
```



As the query above shows, a `set` is just a subtype and not its own type so you can pass in an `array` into anything expecting a `set`. The only difference is that it will never hold a duplicate item.

### Define arrays and sets with a type and maximum size

In addition to a type, both arrays and sets can have a maximum number of items built into the type definition itself. The definition below pairs this with an assertion using the [`array::all()`](/docs/surrealql/functions/database/array#arrayall) function to also  ensure that every item in the `bytes` field is between 0 and 255.

```surql
DEFINE FIELD bytes ON data TYPE array<int, 640> ASSERT $value.all(|$int| $int IN 0..=255);
```

Learn more about [database functions](/docs/surrealql/functions/database).

### Define nested indexes

Even the individual indexes of an array can be defined. This is useful for data types like RGB colours that can must be exactly three items in length. This time the schema uses an `ASSERT value.len() = 3` instead of `array<3>` to ensure that the array is an exact length instead of a maximum length. 

```surql
DEFINE FIELD rgb ON colour TYPE array ASSERT $value.len() = 3;
DEFINE FIELD rgb[0] ON colour TYPE int ASSERT $value IN 0..=255;
DEFINE FIELD rgb[1] ON colour TYPE int ASSERT $value IN 0..=255;
DEFINE FIELD rgb[2] ON colour TYPE int ASSERT $value IN 0..=255;

CREATE colour SET rgb = [0, 2, 30];
```

[Learn more about assertions in `DEFINE FIELD`](/docs/surrealql/statements/define/field#assertions)



###  Use `FLEXIBLE` objects and defined fields in `SCHEMAFULL` tables

The documentation mentions that a `SCHEMAFULL` table requires objects to have the `FLEXIBLE` keyword in order to treat them as free-form objects. Without this keyword, a `TYPE object` only tells the database that an object is to be expected but a `SCHEMAFULL` table disallows any field that hasn't been defined yet.

```surql
DEFINE TABLE user SCHEMAFULL;
DEFINE FIELD name ON user TYPE string;
DEFINE FIELD metadata ON user TYPE object;

-- Returns {} for `metadata`
CREATE user SET name = "Billy", metadata = {
    created_at: time::now(),
    age: 5
};
```



With the `FLEXIBLE` keyword the `metadata` field will now work, accepting any and all input.

```surql
DEFINE FIELD metadata ON user TYPE object FLEXIBLE;

CREATE user SET name = "Billy", metadata = {
    created_at: time::now(),
    age: 5
};
```



However, you can also simply define each field of an object in the same way you would with the field of a table. This allows the `metadata` field to hold these fields and ignore all other data used during a `CREATE` or `INSERT` statement.

```surql
DEFINE TABLE user SCHEMAFULL;
DEFINE FIELD name ON user TYPE string;
DEFINE FIELD metadata ON user TYPE object;
DEFINE FIELD metadata.created_at ON user TYPE datetime;
DEFINE FIELD metadata.age ON user TYPE int;

CREATE user SET name = "Billy", metadata = {
    created_at: time::now(),
    age: 5,
    wrong_field: "WRONG DATA"
};
```



### Use `THROW` to add more detailed error messages to `ASSERT` clauses

A `DEFINE FIELD` statement allows an `ASSERT` clause to be added in order to ensure that the value, which here is represented as the parameter `$value`, meets certain expectations. A simple example here makes sure that the `name` field on the `person` table is under 20 characters in length.

```surql
DEFINE FIELD name ON person TYPE string ASSERT $value.len() < 20;

CREATE person SET name = "Mr. Longname who has much too long a name";
```



In this case, the default error message is pretty good.

```surql
"Found 'Mr. Longname who has much too long a name' for field `name`, with record `person:2gpvut914k1qfysqs3lc`, but field must conform to: $value.len() < 20"
```



However, `ASSERT` only expects a truthy value at the end and otherwise isn't concerned at all with what happens before. This means that you can outright customize the logic, including a custom error message. Let's give this a try.

```surql
DEFINE FIELD name ON person TYPE string ASSERT {
    IF $value.len() >= 20 {
        THROW "`" + <string>$value + "` too long, must be under 20 characters. Up to `" + $value.slice(0,19) + "` is acceptable";
    } ELSE {
       RETURN true;
    }
};

CREATE person SET name = "Mr. Longname who has much too long a name";
```



Not bad!

```surql
'An error occurred: `Mr. Longname who has much too long a name` too long, must be under 20 characters.
Up to `Mr. Longname who ha` is acceptable'
```



### Use formatters on internal datetimes for strings with alternative formats

A lot of legacy systems require datetimes to be displayed in a format that doesn't quite match a `datetime`.

That doesn't mean that you have to give up the precision of a `datetime` though. By using the [`time::format()`](/docs/surrealql/datamodel/formatters) function, you can keep the actual stored date as a precise SurrealQL `datetime` and then use that to output a string in any format you like.

```surql
DEFINE FIELD created_at ON user VALUE time::now() READONLY;
DEFINE FIELD since ON user VALUE time::format(created_at, "%Y-%m-%d");

CREATE user RETURN id, since;
```

```surql title="Output"
[
	{
		id: user:50s2riya8fm3cdbrhwpe,
		since: '2025-06-12'
	}
]
```



### Use `!!$value` in `DEFINE` statements

As the `!` operator reverses the truthiness of a value, using it twice in a row as `!!` returns a value's truthiness. As empty and default values (such as 0 for numbers) are considered to be non-truthy, this operator is handy if you want to ensure that a value is both present and not empty.

```surql
DEFINE FIELD name ON character TYPE string;
DEFINE FIELD metadata ON character TYPE object;
-- Works because "" is of type string
CREATE character SET name = "", metadata = {};

DEFINE FIELD OVERWRITE name ON character TYPE string ASSERT !!$value;
-- Now returns an error because "" and {} are non-truthy
CREATE character SET name = "", metadata = {};
```



### Use `DEFINE PARAM` for clarity

If you find that parts of your table- or field-specific code are getting a bit long, it might be time to think about moving parts of it to a [database-wide parameter](/docs/surrealql/statements/define/param).

```surql
DEFINE FIELD month_published ON book TYPE string ASSERT $value IN ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
```



Doing so not only makes the code cleaner, but makes it easy to reuse in other parts of the schema as well.

```surql
DEFINE PARAM $MONTHS VALUE ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

DEFINE FIELD month_published ON book TYPE string ASSERT $value IN $MONTHS;
DEFINE FUNCTION fn::do_something_with_month($input: string) {
    IF !($input IN $MONTHS) {
        THROW "Some error about wrong input";
    } ELSE {
        // do something with months here
    }
};
```



### Use literals to return rich error output

Error types in programming languages often take the form of a long list of possible things that could go wrong. SurrealQL's [literal](/docs/surrealql/datamodel/literals) type allows you to specify a list of all possible forms it could take, making it the perfect type for error logic.

```surql
DEFINE PARAM $ERROR_CODES VALUE [200, 300, 400, 500];

DEFINE FUNCTION fn::return_response($input: 
    { type: "internal_error", message: string } |
    { type: "bad_request", message: string } | 
    { type: "invalid_date", got: any, expected: "YYYY-MM-DD" } |
    int) {
    IF $input.is_int() {
        IF $input IN $ERROR_CODES {
            RETURN $input
        } ELSE {
            THROW "Input must be one of " + <string>$ERROR_CODES;
        }
    } ELSE {
        RETURN $input
    }
};

fn::return_response(500);
fn::return_response({ type: "internal_error", message: "You can't do that"});
```



### Use graph queries in the schema

While graph queries are usually seen in `SELECT` statements in the documentation, they can live inside your database schema just like any other datatype or expression. In the schema below for a family tree, any inserted record must either have a parent (via the `<-parent_of<-person` path) or be `first_generation`.

```surql
DEFINE FIELD parents ON person ASSERT <-parent_of<-person OR first_generation;

CREATE person:one SET first_generation = true;
CREATE person:two;

RELATE person:one->parent_of->person:two;
CREATE person:two;
```



By the way, this pattern is possible because `RELATE` statements can be used before the records to relate exist. To disallow this, you can add the [`ENFORCED`](/docs/surrealql/statements/define/table#using-enforced-to-ensure-that-related-records-exist) clause to a `DEFINE TABLE table_name TYPE RECORD` definition.



================================================
FILE: src/content/doc-surrealdb/reference-guide/security-best-practices.mdx
================================================
---
sidebar_position: 4
sidebar_label: Security Best Practices
title: Security Best Practices | Reference guides
description: This guide outlines some key security best practices for using SurrealDB 2.0. While SurrealDB offers powerful and flexible features to support you in meeting your desired security standards, the use that you make of those features will ultimately determine whether or not you meet them.
---
import SurrealistMini from "@components/SurrealistMini.astro";

# Security Best Practices

This guide outlines some key security best practices for using SurrealDB `v2.x.x`. While SurrealDB offers powerful and flexible features to help you meet your desired security standards, your use of those features will ultimately determine whether or not you meet them.

The following is a non-exhaustive list of security best practices you should consider when building services and applications with SurrealDB to help you address common security challenges while preventing frequent pitfalls.

## Capabilities

When running a SurrealDB server, you can configure the [capabilities](/docs/surrealdb/security/capabilities) for your SurrealQL queries. Most of these capabilities are disabled by default to expose as little attack surface as possible to malicious actors.

For the strongest security, we recommend denying all capabilities by default and only allowing the specific capabilities necessary for your service, following an allowlisting approach. We strongly discourage running SurrealDB with all capabilities allowed.

### Example: Deny all capabilities with some exceptions

```bash
# Allow SurrealDB to call any functions from the array and string families, generate and compare Argon2 hashes
# and make HTTP GET requests over HTTPS to the address of a specific API.
surreal start --deny-all --allow-funcs "array, string, crypto::argon2, http::get" --allow-net api.example.com:443
```

When you need to enable a capability, we recommend doing it specifically instead of generally. For example, suppose you know that your queries need to be able to parse emails using functions. In that case, we recommend you run SurrealDB with the `--allow-funcs "parse::email::*"` flag instead of allowing all functions with `--allow-funcs` without arguments. Doing this can help mitigate the performance impact that users can have when using certain functions and ensures that your SurrealDB instance will not be affected by vulnerabilities in the code of any other functions that a malicious actor could leverage to attack SurrealDB.

In the case where it is absolutely necessary to generally allow a capability, we recommend carefully reviewing the scope of that capability and denying any specific instances where it may introduce unacceptable risks. This is especially important in the case of the network capability, which allows SurrealDB to perform network requests such as those required by the [`http::*`](/docs/surrealql/functions/database/http) functions. Allowing untrusted users to perform network requests from your SurrealDB instance can allow them access to its local network or services that specifically allow network access from the SurrealDB server.

### Example Anti-Pattern: Allow all outgoing network connections with some exceptions

```bash
// highlight-next-line
# Avoid doing this:
# Allow SurrealDB to make outgoing HTTP GET and POST request to any address except to some known private CIDR blocks.
surreal start --deny-all --allow-funcs "http::get, http::post" --allow-net --deny-net "10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16"
```

Following a denylisting approach as described above should only be used as a last resort, since it is common to miss some risky cases (e.g. [169.254.169.254](https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf)), which in that case would become allowed by default.

Additionally, SurrealDB currently does not perform reverse DNS lookups to prevent http functions directly accessing an IP address, even when the hostname that resolves to that IP address is listed within `--deny-net`. This is an issue when SurrealDB is configured with allow network access by default e.g `--allow-net --deny-net www.google.com`.

It is **strongly recommended** that you deny by default by defining specific `--allow-net` targets and using additional layers of network security within your infrastructure.

## Passwords

If you require storing passwords for your users, do not rely on table or field permissions to keep them private. In the event that your application or database is compromised, these passwords would become known by the attacker. Instead, use the [password hashing functions](/docs/surrealql/functions/database/crypto) provided by SurrealDB such  as `crypto::argon2::*`, `crypto::bcrypt::*`, `crypto::pbkdf2::*` and  `crypto::scrypt::*` . These functions ensure that irreversible cryptographic hashes are stored instead of the original passwords, so that the passwords from your users remain safe even in the event of a compromise.

Do not use other cryptographic hash functions (e.g. `crypto::md5`, `crypto::sha1`, `crypto::sha512`) for hashing passwords, even if you do use an additional salt. These functions are designed to be efficient in computing, which will benefit an attacker that sets out to crack any hashes that they may have obtained from the compromise of your application. Hash functions intended for password hashing already incorporate a salt as well as other mechanisms to prevent hash cracking by making the computation of such hashes less efficient. This mitigates password cracking at scale at the small cost of adding a few milliseconds delay while checking credentials for legitimate users.

Even if you only store password hashes, it is a good practice to additionally use field permissions to prevent unauthorised access to the password hashes, which could allow an attacker to perform inefficient but potentially effective attacks such as testing candidate passwords against a specific hash. For even better security, you may store passwords in a separate table and use table permissions to disallow all access to that table. Due to their internal implementation, table permissions provide additional security compared to field permissions.

### Example: Securely hash user passwords

```surql
DEFINE TABLE user SCHEMAFULL
  -- Only allow users to query their own record, including their password.
	PERMISSIONS
		FOR select, update, delete WHERE id = $auth.id;

DEFINE FIELD name ON user TYPE string;
DEFINE FIELD email ON user TYPE string ASSERT string::is_email($value);
DEFINE FIELD password ON user TYPE string;

DEFINE INDEX email ON user FIELDS email UNIQUE;

DEFINE ACCESS user ON DATABASE TYPE RECORD
	SIGNUP (
		CREATE user CONTENT {
			name: $name,
			email: $email,
			password: crypto::argon2::generate($password) -- Use Argon2 to generate the hash.
		}
	)
	SIGNIN (
		SELECT * FROM user WHERE email = $email AND
		  crypto::argon2::compare(password, $password) -- Use Argon2 to compare the hashes.
	);
```

## Expiration

When defining [users](/docs/surrealql/statements/define/user) and [access methods](/docs/surrealql/statements/define/access), ensure that you set a specific [session and token duration](/docs/surrealdb/security/authentication#expiration) whenever possible using the `DURATION` clause.

Default values provided by SurrealDB are intended to support cases where SurrealDB is used as a traditional backend database, which is why sessions do not expire by default. Suppose you build an application where your end users directly connect with SurrealDB. In that case, we strongly encourage setting a session expiration that is as short as possible (typically a few hours) to provide a good experience to your users without compromising security.

Expiring user sessions ensures that a user cannot remain authenticated long after their access has been revoked. This cannot be done on demand, as user sessions do not persist in the database. However, unlike tokens, user sessions are not typically susceptible to being stolen, as they exist only in the context of an established WebSocket connection.

### Example: Set a session duration

```surql
DEFINE USER username ON DATABASE PASSWORD 'CHANGE_THIS' DURATION FOR SESSION 5d;
```

```surql
DEFINE ACCESS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR SESSION 12h
;
```

Tokens, however, are usually stored in the client (e.g. a web browser) and may be stolen by client-side attacks such as a cross-site scripting vulnerability in your application. For this reason, we strongly recommend reducing the token duration from the default one hour to the minimum amount of time that your use case can tolerate. Ideally, a token should only be valid for as long as the client needs to use it to establish a session, which can be as little as a few seconds.

### Example: Set a token duration

```surql
DEFINE USER username ON DATABASE PASSWORD 'CHANGE_THIS' DURATION FOR TOKEN 15m;
```

```surql
DEFINE ACCESS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 5s
;
```

## Query Safety

When using SurrealDB as a traditional backend database, your application will usually build SurrealQL queries that may need to contain some untrusted input, such as that provided by the users of your application. To do so, SurrealDB offers [`bind`](/docs/sdk/rust/setup#query) as a method to `query` (implemented in other SDKs as [the `vars` argument to `query`](/docs/sdk/javascript/core/data-maniplulation)), which should always be used when including untrusted input into queries. Otherwise, SurrealDB will be unable to separate the actual query syntax from the user input, resulting in the well-known [SQL injection](https://en.wikipedia.org/w/index.php?title=SQL_injection&oldid=1234729055) vulnerabilities. This practice is known as [prepared statements or parameterised queries](https://en.wikipedia.org/w/index.php?title=Prepared_statement&oldid=1195122133).

Binding parameters ensure that untrusted data is passed to SurrealDB as SurrealQL parameters, which are independent of the query syntax, preventing SQL injection attacks.

### Example: Bind parameters in the provided SDKs

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

<Tabs groupId="language-sdk">
  <TabItem value="rust" label="Rust" default>

```rust
// Do this:
let name = "tobie"; // User-controlled input.
let mut result = db
    .query("CREATE person CONTENT name = $name;")
    .bind(("name", name))
    .await?;
```

```rust
// highlight-next-line
// Do NOT do this:
let name = "tobie"; // User-controlled input.
let mut result = db
    .query(format!("CREATE person CONTENT name = {name};"))
    .await?;
```

  </TabItem>
  <TabItem value="js" label="JavaScript">

```jsx
// Do this:
const name = "tobie"; // User-controlled input.
const result = await db.query(
	'CREATE person CONTENT name = $name;',
	{ name }
);
```

```jsx
// highlight-next-line
// Do NOT do this:
const name = "tobie"; // User-controlled input.
const result = await db.query(`CREATE person CONTENT name = "${name}";`);
```

  </TabItem>
  <TabItem value="csharp" label=".NET (C#)">

```csharp
// Do this:
string name = "tobie"; // User-controlled input.
var result = await db.Query($"CREATE person CONTENT name = {name};");

// Translated as "CREATE person CONTENT name = $p0;"
// with the parameter $p0 having the value "tobie"
```

```csharp
// highlight-next-line
// Do NOT do this:
string name = "tobie"; // User-controlled input.
var result = await db.RawQuery($"CREATE person CONTENT name = "{name}";");
```

  </TabItem>
</Tabs>

### Example: Bind parameters in the HTTP REST API

<Tabs groupId="http-sql">
<TabItem value="V2" label="V2.x" default>
```bash title="Request"
curl -X POST -u "root:root" -H "surreal-ns: mynamespace" -H "surreal-db: mydatabase" -H "Accept: application/json" \
-d 'SELECT * FROM person WHERE age > $age' http://localhost:8000/sql?age=18
```
</TabItem>
<TabItem value="V1" label="V1.x">
```bash title="Request"
curl -X POST -u "root:root" -H "ns: mynamespace" -H "db: mydatabase" -H "Accept: application/json" \
  -d 'SELECT * FROM person WHERE age > $age' http://localhost:8000/sql?age=18
```
</TabItem>

</Tabs>

## Content Safety

Content generated by users and other untrusted parties will often be stored in SurrealDB and later rendered in an HTML page to be displayed. Regardless of SurrealDB, rendering untrusted content is the source of some dangerous pitfalls which can lead to [cross-site scripting](https://en.wikipedia.org/w/index.php?title=Cross-site_scripting&oldid=1232455342) attacks and other client-side code injection issues like [site defacement](https://en.wikipedia.org/w/index.php?title=Website_defacement&oldid=1231310592) or [clickjacking](https://en.wikipedia.org/w/index.php?title=Clickjacking&oldid=1227193298).

When retrieving content that may be rendered in an HTML document, we strongly recommend that you use the [`string::html::encode`](/docs/surrealql/functions/database/string#stringhtmlencode) function, which will encode any characters that have special meaning in HTML syntax (e.g. `<`, `>`, `&`...) into HTML entities (e.g. `&lt;`, `&gt;`, `&amp;`...) that will be rendered as the actual original character instead of interpreted as HTML syntax.

### Example: Encode HTML content

```surql
RETURN string::html::encode("<h1>Safe Title</h1><script>alert('XSS')</script><p>Safe paragraph. Not safe <span onload='logout()'>event</span>.</p>");

['&lt;h1&gt;Safe&#32;Title&lt;&#47;h1&gt;&lt;script&gt;alert(&apos;XSS&apos;)&lt;&#47;script&gt;&lt;p&gt;Safe&#32;paragraph.&#32;Not&#32;safe&#32;&lt;span&#32;onload&#61;&apos;logout()&apos;&gt;event&lt;&#47;span&gt;.&lt;&#47;p&gt;']
```

If you absolutely require user-generated content to be rendered as HTML but still want to prevent users from injecting dangerous HTML into your page, you can use the [`string::html::sanitize`](/docs/surrealql/functions/database/string#stringhtmlsanitize) function instead, which will keep all characters intact, so that the content can be interpreted as HTML syntax, while removing the specific syntax that is deemed dangerous. It is important to note that, although the set of accepted syntax is very conservative, sanitization is less safe that encoding and could potentially be bypassed due to a flaw in the function.

### Example: Sanitize HTML content

```surql

RETURN string::html::sanitize("<h1>Safe Title</h1><script>alert('XSS')</script><p>Safe paragraph. Not safe <span onload='logout()'>event</span>.</p>");

['<h1>Safe Title</h1><p>Safe paragraph. Not safe <span>event</span>.</p>']
```

## JSON Web Tokens

When configuring how [JSON Web Tokens](https://datatracker.ietf.org/doc/html/rfc7519) are verified before authenticating a [system](/docs/surrealdb/security/authentication#system-users) or [record](/docs/surrealdb/security/authentication#record-users) user with [`DEFINE ACCESS ... TYPE JWT`](/docs/surrealql/statements/define/access/jwt) or [`DEFINE ACCESS ... TYPE RECORD ... WITH JWT`](/docs/surrealql/statements/define/access/record#with-json-web-token), we recommend using an asymmetric algorithm (i.e. `PSXXX`,  `RSXXX` , `ECXXX`) when only a mechanism for token verification is being defined. This ensures that the only key stored by SurrealDB is a public key that does not represent a threat in the event of a compromise.

On the other hand, symmetric algorithms (i.e., HSXXX) use the same key for signature and verification, which the attacker could use to issue tokens that SurrealDB would trust.

### Example: Define a JWT access method

```surql
DEFINE ACCESS token ON DATABASE TYPE RECORD WITH JWT
ALGORITHM RS256 KEY "-----BEGIN PUBLIC KEY-----
MUO52Me9HEB4ZyU+7xmDpnixzA/CUE7kyUuE0b7t38oCh+sQouREqIjLwgHhFdhh3cQAwr6GH07D
ThioYrZL8xATJ3Youyj8C45QnZcGUif5PkpWXDi0HJSoMFekbW6Pr4xuqIqb2LGxGDVJcLZwJ2AS
Gtu2UAfPXbBD3ffiad393M22g1iHM80YaNi+xgswG7qtXE4lR/Lt4s0MeKKX7stdWI1VIsoB+y3i
r/OWUvJPjjDNbAsyy8tQmxydv+FUnLEP9TNT4AhN4DXcJ+XsDtW7OWt4EdSVDeKpGbIMvIrh1Pe+
Nilj8UHNyNDHa2AjK3seMo6CMvaIQJKj5o4xGFblFGwvvPD03SbuQLs1FdRjsZCeWLdYeQ3JDHE9
sFG7DCXlpMJcaYT1mf4XHJ0gPekNLQyewTY3Vxf7FgV3GCNjV20kcDFgJA2+iVW2wSrb+txD1ycE
kbi8jh0pedWwE40VQWaTh/8eAvX7IHWya/AEro25mq+m6vktNZLbvLphhp586kJK3Tdt3YjpkPre
M3nkFWOWurIyKbtIV9JemfwCgt89sNV45dTlnEDEZFFGnIgDnWgx3CUo4XmhICEQU8+tklw9jJYx
iCTjhbIDEBHySSSc/pQ4ftHQmhToTlQeOdEy4LYiaEIgl1X+hzRH1hBYvWlNKe4EY1nMCKcjgt0=
-----END PUBLIC KEY-----";
```

Additionally, we recommend using [JSON Web Key Sets](https://datatracker.ietf.org/doc/html/rfc7517) to configure the verification algorithm and key from a remote authoritative source using the `URL` clause instead of providing them directly to SurrealDB using the `ALGORITHM` and `KEY` clauses. This ensures that the original token issuer will be able to rotate keys in the event of a compromise to prevent potentially compromised tokens to be used with your application without affecting the availability of your service.

### Example: Define a JWT access method with JWKS

```surql
DEFINE ACCESS token ON DATABASE TYPE RECORD WITH JWT
URL "https://example.com/.well-known/jwks.json";
```

## Network Exposure

When deploying SurrealDB, we recommend limiting the attack surface as much as possible in order to minimise the risk of attacks or information gathering from unauthorised parties. If your database should only be available to other internal services, we suggest that you expose SurrealDB exclusively to the internal network instead of deploying the service with a publicly addressable network interface that is accessible from the internet, regardless of whether or not allowlisting has been applied at the networking or application level.

If you must publish SurrealDB to the internet (e.g. if your users directly connect to SurrealDB), you may want to monitor and prevent unwanted connections using tools such as a network [intrusion prevention system](https://en.wikipedia.org/w/index.php?title=Intrusion_detection_system&oldid=1223972754#Intrusion_prevention) or a [web application firewall](https://en.wikipedia.org/w/index.php?title=Web_application_firewall&oldid=1234730173). If you do so, ensure that these systems are appropriately tuned and do not interfere with the regular use of SurrealDB.

In cases where SurrealDB is publicly exposed in environments where any sort of information leakage is unacceptable, the `--no-identification-headers` flag can be enabled, which will result in the SurrealDB server no longer responding to HTTP requests with headers that identify the product or its current version to prevent passive fingerprinting and metadata indexing. Note that this will not prevent active fingerprinting such as directly querying the `/version` endpoint if available or directly attempting to exploit a known security vulnerability without regard for compatibility. On the other hand, consider whether or not enabling this feature is compatible with your clients, which may rely on these headers in order to identify the version of SurrealDB running on the server.

### Example: Start SurrealDB with identification headers

```bash
$ surreal start &
$ curl -vvv "127.0.0.1:8000"
*   Trying 127.0.0.1:8000...
* Connected to 127.0.0.1 (127.0.0.1) port 8000 (#0)
> GET / HTTP/1.1
> Host: 127.0.0.1:8000
> User-Agent: curl/7.81.0
> Accept: */*
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 307 Temporary Redirect
< location: https://surrealdb.com/app
< access-control-allow-origin: *
< vary: origin
< vary: access-control-request-method
< vary: access-control-request-headers
# highlight-start
< surreal-version: surrealdb-2.0.0+20240612.2184e80f
< server: SurrealDB
# highlight-end
< x-request-id: 157413ce-7cc4-41a1-a93b-0940bf87874c
< content-length: 0
< date: Mon, 17 Jun 2024 15:47:29 GMT
<
* Connection #0 to host 127.0.0.1 left intact
```

### Example: Start SurrealDB without identification headers

```bash
$ surreal start --no-identification-headers &
$ curl -vvv "127.0.0.1:8000"
*   Trying 127.0.0.1:8000...
* Connected to 127.0.0.1 (127.0.0.1) port 8000 (#0)
> GET / HTTP/1.1
> Host: 127.0.0.1:8000
> User-Agent: curl/7.81.0
> Accept: */*
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 307 Temporary Redirect
< location: https://surrealdb.com/app
< access-control-allow-origin: *
< vary: origin
< vary: access-control-request-method
< vary: access-control-request-headers
< x-request-id: deec3301-e930-4389-a0da-b2a336bd2631
< content-length: 0
< date: Mon, 17 Jun 2024 15:49:43 GMT
<
* Connection #0 to host 127.0.0.1 left intact
```

## Least Privilege

When defining [system users](/docs/surrealdb/security/authentication#system-users) in SurrealDB, you may assign them [roles](/docs/surrealql/statements/define/user#roles) that will limit the actions they can perform inside the level where they are defined. Ensure that you employ the principle of least privilege and create users at the lowest level possible and with the minimum role in order to be able to perform their duties inside of SurrealDB. This will mitigate some of the risk in the case where credentials for that user are ever compromised.

### Example: Define users with specific roles

A user who only needs to query the database:

```surql
DEFINE USER db_viewer ON DATABASE PASSWORD 'CHANGE_THIS' ROLES VIEWER;
```

A user who only needs to manage content in any databases on the same namespace:

```surql
DEFINE USER ns_editor ON NAMESPACE PASSWORD 'CHANGE_THIS' ROLES EDITOR;
```

## Encryption in Transit

Encryption in transit is recommended, especially when deploying SurrealDB on a server in a different network than its clients. This mitigates the impact of man-in-the-middle attacks and provides confidentiality and integrity guarantees with regard to the data being exchanged. Encryption in transit can be achieved by using the SurrealDB server to serve its interfaces through HTTPS by providing the `--web-crt` and `--web-key` arguments when calling [the `start` subcommand in the CLI](/docs/surrealdb/cli/start#command-help). For production deployments, we recommend that TLS termination be performed by a load balancer or reverse proxy, which will often provide additional guarantees to the process.

### Example: Start SurrealDB with TLS

```bash
# If you want to serve TLS directly with SurrealDB:
surreal start --web-crt "cert.pem" --web-key "key.pem"
```

## Encryption at Rest

Encryption at rest is recommended especially when storing sensitive data in a location where you cannot guarantee the security of the storage media. If encryption at rest is not used, physical access to the storage media may result in the complete compromise of the data stored. It is important to note that most kinds of encryption at rest will not prevent logical attacks from resulting in compromise of the data, as such attacks will often access the data using the compromised system as a [confused deputy](https://en.wikipedia.org/w/index.php?title=Confused_deputy_problem&oldid=1230222963) in order to leverage its ability to access data after it is already decrypted.

Encryption at rest can be achieved by ensuring that the data is stored encrypted using a disk encryption solution such as [LUKS](https://en.wikipedia.org/w/index.php?title=Linux_Unified_Key_Setup&oldid=1225491340) or [BitLocker](https://en.wikipedia.org/w/index.php?title=BitLocker&oldid=1232782210) in Linux and Windows systems respectively and, in the case where you are hosting SurrealDB in a cloud provider, by leveraging their storage encryption solutions in the volume or disk that will store your data.

You might consider additional encryption for your datastore in some specific scenarios. This can provide increased security when your database servers, storage media and their corresponding encryption keys are managed in different security contexts, where the storage media and its keys may be compromised without also compromising the datastore servers. Encryption at rest at the datastore level can be achieved by using a datastore backend that offers transparent encryption such as [TiKV (≥4.0)](https://docs.pingcap.com/tidb/stable/encryption-at-rest#tikv-encryption-at-rest). This encryption is independent from SurrealDB.

It is important to note that, even in this scenario, physical or logical access to the SurrealDB server will result in access to the data, as SurrealDB must receive decrypted data from the datastore in order to perform any sort of queries.

## Untrusted Queries

Due to the powerful SurrealQL language and the addition of functions, scripting and network capabilities, running untrusted queries in SurrealDB as a [system user](/docs/surrealdb/security/authentication#system-users) should be treated similarly to running untrusted software in any system. When copying queries or importing datasets from sources that you do not trust, make sure to review their contents to ensure that they do not contain any malicious code intended to perform unauthorized changes, computations or network requests.

## Session Isolation

One of the interfaces to SurrealDB is [RPC through WebSockets](/docs/surrealdb/integration/rpc). This interface is usually used by the official [SDKs](/docs/surrealdb/integration/sdks) and offers performance benefits over the [HTTP REST API](/docs/surrealdb/integration/http), which requires establishing a new connection for every operation. The RPC interface can either be directly exposed to end users or used internally from your backend to communicate with SurrealDB.

In the later scenario, some developers may choose to still authenticate each user individually (e.g. using [`signin`](/docs/surrealdb/integration/rpc#signin) or [`authenticate`](/docs/surrealdb/integration/rpc#authenticate) in the WebSockets [session](/docs/surrealdb/security/authentication#sessions) as opposed to using a single service user for their backend. This could be done by calling [`invalidate`](/docs/surrealdb/integration/rpc#invalidate) or just authenticating a new user in the same connection and may provide some performance benefits over establishing a new WebSocket connection for each user. However, we recommend using separate WebSocket sessions or connections for different users. Consider terminating the connection and establishing a new one for every individual user.

WebSocket connections offer an additional degree of isolation between users that may become relevant in the event where some session information for previous users who were using the same connection was not properly cleared. Additionally, even if successfully isolated from the security perspective, some resources associated with users are freed by SurrealDB only when the connection is terminated. Sharing the same WebSockets connection between several users may cause these unused resources to grow indefinitely.

## Token Storage

In some instances, applications may need to store some of the authentication tokens issued by SurrealDB. Even when token expiration has been configured to be as low as possible, tokens may potentially be stolen as a result of attacks against the application. To mitigate this risk, it is important to take steps to protect tokens in storage from being stolen as a result of these attacks. This is specially relevant in web applications, which usually expose additional attack vectors compared to other client applications.

The best way to protect tokens against stealing is to not store them at all. If your use case supports it, use the token in memory to [`authenticate`](/docs/sdk/javascript/methods/authenticate) a persistent session using the WebSocket protocol and destroy the token from memory after the session is established. When the session expires, ask your users to sign in again with their credentials and establish a new authenticated session with SurrealDB. Your use case may even support not using a token at all by directly authenticating the session with user credentials using [`signin`](/docs/sdk/javascript/methods/signin).

However, if you must store the authentication token (e.g. you want authentication to persist across browser tabs or restarts), our recommendation for most use cases is that you store tokens using browser storage primitives such as local storage and that you take steps to protect your web application from script injection attacks by taking measures including the following:

- Encode or at least sanitize all [untrusted input](/docs/surrealdb/reference-guide/security-best-practices#content-safety) before showing it on the page.
- Implement a [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) to prevent unauthorized scripts from executing.
- Implement [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity) to verify authorized external scripts.
- Use modern frontend frameworks that are designed to prevent content injection.

Understand that an attacker who is ultimately able to inject scripts into your web application or compromise the devices of your users will still be able to steal their tokens. These recomendations are intended to prevent this script injection from taking place. There is very little you can do to protect your users if you application is vulnerable to script injection attacks regardless of storage method. The impact of this actually happening can be mitigated by ensuring that token expiration is short to minimize the chance of an attacker capturing a valid token and reduce the window of oportunity to exploit it otherwise.

#### Why not cookies?

SurrealDB does not support authenticating via cookies. Although cookies with the `secure` and `HttpOnly` flags are often cited as the superior choice for token storage, this is [not always the case](https://portswigger.net/research/web-storage-the-lesser-evil-for-session-tokens). This is specially not true in the case of generic backend services such as SurrealDB, where protecting against [Cross-Site Request Forgery (CRSF)](https://owasp.org/www-community/attacks/csrf) attacks is not trivial without additional control of the frontend application. These attacks are possible because of how cookies work and would allow attackers to force users to make unauthorized requests to SurrealDB using their own valid cookies. Additionally, cookies are limited to a 4KB size, making them unsuitable for storing certain JWT payloads.

The proposed benefits of using cookies would be that [Cross-Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/) attacks could not be used to directly read the contents of the token as long as cookies were configure with the `HttpOnly` flag. Although this is true, XSS attacks could still be used to take control of the browser session and impersonate the user using their own cookies to perform any authenticated actions that the token could be used for. This is essentially as bad as the token being stolen because an attacker is not interested in the token itself but rather in what the token can be used for. Most modern attacks against cookies with `HttpOnly` will lead to essentially the same results as those against cookies without it.

In our opinion, the CSRF attacks made possible by cookies would be an unmitigated threat to applications built on SurrealDB. Additionally, XSS attacks are still a threat when using cookies with the `HttpOnly` flag. On the other hand, significant advances have been made by modern browsers and frontend frameworks to prevent XSS attacks, whereas CSRF attacks are not possible to mitigate without the frontend and backend services working together in a way that would not be trivial to implement between SurrealDB and self-developed frontend applications.

## Vulnerabilities

When SurrealDB is part of your service or application, vulnerabilities that affect SurrealDB may also impact your environment. Due to this fact, we highly recommend that you track [vulnerabilities published for SurrealDB](https://github.com/surrealdb/surrealdb/security/advisories) so that you become aware of any updates that address vulnerabilities that you may be affected by. This can be done most effectively by leveraging automation tools that will consume the [Github Advisory Database](https://github.com/advisories?query=surrealdb). These automations will usually also warn of vulnerabilities in dependencies used by SurrealDB, which may also have an impact in your environment. Keeping up to date with the latest releases of SurrealDB is, in general, a good practice.

If you identify a vulnerability in SurrealDB that has not been published yet, we encourage you to [create a security advisory report](https://github.com/surrealdb/surrealdb/security/advisories/new) on Github so that the SurrealDB team can privately look into it in order to identify and work on a solution that can benefit you as well as the rest of the users.



================================================
FILE: src/content/doc-surrealdb/security/authentication.mdx
================================================
---
sidebar_position: 3
sidebar_label: Authentication
title: Authentication | Security
description: There are multiple forms of authentication built into SurrealDB, supporting server-side and client-side authentication.
---

import Since from '@components/shared/Since.astro'

# Authentication

There are multiple forms of authentication built into SurrealDB, supporting different use cases:

- [System users](/docs/surrealdb/security/authentication#system-users): Created by the SurrealDB administrator and used for managing and consuming the database.
- [Record users](/docs/surrealdb/security/authentication#record-users): Used for consuming the database within permissions logic, they allow custom signup and signin.

## System users

System users is the term we use to describe users defined directly on SurrealDB by the administrator. Same concept as any other database.

Users may belong to different levels (root, namespace or database) and have different roles assigned to limit what they can do to the system. Users are defined with the [DEFINE USER](/docs/surrealql/statements/define/user) statement.

SurrealDB implements RBAC (Role Based Access Control) to define what a user can do. Each user is assigned one or more roles (currently limited to the built-in `OWNER`, `EDITOR` and `VIEWER` roles) and will be allowed to perform an action over a resource as long as at least one of their roles allow it.

Go to [DEFINE USER](/docs/surrealql/statements/define/user) for more information.

### Example: Define a Root-level user

Root-level users have visibility into all namespaces and databases, which means that their permissions apply to all of those levels.

In this example we will create a root-level user `john` with a password and the `OWNER` role:

```surql
DEFINE USER john ON ROOT PASSWORD "VerySecurePassword!" ROLES OWNER;
```

To learn more about authentication in SurrealDB, check out this explainer video:
<iframe width="100%" src="https://www.youtube.com/embed/cGAxH9FezUY?si=qolPqSytH4DU3prg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" 
style={{aspectRatio: 1.7, paddingTop: '20px'}} allowfullscreen></iframe>

### Sign in using the new user

Examples using the JavaScript SDK or a raw HTTP request.

#### JavaScript SDK

```javascript
const db = new Surreal();
db.connect('ws://localhost:8000/rpc', {
	namespace: 'test',
	database: 'test',
});

db.signin({
	username: 'john',
	password: 'VerySecurePassword!',
});
```

#### HTTP Request

```bash
curl -X POST \
	-H "Accept: application/json" \
	-d '{"user":"john", "pass":"VerySecurePassword!"}' \
	http://localhost:8000/signin
```

### Example: Define a Database-level user

Database-level users have visibility into all resources that belong to the database where the user is defined.

In this example we will create a database-level user `mary` with a password and the `EDITOR` role:

```surql
DEFINE USER mary ON DATABASE PASSWORD "VerySecurePassword!" ROLES EDITOR;
```

### Sign in using the new user

Examples using the JavaScript SDK or a raw HTTP request.

Notice how we need to pass along `NS` and `DB` properties here, to let SurrealDB know where the user is defined.

#### JavaScript SDK

```javascript
const db = new Surreal();
db.connect('ws://localhost:8000/rpc', {
	namespace: 'test',
	database: 'test',
});

db.signin({
	// Because we are signin in a database user, we need to let SurrealDB know on which database this user is located.
	namespace: 'test',
	database: 'test',

	username: 'mary',
	password: 'VerySecurePassword!',
});
```

#### HTTP Request

```bash
curl -X POST \
	-H "Accept: application/json" \
	-d '{"NS":"test", "DB":"test", "user":"mary", "pass":"VerySecurePassword!"}' \
	http://localhost:8000/signin
```

## Record users

<Since v="v2.0.0" />

Record users (called "scope users" before v2.0.0) represent users that are defined as a record in a database instead of through the `DEFINE USER` statement. Since these users exist as regular database records, they can have associated fields containing any information required for authentication and authorization.

Thanks to this, SurrealDB is able to offer mechanisms to define your own signin and signup logic as well as custom table and field permissions for record users. This feature contributes to making SurrealDB an all-in-one BaaS (Backend-as-a-Service).

Record users are defined with the [DEFINE ACCESS](/docs/surrealql/statements/define/access) statement of `TYPE RECORD`.

A record access is configured with the following specific clauses:

- `SIGNUP`: Defines the logic for when a user signs up as a record user. Usually creates a new record in a table.
- `SIGNIN`: Defines the logic for when a user signs in as a record user. Usually checks credentials against table records.

By default, record users have no permissions. They don't use the Role-Based Access Control (RBAC) system and can only access data if allowed by a `PERMISSIONS` clause, which is defined on every data resource (i.e. tables and fields) and defaults to `NONE`.

To learn more about creating a record user, refer to the [DEFINE ACCESS ... TYPE RECORD](/docs/surrealql/statements/define/access/record) documentation.

### Example: Setup record authentication

We will go over one of the many ways you can set up record authentication. Given you can define your own logic, there is not a single way to do it. Feel free to modify where needed!

#### Define the User table and fields

Typically, you would define a user table where new records are created every time a user signs up.

In the following code snippet we will define the `user` table and a few `fields` that enforce the following:

- An authenticated user can select, update and delete its own user record.
- Asserts that the email provided by the user is actually an email address.
- Forbid users to use an email that is already in use by another user. We do this by creating a unique index for the email field.

```surql title="Define tables and fields"
DEFINE TABLE user SCHEMAFULL
	PERMISSIONS
		FOR select, update, delete WHERE id = $auth.id;

DEFINE FIELD name ON user TYPE string;
DEFINE FIELD email ON user TYPE string ASSERT string::is_email($value);
DEFINE FIELD password ON user TYPE string;

DEFINE INDEX email ON user FIELDS email UNIQUE;
```

##### Define the User record access

Define the `user` record access: allow users to signin and signup by using the table and fields defined in the previous step

We will configure the record access like this:

- The sign in logic needs the `email` and `password` parameters to be provided by the user. In the query, we can use them as `$email` and `$password`.
- The sign up logic needs the `name`, `email` and `password` parameters to be provided by the user. In the query, we can use them as `$name`, `$email` and `$password`.

```surql title="Scope definition"
DEFINE ACCESS user ON DATABASE TYPE RECORD
	SIGNIN (
		SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(password, $password)
	)
	SIGNUP (
		CREATE user CONTENT {
			name: $name,
			email: $email,
			password: crypto::argon2::generate($password)
		}
	);
```

### Sign up as a user record

Now that the record access is defined, we can start using it.

Examples using the JavaScript SDK or a raw HTTP request.

#### JavaScript SDK

```js
const db = new Surreal();
db.connect('ws://localhost:8000/rpc', {
	namespace: 'test',
	database: 'test',
});

db.signup({
	namespace: 'test',
	database: 'test',

	// Provide the name of the access method
	access: 'user',

	// Provide the variables used by the signup query
	variables: {
    	name: 'John Doe',
    	email: 'john.doe@example.com',
    	password: 'VerySecurePassword!',
	}
});
```
#### HTTP Request

```bash
curl -X POST \
	-H "Accept: application/json" \
	-d '{"NS":"test", "DB":"test", "AC":"user", "name":"John Doe", "email":"john.doe@example.com", "password":"VerySecurePassword!"}' \
	http://localhost:8000/signup
```

### Sign in as a record user

Once a user has signed up, it can now sign in when needed.

Examples using the JavaScript SDK or a raw HTTP request.

#### JavaScript SDK

```js
const db = new Surreal();
db.connect('ws://localhost:8000/rpc', {
	namespace: 'test',
	database: 'test',
});

db.signin({
	namespace: 'test',
	database: 'test',

	// Provide the name of the access method
	access: 'user',

	// Provide the variables used by the signin query
	variables: {
    	email: 'john.doe@example.com',
    	password: 'VerySecurePassword!',
	}
});
```

#### HTTP Request

```bash
curl -X POST \
	-H "Accept: application/json" \
	-d '{"NS":"test", "DB":"test", "AC":"user", "email":"john.doe@example.com", "password":"VerySecurePassword!"}' \
	http://localhost:8000/signin
```

## Sessions

<Since v="v2.0.0" />

Whenever authentication is performed with any kind of user against SurrealDB, a session is established between the client and the SurrealDB server with which the connection was established. These sessions exist only in memory on the server for the duration of the connection, whether it is a single request through the [HTTP REST API](/docs/surrealdb/integration/http) or through multiple requests in the same connection using the [WebSocket API](/docs/surrealdb/integration/rpc) and any of the [SDKs](/docs/surrealdb/integration/sdks) that leverage it.

### Parameters

Certain security-related parameters are automatically set by SurrealDB in the context of a session. These parameters can be referenced in SurrealQL during authentication and authorization.

#### Session

The `$session` parameter contains information about the current session. This parameter is set in every SurrealDB session.

In the following example, you can see the result of the `SELECT * FROM $session` query in an authenticated session for a record user using the [HTTP REST API](/docs/surrealdb/integration/http):

```json
{
	"ac": "user",
	"db": "test",
	"exp": null,
	"id": "example-client",
	"ip": "127.0.0.1",
	"ns": "test",
	"or": "http://www.example.com",
	"rd": "user:example",
	"tk": {
		"AC": "user",
		"DB": "test",
		"ID": "user:example",
		"NS": "test",
		"exp": 1723118226,
		"iat": 1723114626,
		"iss": "SurrealDB",
		"jti": "3b3fe74a-955c-46d7-9400-363848912292",
		"nbf": 1723114626
	}
}
```

On the root of the object, you will find the following fields:

- `ip`: The IP address that established the connection with SurrealDB.
- `exp`: The time at which the session will expire.
  - Will be `NONE` or `null` when the session does not expire.
- `ns`: The name of the currently selected namespace.
  - Will be `NONE` or `null` when no namespace is selected.
- `db`: The name of the currently selected database.
  - Will be `NONE` or `null` when no database is selected.
- `rd`: The record identifier of the currently authenticated record user.
  - Will be `NONE` or `null` when unauthenticated or authenticated as a system user.
- `ac`: The name of the access method that was used to authenticate.
  - Will be `NONE` or `null` when not authenticated with an access method.
- `or`: The value of the `Origin` header of the HTTP request.
  - This header is usually set by browsers to identify the site that originated the request.
- `id`: The value of the `surreal-id` header of the HTTP request.
  - This value can be set by clients to identify their individual sessions to the server.
- `tk`: An object containing the claims present in the authentication token used to establish the session.
  - Will be `NONE` or `null` when not authenticated.

The values stored in the session parameter can be accessed through [the `session::*` family of functions](/docs/surrealql/functions/database/session).

#### Token

The `$token` parameter contains the claims contained in the token used to authenticate the current session. This parameter is set in every authenticated SurrealDB session.

In this example, you can see the result of the `SELECT * FROM $token` query in an authenticated session for a record user:

```js
{
	"AC": "user",
	"DB": "test",
	"ID": "user:example",
	"NS": "test",
	"exp": 1723118226,
	"iat": 1723114626,
	"iss": "SurrealDB",
	"jti": "3b3fe74a-955c-46d7-9400-363848912292",
	"nbf": 1723114626
}
```

Whenever authentication is done directly using a token, this object will contain the claims contained in that token.

When that token is issued by SurrealDB after successful authentication, the object will usually contain the following fields:

- `NS`: The name of the namespace the user is authenticated in.
  - Will be `NONE` or `null` when the user is authenticated at the root level.
- `DB`: The name of the database the user is authenticated in.
  - Will be `NONE` or `null` when the user is authenticated at the root or namespace level.
- `ID`: The record identifier of the currently authenticated record user.
  - Will not be present when not authenticated as a record user.
- `AC`: The name of the access method that is used to authenticate.
  - Will be `NONE` or `null` when authenticating without an access method.

The following fields correspond to claims defined in the standard JWT implementation described in [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519):

- `iat`: The time at which the token was issued.
- `nbf`: The time before which the token will not be accepted to establish new authenticated sessions.
- `exp`: The time after which the token will not be accepted to establish new authenticated sessions.
- `jti`: A unique identifier used to reference the token.
- `iss`: A string identifying the entity which issued the token.

#### Auth

The `$auth` parameter points to the record belonging to the current authenticated record user. This parameter is set only when the session is authenticated with an existing record user.

When the `$auth` parameter is set, you can access any of the fields of the record corresponding to the authenticated user (e.g. `$auth.name` or `$auth.email`) via that parameter.

### Expiration

Authenticated sessions remain valid for a certain duration. This duration is `NONE` by default, meaning that sessions will not expire unless otherwise specified. This duration can be customised on both the `DEFINE USER` and `DEFINE ACCESS` statements to any specific value defining the maximum duration of an authenticated session associated with that user or access method. After the defined duration, the authenticated session will expire. For example, the `DEFINE USER example DURATION FOR SESSION 1d` clause will ensure that any authenticated sessions for the `example` user will expire after a day.

Expired sessions can no longer be used to call authenticated methods and doing so will result in a specific error indicating that the session has expired. SurrealQL can be used to check the expiration of the active session by running `SELECT exp FROM $session`, which show the Unix time when the session will expire or `NONE` in the case that the session does not expire.

Clients can reuse a connection with an expired session to refresh the session using valid credentials. This includes calling the [`signin`](/docs/surrealdb/integration/rpc#signin) method to obtain a new token with credentials and reauthenticate the session using that token or calling the [`authenticate`](/docs/surrealdb/integration/rpc#authenticate) method to reauthenticate the session with an existing token.

It is important to note that token duration and session duration are independent concepts. Token duration, which can be similarly customised, refers to the validity of the token (i.e. the value of its `exp` claim), during which it can be used to establish an authenticated session. Tokens issued by SurrealDB have a default duration of one hour. Token expiration is used to limit the time during which a token can be compromised resulting in unauthorized access; tokens are often stored in the client and could be stolen with attacks like cross-site scripting. Session expiration can be used to ensure that users are required to reauthenticate in order to prove that they still have access to valid credentials as well as to limit the impact of a compromised client with an established session; sessions are stored in memory in the server and cannot be similarly stolen. It is recommended that tokens are configured to last for as little as necessary before being exchanged for an authenticated session, whereas sessions are recommended to last for as little as necessary to allow for the typical client to complete a set of authenticated actions.



================================================
FILE: src/content/doc-surrealdb/security/capabilities.mdx
================================================
---
sidebar_position: 4
sidebar_label: Capabilities
title: Capabilities | Security
description: SurrealDB is secure by default and is suitable for all database use cases. It offers powerful features like scripting, functions or network access from within your SurrealQL queries.
---

import Since from "@components/shared/Since.astro";

# Capabilities

SurrealDB is secure by default and is suitable for all database use cases. It offers powerful features like scripting, functions or network access from within your SurrealQL queries. For the strongest security, SurrealDB doesn't allow most of these features by default and instead lets the administrator allow them as needed per use case.

> [!IMPORTANT]
> Capabilities can be enabled and configured in SurrealDB Cloud . This is done by clicking on the "Configure instance" button in the SurrealDB Cloud dashboard. Learn more about capabilities in SurrealDB Cloud [in the Cloud documentation](/docs/cloud/advanced-topics/configure-an-instance).

When a query wants to use a capability that is not allowed, SurrealDB will reject it.

```surql title="Rejected Query"
> RETURN http::get("https://www.surrealdb.com");

["Access to network target 'www.surrealdb.com:443' is not allowed"]
```

This rejection will also be logged in the SurrealDB server.

```surql title="Rejected Query Logging"
WARN surrealdb_core::ctx::context: Capabilities denied outgoing network connection attempt, target: 'www.surrealdb.com:443'
```

In production deployments, we recommend denying all capabilities by default and specifically allowing only those required.

```bash
surreal start --deny-all --allow-funcs "array, string, crypto::argon2, http::get" --allow-net api.example.com:443
```

You can learn more about best practices when using capabilities in our [Security Best Practices](/docs/surrealdb/reference-guide/security-best-practices#capabilities) guide.

## Priority

By default, all capabilities are denied unless allowed. Some few capabilities (e.g. functions) are allowed by default.

Capabilities can be configured globally (e.g. `--allow-all`, `--deny-all`), generally (e.g. `--allow-net`, `--deny-funcs`) or specifically (e.g. `--deny-net 192.168.1.1`, `--allow-funcs string::len`).
When capabilities are configured, the more specific capabilities prevail over the less specific. At the same level of specificity, denies always prevail over allows.

### Examples

Capabilities configured generally prevail over those defined globally:
- Running with `--deny-all --allow-scripting` will deny all capabilities except for scripting.
- Running with `--allow-all --deny-net` will allow all capabilities except for network.

Capabilities configured specifically prevail over those defined globally or generally:
- Running with `--deny-all --allow-net example.com` will deny all capabilities except network connections to `example.com`.
- Running with `--allow-all --deny-funcs http` will allow all capabilities except for calling functions of the `http` family.
- Running with `--deny-funcs --allow-funcs string::len` will deny all functions except for `string::len`.
- Running with `--allow-net --deny-net 10.0.0.0/8` will allow all network connections except to the `10.0.0.0/8` block.

Capabilities denied specifically prevail over those allowed specifically:
- Running with `--deny-funcs crypto --allow-funcs md5` will deny all functions of the `crypto` including `crypto::md5`.
- Running with `--allow-funcs crypto --deny-funcs md5` will allow all functions of the `crypto` family except for `crypto::md5`.

## List

List of options for allowing capabilities:

<table>
    <thead>
        <tr>
            <th scope="col">Option</th>
            <th colspan="2" scope="col">Description</th>
            <th scope="col">Default</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Option">
                -A, --allow-all
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Allow all capabilities except for those more specifically denied like experimental features
            </td>
            <td scope="row" data-label="Default">
                False
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Option">
                -A, --allow-arbitrary-query
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Denies arbitrary queries to be used by user groups. Possible user groups are: 'guest', 'record', and 'system'.
            </td>
            <td scope="row" data-label="Default">
                False
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Option">
                --allow-experimental
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Allow the usage of one or more experimental features (current experimental features are [GraphQL](/docs/surrealdb/querying/graphql) and [Record references](/docs/surrealql/datamodel/references)). Possible values are `graphql`, `surrealism`, `files`, and `define_api`, separated by a comma.
            </td>
            <td scope="row" data-label="Default">
                None
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Option">
                --allow-funcs [&lt;target&gt;,...]
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Allow execution of all functions except for functions that are specifically denied. Alternatively, you can provide a comma-separated list of function names to allow
            </td>
            <td scope="row" data-label="Default">
                None
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Option">
                --allow-guests
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Allow non-authenticated users to execute queries when authentication is enabled
            </td>
            <td scope="row" data-label="Default">
                False
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Option">
                --allow-net [&lt;target&gt;,...]
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Allow all outbound network access except for network targets that are specifically denied. Alternatively, you can provide a comma-separated list of network targets to allow
            </td>
            <td scope="row" data-label="Default">
                None
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Option">
                --allow-scripting
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Allow execution of embedded scripting functions
            </td>
            <td scope="row" data-label="Default">
                False
            </td>
        </tr>
    </tbody>
</table>

List of options for denying capabilities:

<table>
    <thead>
        <tr>
            <th scope="col">Option</th>
            <th colspan="2" scope="col">Description</th>
            <th scope="col">Default</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Option">
                -D, --deny-all
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Deny all capabilities except for those more specifically allowed
            </td>
            <td scope="row" data-label="Default">
                False
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Option">
                -D, --deny-arbitrary-query
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Denies arbitrary queries from being used by user groups. Possible user groups are: 'guest', 'record', and 'system'
            </td>
            <td scope="row" data-label="Default">
                False
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Option">
                --deny-funcs [&lt;target&gt;,...]
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Deny execution of all functions except for functions that are specifically allowed. Alternatively, you can provide a comma-separated list of function names to deny
            </td>
            <td scope="row" data-label="Default">
                None
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Option">
                --deny-guests
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Deny non-authenticated users to execute queries when authentication is enabled
            </td>
            <td scope="row" data-label="Default">
                False
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Option">
                --deny-net [&lt;target&gt;,...]
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Deny all outbound network access except for network targets that are specifically allowed. Alternatively, you can provide a comma-separated list of network targets to deny
            </td>
            <td scope="row" data-label="Default">
                None
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Option">
                --deny-scripting
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Deny execution of embedded scripting functions
            </td>
            <td scope="row" data-label="Default">
                False
            </td>
        </tr>
    </tbody>
</table>

## Guest Access

Guest access is used when you want to expose certain parts of a database to non-authenticated users. It's useful when you want to serve datasets publicly and still require authentication for the rest of the system.

Even when this capability is allowed, a guest user can only execute functions or data operations like SELECT, CREATE, etc, and only if the `PERMISSIONS` clause for the resource being used in the query allows it.

```surql
// Prepare tables with custom PERMISSIONS
test/test> DEFINE TABLE protected PERMISSIONS NONE;
test/test> DEFINE TABLE public PERMISSIONS FULL;

// When guest access is allowed
$ surreal start --allow-guests

test/test> CREATE public;
[{ id: public:uy0qzy31v4xox8vivrd4 }]

test/test> SELECT * FROM public;
[{ id: public:uy0qzy31v4xox8vivrd4 }]

test/test> CREATE protected;
[]

test/test> SELECT * FROM protected;
[]

// When guest access is denied
$ surreal start --deny-guests

test/test> CREATE public;
There was a problem with the database: There was a problem with the database: IAM error: Not enough permissions to perform this action

test/test> SELECT * FROM public;
There was a problem with the database: There was a problem with the database: IAM error: Not enough permissions to perform this action

test/test> CREATE protected;
There was a problem with the database: There was a problem with the database: IAM error: Not enough permissions to perform this action

test/test> SELECT * FROM protected;
There was a problem with the database: There was a problem with the database: IAM error: Not enough permissions to perform this action
```

## Functions

SurrealDB offers [built-in functions](/docs/surrealql/functions/database/array) to perform common operations like string manipulation, math, etc. Users can also define [their own functions](/docs/surrealql/statements/define/function) with custom logic.

In certain environments, you may not want users to use specific functions (i.e. `http::*`) or execute any custom function at all. You can use the allow/deny lists to configure what functions are allowed and what functions are denied.

```surql
// Allow all functions except the http family and crypto::md5()
surreal start --allow-funcs --deny-funcs "http","crypto::md5"

// Allow certain custom functions only (all custom functions start with "fn::")
surreal start --allow-funcs "fn::shared_fn"
```

## Network

SurrealDB offers http functions that can access external network endpoints.

If you want to allow or deny access to certain network target, you can configure the network options accordingly. Here are some examples:

```surql
// Deny network access to localhost and private IPv4 ranges
$ surreal start --allow-net --deny-net "127.0.0.1","localhost","10.0.0.0/8","192.168.0.0/16","172.16.0.0/12"

// Allow access to an internal system but only to port 443
$ surreal start --allow-net internal.example.com:433

// Allow access to some private networks but not to others
$ surreal start --allow-net 10.0.0.0/16 --deny-net 10.10.0.0/24
```

SurrealDB will perform DNS lookups and prevent network access to a hostname that resolves to an IP network target defined within `--deny-net`.  

> [!WARNING]
> SurrealDB currently does not perform reverse DNS lookups to prevent http functions directly accessing an IP address, even when the hostname that resolves to that IP address is listed within `--deny-net`. This is an issue when SurrealDB is configured with allow network access by default e.g `--allow-net --deny-net www.google.com` or when the IP is in the allowlist, but the hostname that resolves to that IP is in the denylist e.g `--allow-net 172.217.169.14 --deny-net www.google.com` 

It is **strongly recommended** that you deny by default by defining specific `--allow-net` targets and using additional layers of network security within your infrastructure.

## Arbitrary queries

<Since v="v2.2.0" />

The `--allow-arbitrary-query` and `--deny-arbitrary-query` allows database administrators to allow or deny arbitrary quering by either guest, record or system users, or a combination of those. This capability settings affects the following:  [/sql endpoint](/docs/surrealdb/integration/http#sql), [/key endpoints](/docs/surrealdb/integration/http#get-table), [/graphql endpoint](/docs/surrealdb/integration/http#graphql) and [RPC methods](/docs/surrealdb/integration/rpc) `use`, `select`, `create`, `update`, `merge`, `patch`, `delete`, `relate`, `insert`, `insert_relation`, `query` and `graphql`.

Endpoints that do not accept arbitrary queries such as [`/version`](/docs/surrealdb/integration/http#version) and [authentication endpoints](/docs/surrealdb/integration/http#signin) are not affected.


================================================
FILE: src/content/doc-surrealdb/security/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Security
title: Security
description: In this section, you will explore the robust security features and best practices that SurrealDB offers to protect your data and ensure the integrity of your applications.
---

# Security

Welcome to the Security section of the SurrealDB documentation! In this section, you will explore the robust security features and best practices that SurrealDB offers to protect your data and ensure the integrity of your applications.

The security of your data is of utmost importance, and SurrealDB provides a comprehensive set of security features to safeguard your information. This section will guide you through the various security measures and best practices that you can implement when working with SurrealDB.

Additionally, we recommend that you consult the [security best practices reference guide](/docs/surrealdb/reference-guide/security-best-practices) for a more comprehensive list of security recommendations that are important to secure SurrealDB deployments. Following the security recommendations and implementing the suggested measures will help you in ensuring that your SurrealDB-powered applications are protected against potential threats and vulnerabilities.

Here are some helpful pointers on how to start exploring this section:

- To learn about the security features that SurrealDB offers, visit the [Summary (Product)](/docs/surrealdb/security/summary#product) section.
- To learn about the security of the development process of SurrealDB, visit the [Summary (Process)](/docs/surrealdb/security/summary#process) section.
- To learn the key authentication concepts in SurrealDB with some examples, consult the [Authentication](/docs/surrealdb/security/authentication) section.
- To tighten or loosen the security of the SurrealDB server, you should consult the [Capabilities](/docs/surrealdb/security/capabilities) section.

## Best Practices

In addition to the built-in security features, this section will describe some best practices and guidelines to enhance the security of your SurrealDB deployments. You will learn about secure coding practices, network security considerations and data protection strategies.

However, we recommend that you consult the [security best practices reference guide](/docs/surrealdb/reference-guide/security-best-practices) for a more comprehensive list of security recommendations that are important to secure SurrealDB deployments.

Following the security recommendations and implementing the suggested measures will help you in ensuring that your SurrealDB-powered applications are protected against potential threats and vulnerabilities.

Let's dive into the Security section and explore the robust security features that SurrealDB offers!


================================================
FILE: src/content/doc-surrealdb/security/summary.mdx
================================================
---
sidebar_position: 2
sidebar_label: Summary
title: Summary | Security
description: This page summarizes some of the security features offered by SurrealDB as well as some security elements of its development process with the goal of providing a starting point to both new and experienced users who wish to know more about the security of SurrealDB.
---

# Security Summary

This page summarizes some of the security features offered by SurrealDB as well as some security elements of its development process with the goal of providing a starting point to both new and experienced users who wish to know more about the security of SurrealDB.


> [!NOTE]
> This page is intended to direct the reader to other more specific and comprehensive resources. Some information shown in this page may be simplified or omit information that could be relevant in a particular scenario. When available, we recommend that you consult the provided references.

## Product

### Capabilities
SurrealDB offers the ability to limit its functionality to what is strictly required to reduce its attack surface. Most capabilities (e.g. scripting, networking…) are disabled by default. Even when enabled, capabilities can be restricted to specific targets such as functions that can be executed or network addresses that outbound connections can be made to.
- [Security: Capabilities](/docs/surrealdb/security/capabilities)
- [Security Best Practices: Capabilities](/docs/surrealdb/reference-guide/security-best-practices#capabilities)

### System Users
SurrealDB is managed by system users. Such users can be defined at the root, namespace and database level, which they can sign into with username and password. The password for those users is stored hashed and salted using the [Argon2id](https://datatracker.ietf.org/doc/html/rfc9106#name-recommendations) algorithm with default parameters, which ensures robust resistance against modern attacks. Passwords can also be provided to SurrealDB already hashed in the form of a passhash, ensuring that the SurrealDB server never has knowledge of the original password. When defining a user, the maximum duration for authentication tokens and authenticated sessions can be explicitly defined to mitigate the impact of compromised credentials.
- [Statement: DEFINE USER](/docs/surrealql/statements/define/user)
- [Security Best Practices: Expiration](/docs/surrealdb/reference-guide/security-best-practices#expiration)

### Roles
SurrealDB implements Role-Based Access Control (RBAC) for system users at any level. This means that even if a person or system needs to authenticate with a SurrealDB user at the root, namespace or database level, its access can be restricted within that level by the owner, editor and viewer roles to minimize the impact of an incident involving the user.
- [Statement: DEFINE USER (Roles)](/docs/surrealql/statements/define/user#roles)
- [Security: Authentication (System Users)](/docs/surrealdb/security/authentication#system-users)
- [Security Best Practices: Least Privilege](/docs/surrealdb/reference-guide/security-best-practices#least-privilege)

### Record Users
SurrealDB supports being used as a web database by allowing end users limited access to the database. This allows clients like single-page applications or mobile applications to directly connect to the database and access certain data or even run arbitrary queries. When accessing the database as a record user, users will be restricted by table and field permissions, which deny all operations by default. End users can independently sign up and sign in to use surreal following custom logic that can be defined with SurrealQL.
- [Statement: DEFINE ACCESS ... TYPE RECORD](/docs/surrealql/statements/define/access/record)
- [Security: Authentication (Record Users)](/docs/surrealdb/security/authentication#record-users)

### Permissions
SurrealDB enforces table and field permissions for record users. Those permissions ensure that record users can only perform explicitly defined actions over explicitly defined data. Permissions are specified when defining a table or a field and use SurrealQL syntax to establish the conditions under which the table or the field can be queried with SELECT, UPDATE, CREATE and DELETE operations individually. No table permissions are defined by default, thus preventing a record user from querying any data unless explicitly allowed.
- [Statement: DEFINE TABLE](/docs/surrealql/statements/define/table)
- [Statement: DEFINE FIELD](/docs/surrealql/statements/define/field)

### JSON Web Tokens
SurrealDB internally uses JWT to perform and manage authentication for both system and record users. It also supports accepting tokens issued by third party authentication providers in order to authenticate as a system user on any level as well as a record user for an application. This ensures that advanced authentication features not present in SurrealDB can be integrated through a third party provider. This integration is simple and reliable thanks to JSON Web Key Set (JWKS) support implemented by SurrealDB.
- [Statement: DEFINE ACCESS ... TYPE JWT](/docs/surrealql/statements/define/access/jwt)
- [Statement: DEFINE ACCESS ... TYPE RECORD ... WITH JWT](/docs/surrealql/statements/define/access/record#with-json-web-token)
- [Tutorial: Integrate Auth0 as Authentication Provider](/docs/tutorials/integrate-auth0-as-authentication-provider)
- [Tutorial: Integrate AWS Cognito as Authentication Provider](/docs/tutorials/integrate-aws-cognito-as-authentication-provider)
- [Security Best Practices: JSON Web Tokens](/docs/surrealdb/reference-guide/security-best-practices#json-web-tokens)
- [Security Best Practices: Expiration](/docs/surrealdb/reference-guide/security-best-practices#expiration)

### Custom Authentication
SurrealDB allows record users to authenticate using a token that can be issued by a third party or SurrealDB itself after successful authentication. When verifying these tokens, custom logic can be implemented using SurrealQL to abort authentication while returning a custom error if certain conditions are not met. This logic can be used to implement various kinds of token auditing and revocation mechanisms. Additionally, tokens issued by SurrealDB can be customized to be signed with specific keys or using a specific algorithms so that other services can rely on the authentication provided by SurrealDB.
- [Statement: DEFINE ACCESS ... TYPE RECORD ... AUTHENTICATE](/docs/surrealql/statements/define/access/record#with-authenticate-clause)
- [Statement: DEFINE ACCESS ... TYPE RECORD ... WITH ISSUER](/docs/surrealql/statements/define/access/record#with-issuer)
- [Security Best Practices: Expiration](/docs/surrealdb/reference-guide/security-best-practices#expiration)

### Parametrized Queries
SurrealDB is usually queried through [multiple SDKs](/docs/surrealdb/integration/sdks) and a powerful [RPC interface](/docs/surrealdb/integration/rpc). The default query method for both of those interfaces is designed to accept query logic and variables separately to prevent query injection attacks like SQL injection. This separation ensures that user-controlled inputs are not mixed with any business logic defined in SurrealQL.
- [Interfaces: RPC (Query Method)](/docs/surrealdb/integration/rpc#query)
- [Interfaces: Rust SDK (Query Method)](/docs/sdk/rust/setup#query)
- [Security Best Practices: Query Safety](/docs/surrealdb/reference-guide/security-best-practices#query-safety)

### Sessions
SurrealDB accepts persistent connections through its RPC interface in the form of sessions. Sessions will usually be associated with an authentication token that represents a system user or a record user. Sessions and tokens can be configured to have different expiration times. Thanks to this, tokens can be issued to last the minimum time required to mitigate the impact of an attacker stealing the token while ensuring that sessions can last as long as required for the service or application.
- [Security: Sessions](/docs/surrealdb/security/authentication#sessions)
- [Statements: DEFINE USER (Duration)](/docs/surrealql/statements/define/user#duration)
- [Statements: DEFINE ACCESS (Duration)](/docs/surrealql/statements/define/access#duration)
- [Security Best Practices: Expiration](/docs/surrealdb/reference-guide/security-best-practices#expiration)
- [Interfaces: RPC (Authenticate)](/docs/surrealdb/integration/rpc#authenticate)

### Cryptographic Functions
SurrealDB provides a series of cryptographic functions that can be called from within SurrealQL in order to implement modern and robust security practices in your application. This includes state of the art password hashing algorithms such as Argon2, Bcrypt, Scrypt and PBKDF2. Traditional hashing algorithms like SHA-256 and SHA-512 are also provided for other applications such as integrity verification.
- [Functions: Crypto](/docs/surrealql/functions/database/crypto)
- [Security Best Practices: Passwords](/docs/surrealdb/reference-guide/security-best-practices#passwords)

### Other Security Functions
SurrealDB also aims to provide other functions that support developers with building secure applications. An example of this are functions which encode and sanitize HTML content that is stored in the database to prevent code injection (which can lead to cross-site scripting, clickjacking or content injection) when displaying the content in an HTML page.
- [Functions: String (HTML Encode)](/docs/surrealql/functions/database/string#stringhtmlencode)
- [Functions: String (HTML Sanitize)](/docs/surrealql/functions/database/string#stringhtmlsanitize)
- [Security Best Practices: Content Safety](/docs/surrealdb/reference-guide/security-best-practices#content-safety)

### Transport Layer Security
SurrealDB has the ability to provide a secure TLS connection to its HTTP server without the need for a reverse proxy or load balancer. A certificate and a private key can be provided when starting the server in order to provide a secure connection.
- [CLI: Start](/docs/surrealdb/cli/start)
- [Security Best Practices: Encryption in Transit](/docs/surrealdb/reference-guide/security-best-practices#encryption-in-transit)

## Process

### Open Source Security
SurrealDB has an open source security policy extending its security process to the wider community. This policy is made available through Github and a “security.txt” file, and allows SurrealDB to benefit from the security expertise and resources of its community. In turn, it provides the community with safe and responsible avenues to contribute to the security of an open source product that they rely on.
- [Github: Security Policy](https://github.com/surrealdb/surrealdb/security/policy)
- [Website: Well-Known Security File](/.well-known/security.txt)

### Responsible Disclosure
SurrealDB encourages external contributors to report security vulnerabilities following a small set of practices described in the open source security policy. SurrealDB commits to address all legitimate reports within three days, work on resolving the issue while keeping the reporter updated and crediting the reporter when an advisory is eventually published. The responsible disclosure process protects legitimate security reporters from legal repercussions and promotes an open discussion around the security of SurrealDB.
- [Github: Security Policy (Reporting a Vulnerability)](https://github.com/surrealdb/surrealdb/security/policy#reporting-a-vulnerability)


### Security Advisory
SurrealDB releases security advisories whenever a significant security issue has been resolved in the product. These advisories provide details about the vulnerability, its potential impact, affected versions and possible workarounds. The publication of advisories assists both humans and automations in identifying existing risks early as well as being aware of how to immediately mitigate or resolve them.
- [Github: Security Policy (Security Advisories)](https://github.com/surrealdb/surrealdb/security/policy#security-advisories)
- [Github: Security Advisories](https://github.com/surrealdb/surrealdb/security/advisories)


### Software Composition Analysis
SurrealDB includes SCA in its development process by using both the Cargo Deny binary crate for Rust code as well as Dependabot in its CI/CD pipelines. The latter ensures that changes including dependencies with known vulnerabilities cannot be merged unless those vulnerabilities are explicitly acknowledged in a public file; this usually requires either updating or replacing the affected dependency. The former provides notification of emerging vulnerabilities in dependencies that are currently being used by SurrealDB so that they can be updated or replaced.
- [Github: Security Policy (Dependencies)](https://github.com/surrealdb/surrealdb/security/policy#dependencies)
- [Github: Cargo Deny Configuration](https://github.com/surrealdb/surrealdb/blob/main/deny.toml)

### Fuzzing
SurrealDB automatically identifies crashes and other security-relevant bugs using automated coverage-based fuzzing. This process is hosted by the Google OSS-Fuzz project and continuously runs SurrealDB with a huge range of valid and invalid inputs mutated with the help of artificial intelligence in order to cover every part of the code. This enables the early detection of edge cases which may result in security issues. The OSS-Fuzz project automatically publicly discloses bugs that have not been fixed in 90 days.
- [Github: Security Policy (Fuzzing)](https://github.com/surrealdb/surrealdb/security/policy#fuzzing)

### Supply Chain Security
SurrealDB aims to reduce the risk and impact of compromised dependencies in its supply chain by implementing processes and automation to ensure that new and updated dependencies are consciously evaluated, especially when they have not yet been audited by trusted organizations or they extend their access to Rust standard library interfaces. This is accomplished in Rust code by using the Cargo ACL and Cargo Vet binary crates, both of which will need to pass in CI/CD before any changes to dependencies can be merged.
- [Github: Supply Chain Security](https://github.com/surrealdb/surrealdb/blob/main/supply-chain/README.md)



================================================
FILE: src/content/doc-surrealdb/security/troubleshooting.mdx
================================================
---
sidebar_position: 5
sidebar_label: Troubleshooting
title: Troubleshooting | Security
description: This page provides some troubleshooting advice to support users in addressing issues either caused by or involved in the usage of specific security features provided by SurrealDB.
---

# Troubleshooting

This page provides some troubleshooting advice to support users in addressing issues either caused by or involved in the usage of specific security features provided by SurrealDB.

## Authentication

### Invalid Authentication Error

The most common error that users may receive when authenticating to SurrealDB is `InvalidAuth`, which results in a generic message such as `There was a problem with authentication`. The reason that this message is so vague and yet so common is that it is a placeholder for other more specific internal errors related to authentication. These errors are not returned to the client due to their potential to leak internal information about the database (e.g. whether or not a user or access method exists, whether a token failed to verify because of its signature or a specific claim...) to unauthenticated users.

Although the internal cause for these errors is not revealed to clients, it can be identified by the SurrealDB administrator through its server logs. These logs will usually be prefixed by `surrealdb::core::iam`. Most helpful messages will be displayed when [starting SurrealDB with `--log debug`](/docs/surrealdb/cli/start#command-help). If those logs are not enough to diagnose the problem, starting the server with `--log trace` will provide additional messages describing the authentication process.

In situations where debugging must be performed on the client, starting the SurrealDB server with the environment variable `SURREAL_INSECURE_FORWARD_ACCESS_ERRORS` set to `true` will forward errors resulting from [`SIGNIN`, `SIGNUP`](/docs/surrealql/statements/define/access/record#example-usage) and [`AUTHENTICATE`](/docs/surrealql/statements/define/access/record#with-authenticate-clause) clauses directly to clients. Since these errors may expose the internal logic of such clauses, this variable should only be used for debugging in controlled environments with trusted clients.

#### Common Causes

The following are the most common causes for a generic authentication error in SurrealDB.

##### Incorrect user credentials

The simplest reason why authentication may fail. Ensure that the credentials that you are using to authenticate (e.g. username and password) match the ones that you have defined.

For system users, ensure that any special characters (e.g. quotes) have been interpreted correctly as part of the username or password rather than as SurrealQL syntax. Use the `INFO` statements to display the defined users and ensure that their password hash matches the hash of the password that you are providing. You can use the included [compare hash functions in SurrealQL](/docs/surrealql/functions/database/crypto#cryptoargon2compare) to perform this verification.

For record users, ensure that the `SIGNIN` and `SIGNUP` queries will return a user. You can do that by running those queries by themselves in the SurrealQL interpreter (`surreal sql`) or in Surrealist. You will just need to replace any parameters from those queries by the parameters that you are providing during authentication. Ensure that you are in fact providing all the expected parameters during authentication in your actual code.

##### The referenced user or access method does not exist

Ensure that the user and access method that you are authenticating with exists on the level that you are trying to authenticate. Check that you are authenticating against the namespace or database where the resource is defined and that you have correctly spelled the resource everywhere.

When authenticating with the SurrealDB CLI or with the HTTP REST API, ensure that you specify the namespace and database that your user exists in (i.e. `--auth-level ns` and `--auth-level db` or `surreal-auth-ns` and `surreal-auth-db`), in addition to the namespace and database that you want to use for the connection (i.e. `--namespace` and `--database` or `surreal-ns` and `surreal-db`). Otherwise, SurrealDB will default to authenticating at the root level.

##### The token could not be cryptographically verified

When using a token to authenticate, SurrealDB will reject tokens that fail the verification of its cryptographic signature. If the token has been issued by SurrealDB, this is most likely not the cause for your issue. If the token has not been issued by SurrealDB, this usually means that the provided token is signed using a different algorithm than defined or that the key used to sign the token is incorrect.

For tokens that are [verified from a URL hosting a JWKS object](/docs/surrealql/statements/define/access/jwt#json-web-key-set-jwks), failure to verify the token may be caused by the URL being incorrect, unreachable by the SurrealDB server or outbound connections to the address not being allowed by the [network capability](/docs/surrealdb/security/capabilities#network). Relevant logs will be displayed on the SurrealDB server when running it with `--log debug` or `--log trace`.

##### The token is missing a required claim

Tokens that are missing any of the claims required by SurrealDB will be rejected with a generic error. Ensure that tokens issued outside of SurrealDB contain all the required claims. Depending on whether the token is for a system user, a record access method or a JWT access method, different claims will be expected. In all cases, the `exp` claim is required. Consult the [Using Tokens](/docs/surrealql/statements/define/access/jwt#using-tokens) section of the `DEFINE ACCESS ... TYPE JWT` documentation for more information about the required claims for system and record users.

### Other Authentication Errors

The following is a non-comprehensive list of authentication errors which may sometimes be challenging to understand.

#### Unexpected Authentication Error

Like `InvalidAuth`, `UnexpectedAuth` is an error that acts as a placeholder for a different group of errors. This error results in a generic message such as `There was an unexpected error while performing authentication`. Unlike errors specific to authentication, this error is returned when the original error is not directly related with authentication, but rather with a failure in some of the components necessary for authentication.

This distinction is made because, unlike `InvalidAuth` errors, `UnexpectedAuth` errors may be retried by clients, as it is possible that the internal failure that resulted in the error is ephemeral. Clients may want to handle these two errors differently; for example, by returning `InvalidAuth` errors to user but internally attempting to retry on `UnexpectedAuth` errors, only returning an internal error to the user if the error persists.

A specific example for this error is the `AUTHENTICATE`, `SIGNIN` or `SIGNUP` clauses failing due to a transaction error, such as those which can arise from a write conflict during the transaction. These conflicts may appear for some datastores in any query when two transactions simultaneously access the same document.

#### Token Expired Error

This error is returned when the token that is being used to authenticate a session has [expired](/docs/surrealdb/security/authentication#expiration). If this token was issued by SurrealDB, this expiration defaults to an hour and can be changed using the `DURATION FOR TOKEN` clause in [`DEFINE ACCESS`](/docs/surrealql/statements/define/access/record) and [`DEFINE USER`](/docs/surrealql/statements/define/user). If the token was not issued by SurrealDB, this expiration will be set by the `exp` claim. 

Note that this error will only appear when trying to authenticate the [session](/docs/surrealdb/security/authentication#sessions). After authentication, the session will not expire when the token does, but rather after the independent session duration that has been defined in the `DURATION FOR SESSION` clause. By default, sessions will not expire. When using the HTTP REST API, a persistent session is not established as each request will be individually authenticated, as a consequence, requests made using an expired token will be rejected with this error.

Although tokens accepted by SurrealDB must have some expiration, you can configure any amount of time that fits your security and usability requirements with the `DURATION FOR TOKEN` clause or by configuring the `exp` claim if you are using an external token issuer.

To address token expiration errors you will either have to ask your end user to authenticate again with credentials to obtain a new token, rely on a persistent authenticated WebSocket session, rely on an external identity provider like [Auth0](/docs/tutorials/integrate-auth0-as-authentication-provider) or [AWS Cognito](/docs/tutorials/integrate-aws-cognito-as-authentication-provider) or, for development purposes, test the [expimental refresh token feature](/docs/surrealql/statements/define/access/record#with-refresh-token).

### Other Authentication Issues

#### Slow / Expensive Authentication

In SurrealDB, clients can authenticate using different methods, such as credentials (e.g. username and password), a token (i.e. JWT) and other experimental access methods like bearer keys. These access methods provide different benefits and have different performance implications. Different options are provided precisely to allow flexibility for different use cases.

If you observe that authentication requests are slow or computationally (e.g. CPU, memory...) expensive, consider switching from authentication with credentials to token authentication. By default, SurrealDB verifies passwords for system users with [Argon2id](https://en.wikipedia.org/wiki/Argon2), which is a password hashing algorithm that ensures that the password verification process is slow and expensive to prevent password cracking. If you are using the [HTTP REST API](/docs/surrealdb/integration/http) to authenticate using credentials (i.e. with `Authorization: Basic ...` rather than `Authorization: Bearer ...`), this password verification process will be performed for every request. Instead, consider [authenticating once with credentials](/docs/surrealdb/integration/http#signin) to obtain a token and performing subsequent requests using that token in the `Authorization` header prefixed by `Bearer`. Token verification is a different cryptographic process that is designed to be orders of magnitude faster and cheaper.

When using credentials to authenticate record users, you are able to choose the password hashing algorithm that you use in your `SIGNIN` query. If you must repeatedly authenticate using credentials and the performance impact of using Argon2id is unacceptable to your use case, you may consider using different password hashing algorithms (e.g. [Bcrypt](/docs/surrealql/functions/database/crypto#cryptobcryptcompare), [Scrypt](/docs/surrealql/functions/database/crypto#cryptoscryptcompare) or [PBKDF2](/docs/surrealql/functions/database/crypto#cryptopbkdf2compare)) that may be more efficient at the cost of diminished security against certain types of password cracking.

Authentication logic that is implemented by users via the `SIGNIN`, `SIGNUP` and `AUTHENTICATION` clauses may also be costly depending on the logic implemented therein. If you are using any custom authentication logic, verify that it is not the cause for the performance cost by manually executing the query in the SurrealQL interpreter (`surreal sql`) or in Surrealist and ensuring that the time that it takes to execute is acceptable.

### Requesting Authentication Support

If you are not able to diagnose a specific authentication issue with the information provided on this page, you may consider asking support from the SurrealDB community. If you do so, this section describes some information that you should provide in order to help others help you with your issue. Please, only ask support directly from the developers of SurrealDB if you believe your issue may be related to a bug in SurrealDB.

Before sharing any information with other SurrealDB users or the SurrealDB team, please ensure that it does not contain any sensitive data, including secrets which may be used to access sensitive data. We recommend setting up a separate SurrealDB environment with dummy data for the purposes of debugging.

When requesting support with authentication, we recommend that you provide the following information:

- The version of SurrealDB that you are using, which you can obtain with the `surreal version` command.
- The command line arguments that you are using to start the SurrealDB server with the `surreal start` command.
- The error message that your client receives when attempting to authenticate against SurrealDB.
- The logs that are displayed on the server, running with `--log debug`, when authentication fails.
- A description of the resources you are using to authenticate. These resources will most likely be included in the output of `INFO FOR ROOT`, `INFO FOR NAMESPACE` and `INFO FOR DATABASE`. If your authentication logic relies on data from specific records through `SIGNIN`, `SIGNUP` or `AUTHENTICATE` clauses, include the contents of those records as well.
- A simplified proof of concept that reproduces your issue. Please, do not share the complete code that you are using to authenticate with SurrealDB. Instead, provide a minimal example that only contains the relevant elements and that does not require a specific SDK to reproduce. If possible, provide a simple request that uses the [HTTP REST API](/docs/surrealdb/integration/http#signin) (e.g. with `curl` or similar) to reproduce the error that you are encountering.
- If you are using a token to authenticate, provide an example of a token that triggers the issue. In the case of a JWT, please include the full encoded contents of the token, not just the values of its claims.



================================================
FILE: src/content/doc-surrealist/getting-started.mdx
================================================
---
sidebar_position: 3
sidebar_label: Getting Started
title: Surrealist | Getting Started
description: This page will guide you through the process of setting up and using Surrealist. At this point we assume you have already installed Surrealist on your system. If you have not done so yet, please refer to the installation guide.
---

import Image from "@components/Image.astro";
import ImageStart from "@img/image/surrealist/surrealist-overview-page.png";
import ImageHttpConnection from "@img/image/surrealist/new-http-connection.png";
import ImageSidebar from "@img/image/surrealist/sidebar.png";

# Getting Started

This page will guide you through the process of setting up and using Surrealist. At this point we assume you have already installed Surrealist on your system. If you have not done so yet, please refer to the [installation guide](/docs/surrealist/installation).

## Start screen

When launching Surrealist for the first time you will be greeted by the start screen. This screen allows you to easy jump into a sandbox environment or create a new connection to your SurrealDB instance.

If you are new to SurrealDB or looking to experiment with SurrealQL, we recommend starting with the sandbox environment. This environment allows you to test and experiment without installing the SurrealDB database or storing data persistently.

If you are looking to connect to a local or remote hosted SurrealDB instance, you can create a new connection by clicking the **Create new** button. This will open the connection dialog, then select the **Connection** option where you can enter your database details. 

Alternatively, you can select the **Cloud instance** option where you can create a new connection to a SurrealDB Cloud instance. Learn more about SurrealDB Cloud in the [SurrealDB Cloud documentation](/docs/cloud).

<Image
  alt="Start screen"
  src={ImageStart}
/>

## Connections

In order to interact with a SurrealDB database you must first create a connection. Connections store the details required to connect to a database, such as the endpoint, namespace, database, and authentication details.
When you select an active connection in Surrealist, you will connect to the database and be able to interact with it using the available interface views.

After opening a connection, you can switch to another connection at any time by pressing the connection name in the top left of the interface. This will open the connection list allowing you to switch to another connection, or create a new one.

Within the connection list you will also find a special connection called <span style={{ color: 'var(--ifm-font-color-base)' }}>Sandbox</span>, which is always available and allows you to test and experiment without storing data persistently. This connection is useful for learning SurrealQL, testing queries, and more. As the Sandbox connection runs inside a single thread within the browser's WebAssembly engine, it should not be used to estimate or evaluate performance.

## Creating a connection

When creating a new connection you will be prompted with a dialog to enter your database details. These details are required to connect to your SurrealDB instance.

- **Protocol dropdown**: The protocol determines how Surrealist connects to the database. If you are unsure, select `HTTP`.
- **Endpoint**: The address of your database. This can be localhost, an ip address, or a domain name.
- **Authentication method**: The auth method determines how you want to authenticate with your database.

> [!IMPORTANT]
> In the new Surrealist redesign, the namespace and database fields are now configured per connection before you can [send queries to the database](/docs/surrealist/concepts/sending-queries).

Depending on the selected authentication method, you will be prompted to enter additional details such as a username and password, or a token.

<Image
  alt="Http connection"
  src={ImageHttpConnection}
/>

After filling in all fields, press **Create** to continue. If the connection was established successfully, you should see a green indicator next to the session name in the top left of the interface.

If the connection failed and you see a red indicator, make sure all your details are correct and update your connection accordingly. You can edit connection details again by expanding the connection list, and choosing **Edit** on your connection.

## Using the Sandbox

As mentioned earlier, the sandbox environment is a special connection that allows you to test and learn SurrealQL. When active, the toolbar will provide some additional buttons useful for working with the sandbox environment.

- **Reset sandbox**: This button will clear any records and schema you have configured in the sandbox. Use this button to start fresh or clear your sandbox environment.
- **Load demo dataset**: This button will load an official demo dataset into the sandbox environment. This dataset contains a set of records and relations that you can explore and query.

## Creating a SurrealDB Cloud Connection

A SurrealDB Cloud connection allows you to connect to a SurrealDB Instance. This connection type is useful for working with production databases, and for using SurrealDB's cloud-native features. To make a SurrealDB Cloud connection, you will need to create a SurrealDB Cloud account. Learn more about SurrealDB Cloud in the [SurrealDB Cloud documentation](/docs/cloud).

## Navigation

On the left side of the interface you will find the navigation sidebar. This sidebar allows you to switch between different views in Surrealist. Each view is focused on a specific workflow for working with the database.
If you are just getting started, we recommend one of the following:

* Choose the **Query** view if you want to start writing your SurrealQL queries and execute them.
* Choose the **Explorer** view if you want to explore existing records and the relations between them.

Additional views are available for managing your schema, writing stored procedures (functions), exploring API documentation, and more.

In addition to the different views, you can also find a button to open [Surrealist Search](/docs/surrealist/advanced-topics/search-and-shortcuts), and a button to open the [settings](/docs/surrealist/advanced-topics/settings-and-customisation). Within the settings
dialog you can also find an option to change the appearance of the navigation sidebar.

<div style={{ clear: 'both' }} />


## Video guide

After reading this guide, you can watch the following video which covers some features of Surrealist that can help you get started. This includes organising connections and connection groups, [recordID](/docs/surrealql/datamodel/ids) inspector, [editor shortcuts](/docs/surrealist/advanced-topics/search-and-shortcuts), surrealist search and useful settings.
<iframe
	width="100%"
	src="https://www.youtube.com/embed/q5LFNPpH2X0?si=_DSmWv9SB0R1yfko"
	title="Surrealist"
	frameborder="0"
	allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
	referrerpolicy="strict-origin-when-cross-origin"
	style={{ aspectRatio: 1.7 }}
	allowfullscreen
></iframe>



================================================
FILE: src/content/doc-surrealist/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Introduction
title: Surrealist | Introduction
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
no_page_headings: true
---

import { Icon } from 'astro-icon/components';
import Image from "@components/Image.astro";
import ImageLogo from "@img/icon/dark/surrealist.png";
import LightSurrealist from '@img/icon/light/surrealist-light.png';

<div class="flag-title">
	<Image
		class="size-11 my-auto"
		alt="Surrealist"
		width={300}
		src={{
			light: LightSurrealist,
			dark: ImageLogo,
		}}
	/>
	# Surrealist
</div>

Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more. Surrealist is available as a web and desktop app, and this guide will walk you through the setup process, interface navigation, and everything you need to know to get started.

Before we dive into the details, let's start by installing Surrealist. The next page will introduce you to the web app and guide you through the installation process for Surrealist Desktop.

<div class="flex gap-4 items-center mt-6 mb-16">
	<a
		href="/docs/surrealist/installation"
		class="gradient-button group"
	>
		Installation guide
		<Icon name="fa6-solid:arrow-right" class="w-4 transition-transform group-hover:translate-x-1" />
	</a>
	<a
		href="https://app.surrealdb.com"
		class="outline-button group"
	>
		Visit app.surrealdb.com
		<Icon name="fa6-solid:arrow-right" class="w-4 transition-transform group-hover:translate-x-1" />
	</a>
</div>

<iframe
	width="100%"
	src="https://www.youtube.com/embed/l0_lj-ILVhE?si=gNnTmumSuJLBjr2q"
	title="Surrealist"
	frameborder="0"
	allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
	referrerpolicy="strict-origin-when-cross-origin"
	style={{ aspectRatio: 1.7 }}
	allowfullscreen
	class="mt-8"
></iframe>

## Video guide

If you prefer a video guide, you can watch the following video which covers similar content to this documentation. This includes
installing Surrealist Desktop, getting started with the Sandbox, and exploring the many features Surrealist has to offer.

<iframe
	width="100%"
	src="https://www.youtube.com/embed/VQnHYKNiPso?si=wxkBYCpiIVqXQB1J"
	title="Surrealist"
	frameborder="0"
	allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
	referrerpolicy="strict-origin-when-cross-origin"
	style={{ aspectRatio: 1.7 }}
	allowfullscreen
></iframe>



================================================
FILE: src/content/doc-surrealist/installation.mdx
================================================
---
sidebar_position: 2
sidebar_label: Installation
title: Surrealist | Installation
description: Get started with Surrealist by installing the desktop or web app. The desktop app offers more features and flexibility, while the web app is more accessible and portable.
---

import { Icon } from 'astro-icon/components';

# Installation

There are two primary ways to use Surrealist: as a desktop app or as a web app. While the desktop app offers more features and flexibility, the web app is more accessible and portable.
This article will explain how to get up and running with both the desktop and web versions of Surrealist, and explains the key differences between the two.

## Web app

The fastest way to get started with Surrealist is using the web app available at [app.surrealdb.com](http://app.surrealdb.com/cloud). No additional installation is required, and you can start using Surrealist right away.

This web app contains most of the features available in the desktop app, but with a few limitations. For example, the web app may not be able to connect to insecure endpoints (non-HTTPS) due to browser restrictions.


> [!IMPORTANT]
> Due to security restrictions it will not always be possible to connect to databases hosted locally on localhost (or 127.0.0.1) using the web app in certain browsers.
> If you intend on doing so, we recommend using the desktop app instead as it does not have such restrictions.


## Desktop app

The Surrealist Desktop app is the recommended way to use Surrealist, as it offers more features and flexibility compared to the web app. Some advantages of the desktop app include the ability to connect to insecure endpoints,
directly opening `.surql` files from your file system, and more.

<a
	href="/surrealist?download"
	class="gradient-button group mt-2 mb-8"
>
	Install Surrealist Desktop
	<Icon name="fa6-solid:download" class="w-4 transition-transform group-hover:translate-x-1" />
</a>

### Windows

For Windows simply execute the downloaded installer and follow the instructions. Once installed, Surrealist will be ready to use.

### MacOS

For MacOS, download the .dmg file and drag the Surrealist icon to your Applications folder. The app will now be available in your Applications folder and can be opened from there.

### Linux

There are three ways to install Surrealist on Linux

- `deb` for Ubuntu and Debian-based systems
- `rpm` for Fedora and Red Hat-based systems
- `AppImage` for other Linux distributions

Follow the instructions of your respective package manager to install Surrealist on your system.
We currently do not plan on supporting other package formats, however the AppImage should work on most Linux distributions.



================================================
FILE: src/content/doc-surrealist/troubleshooting.mdx
================================================
---
sidebar_position: 8
sidebar_label: Troubleshooting
title: Surrealist | Troubleshooting 
description: This page contains information on troubleshooting and feedback for Surrealist.
---

# Troubleshooting

If you experience issues or unintended behaviour when using Surrealist, please [open an issue](https://github.com/surrealdb/surrealist/issues/new/choose) on our GitHub repository.
Additionally check the [FAQ](/docs/surrealist/faqs/info) and [known issues](/docs/surrealist/faqs/known-issues) first as they too might solve your issue.
If you are still running into issues you can attempt one of the following:

### Opening the developer console

The developer console may include hints to the cause of your problem. Include any errors you find inside with reported GitHub issues as it may significantly help the maintainers understand your problem.

You can open the developer tools panel using the following key combination

- **Windows / Linux:** `Ctrl + Shift + i`
- **MacOS:** `Command + Option + i`

Once the developer tools are open, navigate to the console tab to view any errors or warnings. These may help you diagnose any issues.

### Backing up / resetting the configuration file

Removing your configuration file may solve issues, however you will lose configured connections and other settings. It is recommended to backup the config file before deleting it.

The config file can be found at the following location

- **Linux:** `$HOME/.config/SurrealDB/Surrealist/config.json`
- **MacOS:** `$HOME/Library/Application Support/SurrealDB/Surrealist/config.json`
- **Windows:** `%AppData%\SurrealDB\Surrealist\config.json`

> [!NOTE]
> Avoid sharing your config or uploading it to public locations as it contains the authentication details to your configured connections.

### Viewing the logs

Surrealist outputs logfiles that may contain hints to the cause of the issue. You can find the logs at the following locations:

- **Linux:** `$HOME/.config/SurrealDB/Surrealist/logs`
- **MacOS:** `$HOME/Library/Application Support/SurrealDB/Surrealist/logs`
- **Windows:** `%AppData%\SurrealDB\Surrealist\logs`

> [!NOTE]
> Logfiles should not contain any sensitive information, however please review them carefully before sharing them with others.

## Connection issues

Since Surrealist operates over a network connection it is possible to run into unexpected issues while attempting to connect to, or query, a database. While there are many reasons why a connection might fail, here are some common issues and their solutions:

### Unsupported protocols

Some protocols might not always be supported by the network configuration. For example, some networks might block the WebSocket protocol. In this case, you can switch to the HTTP or HTTPS protocol to bypass the restriction.

### SSL

You might be connecting to an endpoint using the HTTPS or WSS protocol without a valid SSL certificate present on the server. In this case, you can switch to the HTTP or WS protocol to bypass the SSL verification.
It is recommended to perform HTTP or WS connections through the desktop app, as web browsers might block these connections due to security reasons.

### Firewall issues

Firewalls might block Surrealist from connecting to the internet. Make sure that Surrealist is allowed to connect to the internet by checking your firewall settings.

### Browser restrictions

Using the Web App you might find yourself restricted by browsers or browser extensions. Make sure to disable any browser extensions that might interfere with Surrealist, or switch to the desktop app.

### Troubleshooting connection issues

Connection issues can be notirously difficult to troubleshoot. Here are some steps you can take to diagnose the issue:

- **Connect using the CLI**: Since Surrealist always runs in a secure environment, localhost or LAN connections may be blocked by a viarety of reasons. Try connecting to the database using the [CLI](/docs/surrealdb/cli) to see if the issue persists, as this is not subject to the same restrictions.
- **Check the logs**: The Surrealist logfiles may contain hints to the cause of the issue. Check the logs for any errors or warnings that might help you diagnose the issue.
- **Check the developer console**: You can open the developer console to reveal hidden errors or warnings that might help you diagnose the issue.
- **Check the network tab**: The network tab in the developer console may contain information on the network requests that Surrealist is making. Check for any failed requests or errors that might help you diagnose the issue.

## Submitting feedback

You are always welcome to share feedback and ask questions about Surrealist in the #surrealist channel in our [Discord](https://discord.gg/surrealdb) server.

If you have found a bug or would like to request a feature, please open an issue on our [GitHub repository](https://github.com/surrealdb/surrealist).

If you have any other questions or feedback, feel free to leave some feedback using the feedback button on the righhand side of the screen.



================================================
FILE: src/content/doc-surrealist/advanced-topics/connection-templates.mdx
================================================
---
sidebar_position: 3
sidebar_label: Connection Templates
title: Surrealist | Connection Templates
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
---

import Image from "@components/Image.astro";
import ImageTemplates from "@img/image/surrealist/templates.png";

# Connection Templates

When you find yourself frequently connecting to databases that share similar connection details, it might make sense to create a template.
Templates allow you to save partial connection details and reuse them when creating new connections.

## Creating a new template

Templates can be managed from the settings dialog under the "Templates" section. To create a new template, click the "New template" button and fill in the connection details you want to save.
All fields within a template are optional, so you can save as much or as little information as you like.

<Image
  alt="Surrealist Templates"
  src={ImageTemplates}
/>



================================================
FILE: src/content/doc-surrealist/advanced-topics/embedding-surrealist.mdx
================================================
---
sidebar_position: 2
sidebar_label: Embedding Surrealist
title: Surrealist | Embedding Surrealist
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
---

import Image from "@components/Image.astro";
import ImageEmbed from "@img/image/surrealist/embed.png";

# Embedding Surrealist

Surrealist can be added to any website or application using Embeds. This lets you run your queries and results on any website or application. Another use case for embeds is making it easy to share your queries and results with others and debug in the same environments.

<Image
  alt="Surrealist Embed"
  src={ImageEmbed}
/>

## Creating a new Embed

To create an embed, head over to the surrealist overview page and click on the embed surrealist option. Then, in the `Editor query` section, you can write the query you want to be embedded. If the query uses variables, you can enter the values for the variables in the `Editor variables` section, and they will appear in the Embed preview section on the right.

### Setup query

In the `Setup query` section you can enter the queries that you want to run before the main query. This can be used to set up the environment for the main query.

For example, if you want to create a user table with some fields to populate before running the main query to add a record, you can enter the create table query in the `Setup query` section.

```surql
-- Create a schemafull user table.
DEFINE TABLE user SCHEMAFULL;
-- Define some fields.
DEFINE FIELD firstName ON TABLE user TYPE string;
DEFINE FIELD lastName ON TABLE user TYPE string;
DEFINE FIELD email ON TABLE user TYPE string;
  ASSERT string::is_email($value);
```
Then, you can write the main query in the `Editor query` section.

```surql
-- 1: Add a user with all required fields.
CREATE user CONTENT {
    firstName: 'John',
    lastName: 'Doe',
    email: 'JohnDoe@someemail.com',
};
```

Once you have entered your query, the results will appear in the `Embed preview` section on the right. You can copy the URL or embed the generated iframe in the `Embed snippet` section.


> [!NOTE]
> If your query uses variables, you can also enter the values for the variables in the `EditorVariables` section, and they will show up in the Embed preview section on the right.


### Loading dataset in Embeds

Surrealist comes with a few datasets that you can load in the embeds. To select a dataset, click the `Dataset` dropdown and select the dataset you want to load.

For example, to load the [surreal deal dataset](/docs/surrealql/demo#surreal-deal---deals-so-good-its-surreal) in the embeds by selecting the dropdown in the `Dataset` section and selecting the `surreal deal` dataset. This allows you to query the tables within a dataset and embed the results in your website or application.

### Orientation in Embeds

You can also select the orientation of the embeds by selecting the `Orientation` dropdown. You can choose between `Vertical` and `Horizontal` orientation. This allows you to embed the query in the orientation that fits your website or application.

## Restore query in Embeds

If you have an embed link, you can restore the query by clicking the `Restore from URL` button at the bottom and entering the embed link. This will restore the query and variables if any and you can then run the query. You can also share this link with others to share the query and results.

## Embed messaging protocol

Surrealist embeds can be controlled externally using the iframe messaging protocol. This allows you to manipulate an embed located within your website or application.
Here is an example which sets the query displayed in the embed:

```js
const embed = document.getElementById("#embed");

embed.postMessage({
	action: "set_query",
	options: {
		query: "SELECT * FROM example;"
	}
}, "https://app.surrealdb.com");
```

### Messages


<br/>

<br/>

<table>
    <thead>
        <tr>
            <th scope="col">Action</th>
            <th scope="col">Description</th>
            <th scope="col">Options</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Type">
                <code>set_editor</code>
            </td>
            <td scope="row" data-label="Description">
                Overwrite the query in the editor.
            </td>
			<td scope="row" data-label="Description">
                - **query** (optional): The query string to set in the editor.
                - **variables** (optional): The variables structure to set in the editor.
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Type">
                <code>clear_response</code>
            </td>
            <td scope="row" data-label="Description">
                Removes any responses currently present in the embed.
            </td>
			<td scope="row" data-label="Description"></td>
        </tr>
		<tr>
            <td scope="row" data-label="Type">
                <code>set_editor_mode</code>
            </td>
            <td scope="row" data-label="Description">
                Change which panel is currently displayed in the editor.
            </td>
			<td scope="row" data-label="Description">
				- **mode**: Can either be "query" or "variables".
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Type">
                <code>set_result_mode</code>
            </td>
            <td scope="row" data-label="Description">
                Change which visualization is used for rendering results.
            </td>
			<td scope="row" data-label="Description">
				- **mode**: Can be "combined", "single", "table", or "live".
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Type">
                <code>run_query</code>
            </td>
            <td scope="row" data-label="Description">
                Executes the query currently present within the embed
            </td>
			<td scope="row" data-label="Description"></td>
        </tr>
		<tr>
            <td scope="row" data-label="Type">
                <code>execute_query</code>
            </td>
            <td scope="row" data-label="Description">
                Executes the specified query in the background without displaying the results.
            </td>
			<td scope="row" data-label="Description">
				- **query**: The query to execute
            </td>
        </tr>
	</tbody>
</table>

## Video guide

If you prefer a video guide, you can watch the following video which covers similar content to this documentation.

<iframe
	width="100%"
	src="https://www.youtube.com/embed/AzQBvyg9Awc?si=JuiRap8L_2x43rja"
	title="Embed Surrealist in your projects"
	frameborder="0"
	allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
	referrerpolicy="strict-origin-when-cross-origin"
	style={{ aspectRatio: 1.7 }}
	allowfullscreen
></iframe>



================================================
FILE: src/content/doc-surrealist/advanced-topics/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Advanced topics
title: Surrealist | Advanced topics
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
no_page_headings: true
---

# Advanced topics

In this section, we will go over additional features that surrealist offers to enhance your workflow.

- [Search and shortcuts](/docs/surrealist/advanced-topics/search-and-shortcuts)
- [Embedding Surrealist](/docs/surrealist/advanced-topics/embedding-surrealist)
- [Connection Templates](/docs/surrealist/advanced-topics/connection-templates)
- [Settings and customisation](/docs/surrealist/advanced-topics/settings-and-customisation)
- [SurrealQL Editors](/docs/surrealist/advanced-topics/surrealql-editors)
- [URL Intents](/docs/surrealist/advanced-topics/intents)






================================================
FILE: src/content/doc-surrealist/advanced-topics/intents.mdx
================================================
---
sidebar_position: 7
sidebar_label: URL Intents
title: Surrealist | URL Intents
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
---

# URL Intents

Surrealist provides a low level system for triggering actions within the interface through a URL. For example, you can use it to open specific dialogs, switch views, or even run queries.
The intent system is used under the hood to power the command palette so most commands found there can be triggered via intents.

## Usage

Intents can be configured using the `intent` query argument. A simple example of an intent to open the connections dialog would look like this:

```
https://app.surrealdb.com/?intent=open-connections
```

A more advanced example of an intent can contain additional arguments. These are key-value pairs separated by `=` and are appended after the intent name suffixed by a colon `:`.
This is an example of an intent to open the settings page and switch to the appearance tab:

```
https://app.surrealdb.com/?intent=open-settings:tab=appearance
```

You can also trigger intents for the Desktop App by using the surrealist URI protocol. This will open a new Surrealist window
if one is not already open. Here is an example of an intent to toggle database serving:

```
surrealist://?intent=toggle-serving
```

Additionally, certain intents are bound to a specific view. In this case Surrealist will automatically switch to the correct view when the intent is triggered.

## List of intents

<br/>

<br/>

<table>
    <thead>
        <tr>
            <th scope="col">Name</th>
            <th scope="col">View</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Type">
                <code>open-command-palette</code>
            </td>
			<td scope="row" data-label="View">
                &hyphen;
            </td>
            <td scope="row" data-label="Description">
                Open the command palette dialog.
            </td>
        </tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>open-connections</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Open the connection list dialog.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>open-help</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Open the help & support dialog.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>open-news</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Opens the news drawer.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>open-changelog</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Opens the changelog dialog.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>open-settings</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Opens the settings dialog. You can specify a tab to open using the `tab` argument.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>open-embedder</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Opens the embedder dialog.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>open-desktop-download</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Opens the Surrealist Desktop download dialog. Only applicable to the web app.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>open-keymap</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Opens the keymap dialog.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>new-connection</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Opens the connection creator.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>new-table</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Opens the table creator.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>toggle-serving</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Toggles database serving. Only applicable to the desktop app.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>open-serving-console</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Reveals the database serving console drawer. Only applicable to the desktop app.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>increase-window-scale</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Increases the window zoom level. Only applicable to the desktop app.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>decrease-window-scale</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Decreases the window zoom level. Only applicable to the desktop app.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>increase-editor-scale</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Increases the font size of text editors.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>decrease-editor-scale</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Decreases the font size of text editors.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>toggle-pinned</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Toggle whether the window is always on top. Only applicable to the desktop app.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>highlight-tool</code>
			</td>
			<td scope="row" data-label="View">
				&hyphen;
			</td>
			<td scope="row" data-label="Description">
				Opens a developer tool used to generate clipboard compatible SurrealQL highlighting
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>new-query</code>
			</td>
			<td scope="row" data-label="View">
				Query
			</td>
			<td scope="row" data-label="Description">
				Creates a new query tab.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>run-query</code>
			</td>
			<td scope="row" data-label="View">
				Query
			</td>
			<td scope="row" data-label="Description">
				Executes the current query
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>save-query</code>
			</td>
			<td scope="row" data-label="View">
				Query
			</td>
			<td scope="row" data-label="Description">
				Open the query save dialog for the active query
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>format-query</code>
			</td>
			<td scope="row" data-label="View">
				Query
			</td>
			<td scope="row" data-label="Description">
				Formats the current query
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>toggle-variables</code>
			</td>
			<td scope="row" data-label="View">
				Query
			</td>
			<td scope="row" data-label="Description">
				Toggles the visibility of the variables panel
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>infer-variables</code>
			</td>
			<td scope="row" data-label="View">
				Query
			</td>
			<td scope="row" data-label="Description">
				Infer variables from the currently active query
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>open-saved-queries</code>
			</td>
			<td scope="row" data-label="View">
				Query
			</td>
			<td scope="row" data-label="Description">
				Opens the saved queries drawer
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>open-query-history</code>
			</td>
			<td scope="row" data-label="View">
				Query
			</td>
			<td scope="row" data-label="Description">
				Opens the query history drawer
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>explore-table</code>
			</td>
			<td scope="row" data-label="View">
				Explorer
			</td>
			<td scope="row" data-label="Description">
				Opens a table in the Explorer view. Requires a `table` argument with the table name.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>import-database</code>
			</td>
			<td scope="row" data-label="View">
				Explorer
			</td>
			<td scope="row" data-label="Description">
				Opens the data importing dialog.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>export-database</code>
			</td>
			<td scope="row" data-label="View">
				Explorer
			</td>
			<td scope="row" data-label="Description">
				Opens the data exporting dialog.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>design-table</code>
			</td>
			<td scope="row" data-label="View">
				Designer
			</td>
			<td scope="row" data-label="Description">
				Opens a table in the Designer view. Requires a `table` argument with the table name.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>create-user</code>
			</td>
			<td scope="row" data-label="View">
				Authentication
			</td>
			<td scope="row" data-label="Description">
				Opens the user creation dialog. Requires a `level` argument set to either ROOT, NAMESPACE, or DATABASE.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>create-scope</code>
			</td>
			<td scope="row" data-label="View">
				Authentication
			</td>
			<td scope="row" data-label="Description">
				Opens the scope creation dialog.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>register-user</code>
			</td>
			<td scope="row" data-label="View">
				Authentication
			</td>
			<td scope="row" data-label="Description">
				Opens the scope user registration dialog. Requires a `scope` argument with the scope name.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				<code>docs-switch-language</code>
			</td>
			<td scope="row" data-label="View">
				API Docs
			</td>
			<td scope="row" data-label="Description">
				Changes the language used for the code snippets. Requires a `lang` argument with a valid language code.
			</td>
		</tr>
	</tbody>
</table>



================================================
FILE: src/content/doc-surrealist/advanced-topics/search-and-shortcuts.mdx
================================================
---
sidebar_position: 1
sidebar_label: Search and Shortcuts
title: Surrealist | Search and Shortcuts
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
---

import Image from "@components/Image.astro";
import ImageHotkey from "@img/image/surrealist/search-and-hot-key.png";

# Search and shortcuts

Surrealist offers a range of shortcuts to help you navigate the interface more efficiently. You can find a list of all available shortcuts by pressing `Ctrl + K` or `Cmd + K` on your keyboard.

In the search modal, you can access all available shortcuts for open sessions, the views, all available tables in your connect database and the settings dialog.

<Image
    alt="Search and shortcuts"
    src={ImageHotkey}
/>

<br/>

<br/>

<table>
    <thead>
        <tr>
            <th scope="col">Options</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Type">
                <code>Connections</code>
            </td>
            <td scope="row" data-label="Description">
                Open a list of all available connections and create a new connection type.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Views</code>
            </td>
            <td scope="row" data-label="Description">
                Open all available views in the current session. This can be the Query view, Designer view or the authentication view.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Tables</code>
            </td>
            <td scope="row" data-label="Description">
                Shows all available tables in the connected database. If you have no tables in the connection load the surreal deal dataset, you can see the tables in the dataset.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Query</code>
            </td>
            <td scope="row" data-label="Description">
                See all saved queries, view the query history and create a new query. Comment out a line in the query editor using `Cmd + /` or `Ctrl + /`.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Explorer</code>
            </td>
            <td scope="row" data-label="Description">
                Import and export your database schema in a `.surql` file format.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Authentication</code>
            </td>
            <td scope="row" data-label="Description">
                Create user permissions and roles for your connected database.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>API Docs</code>
            </td>
            <td scope="row" data-label="Description">
                Access the SurrealDB API documentation and access snippets for your queries in different SDK languages.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Settings</code>
            </td>
            <td scope="row" data-label="Description">
                Access the settings dialog to customise the appearance and behaviour of Surrealist.
                Increase the view size of your editor with `cmd + Option + +` or reduce with `cmd + Option + -`.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Navigator</code>
            </td>
            <td scope="row" data-label="Description">
                Reload the navigator to see all available shortcuts and open the search modal.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>Developer</code>
            </td>
            <td scope="row" data-label="Description">
                Open a new connection and reset tour settings.
            </td>
        </tr>
    </tbody>
</table>



================================================
FILE: src/content/doc-surrealist/advanced-topics/settings-and-customisation.mdx
================================================
---
sidebar_position: 4
sidebar_label: Settings and Customisation
title: Surrealist | Settings and Customisation
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
---


#  Settings and customisation

In the bottom left of the interface you can find a settings button (⚙) to open the settings dialog. These settings allow you to further customise the behaviour and appearance of Surrealist, such as switching between light and dark mode, increasing or decreasing the editor font sizes, and configure default values for new connections.

## Behaviour

In this section you can configure the behaviour of the interface, such as connection and editor related settings.

## Appearance

The appearance section allows you to scale the fonts in the editor and also select your default query output view and set the behaviour for your Query and designer views.

## Templates

You can configure [connection templates](/docs/surrealist/advanced-topics/connection-templates) to reuse connection details when creating new connections. This is especially useful when you find yourself connecting to similar databases frequently.

## Database Serving

This section allows you to alter the behaviour of the database serving functionality found in Surrealist Desktop, such as altering the port and specifying the path to the database executable.

## Feature flags

Feature flags allow you to enable or disable stable and experimental features in Surrealist to suit your needs best.

Some of these features need to be stable and may not work as expected or be removed in future versions. To access the feature flags, press `Ctrl + K` or `Cmd + K` on your keyboard to open the command palette, then type in "Manage Feature Flags" and hit enter. You'll be taken to the feature flags settings.

After enabling a feature flag, you can access it by clicking on the settings button in the bottom left of the interface and selecting the feature flags tab. Here, you can enable or disable features. Here is a list of the current feature flags:

<table>
    <thead>
        <tr>
            <th scope="col">Options</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Type">
                <code>feature_flags</code>
            </td>
            <td scope="row" data-label="Description">
                Toggle feature flags.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>models_view</code>
            </td>
            <td scope="row" data-label="Description">
                Toggle the view for SurrealML models.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>apidocs_view</code>
            </td>
            <td scope="row" data-label="Description">
                Toggle the view for API documentation.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>themes</code>
            </td>
            <td scope="row" data-label="Description">
                Toggle between light and dark mode.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>newsfeed</code>
            </td>
            <td scope="row" data-label="Description">
                Toggle the newsfeed view.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>database_version_check</code>
            </td>
            <td scope="row" data-label="Description">
                Toggle the database version check in the Surrealist CLI
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>highlight_tool</code>
            </td>
            <td scope="row" data-label="Description">
                Toggle the highlight tool.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>surreal_compat</code>
            </td>
            <td scope="row" data-label="Description">
                Toggle SurrealDB version between `1.x` and `2.x`.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>changelog</code>
            </td>
            <td scope="row" data-label="Description">
                Toggle the changelog view to see the latest changes, read all or unread all.
            </td>
        </tr>
    </tbody>
</table>



================================================
FILE: src/content/doc-surrealist/advanced-topics/surrealql-editors.mdx
================================================
---
sidebar_position: 6
sidebar_label: SurrealQL Editors
title: Surrealist | SurrealQL Editors
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
---

# SurrealQL Editors

Throughout Surrealist you will encounter various SurrealQL editors. These editors support intelligent SurrealQL highlighting and provide a range of features to help you write queries and edit records.

## Shortcuts

Editors support an array of useful shortcuts to help you navigate and edit more efficiently.

<table>
    <thead>
        <tr>
            <th scope="col">Shortcuts</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Shortcuts">
                <code>tab</code>
            </td>
            <td scope="row" data-label="Description">
                Indent the current line by 4 spaces.
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Shortcuts">
                <code>shift + tab</code>
            </td>
            <td scope="row" data-label="Description">
                Unindent the current line by 4 spaces.
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Shortcuts">
                <code>ctrl/cmd + f</code>
            </td>
            <td scope="row" data-label="Description">
                Open the search and replace panel
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Shortcuts">
                <code>ctrl/cmd + /</code>
            </td>
            <td scope="row" data-label="Description">
                Toggles comments on the selected or active line(s)
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Shortcuts">
                <code>ctrl/cmd + left click</code>
            </td>
            <td scope="row" data-label="Description">
                Place multiple cursors at the clicked locations
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Shortcuts">
                <code>ctrl/cmd + shift + L</code>
            </td>
            <td scope="row" data-label="Description">
                Selects all occurrences of the currently selected text
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Shortcuts">
                <code>ctrl/cmd + d</code>
            </td>
            <td scope="row" data-label="Description">
                Selects next occurrence of the currently selected text
            </td>
        </tr>
		<tr>
            <td scope="row" data-label="Shortcuts">
                <code>ctrl/cmd + enter</code>
            </td>
            <td scope="row" data-label="Description">
                Execute the query query (only applied to the query editor)
            </td>
        </tr>
	</tbody>
</table>

## Record inspection

Some editors support record inspection, which allows you to open a record in the Record Inspector drawer by holding `ctrl/cmd` and left-clicking on a record id.

## JSON

Some editors, such as the record editor and query responses, support falling back to a JSON representation.
This can be configured in the settings dialog under `Appearance > Value formatting mode`.



================================================
FILE: src/content/doc-surrealist/concepts/designing-the-database-schema.mdx
================================================
---
sidebar_position: 4
sidebar_label: Designing the database schema
title: Surrealist | Designing the database schema
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
---
import Image from "@components/Image.astro";
import ImageDesigner from "@img/image/surrealist/designer.png";

# Designing the database schema

The Designer view allows you to graphically visualise, design, and modify your database schema in real time. This view can speed up the creation of tables, indexes, fields, and more. Additionally it will plot your current schema into a diagram representation to  view the structure of your database and relationships between its tables.


<Image
  alt="Surrealist designer view"
  src={ImageDesigner}
/>

### Table graph panel

The table graph renders an interactive diagram representation of your schema. You can use your mouse to move and zoom around the canvas and press any table to modify it. Surrealist will make a best effort to correctly and clearly visualise your tables automatically.

When rendering the diagram, Surrealist will attempt to detect whether a table is a regular table or an edge table. It does so by checking for the presence of an `in` and `out` field. Surrealist expects these two fields to be configured as `record` types and correctly define the table(s) they point to. This works for both schemafull and schemaless tables.

On the top right of this panel you will find a + button which allows you to easily create new tables and edge tables, similar to the one found in the Explorer view.

The Settings icon ⚙  provides the option to alter the appearance of tables in the diagram. This can either be set to `fields`  when you want to display all defined fields, `summary` for showing condensed stats for each table, or `simple` when you only want to display only the name of each table.

### Table designer panel

Clicking any table in the table graph will open the table designer panel. This is where you can visually update the structure of a table, including permissions, fields, indexes, events, and more.

In addition, you can press the delete button in the top right to remove a table from your database.

### Accessing underlying schema information

The Designer view is built on top of the powerful [INFO FOR DB](/docs/surrealql/statements/info#database-information) and [INFO FOR TABLE](/docs/surrealql/statements/info#table-information) statements, which you can utilize yourself to programatically extract schema information from the database.



================================================
FILE: src/content/doc-surrealist/concepts/explore-database-records.mdx
================================================
---
sidebar_position: 3
sidebar_label: Exploring database records
title: Surrealist | Exploring database records
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
---

import Image from "@components/Image.astro";
import ImageExplorer from "@img/image/surrealist/explorer.png";
import ImageImport from "@img/image/surrealist/import.png";

# Exploring database records

The second view you can find in Surrealist is the Explorer view, which lists out tables and allows you to browse through all records. This view is especially useful when you want to effortlessly explore your data, compare records, or edit their contents.


<Image
  alt="Surrealist explorer view"
  src={ImageExplorer}
/>

### Tables panel

As the name implies, the tables panel will list out all tables in the database. The icon to the left indicates if a table is a normal table or an edge table. The + button in the top right of this panel allows you to quickly define new tables without switching to the Designer view.


> [!NOTE]
> In the [Designer view](/docs/surrealist/concepts/designing-the-database-schema) section we will explain more in-depth about what constitutes tables as normal or edge tables.

### Record explorer panel

After selecting a table in the tables panel, the records in this table are listed out here, grouped into navigable pages. You can press any record to open it in the inspector panel where you can view and edit record contents and view its relationships.

Pressing the ▼ button in the top right of this panel expands an input in which you can enter a [WHERE](/docs/surrealql/statements/select#filter-queries-using-the-where-clause) clause to filter down the displayed records on certain conditions.

Additionally, the + button can be used to manually create new records in the current table.

### Inspector panel

The inspector panel, although available globally, is mostly used in the Explorer view to view and edit the contents of a record. You can also use the inspector to view and follow the relationships of a record, as well as delete records.

## Import Files

Surrealist allows you to import files into your database in the Explorer view. This can be useful for importing data from other sources, or for importing data from one database to another.

### Importing a CSV file

To import CSV data into SurrealDB using Surrealist, navigate to the `Import database` button at the bottom of the Explorer view. This will open your default file explorer, where you can select the CSV file you want to import.

Once you have selected the file, you will be prompted to enter a table name. This is the name of the table that will be created in your database.

Surrealist will automatically convert the rows from your CSV file into records in the new table. The importer also handles SurrealQL compatible data like objects, arrays, and dates. 

<Image
  alt="Surrealist import view"
  src={ImageImport}
/>

Here's a more detailed breakdown: 
1. Locate the Importer: Open Surrealist and navigate to the Explorer view, then find the "Import database" option.
2. Select CSV File: Browse and select the CSV file you want to import.
3. Specify Table Name: Enter the name you want to give the new table that will be created from the CSV data.
4. Automatic Conversion: Surrealist will automatically convert the rows from your CSV file into records in the new table.
    - If your table includes relationships, Surrealist will automatically create the necessary edges if you toggle the insert as a relationship option. 
5. SurrealQL Compatibility: The importer is also designed to handle data types that are compatible with SurrealQL, such as objects, arrays, and dates.
6. Additional Features: Surrealist also supports exporting data in SurrealQL format and importing SurrealQL files, as well as models from various machine learning libraries.


================================================
FILE: src/content/doc-surrealist/concepts/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Concepts
title: Surrealist | Concepts
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
no_page_headings: true
---

# Concepts

In this section, we will go over the different views and features available in Surrealist. You will learn how to connect to your database, how to execute queries, how to explore your data, and how to design your schema.

- [Sending queries to the database](/docs/surrealist/concepts/sending-queries)
- [Exploring database records](/docs/surrealist/concepts/explore-database-records)
- [Designing your schema](/docs/surrealist/concepts/designing-the-database-schema)
- [Manage database access](/docs/surrealist/concepts/manage-database-access)
- [Sending queries with GraphQL](/docs/surrealist/concepts/sending-queries-with-graphql)
- [Local database serving](/docs/surrealist/concepts/local-database-serving)
- [Writing stored procedures](/docs/surrealist/concepts/writing-stored-procedures)
- [Specialized API Docs](/docs/surrealist/concepts/specialized-api-docs)





================================================
FILE: src/content/doc-surrealist/concepts/local-database-serving.mdx
================================================
---
sidebar_position: 6
sidebar_label: Local database serving
title: Surrealist | Local database serving
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
---

import Image from "@components/Image.astro";
import ImageConsole from "@img/image/surrealist/console.png";

# Local database serving

Surrealist allows you to easily and effortlessly launch a localhost instance of SurrealDB directly from the interface. For this you will first need to install SurrealDB for your platform. After this you can press the play button in the top right of the interface to start SurrealDB.


> [!NOTE]
> Local database serving is only available in the Surrealist Desktop app.

### Configuration

Surrealist will automatically detect the location of the SurrealDB executable if it is in your environment PATH. If it is not, you can manually enter the path to the executable in the Surrealist settings dialog.
This setting, along with other local database serving settings, can be found in the settings dialog accessible from the top right of the interface.

### Console drawer

After launching the local database, you can press the console button to reveal the output of the SurrealDB instance.

<Image
  alt="Console drawer"
  src={ImageConsole}
/>



================================================
FILE: src/content/doc-surrealist/concepts/manage-database-access.mdx
================================================
---
sidebar_position: 5
sidebar_label: Manage database access
title: Surrealist | Manage database access
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
---
import Image from "@components/Image.astro";
import ImageAuthentication from "@img/image/surrealist/authentication.png";

# Manage database access

The Authentication view allows you to control account access to the database. This includes system users (root, namespace, and database) as well as scope access.

<Image
  alt="surrealist Authentication View"
  src={ImageAuthentication}
/>


## System users

The first three panels are used to configure root, namespace, and database access to the database, also known as [system users](/docs/surrealdb/security/authentication#system-users). These panels list out users, which you can modify using the pencil button.

Additionally you can press the + buttons to add new users to the database.

## Database scopes

The last panel lists out configured [authentication scopes](/docs/surrealql/statements/define/access/record) which, much like the other panels, allows for the creating and updating of scopes. Visit the documentation on scope authentication to learn more about what to enter into the sign up and sign in query fields.



================================================
FILE: src/content/doc-surrealist/concepts/sending-queries-with-graphql.mdx
================================================
---
sidebar_position: 5
sidebar_label: Sending queries with GraphQL
title: Surrealist | Sending queries with GraphQL
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";
import Image from "@components/Image.astro";
import ImageQuering from "@img/image/surrealist/graphql-querying-fields.png";

# Sending queries with GraphQL (experimental)

The GraphQL view in Surrealist allows you to write, execute, and visualize GraphQL queries in real-time. You can see the results of your queries in JSON structure returned by GraphQL.

> [!IMPORTANT]
> GraphQL is an experimental feature. We cannot guarantee that it will provide the same security guarantees as SurrealQL. It is not recommended for production use. We welcome your feedback and contributions to help improve the feature and make it more robust.


<Image
  alt="Surrealist GraphQL query"
  src={ImageQuering}
/>


## Refetch schema

In the GraphQL view, you can refetch the schema by clicking the refresh button in the top right corner. This will refetch the schema from the database and update the GraphQL view.


## Formatting query

Additionally, you can format your query by clicking the format button in the top right corner. This will format your query to the GraphQL syntax.


## Variable view

When working with variables, you can view them by clicking the variables button in the top right corner. This will show you the variables that you can use in your query.

You can also infer the variables from the query by clicking the infer variables button in the top right corner. This will infer the variables from the query and show you the variables that you can use in your query.


## Learn more

To learn more about using the GraphQL view, check the [Querying via GraphQL](/docs/surrealdb/querying/graphql/surrealist) documentation.



================================================
FILE: src/content/doc-surrealist/concepts/sending-queries.mdx
================================================
---
sidebar_position: 2
sidebar_label: Sending queries to the database
title: Surrealist | Sending queries to the database
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
---

import Image from "@components/Image.astro";
import ImageQuery from "@img/image/surrealist/query-new.png";

# Sending queries to the database

The first view you encounter when starting Surrealist is the Query view. At its core the Query view allows you to execute SurrealQL queries and view their responses, however additional features include configuring variables to use within your queries, saving queries for later use, and viewing incoming live select messages.

<Image
  alt="Surrealist query view"
  src={ImageQuery}
/>

> [!NOTE]
> The example above shows writing a query to a sandbox connection where no credentials are required. When connecting to a SurrealDB Cloud instance or a local connection, you will need to enter your namespace and database credentials in the connection dialog before you can send queries.

## Queries panel

The panel on the left of the Query view lists out your active query tabs. Each tab has its own query editor, so you can work with multiple queries at once and keep your workspace organised. You can double-click a tab to rename it, and right-click a tab to reveal additional actions.

Additionally, near the bottom of the queries panel, you can find buttons to open the query history and view your saved queries.

## Query history

The query history drawer will show a list of recently executed queries for the current connection. Right click any query and choose “Open in new tab” or “Open in current tab” to bring it back into your query editor.

## Saved Queries

The saved queries drawer lists out any queries you have saved, which you can do by pressing the saved query button underneath the query editor. This is useful for queries you intend on executing frequently or would like to use in multiple connections.

### Saving a new query

To save a query, press the save query button at the top right the query editor. You will be prompted to enter a name for the query, after which it will be saved and listed in the saved queries panel.

## Variables panel

You can reveal the variables panel by pressing “Show variables”. Any variables you define in here are made available to your query. Use the convenient “Infer from query” button to analyse your query for variables and automatically define them.

### Results panel

After executing a query the result of the query will be displayed in the results panel underneath the query editor. This panel lets you visualise the response in multiple ways, so pick the most convenient one for your use case.

- **Combined mode**: will list all query responses in a single list. This is especially useful for requests with only a handful of statements or when you would like to view all responses at a glance.

- **Individual mode**: will display each response separately and provide navigation buttons to switch between them. This is mostly useful when you are sending many queries at once or would like to focus on each response individually.

- **Graph mode**: will display the response as a graph if they are compatible with the response i.e is a list of records with relations. This is useful for visualising the relationships between records.

- **Table mode**: presents your responses in an interactive table similar to the Explorer view. You can press any record id to view and edit the record in the inspector panel.

- **Live mode**: will display incoming messages received by any [LIVE SELECT](/docs/surrealql/statements/live) queries sent in your request. You can also terminate active live queries here as well.



================================================
FILE: src/content/doc-surrealist/concepts/specialized-api-docs.mdx
================================================
---
sidebar_position: 8
sidebar_label: Specialized API docs
title: Surrealist | Specialized API docs
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
---

import Image from "@components/Image.astro";
import ImageApidocs from "@img/image/surrealist/api-docs.png";

# Specialized API docs

SurrealDB supports a wide array of programming languages to integrate with. The Surrealist API Docs view provides you with a detailed and specialized documentation to integrate with your database using your preferred programming language.
The API Docs contains topics such as authentication, schema management, and query execution, all brought in context using your database schema.

<Image
  alt="Surrealist API Docs view"
  src={ImageApidocs}
/>

## Topics panel

The topics panel acts as the Table of Contents for the API Docs. It lists out all the available topics in the API Docs categorized under different sections. You can press any topic to reveal it in the documentation panel where you can view the topic's contents.

Depending on the selected SDK, the topics panel will show different sections and topics. For example, functionality unsupported by the selected SDK will not be shown in the topics panel.

You will also notice certain topics are related to the schema of the active database. These topics will provide ready to use code snippets using elements from the schema, such as table names or defined fields.

## Selecting a preview language

At the top of the documentation panel, you can select a programming language to preview the code snippets in. This will change the code snippets in the documentation panel to the selected language.

Additionally, a CLI option is provided to show snippets in the form of command line commands and raw SurrealQL.



================================================
FILE: src/content/doc-surrealist/concepts/surreal-cloud.mdx
================================================
---
sidebar_position: 9
sidebar_label: Deploying your database
title: Surrealist | SurrealDB Cloud | Deploying your database
description:  SurrealDB Cloud redefines the database experience, offering the power and flexibility of SurrealDB without the pain of managing infrastructure. Elevate your business to unparalleled levels of scale and resilience. Focus on building tomorrow's applications. Let us take care of the rest.
no_page_headings: true
---

import Image from "@components/Image.astro";

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

import CloudImageLight from '@img/image/cloud/light/cloud-light.png';
import CloudImageDark from '@img/image/cloud/cloud-dark.png';

import OpenInSurrealistLight from '@img/image/surrealist/surrealist-cloud.png';
import OpenInSurrealistDark from '@img/image/surrealist/surrealist-cloud.png';

import LightCloud from '@img/image/cloud/surrealcloud.png';
import DarkCloud from '@img/image/cloud/surrealcloud.png';

import HighlyAvailable from '@img/image/cloud/light/highly-available-and-scalable-light.png';
import HighlyAvailableDark from '@img/image/cloud/highly-available-and-scalable-dark.png';


<div class="flag-title">
	<Image
		alt="SurrealDB Cloud "
		width={42}
		src={{
			light: LightCloud,
			dark: DarkCloud,
		}}
	/>
	# SurrealDB Cloud 
</div>

SurrealDB Cloud transforms the database experience, providing the power and versatility of SurrealDB without the complexity of managing infrastructure. Whether you’re building for passion projects or enterprise-scale applications, SurrealDB Cloud offers the scalability, resilience, and innovation you need to stay ahead.

Enjoy a fully managed solution that takes the hassle out of infrastructure operations. With SurrealDB’s ACID compliance, you can confidently run transactions at scale across multiple environments, ensuring data integrity and reliability.

Designed to support your growth, SurrealDB Cloud scales effortlessly [from prototypes to large-scale deployments](/docs/cloud/getting-started/create-an-instance). By leveraging centralized data, it enables departments or teams to work efficiently while maintaining consistent data integrity and reducing redundancy.

Our transparent and [predictable pricing](/pricing) ensures you only pay for what you need.

<Image
  alt="Surrealist API Docs view"
  src={{
    light: OpenInSurrealistLight,
    dark: OpenInSurrealistDark,
  }}
/>

## What can you do? 

When using SurrealDB Cloud , you can connect to your SurrealDB instance with a few clicks. You can connect to any SurrealDB instance via Surrealist, a command-line interface, and any of the supported SDKs. 


<div className="flex flex-col items-start justify-between">
  <div className="w-full">
    <Tabs groupId="What can you do">
      <TabItem value="Create an instance" label="Create an instance" default>
        <div className="flex flex-col md:flex-row items-start justify-between">
          <div className="flex-1">
            SurrealDB Cloud allows you to connect to your SurrealDB instance with just a few clicks. You can create an instance, connect to it, and start building your application.

            <h4>1. Create Instance.</h4>

            When creating an instance, you will enter the instance name and organization to ensure that you can easily identify your instance. Finally, you can select the version of SurrealDB to use and the region to deploy your instance.

            <h4>2. Select a region.</h4>

            Once you have created your instance, you can select the region to deploy your instance. This will allow you to connect to your instance from anywhere in the world.

            <h4>3. Select an Instance preset.</h4>

            Once you have selected a region, you can select an instance preset. This will allow you to select the instance size and type to best suit your needs.

            <h4>4. Finalize and connect to your Instance.</h4>

            Once you have created your instance, you can connect to it from anywhere in the world. You can connect to your instance from anywhere in the world.
          </div>
          
        </div>
      </TabItem>
      <TabItem value="Connect to your instance" label="Connect to your instance">
        <div className="flex flex-col md:flex-row items-start justify-between">
          <div className="flex-1 text-left">
            You can connect to any SurrealDB Cloud Instance via [Surrealist](/docs/cloud/connect/surrealist), a [command-line interface (CLI)](/docs/cloud/connect/cli), and [any of the supported SDKs](/docs/cloud/connect/sdk).

            #### [Connect via Surrealist](/docs/cloud/connect/surrealist)

            Since SurrealDB Cloud is closely integrated with Surrealist, you can execute queries directly from the interface. This allows you to interact with your data in real-time, without having to switch between different tools.

            #### [Connect via CLI](/docs/cloud/connect/cli)

            If you prefer to use a command-line interface, you can use the SurrealDB CLI to connect to your instance. This connection includes a token that is used to authenticate your connection.

            To do so, select the connect with the CLI option and copy the command.

            #### [Connect via SDK](/docs/cloud/connect/sdk)

            You can also connect to your instance using any of the supported SDKs. In your preferred SDK, use the connect method and pass in your instance endpoint.
          </div>
        </div>
      </TabItem>
    </Tabs>
  </div>
</div>





================================================
FILE: src/content/doc-surrealist/concepts/writing-stored-procedures.mdx
================================================
---
sidebar_position: 7
sidebar_label: Writing stored procedures
title: Surrealist | Writing stored procedures
description: Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, and much more.
---

import Image from "@components/Image.astro";
import ImageFunctions from "@img/image/surrealist/functions.png";

# Writing stored procedures

SurrealDB provides the ability to write and store functions, also known as stored procedures, directly in the database. These functions can be called from SurrealQL queries, allowing for more complex and reusable queries.

Surrealist provides a useful view where you can manage and create these functions visually using an intuitive SurrealQL editor.

<Image
  alt="Surrealist functions view"
  src={ImageFunctions}
/>

### Functions panel

The functions panel list out all functions stored in the database. You can press any function to open it in the editor panel where you can view and edit the function's contents.

### Creating a function

You can press the plus button in the top right of this panel to start writing a new function. This will first prompt you to enter a name for the function. For complex function names it is conventional to namespace them using double colons (`::`), for example `fn::project::has_member`.

After entering the function name, press "Continue" to open the function editor panel where you can write the function body.

## Function editor panel

After selecting or creating a function you will be presented with the function editor panel. Here you can write the function body using SurrealQL statements, similar to how you would write a query.
To the right of the editor you will see a column with some metadata about the function, such as function arguments, a permission clause, and a comment field.
You can also find buttons to download the function as a file, and a function to remove the function from the database.

When you make changes to a function, you can press the "Save changes" button in the bottom right of the editor to save the changes to the database.



================================================
FILE: src/content/doc-surrealist/faqs/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: FAQs
title: Surrealist | Frequently Asked Questions
description: Frequently asked questions about Surrealist. Find answers to common questions about Surrealist, the SurrealDB database, and more.
---

# Frequently Asked Questions

We want to make Surrealist the best database client for SurrealDB. If you have any questions, please reach out to us on [Discord](https://discord.com/invite/surrealdb) or [GitHub](https://github.com/surrealdb/surrealist).

For more specific questions about SurrealDB, please refer to the [SurrealDB FAQs](/docs/surrealist/faqs/info).

We also have a list of [known issues](/docs/surrealist/faqs/known-issues) which you may find useful.


================================================
FILE: src/content/doc-surrealist/faqs/info.mdx
================================================
---
sidebar_position: 1
sidebar_label: FAQs
title: Surrealist | Frequently Asked Questions
description: Frequently asked questions about Surrealist. Find answers to common questions about Surrealist, the SurrealDB database, and more.
---

# Frequently Asked Questions

View some of the frequently asked questions regarding Surrealist. Questions which are frequently asked across our GitHub, Discord and other social platforms will be added here from time-to-time.

## Which platforms does Surrealist support?

Surrealist supports Windows, MacOS, and Linux platforms. For Windows we provide an `exe` installer, MacOS a `dmg` containing the executable, and for Linux we provide `deb`, `rpm`, and `AppImage` packages.
In addition, we provide a universal web app which can be accessed from any platform with a modern web browser.

Any other distribution is unofficial and not supported by the Surrealist team.

## Why does Surrealist not support version x.y.z?

While we aim to keep Surrealist compatible with the latest stable release of SurrealDB, we do not guarantee compatibility with alpha and beta releases. Support for alpha and beta releases is added
if we have the resources to do so, and often hidden behind a feature flag. If you are using an alpha or beta release of SurrealDB and are experiencing issues, please open an issue on our GitHub repository,
as this gives us the opportunity to fix the issue before the stable release.

## Which protocol should I use for my connections?

This mostly depends on your preference and the database you are connecting to. The best overall protocol to use is `WSS` (Web Socket Secure) as it offers the best performance and security.
However, this requires an SSL certificate to be configured on the remote database. If the remote has no SSL certificate, or you are connecting to localhost, you can use `WS` or `HTTP` which both work for unencrypted connections.

One thing to keep in mind is that unencrypted connections are not always available from the Web App and work better in the desktop app.

## Why is Surrealist not connecting to my database?

There can be may reasons why Surrealist is unable to connect to a remote database. Some common reasons include specifying the wrong port, using the wrong protocol, or entering incorrect authentication details.
However there can more complex reasons such as network issues, firewalls, or the remote database not being available. You can always try connecting via the [CLI](https://deploy-preview-647--surrealdb-docs.netlify.app/docs/surrealdb/cli/) to see if the issue is with Surrealist or the remote database.

## Could you add a feature to Surrealist?

We are always open to feature requests and suggestions. If you have a feature request, please open an issue on our [GitHub repository](https://github.com/surrealdb/surrealist).
We will review the request and add it to our backlog if it aligns with our roadmap.

## What is the license for Surrealist?

Source code for Surrealist is licensed under MIT. You can find the license [here](https://github.com/surrealdb/surrealist/blob/main/LICENSE).
Keep in mind that the SurrealDB database source code is not licensed under MIT.



================================================
FILE: src/content/doc-surrealist/faqs/known-issues.mdx
================================================
---
sidebar_position: 2
sidebar_label: Known Issues
title: Surrealist | Known Issues
description: Known issues and bugs with Surrealist. Here are some known bugs and issues with Surrealist.
---

# Known Issues

Here are some known bugs and issues with Surrealist:

## Interface

- Some users may experience issues with the interface not loading correctly. This can be caused by a variety of reasons, such as network issues, browser cache, or browser extensions. Since Surrealist uses the browser native webview, it may be caused by an outdated browser version.

## Query view

- Querying certain binary data such as byte types causes Surrealist to crash. This is a known issue and is being worked on.
- Formatting a query strips out comments and white space. This happens because we parse the query into SurrealDB and pretty print it, however since the parser does not retain comments these are lost.

## Designer view

- The table graph will sometimes become invisible while still functioning correctly. We have not been able to reproduce this issue internally so far.


================================================
FILE: src/content/doc-surrealkv/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Introduction
title: SurrealKV | Introduction
description: SurrealKV is A low-level, versioned, embedded, ACID-compliant, key-value datastore for SurrealDB
no_page_headings: true
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/kv.png";
import DarkLogo from "@img/icon/dark/kv.png";

<div class="flag-title">
	<Image
		alt="SurrealKV"
		width={42}
		src={{
			light: LightLogo,
    		dark: DarkLogo,
		}}
	/>
	# SurrealKV
</div>

SurrealKV is an embedded ACID-compliant key-value storage engine with built-in versioning, that allows for historical or temporal querying. It is built entirely in Rust - like the rest of SurrealDB.

Since SurrealKV supports historical/temporal querying, you can use the [VERSION](/docs/surrealql/statements/select#the-version-clause) clause when selecting or creating data to access historical data. Learn more in the SurrealQL documentation.

> [!IMPORTANT]
> Although included in SurrealDB `2.0`, the storage engine itself is considered beta, and may require additional development and testing before it is ready for production use.


## Key Features

SurrealKV offers several key features that makes it a powerful and versatile database storage engine:

- **Embedded Database**: SurrealKV is available for embedded environments.

- **Built-in Versioning**: Start SurrealKV [in versioned mode](/docs/surrealdb/cli/start#surrealkv-beta) to track and access historical versions of your data.

- **Compaction**: Efficient storage management through compaction.

- **Durability Guaranteed**: Persistent storage with protection against system failures.

## When do I use SurrealKV?

While SurrealKV is particularly well-suited for certain use cases, it can differ in terms of performance and limitations from RocksDB. The next article will list the benefits and limitations of SurrealKV.




================================================
FILE: src/content/doc-surrealkv/performance.mdx
================================================
---
sidebar_position: 2
sidebar_label: Performance characteristics
title: Performance characteristics | SurrealQL
description: Learn about the performance characteristics of SurrealQL and how it optimizes query execution and resource usage in SurrealDB.
---

# SurrealKV performance characteristics and trade-offs

## Strengths

SurrealKV offers several notable performance advantages:

From a latency perspective, the system provides constant-time retrieval operations through direct offset lookups. Write operations are primarily bound by sequential I/O performance, and the system maintains minimal disk seeks during normal operation.

In terms of throughput properties, SurrealKV excels through its sequential write patterns that maximize I/O bandwidth utilization. The system's concurrent read operations effectively scale with available CPU cores, while range queries are optimized through the trie's prefix-based organization.

The recovery semantics are robust and predictable. During initial startup, the system performs a full segment scan to rebuild the index. Recovery and repair times scale proportionally with the total segment size and last active segment size, respectively. Data integrity is maintained through CRC verification during recovery. The system handles partial writes effectively by using CRC32 calculations from record fields to detect truncated writes, identifying and truncates incomplete records during recovery, and ensuring transaction logs are recovered to the last valid record boundary.

Operationally, SurrealKV offers significant advantages. The compaction process runs concurrently with normal operations, and the append-only format makes replication procedures straightforward.

## Limitations

SurrealKV does have some important limitations to consider, many of which pertain to SurrealKV [when versioning is enabled](/docs/surrealdb/cli/start#surrealkv-beta):

* Memory management is a key consideration, as the index must reside in memory. Memory usage scales with the number of unique keys, key size distribution, and the number of versions per key.

* Write amplification is another factor to consider. Each update creates a new version, requiring periodic compaction. During compaction, space usage temporarily increases.

* Range query performance varies depending on several factors: key distribution, version history depth, and range size. Large ranges may require multiple disk reads to complete.

* From an operational standpoint, regular compaction is necessary for space reclamation. System restart time increases with log size, and high-cardinality keyspaces can create memory pressure.

## Performance implications

SurrealKV is particularly well-suited for certain use cases. It performs optimally with write-intensive workloads, point query dominated patterns, prefix-based access patterns, and time-series data with version tracking.

However, some scenarios may not be ideal for SurrealKV. These include memory-constrained environments, very large key spaces, scan-heavy workloads, and situations involving random updates to large datasets.


================================================
FILE: src/content/doc-surrealml/computation.mdx
================================================
---
sidebar_position: 3
sidebar_label: Computation
title: SurrealML | Computation
description: SurrealML enables machine learning models to be greatly simplified, ensuring reproducibility and consistency in machine learning pipelines.
---

# Computation

If we have a loaded a model you will want to execute it to perform a calculation. First we will cover the high-level execution of models in Python and Rust, then will explore what is going on under the hood for these executions. Before we go through some code examples, let us define the different types of computation that we can perform on a model.

## Raw Compute

Raw compute passes an array directly into the model for execution. Here we bypass all the metadata in the file. This means that you need to perform your own normalisations on your input data if you normalised the model training data when training the model. This approach is more beneficial to complex data structures such as images, as they are multi-dimensional. When executing the raw compute, you do not need to pass in the dimensions of the input, as these are extracted from the saved model itself as the code shows [here](https://github.com/surrealdb/surrealml/blob/34baa045da9184ccd1479220e6205dd298b78ee3/modules/core/src/execution/compute.rs#L80C68-L80C75).

## Buffered Compute

Buffered computer passes a dictionary or hashmap with the names of the columns as the keys, and the values associated with the column. The engine then checks all the columns, applies normalisation functions to the inputs if the normalisation functions are present for the column, and constructs a vector in the correct order for inputs. At this point, the model computation will error if any of the columns are missing, only allowing valid input to pass through. The processed vector is then passed into the raw compute function.

Now that we have explored the two types of computation, we can explore how to perform these computations.

## Executing a model in Python

We can execute a model in Python using the following code:

```python
# raw compute
print(new_file.raw_compute(input_vector=[5, 6]))

# buffered compute (implement data from the meta data)
print(
	new_file.buffered_compute(
		value_map={
			"squarefoot": 5, 
			"num_floors": 6
		}
	)
)
```

## Executing a model in Rust

Starting with the following `use` statements will let us bring a number of necessary types into scope:

```rust
use surrealml_core::storage::surml_file::SurMlFile;
use surrealml_core::execution::compute::ModelComputation;
use ndarray::ArrayD;
use std::collections::HashMap;
```

We can then create a compute unit with the code below:

```rust
let compute_unit = ModelComputation {
    surml_file: &mut new_file,
};
```

First we can do a buffered compute with a standard HashMap with the following code:

```rust
let mut input_values = HashMap::new();
input_values.insert(String::from("squarefoot"), 1000.0);
input_values.insert(String::from("num_floors"), 2.0);

let output = compute_unit.buffered_compute(&mut input_values).unwrap();
```

If we want to perform a raw compute, we can do so with the code below:

```rust
let x = vec![1000.0, 2.0];
let data: ArrayD<f32> = ndarray::arr1(&x).into_dyn();

let output = compute_unit.raw_compute(data, None).unwrap();
```

Note that the input dimensions fed into the `.raw_compute()` method are specified as None, as they will be extracted directly from the saved model.

## Executing a model in SurrealDB

Once the model is stored in the database, it can be called with the following code:

```sql
	ml::house-price-prediction<0.0.1>({
		squarefoot: squarefoot_col,
		num_floors: num_floors_col
	})
```

Here the `ml::` is saying that we are using the SurrealDB’s ML module. The `house-price-prediction` is the name of the model in the meta data of the `surml` file. The `<0.0.1>` is the version that is also defined in the header of the `surml` file. The object passed into it is essentially a hashmap for the buffered compute.  This calculation then yields a result that can then be inputted into the rest of the SurrealQL statement. 

## Execution mechanics

The interface between the ONNX `C++` and Rust can be found in SurrealDB’s source code [here](https://github.com/surrealdb/surrealml/blob/main/modules/core/src/execution/onnx_environment.rs). Based on different build parameters, we embed the `libonnxruntime` library into the Rust binary. When performing an execution, we load the `libonnxruntime` library into a `Lazy<Arc<Environment>>`. This leads to a single Environment instance that lasts for the entire duration of the program. This environment can be accessed by any thread, which is safe to do so as access is protected by a lock that is only available once another thread has given it up.

Tests of running a computation in Rust can be found [here](https://github.com/surrealdb/surrealml/blob/34baa045da9184ccd1479220e6205dd298b78ee3/modules/core/src/execution/compute.rs#L161). Python does not perform any computations, but all interactions between the Rust module and the Python code can be found [here](https://github.com/surrealdb/surrealml/blob/develop/surrealml/rust_adapter.py) in the `RustAdapter` object.


================================================
FILE: src/content/doc-surrealml/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Introduction
title: SurrealML | Introduction
description: SurrealML enables machine learning models to be greatly simplified, ensuring reproducibility and consistency in machine learning pipelines.
no_page_headings: true
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/ml-light.png";
import DarkLogo from "@img/icon/dark/surrealml.png";

<div class="flag-title">
	<Image
		alt="SurrealML"
		width={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# SurrealML
</div>

# SurrealML

SurrealML is an engine that seeks to do one thing, and one thing well: store and execute trained ML models. SurrealML does not intrude on the training frameworks that are already out there, instead works with them to ease the storage, loading, and execution of models. Someone using SurrealML will be able to train their model in a chosen framework in Python, save their model, and load and execute the model in either Python or Rust. The inference engine is composed of python bindings interacting with a core written in Rust. This means that the exact same code that the Python client calls will be running on a production node by itself, or in the database. While the SurrealML engine runs in the database, it is developed in a completely isolated Github repository, giving the user 100% freedom on how they deploy and interact with the SurrealML engine.

While this is all exciting, let us check to see if SurrealML works on your machine. There is nothing worse than reading about a package only to find that it does not work. The first move is to install the package.

## Installation

To install SurrealML, make sure you have Python installed. Then, install the `SurrealML` library and either `PyTorch` or `sklearn`, based on your model choice. You can install the package with both `PyTorch` and `SKLearn` with the command below:

```bash
pip install "git+https://github.com/surrealdb/surrealml#egg=surrealml[sklearn,torch]"
```

If you want to use `SurrealML` with `sklearn` you will need the following installation:

```bash
pip install "git+https://github.com/surrealdb/surrealml#egg=surrealml[sklearn]"
```

For `PyTorch`:

```bash
pip install "git+https://github.com/surrealdb/surrealml#egg=surrealml[torch]"
```

Once the package is installed, you can then train and save your first model using sklearn.

## Quick Start with Sklearn

Sklearn models can also be converted and stored in SurrealML’s `.surml` format enabling developers to load them in any Python version as we are not relying on `pickle`. Metadata in the file also enables other users of the model to use them out of the box without having to worry about the normalisation of the data or getting the right inputs in order. We will cover `.surml` files in more depth in the storage section. You will also be able to load your Sklearn models in Rust and run them, meaning you can use them in your SurrealDB server.

Before we start writing any training code we need to import the following:

```python
from sklearn.linear_model import LinearRegression
from surrealml import SurMlFile, Engine
from surrealml.model_templates.datasets.house_linear import HOUSE_LINEAR
```

Here we can see that we have imported the standard `sklearn` `LinearRegression` model. We then import the `SurMlFile` object which will facilitate the saving, loading, and execution of the trained model. We will use the `Engine` enum to tell our `SurMlFile` object if we are using `sklearn` or `torch`. We then finally import a small example dataset called `HOUSE_LINEAR`. This example dataset is a simple linear correlation between house prices, the square foot of the house, and the number of floors. This dataset is also used in the CI testing pipeline when we push updates.

Now that we have imported everything that we need, we can train our model with the code below:

```python
model = LinearRegression()
model.fit(HOUSE_LINEAR["inputs"], HOUSE_LINEAR["outputs"])
```

This will give us a trained model. Now we need to save it and this is where `SurrealML` comes in. First we declare a `SurMlFile` object instance with the inputs, name, model object, and engine with the following code:

```python
file = SurMlFile(
	model=model,
	name="house-price-prediction",
	inputs=HOUSE_LINEAR["inputs"],
	engine=Engine.SKLEARN
)

file.add_version(version="0.0.1")
```

The next step is optional, but it would be nice to map our inputs to some keys. We must be careful with the order that we declare our columns as they need to be mapped with the order or inputs from the vector that our model was trained on. If you click on `HOUSE_LINEAR` you will see the following declaration:

```python
HOUSE_LINEAR = {
    "inputs": inputs,
    "outputs": house_price,

    "squarefoot": squarefoot,
    "num_floors": num_floors,
    "input order": ["squarefoot", "num_floors"],
    "raw_inputs": {
        "squarefoot": raw_squarefoot,
        "num_floors": raw_num_floors,
    },
    "normalised_inputs": {
        "squarefoot": squarefoot,
        "num_floors": num_floors,
    },
    "normalisers": {
        "squarefoot": {
            "type": "z_score",
            "mean": squarefoot.mean(),
            "std": squarefoot.std()
        },
        "num_floors": {
            "type": "z_score",
            "mean": num_floors.mean(),
            "std": num_floors.std()
        }
    },
}
```

Here we can see that there are some normalisers involved. We can also see that the input order for the model training was `["squarefoot", "num_floors"]` . Therefore, we can add the column names to our `SurMlFile` object instance with the code below:

```python
file.add_column("squarefoot")
file.add_column("num_floors")
```

The `add_column` was the only order that we have to be careful about. We need to add our normalisers to the `SurMlFile` object instance with the code below but we do not have to worry about the order as the normalisers by default will be mapped to the columns:

```python
file.add_normaliser(
	"squarefoot",
	"z_score",
	HOUSE_LINEAR["squarefoot"].mean(),
	HOUSE_LINEAR["squarefoot"].std()
)

file.add_normaliser(
	"num_floors",
	"z_score",
	HOUSE_LINEAR["num_floors"].mean(),
	HOUSE_LINEAR["num_floors"].std()
)
```

We are nearly done with adding metadata, with just one item left to add: the output that the model is trying to predict. This can be achieved by the following code:

```python
file.add_output(
	"house_price",
	"z_score",
	HOUSE_LINEAR["outputs"].mean(),
	HOUSE_LINEAR["outputs"].std()
)
```

And now our file is ready to be saved which is done with the code below:

```python
file.save(path="./linear.surml")
```

The file is stored in the `.surml` format meaning that there is a header with the data that we defined, and the weights are stored in the `ONNX` format. This means that there is zero language dependent dependencies. We are now ready to load and perform calculations on our model. We can load our model with the following code:

```python
new_file = SurMlFile.load(path="./linear.surml", engine=Engine.SKLEARN)
```

If you are confident in what you are doing at this point, you can choose to perform calculations through `surrealML` using a raw compute in which the raw vector of inputs is directly passed into the model with the code below:

```python
print(new_file.raw_compute(input_vector=[5, 6]))
```

However, if you want the normalisation to be automatically applied, and inputs mapped via keys, we can use a buffered compute with the following code:

```python
print(
	new_file.buffered_compute(
		value_map={
			"squarefoot": 5,
			"num_floors": 6
		}
	)
)
```

Both types of executions are executing the ML model using the Rust engine under the hood. As a result, the exact same code will be running your model in SurrealDB or your inference server regardless of whether you choose to build a server in Python or Rust. This `.surml` file can be also be loaded by either Rust or any Python version that has surrealML and execute inference inference installed.

Now that we are able to load and execute our model locally, how do we deploy our model onto SurrealDB and run it? In the next section, we cover uploading.

## Model Deployment

Before we try and upload our model, we need to have a node running. We can do with the `docker-compose.yml` file below:

```yaml
version: '3'
services:
  surrealdb:
    image: surrealdb/surrealdb
    command: start
    environment:
      - SURREAL_USER=root
      - SURREAL_PASS=root
      - SURREAL_LOG=trace
    ports:
      - 8000:8000
```

Once our node is running via docker, we can then upload our trained model with the following code:

```python
url = "http://0.0.0.0:8000/ml/import"
SurMlFile.upload(
    path="./linear.surml",
    url=url,
    chunk_size=36864,
    namespace="test",
    database="test",
    username="root",
    password="secret"
)

```

The `upload` function will chunk the model and stream it up to a SurrealDB node. We can then perform an execution of the model with the following SurrealQL function:

```python
ml::house-price-prediction<0.0.1>({
	squarefoot: 500.0,
	num_floors: 2.0
})
```

Here, `house-price-prediction` is the name of the model. The `<0.0.1>` is the version of the model. The SurrealQL function above will give us a model output from the inputs that we passed in.

We can now explore how our model can interact with other data with the SurrealQL script below:

```sql
CREATE house_listing SET squarefoot_col = 500.0, num_floors_col = 1.0;
CREATE house_listing SET squarefoot_col = 1000.0, num_floors_col = 2.0;
CREATE house_listing SET squarefoot_col = 1500.0, num_floors_col = 3.0;

SELECT * FROM (
	SELECT *,
	ml::house_price_prediction<0.0.1>({
		squarefoot: squarefoot_col,
		num_floors: num_floors_col
	}) AS price_prediction
	FROM house_listing
)
WHERE price_prediction > 177206.21875;
```

What is happening here is that we are feeding the columns from the table `house_listing` into a model we uploaded called `house-price-prediction` with a version of `0.0.1`. We then get the results of that trained ML model as the column `price_prediction`. We then use the calculated predictions to filter the rows giving us the following result:

```json
[
  {
    "id": "house_listing:7bo0f35tl4hpx5bymq5d",
    "num_floors_col": 3,
    "price_prediction": 406534.75,
    "squarefoot_col": 1500
  },
  {
    "id": "house_listing:8k2ttvhp2vh8v7skwyie",
    "num_floors_col": 2,
    "price_prediction": 291870.5,
    "squarefoot_col": 1000
  }
]
```

Having covered everything that we need to get up and running with SurrealML, we should explore some other concepts in more depth to get the most out of SurrealML and be able to troubleshoot problems.



================================================
FILE: src/content/doc-surrealml/storage.mdx
================================================
---
sidebar_position: 2
sidebar_label: Storage
title: SurrealML | Storage
description: SurrealML enables machine learning models to be greatly simplified, ensuring reproducibility and consistency in machine learning pipelines.
---

import Image from "@components/Image.astro";
import LightSchema from "@img/image/light/surrealml-storage-schema.png";
import DarkSchema from "@img/image/light/surrealml-storage-schema.png";

# Storage

If you have completed the introduction, you would have stored your ML model in a `.surml` file. Seeing as the `.surml` file is at the heart of storage, we will start by covering the anatomy of a `.surml` file.

## The Anatomy of a Surml File

A `.surml` file is essentially a header, with weights stored in the ONNX format. Interacting with the file takes the following form:

<Image
  alt="SurrealML Storage Schema"
  src={{
    light: LightSchema,
    dark: DarkSchema,
  }}
/>

<br />
<br />

The metadata is data around the model. You can see the definition of the header [here](https://github.com/surrealdb/surrealml/blob/main/modules/core/src/storage/header/mod.rs).   The meta data has the following fields (all fields can be empty if needed):

- **keys ⇒** The name of the column and the index of where that column is placed in an input vector
- **normalisers ⇒** A map of normalisers with parameters to execute the normaliser, and a reference to the column that the normaliser is attached to
- **output ⇒** The name of the output and a normaliser attached to the output (if needed)
- **name ⇒** The name of the model being stored
- **version ⇒** The version of the model. Model versions use a default and auto-increment function that results in formats such as  `0.0.1` and `0.0.2`.
- **description ⇒** The description of the model
- **engine ⇒** The type of engine that was used to train the model, such as the native Linfa Rust module, the Rust PyTorch model, or Undefined (trained using a third party module such as Sklearn, PyTorch, etc.)
- **Origin ⇒** Where the model was trained, such as locally, in the database, or Undefined (local is automatically defined when using the Python surrealML package)
- **input_dims ⇒** the input dimensions that are needed to perform a model imputation. This is automatically defined when tracing the model when saving it in the `.surml` file format.

When reading a file, the loader loads the first 4 bytes of a file. Those first 4 bytes are then converted into a 4 byte integer. This 4 byte integer then tells the loader how many bytes to load to get all of the meta data about the model. Once this is loaded, we can then assume that the rest of the file is ONNX protobuf, and this protobuf data is then loaded into the ONNX runtime C++ library for inference calculations.

## Why ONNX

SurrealML supports the ONNX runtime which is the standard format for storing machine learning weights, and is officially [supported by Microsoft](https://github.com/microsoft/onnxruntime).

Under the hood, SurrealML exports the torch model into ONNX format which is officially supported by [PyTorch](https://pytorch.org/tutorials/advanced/super_resolution_with_onnxruntime.html).

The convergence of the ML community to ONNX as its standard format has led to [research and academic papers](https://cloudblogs.microsoft.com/opensource/2020/12/17/accelerate-simplify-scikit-learn-model-inference-onnx-runtime/) produced by Fang researchers on how to convert models such as random forests into ONNX.

There are also desktop apps like neutron that let you inspect these ONNX models in graphical form such as the following:

https://netron.app/

Alongside this, there is also work directly supported by a range of massive companies to enable ONNX to be run in WASM:

https://onnxruntime.ai/docs/build/web.html

And the official huggingface github is also working on a pure Rust implementation of ONNX with the code link below:

https://github.com/huggingface/candle/tree/main/candle-onnx

ONNX also supports GPUs as seen in the following link:

https://onnxruntime.ai/docs/execution-providers/CUDA-ExecutionProvider.html

With all this support for the ecosystem, it makes sense for us to support ONNX and automate processes that convert models to ONNX such as Sklearn.

Now that we have covered the anatomy of a `.surml` file, we can now move to loading and saving files.

## Loading and Saving with Python

This has been covered in the introduction section, so if you want to see the code around loading and saving, please visit the introduction section. We can save a model with the following code:

```python
file = SurMlFile(
	model=model, # the trained model object
	name="house-price-prediction",
	inputs=HOUSE_LINEAR["inputs"],
	engine=Engine.SKLEARN # change to the pytorch version is storing a pytorch model
)

file.add_version(version="0.0.1")
file.save(path="./linear.surml")
```

To load the file, we use the code below:

```python
new_file = SurMlFile.load(path="./linear.surml", engine=Engine.SKLEARN)
```

We can also load `.surml` files in Rust too.

## Saving and Loading SurML in Rust

To load in Rust you will need the following dependency in your `cargo.toml` file (version may have increased since the time of writing this):

```toml
surrealml-core = "0.0.8"
```

Alternatively, you can add the dependency by typing  `cargo add surrealml-core` on the command line. The `core` is the exact same code that runs in the Python client, ensuring consistency between the client and the server in production.

Starting with the following `use` statements will let us bring a number of necessary types into scope:

```rust
use std::fs::File;
use std::io::{self, Read, Write};

use surrealml_core::storage::surml_file::SurMlFile;
use surrealml_core::storage::header::Header;
use surrealml_core::storage::header::normalisers::{
    wrapper::NormaliserType,
    linear_scaling::LinearScaling
};
```

We can then load the ONNX file that was saved from a training session with the code below:

```rust
let mut file = File::open("./stash/linear_test.onnx").expect("File to be found");
let mut model_bytes = Vec::new();
file.read_to_end(&mut model_bytes).expect(”File content to be read to string”);
```

Once we have loaded our bytes from the ONNX file, we will insert the `model_bytes` once we have defined our file. We can first define our header and add the columns with the following code:

```rust
let mut header = Header::fresh();
header.add_column(String::from("squarefoot"));
header.add_column(String::from("num_floors"));
header.add_output(String::from("house_price"), None);
```

We can then add the normalisers with the code below:

```rust
header.add_normaliser(
    "squarefoot".to_string(),
    NormaliserType::LinearScaling(LinearScaling { min: 0.0, max: 1.0 })
);
header.add_normaliser(
    "num_floors".to_string(),
    NormaliserType::LinearScaling(LinearScaling { min: 0.0, max: 1.0 })
);
```

We now have everything we need to package our `.surml` file which we can do and write to disk with the following code:

```rust
let surml_file = SurMlFile::new(header, model_bytes);
surml_file.write("./stash/test.surml").unwrap();
```

If we want to load a model, it can either be from bytes or a file using the code below:

```rust
let new_file = SurMlFile::from_file("./stash/test.surml").unwrap();
let file_from_bytes = SurMlFile::from_bytes(surml_file.to_bytes()).unwrap();
```



================================================
FILE: src/content/doc-surrealql/comments.mdx
================================================
---
sidebar_position: 8
sidebar_label: Comments
title: Comments | SurrealQL
description: In SurrealQL, comments can be written in a number of different ways.
---

# Comments

In SurrealQL, comments can be written in a number of different ways.

```surql
/*
In SurrealQL, comments can be written as single-line
or multi-line comments, and comments can be used and
interspersed within statements.
*/

SELECT * FROM /* get all users */ user;

# There are a number of ways to use single-line comments
SELECT * FROM user;

// Alternatively using two forward-slash characters
SELECT * FROM user;

-- Another way is to use two dash characters
SELECT * FROM user;
```



================================================
FILE: src/content/doc-surrealql/demo.mdx
================================================
---
sidebar_position: 2
sidebar_label: Demo data
title: Demo data | SurrealQL
description: To quickly test out SurrealDB and SurrealQL functionality, we've included demo data which you can download and import into SurrealDB.
---

import Image from "@components/Image.astro";
import SurrealistMini from "@components/SurrealistMini.astro";

import LightOverview from "@img/image/light/surreal-deal-store-light.png";
import LightSchema from "@img/image/light/surreal_deal_light.png";

import DarkOverview from "@img/image/dark/surreal-deal-store.png";
import DarkSchema from "@img/image/dark/surreal_deal_dark.png";

# Demo data

To quickly test out SurrealDB and SurrealQL functionality, we've included two demo datasets here in `.surql` files which you can download and [`import`](/docs/surrealdb/cli/import) into SurrealDB using the CLI

## Surreal Deal Store - there is a lot in store for you!

Surreal Deal Store is our new and improved demo dataset based on our [SurrealDB Store](https://surrealdb.store/).
The dataset is made up of 12 tables using both [graph relations](/docs/surrealql/statements/relate) and [record links](/docs/surrealql/datamodel/records).

In the diagram below, the nodes in pink are the [standard tables](/docs/surrealql/statements/define/table), the ones in purple represent the [edge tables](/docs/surrealql/statements/relate) which shows relationships between records and SurrealDB as a graph database. While the nodes in gray are the [pre-computed table views](/docs/surrealql/statements/define/table).

<Image
  alt="Surreal Deal Data Model"
  src={{
    light: LightOverview,
    dark: DarkOverview,
  }}
/>


### Download

| Dataset                                                                          | URL                                                       |
| -------------------------------------------------------------------------------- | --------------------------------------------------------- |
| [Surreal Deal Store](https://datasets.surrealdb.com/surreal-deal-store.surql)             | https://datasets.surrealdb.com/surreal-deal-store.surql      |
| [Surreal Deal Store (mini)](https://datasets.surrealdb.com/surreal-deal-store-mini.surql) | https://datasets.surrealdb.com/surreal-deal-store-mini.surql |

### Import

First, download any of the [available datasets](#download).

Secondly, [start the server](/docs/surrealdb/cli/start).

```bash
# Create a new in-memory server
surreal start --user root --pass secret --allow-all
```

Lastly, use the [import command](/docs/surrealdb/cli/import) to add the dataset.

Use the command below to import the [surreal deal store dataset](https://datasets.surrealdb.com/surreal-deal-store.surql):

```bash
surreal import --conn http://localhost:8000 --user root --pass secret --ns test --db test surreal-deal-store.surql
```

To import the surreal downloaded the [Surreal Deal store (mini)](https://datasets.surrealdb.com/surreal-deal-store-mini.surql) use the command below:

```bash
surreal import --conn http://localhost:8000 --user root --pass secret --ns test --db test surreal-deal-store-mini.surql
```

Please be aware that the import process might take a few seconds.


### Using Curl

First, start the surrealdb server

```bash
# Create a new in-memory server
surreal start --user root --pass secret --allow-all
```

Then, download the file and load it into the database

```bash
# Download the file
curl -L "https://datasets.surrealdb.com/surreal-deal-store.surql" -o surreal-deal-store.surql

# Load the file into the database using the rest endpoint
curl -v -X POST -u "root:root" -H "NS: test" -H "DB: test" -H "Accept: application/json" --data-binary @surreal-deal-store.surql http://localhost:8000/import
```

If you want to use the mini version:

```bash
# Download the file
curl -L "https://datasets.surrealdb.com/surreal-deal-store-mini.surql" -o surreal-deal-store-mini.surql

# Load the file into the database using the rest endpoint
curl -v -X POST -u "root:root" -H "NS: test" -H "DB: test" -H "Accept: application/json" --data-binary @surreal-deal-store-mini.surql http://localhost:8000/import
```

### Sample queries

Here are some sample queries you can run on the Surreal Deal Store dataset. We've also included a [Surrealist Mini](https://app.surrealdb.com/mini) below to help you run these queries.

> [!NOTE]
> The query results below have been limited to 4 rows for brevity. If you remove the `LIMIT 4` clause from the queries, you'll see the full results.



<SurrealistMini url='https://app.surrealdb.com/mini?query=--+Query+1%3A+Using+record+links+to+select+from+the+seller+table+%0ASELECT%0A++name%2C%0A++seller.name%0AFROM+product+LIMIT+4%3B%0A%0A%0A--+Query+2%3A+Using+graph+relations+to+select+from+the+person+and+product+table%0ASELECT%0A++++time.created_at as order_date%2C%0A++++product_name%2C%0A++++%3C-person.name+as+person_name%2C%0A++++-%3Eproduct.details%0AFROM+order+LIMIT+4%3B%0A%0A%0A--+Query+3%3A+Conditional+filtering+based+on+an+embedded+object+property.%0ASELECT+%0A++name%2C%0A++email+%0AFROM+person+%0AWHERE+address.country+%3F%3D+%22England%22+LIMIT+4%3B%09%0A%0A%0A--+Query+4%3A+Conditional+filtering+using+relationships.%0ASELECT+*+FROM+review%0AWHERE+-%3Eproduct.sub_category+%3F%3D+%22Activewear%22+LIMIT+4%3B%0A%0A%0A--+Query+5%3A+Count+orders+based+on+order+status%0ASELECT+count%28%29+FROM+order%0AWHERE+order_status+IN+%5B+%22processed%22%2C+%22shipped%22%5D%0AGROUP+ALL+LIMIT+4%3B%0A%0A%0A--+Query+6%3A+Get+a+deduplicated+list+of+products+that+were+ordered%0ASELECT+%0A++++array%3A%3Adistinct%28product_name%29+as+ordered_products%0AFROM+order%0AGROUP+ALL+LIMIT+4%3B%0A%0A%0A--+Query+7%3A+Get+the+average+price+per+product+category%0ASELECT+%0A++++-%3Eproduct.category+AS+product_category%2C%0A++++math%3A%3Amean%28price%29+AS+avg_price%0AFROM+order%0AGROUP+BY+product_category%0AORDER+BY+avg_price+DESC+LIMIT+4%3B%0A%0A%0A--+Query+8%3A+encapsulating+logic+in+a+function%0ARETURN+fn%3A%3Anumber_of_unfulfilled_orders%28%29%3B%0A%0A%0A--+Query+9%3A+using+a+custom+fuction+for+currency+conversion%0ASELECT+%0A++++product_name%2C%0A++++fn%3A%3Apound_to_usd%28price%29+AS+price_usd%0AFROM+order+LIMIT+4%3B&dataset=surreal-deal-store&orientation=horizontal'/>




================================================
FILE: src/content/doc-surrealql/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Overview
title: SurrealQL | Query Language 
description: In this section, you will explore SurrealQL, a powerful database query language that closely resembles traditional SQL but comes with unique differences and improvements.
no_page_headings: true
---

import Image from "@components/Image.astro";
import LightLogo from "@img/icon/light/ql-light.png";
import DarkLogo from "@img/icon/dark/surrealql.png";

<div class="flag-title">
	<Image
		class="size-11 my-auto"
		alt="SurrealQL"
		width={300}
		src={{
			light: LightLogo,
    		dark: DarkLogo,
		}}
	/>
	# SurrealQL
</div>

SurrealQL is a powerful and intuitive database query language that closely resembles traditional SQL but comes with unique differences and improvements.

SurrealQL is designed to provide developers with a seamless and intuitive way to interact with SurrealDB. It offers a familiar syntax and supports various statement types, allowing you to perform complex database operations efficiently.

While SurrealQL shares similarities with traditional SQL, it introduces enhancements and optimizations that make it well-suited for working with SurrealDB's advanced features and data models. Whether you are querying data, modifying records, or managing database structures, SurrealQL provides a comprehensive set of capabilities to meet your needs.

## Key Features

SurrealQL offers several key features that make it a powerful tool for working with SurrealDB:

- **Familiar Syntax**: SurrealQL adopts a syntax similar to traditional SQL, making it easy for developers familiar with SQL to transition to SurrealDB seamlessly.

- **Advanced Querying**: SurrealQL supports a wide range of querying capabilities, including filtering, sorting, aggregating, and joining data from multiple tables.

- **Data Manipulation**: With SurrealQL, you can easily insert, update, and delete records in your SurrealDB database, allowing you to manage your data effectively.

- **Graph relationships**: SurrealQL supports graph relationships, allowing you to define and query relationships between records in your database.

- **Schema Management**: SurrealQL provides features for creating and modifying database schemas, allowing you to define the structure of your data and enforce data integrity.

- **Performance Optimization**: SurrealQL incorporates optimizations specific to SurrealDB, ensuring efficient execution of queries and minimizing resource usage.

## Getting Started

To start using [SurrealQL](/docs/surrealql/statements/begin), refer to the documentation on the various statement types and their syntax. The statements page provides comprehensive examples and explanations for each statement type, helping you understand how to construct queries and interact with SurrealDB effectively.

We hope that SurrealQL empowers you to leverage the full potential of SurrealDB and enables you to build robust and scalable applications. Let's dive into the world of SurrealQL and unlock the capabilities of SurrealDB together!

## Resources

To learn more about SurrealQL and how to use it effectively, check out the following resources:

- [Select Statement](/docs/surrealql/statements/select): Learn how to retrieve data from your SurrealDB database using the `SELECT` statement and explore various querying options:

<iframe width="100%" src="https://www.youtube.com/embed/TyX45cyZ-W0?si=S9M59afDEiqxeC5d" style={{ aspectRatio: 1.7, paddingTop: '20px' }} title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>




================================================
FILE: src/content/doc-surrealql/operators.mdx
================================================
---
sidebar_position: 3
sidebar_label: Operators
title: Operators | SurrealQL
description: A variety of operators in SurrealQL allow for complex manipulation of data, and advanced logic.
---

import Since from '@components/shared/Since.astro'
import Table from '@components/shared/Table.astro'

# Operators

A variety of operators in SurrealQL allow for complex manipulation of data, and advanced logic.

<Table>
	<thead>
		<tr>
			<th scope="col" class="w-48">Operator</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex gap-2">
					<a href="#and">
						<code>&&</code>
					</a>
					<a href="#and">
						<code>AND</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether both of two values are truthy
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex gap-2">
					<a href="#or">
						<code>||</code>
					</a>
					<a href="#or">
						<code>OR</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether either of two values is truthy
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#not">
					<code>!</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Reverses the truthiness of a value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#not_not">
					<code>!!</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Determines the truthiness of a value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#nco">
					<code>??</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether either of two values are truthy and not NULL
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#tco">
					<code>?:</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether either of two values are truthy
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex gap-2">
					<a href="#equal">
						<code>=</code>
					</a>
					<a href="#equal">
						<code>IS</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Check whether two values are equal
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex gap-2">
					<a href="#notequal">
						<code>!=</code>
					</a>
					<a href="#notequal">
						<code>IS NOT</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Check whether two values are not equal
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#exact">
					<code>==</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether two values are exactly equal
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#anyequal">
					<code>?=</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether any value in a set is equal to a value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#allequal">
					<code>*=</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether all values in a set are equal to a value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#match">
					<code>~</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Compare two values for equality using fuzzy matching
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#match">
					<code>!~</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Compare two values for inequality using fuzzy matching
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#match">
					<code>?~</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether any value in a set is equal to a value using
				fuzzy matching
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#match">
					<code>*~</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether all values in a set are equal to a value using
				fuzzy matching
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#lessthan">
					<code>&lt;</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether a value is less than another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#lessthanorequal">
					<code>&lt;=</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether a value is less than or equal to another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#greaterthan">
					<code>&gt;</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether a value is greater than another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#greaterthanorequal">
					<code>&gt;=</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether a value is greater than or equal to another
				value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#add">
					<code>+</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Add two values together
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#sub">
					<code>-</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Subtract a value from another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex gap-2">
					<a href="#mul">
						<code>*</code>
					</a>
					<a href="#mul">
						<code>×</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Multiply two values together
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex gap-2">
					<a href="#div">
						<code>/</code>
					</a>
					<a href="#div">
						<code>÷</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Divide a value by another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#pow">
					<code>**</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Raises a base value by another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col gap-2">
					<a href="#contains">
						<code>CONTAINS</code>
					</a>
					<a href="#contains">
						<code>∋</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a value contains another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col gap-2">
					<a href="#containsnot">
						<code>CONTAINSNOT</code>
					</a>
					<a href="#containsnot">
						<code>∌</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a value does not contain another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col gap-2">
					<a href="#containsall">
						<code>CONTAINSALL</code>
					</a>
					<a href="#containsall">
						<code>⊇</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a value contains all other values
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col gap-2">
					<a href="#containsany">
						<code>CONTAINSANY</code>
					</a>
					<a href="#containsany">
						<code>⊃</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a value contains any other value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col gap-2">
					<a href="#containsnone">
						<code>CONTAINSNONE</code>
					</a>
					<a href="#containsnone">
						<code>⊅</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a value contains none of the following values
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col items-start gap-2">
					<a href="#inside">
						<code>INSIDE</code>
					</a>
					<a href="#inside">
						<code>IN</code>
					</a>
					<a href="#inside">
						<code>∈</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a value is contained within another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col items-start gap-2">
					<a href="#notinside">
						<code>NOTINSIDE</code>
					</a>
					<a href="#notinside">
						<code>NOT IN</code>
					</a>
					<a href="#notinside">
						<code>∉</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a value is not contained within another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col items-start gap-2">
					<a href="#allinside">
						<code>ALLINSIDE</code>
					</a>
					<a href="#allinside">
						<code>⊆</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether all values are contained within other values
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col items-start gap-2">
					<a href="#anyinside">
						<code>ANYINSIDE</code>
					</a>
					<a href="#anyinside">
						<code>⊂</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether any value is contained within other values
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col items-start gap-2">
					<a href="#noneinside">
					<code>NONEINSIDE</code>
					</a>
					<a href="#noneinside">
						<code>⊄</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether no value is contained within other values
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#outside">
					<code>OUTSIDE</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a geometry type is outside of another
				geometry type
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#intersects">
					<code>INTERSECTS</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a geometry type intersects another geometry
				type
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col items-start gap-2">
					<a href="#matches">
						<code>@@</code>
					</a>
					<a href="#matches">
						<code>@[ref]@</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether the terms are found in a full-text indexed
				field
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col items-start gap-2">
					<a href="#knn">
						<code> &lt;|4|&gt; </code>
					</a>
					<a href="#knn">
						<code>&lt;|3,HAMMING| &gt;</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Performs a K-Nearest Neighbors (KNN) search to find a
				specified number of records closest to a given data point,
				optionally using a defined distance metric. Supports
				customizing the number of results and choice of distance
				calculation method.
			</td>
		</tr>
	</tbody>
</Table>

## `&&` or `AND` {#and}

Checks whether both of two values are [truthy](/docs/surrealql/datamodel/values#values-and-truthiness).

```surql
/**[test]

[[test.results]]
value = "30"

*/

SELECT * FROM 10 AND 20 AND 30;

-- 30
```

<br />

## `||` or `OR` {#or}

Checks whether either of two values are [truthy](/docs/surrealql/datamodel/values#values-and-truthiness).

```surql
/**[test]

[[test.results]]
value = "[10]"

*/

SELECT * FROM 0 OR false OR 10;

-- 10
```

<br />

## `!` {#not}

Reverses the truthiness of a value.

```surql
/**[test]

[[test.results]]
value = "[false]"

[[test.results]]
value = "[false]"

*/

SELECT * FROM !(TRUE OR FALSE);
-- false

SELECT * FROM !"Has a value";
-- false
```

<br />

## `!!` {#not_not}

Determines the truthiness of a value (simply an application of the `!` operator twice).

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM !!"Has a value";
-- true
```

## `??` {#nco}

Check whether either of two values are [truthy](/docs/surrealql/datamodel/values#values-and-truthiness) and not `NONE` or `NULL`.

```surql
/**[test]

[[test.results]]
value = "[0]"

*/

SELECT * FROM NULL ?? 0 ?? false ?? 10;

-- 0
```

<br />

## `?:` {#tco}

Check whether either of two values are [truthy](/docs/surrealql/datamodel/values#values-and-truthiness).

```surql
/**[test]

[[test.results]]
value = "[10]"

*/

SELECT * FROM NULL ?: 0 ?: false ?: 10;

-- 10
```

<br />

## `=` or `IS` {#equal}

Check whether two values are equal.

```surql
/**[test]

[[test.results]]
value = "[false]"

*/

SELECT * FROM true = "true";
-- false
```

```surql
/**[test]

[[test.results]]
value = "[false]"

*/

SELECT * FROM 10 = "10";
-- false
```

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM 10 = 10.00;
-- true
```
```surql
/**[test]

[[test.results]]
value = "[false]"

*/

SELECT * FROM 10 = "10.3";
-- false
```

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM [1, 2, 3] = [1, 2, 3];
-- true
```

```surql
/**[test]

[[test.results]]
value = "[false]"

*/

SELECT * FROM [1, 2, 3] = [1, 2, 3, 4];
-- false
```

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM { this: "object" } = { this: "object" };
-- true
```

```surql
/**[test]

[[test.results]]
value = "[false]"

*/

SELECT * FROM { this: "object" } = { another: "object" };
-- false
```

<br />

## `!=` or `IS NOT` {#notequal}

Check whether two values are equal.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM 10 != "15";
-- true
```

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM 10 != "test";
-- true
```

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM [1, 2, 3] != [3, 4, 5];
-- true
```

<br />

## `==` {#exact}

Check whether two values are exact. This operator also checks that each value has the same type.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM 10 == 10;
-- true
```

```surql
/**[test]

[[test.results]]
value = "[false]"

*/

SELECT * FROM 10 == "10";
-- false
```

```surql
/**[test]

[[test.results]]
value = "[false]"

*/

SELECT * FROM true == "true";
-- false
```

<br />

## `?=` {#anyequal}

Check whether any value in an array equals another value.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM [10, 15, 20] ?= 10;
-- true
```

<br />

## `*=` {#allequal}

Check whether all values in an array equals another value.

```surql
/**[test]

[[test.results]]
value = ""

*/

SELECT * FROM [10, 10, 10] *= 10;
-- true
```

<br />

## `~` `?~` `!~` `*~` {#match}

These operators used to compare two values for equality using fuzzy matching. They have been removed since 3.0 to avoid implicitly preferring one algorithm over another, as the type of fuzzy matching to use will depend on each individual case.

Please use the `string::similarity::*` functions instead:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "true"

*/

let $threshold = 10;

string::similarity::smithwaterman("test text", "Test") > $threshold;
-- true
```

<br />

## `<` {#lessthan}

Check whether a value is less than another value.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM 10 < 15;
-- true
```

<br />

## `<=` {#lessthanorequal}

Check whether a value is less than or equal to another value.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM 10 <= 15;
-- true
```

<br />

## `>` {#greaterthan}

Check whether a value is less than another value.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM 15 > 10;
-- true
```

<br />

## `>=` {#greaterthanorequal}

Check whether a value is less than or equal to another value.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM 15 >= 10;
-- true
```

<br />

## `+` {#add}

Add two values together.

```surql
/**[test]

[[test.results]]
value = "[20]"

*/

SELECT * FROM 10 + 10;
-- 20
```

```surql
/**[test]

[[test.results]]
value = "['test this']"

*/

SELECT * FROM "test" + " " + "this";
-- "test this"
```

```surql
/**[test]

[[test.results]]
value = "[13h30m]"

*/

SELECT * FROM 13h + 30m;
-- "13h30m"
```

<br />

## `-` {#sub}

Subtracts a value from another value.

```surql
/**[test]

[[test.results]]
value = "[10]"

*/

SELECT * FROM 20 - 10;
-- 10
```

```surql
/**[test]

[[test.results]]
value = "[1m]""

*/

SELECT * FROM 2m - 1m;
-- 1m
```

<br />

## `*` or `×` {#mul}

Multiplies a value by another value.

```surql
/**[test]

[[test.results]]
value = "[40]"

*/

SELECT * FROM 20 * 2;
-- 40
```

<br />

## `/` or `÷` {#div}

Divides a value with another value.

```surql
/**[test]

[[test.results]]
value = "[10]"

*/

SELECT * FROM 20 / 2;
-- 10
```

<br />

## `**` {#pow}

Raises a base value by another value.

```surql
/**[test]

[[test.results]]
value = "[8000]"

*/

SELECT * FROM 20 ** 3;
-- 8000
```

<br />

## `CONTAINS` or `∋` {#contains}

Check whether a value contains another value.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM [10, 20, 30] CONTAINS 10;
-- true
```

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM "this is some text" CONTAINS "text";
-- true
```

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM {
	type: "Polygon",
	coordinates: [[
		[-0.38314819, 51.37692386], [0.1785278, 51.37692386],
		[0.1785278, 51.61460570], [-0.38314819, 51.61460570],
		[-0.38314819, 51.37692386]
	]]
} CONTAINS (-0.118092, 51.509865);

-- true
```

<br />

## `CONTAINSNOT` or `∌` {#containsnot}

Check whether a value does not contain another value.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM [10, 20, 30] CONTAINSNOT 15;
-- true
```

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM "this is some text" CONTAINSNOT "other";
-- true
```

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM {
	type: "Polygon",
	coordinates: [[
		[-0.38314819, 51.37692386], [0.1785278, 51.37692386],
		[0.1785278, 51.61460570], [-0.38314819, 51.61460570],
		[-0.38314819, 51.37692386]
	]]
} CONTAINSNOT (-0.518092, 53.509865);

-- true
```

<br />

## `CONTAINSALL` or `⊇` {#containsall}

Check whether a value contains all of multiple values.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM [10, 20, 30] CONTAINSALL [10, 20, 10];
-- true
```

<br />

## `CONTAINSANY` or `⊃` {#containsany}

Check whether a value contains any of multiple values.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM [10, 20, 30] CONTAINSANY [10, 15, 25];
-- true
```

<br />

## `INSIDE` or `∈` or `IN` {#inside}

Check whether a value is contained within another value.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM 10 INSIDE [10, 20, 30];
-- true
```

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM "text" INSIDE "this is some text";
-- true
```

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM (-0.118092, 51.509865) INSIDE {
	type: "Polygon",
	coordinates: [[
		[-0.38314819, 51.37692386], [0.1785278, 51.37692386],
		[0.1785278, 51.61460570], [-0.38314819, 51.61460570],
		[-0.38314819, 51.37692386]
	]]
};

true
```

<Since v="v2.1.0" />

This operator can also be used to check for the existence of a key inside an [object](/docs/surrealql/datamodel/objects). To do so, precede `IN` with the field name as a string.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

"name" IN {
    name: "Riga",
    country: "Latvia"
};

-- true
```

`IN` can also be used with a record ID as long as the ID is expanded to include the fields. Both of the following queries will return `true`.

```surql
/**[test]

[[test.results]]
value = "[{ country: 'Latvia', id: city:riga, name: 'Riga', population: 605273 }]"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

*/

CREATE city:riga SET name = "Riga", country = "Latvia", population = 605273;

"name" IN city:riga.*;
"name" IN city:riga.{ name, country };
```

<br />

## `NOTINSIDE` or `∉` or `NOT IN` {#notinside}

Check whether a value is not contained within another value.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM 15 NOTINSIDE [10, 20, 30];
-- true
```

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM "other" NOTINSIDE "this is some text";
-- true
```

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM (-0.518092, 53.509865) NOTINSIDE {
	type: "Polygon",
	coordinates: [[
		[-0.38314819, 51.37692386], [0.1785278, 51.37692386],
		[0.1785278, 51.61460570], [-0.38314819, 51.61460570],
		[-0.38314819, 51.37692386]
	]]
};

-- true
```

<br />

## `ALLINSIDE` or `⊆` {#allinside}

Check whether all of multiple values are contained within another value.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM [10, 20, 10] ALLINSIDE [10, 20, 30];
-- true
```

<br />

## `ANYINSIDE` or `⊂` {#anyinside}

Check whether any of multiple values are contained within another value.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM [10, 15, 25] ANYINSIDE [10, 20, 30];
-- true
```

<br />

## `NONEINSIDE` or `⊄` {#noneinside}

Check whether none of multiple values are contained within another value.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM [15, 25, 35] NONEINSIDE [10, 20, 30];
-- true
```

<br />

## `OUTSIDE` {#outside}
Check whether a geometry value is outside another geometry value.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM (-0.518092, 53.509865) OUTSIDE {
	type: "Polygon",
	coordinates: [[
		[-0.38314819, 51.37692386], [0.1785278, 51.37692386],
		[0.1785278, 51.61460570], [-0.38314819, 51.61460570],
		[-0.38314819, 51.37692386]
	]]
};

-- true
```

<br />

## `INTERSECTS` {#intersects}
Check whether a geometry value intersects another geometry value.

```surql
/**[test]

[[test.results]]
value = "[true]"

*/

SELECT * FROM {
	type: "Polygon",
	coordinates: [[
		[-0.38314819, 51.37692386], [0.1785278, 51.37692386],
		[0.1785278, 51.61460570], [-0.38314819, 51.61460570],
		[-0.38314819, 51.37692386]
	]]
} INTERSECTS {
	type: "Polygon",
	coordinates: [[
		[-0.11123657, 51.53160074], [-0.16925811, 51.51921169],
		[-0.11466979, 51.48223813], [-0.07381439, 51.51322956],
		[-0.11123657, 51.53160074]
	]]
};

-- true
```

<br />

## `MATCHES` {#matches}

Checks whether the terms are found in a full-text indexed field.

```surql
SELECT * FROM book WHERE title @@ 'rust web';


[
	{
		id: book:1,
		title: 'Rust Web Programming'
	}
]
```
Using the matches operator with a reference checks whether the terms are found, highlights the searched terms, and computes the full-text score.

```surql
SELECT id,
		search::highlight('<b>', '</b>', 1) AS title,
		search::score(1) AS score
FROM book
WHERE title @1@ 'rust web'
ORDER BY score DESC;

[
	{
		id: book:1,
		score: 0.9227996468544006f,
		title: '<b>Rust</b> <b>Web</b> Programming'
	}
]
```

<Since v="v3.0.0-alpha.8" />

### `AND`, `OR`, and numeric operators inside `@@`

The keywords `AND` and can be included inside the matches operator, while the keyword `OR` can also be used if an index is defined with the `FULLTEXT ANALYZER` clause instead of the `SEARCH ANALYZER` clause.

```surql
/**[test]

[[test.results]]
value = "[{ id: document:1, text: 'It is rare that I find myself penning a personal note in my chronicles.' }]"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

CREATE document:1 SET text = "It is rare that I find myself penning a personal note in my chronicles.";
DEFINE ANALYZER simple TOKENIZERS blank,class FILTERS lowercase;
DEFINE INDEX some_index ON document FIELDS text FULLTEXT ANALYZER simple BM25;
```

Manually using `AND` and `OR` outside of the matches operator has always been possible. Both of these queries will return `document:1` because both words match in the first case using `AND`, and one matches in the second case using `OR`.

```surql
SELECT id FROM document WHERE text @@ 'PERSONAL' AND text @@ 'INCLUSION';
SELECT id FROM document WHERE text @@ 'PERSONAL' OR text @@ 'cat';
```

## `KNN`

<Since v="v1.3.0" />

K-Nearest Neighbors (KNN) is a fundamental algorithm used for classifying or regressing based on the closest data points in the feature space, with its performance and scalability critical in applications involving large datasets.

In practice, the efficiency and scalability of the KNN algorithm are crucial, especially when dealing with large datasets. Different implementations of KNN are tailored to optimize these aspects without compromising the accuracy of the results.

SurrealDB supports different K-Nearest Neighbors methods to perform KNN searches, each with unique requirements for syntax.
Below are the details for each method, including how to format your query with examples:

### Brute Force Method

Best for smaller datasets or when the highest accuracy is required.

```syntax title="SurrealQL Syntax"
<|K,DISTANCE_METRIC|>
```

- K: The number of nearest neighbors to retrieve.
- DISTANCE_METRIC: The metric used to calculate distances, such as EUCLIDEAN or MANHATTAN.

```surql
/**[test]

[[test.results]]
value = "[{ id: pts:3, point: [8, 9, 10, 11] }]"

[[test.results]]
value = "[{ id: pts:3 }]"

*/

CREATE pts:3 SET point = [8,9,10,11];
SELECT id FROM pts WHERE point <|2,EUCLIDEAN|> [2,3,4,5];
```

### HNSW Method

<Since v="v1.5.0" />

Recommended for very large datasets where speed is essential and some loss of accuracy is acceptable.

```syntax title="SurrealQL Syntax"
<|K,EF|>
```

- K: The number of nearest neighbors.
- EF: The size of the dynamic candidate list during the search, affecting the search's accuracy and speed.

```surql
/**[test]

[[test.results]]
value = "[{ id: pts:3, point: [8, 9, 10, 11] }]"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: pts:3 }]"

*/

CREATE pts:3 SET point = [8,9,10,11];
DEFINE INDEX mt_pts ON pts FIELDS point HNSW DIMENSION 4 DIST EUCLIDEAN EFC 150 M 12;
SELECT id FROM pts WHERE point <|10,40|> [2,3,4,5];
```
<br /><br />

## Types of operators, order of operations and binding power

To determine which operator is executed first, a concept called "binding power" is used. Operators with greater binding power will operate directly on their neighbours before those with lower binding power. The following is a list of all operator types from greatest to lowest binding power.

<Table>
	<thead>
		<tr>
			<th scope="col" class="w-40">Operator name</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Type">
				`Unary`
			</td>
			<td scope="row" data-label="Description">
				The `Unary` operators are `!`, `+`, and `-`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`Nullish`
			</td>
			<td scope="row" data-label="Description">
				The `Nullish` operators are `?:` and `??`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`Range`
			</td>
			<td scope="row" data-label="Description">
				The `Range` operator is `..`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`Cast`
			</td>
			<td scope="row" data-label="Description">
				The `Cast` operator is `<type_name>`, with `type_name` a stand in for the type to cast into. For example, `<string>` or `<number>`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`Power`
			</td>
			<td scope="row" data-label="Description">
				The only `Power` operator is `**`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`MulDiv`
			</td>
			<td scope="row" data-label="Description">
				The `MulDiv` (multiplication and division) operators are `*`, `/`, `÷`, and `%`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`AddSub`
			</td>
			<td scope="row" data-label="Description">
				The `AddSub` (addition and subtraction) operators are `+` and `-`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`Relation`
			</td>
			<td scope="row" data-label="Description">
				The `Relation` operators are `<=`, `>=`, `∋`, `CONTAINS`, `∌`, `CONTAINSNOT`, `∈`, `INSIDE`, `∉`, `NOTINSIDE`, `⊇`, `CONTAINSALL`, `⊃`, `CONTAINSANY`, `⊅`, `CONTAINSNONE`, `⊆`, `ALLINSIDE`, `⊂`, `ANYINSIDE`, `⊄`, `NONEINSIDE`, `OUTSIDE`, `INTERSECTS`, `NOT`, and `IN`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`Equality`
			</td>
			<td scope="row" data-label="Description">
				The `Equality` operators are `=`, `IS`, `==`, `!=`, `*=`, `?=`, and `@`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`And`
			</td>
			<td scope="row" data-label="Description">
				The `And` operators are `&&` and `AND`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`Or`
			</td>
			<td scope="row" data-label="Description">
				The `Or` operators are `||` and `OR`.
			</td>
		</tr>
	</tbody>
</Table>

## Examples of binding power

The following samples show examples of basic operations of varying binding power. The original example is followed by the same example with the parts with higher binding power in parentheses, then the final expression after the first bound portion is calculated, and finally the output.

```surql title="MulDiv first, then AddSub"
/**[test]

[[test.results]]
value = "13"

[[test.results]]
value = "13"

[[test.results]]
value = "13"

[[test.results]]
value = "13"

*/
 
1 + 3 * 4;
1 + (3 * 4);
-- Final expression
1 + 12;
-- Output
13
```

```surql title="Power first, then MulDiv"
/**[test]

[[test.results]]
value = "24"

[[test.results]]
value = "24"

[[test.results]]
value = "24"

[[test.results]]
value = "24"

*/
 
2**3 * 3;
(2**3) * 3;
-- Final expression
8*3;
-- Output
24
```

```surql title="Unary first, then cast"
/**[test]

[[test.results]]
value = "'-4'"

[[test.results]]
value = "'-4'"

[[test.results]]
value = "'-4'"

*/

<string>-4;
<string>(-4);
-- Output
"-4"
```

```surql title="Cast first, then Power"
/**[test]

[[test.results]]
value = "387420489"

[[test.results]]
value = "387420489"

[[test.results]]
value = "387420489"

[[test.results]]
value = "387420489"

*/
 
<number>"9"**9;
(<number>"9")**9;
-- Final expression
9**9;
-- Output
387420489
```

```surql title="AddSub first, then Relation"
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"
*/
 
"c" + "at" IN "cats";
("c" + "at") IN "cats";
-- Final expression
"cat" IN "cats";
-- Output
true
```

```surql title="And first, then Or"
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

*/
 
true AND false OR true;
(true AND false) OR true;
-- Final expression
false OR true;
-- Output
true
```

```surql title="Unary, then Cast, then Power, then AddSub"
/**[test]

[[test.results]]
value = "20dec"

[[test.results]]
value = "20dec"

[[test.results]]
value = "20dec"

*/
 
<decimal>-4**2+4;
((<decimal>(-4))**2)+4;
-- Output
20dec
```


================================================
FILE: src/content/doc-surrealql/parameters.mdx
================================================
---
sidebar_position: 6
sidebar_label: Parameters
title: Parameters | SurrealQL
description: Parameters can be used like variables to store a value which can then be used in a subsequent query.
---

import Since from '@components/shared/Since.astro'
import Label from "@components/shared/Label.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Parameters

Parameters can be used like variables to store a value which can then be used in subsequent queries. To define a parameter in SurrealQL, use the [`LET`](../surrealql/statements/let) statement. The name of the parameter should begin with a `$` character.

## Defining parameters within SurrealQL

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: person:hw8ha95g4gbegaox34gw, name: 'Tobie Morgan Hitchcock' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: person:q4htgstrmm5j4mvisnhp, name: 'Jaime Morgan Hitchcock' }]"
skip-record-id-key = true

*/

-- Define the parameter
LET $suffix = "Morgan Hitchcock";
-- Use the parameter
CREATE person SET name = "Tobie " + $suffix;
-- (Another way to do the same)
CREATE person SET name = string::join(" ", "Jaime", $suffix);
```

```surql title="Response"
[
    {
        "id": "person:3vs17lb9eso9m7gd8mml",
        "name": "Tobie Morgan Hitchcock"
    }
]

[
    {
        "id": "person:xh4zbns5mgmywe6bo1pi",
        "name": "Jaime Morgan Hitchcock"
    }
]
```

A parameter can store any value, including the result of a query.

```surql
-- Assuming the CREATE statements from the previous example
LET $founders = (SELECT * FROM person);
RETURN $founders.name;
```

```surql title="Response"
[
    "Tobie Morgan Hitchcock",
    "Jaime Morgan Hitchcock"
]
```

Parameters persist across the current connection, and thus can be reused between different namespaces and databases. In the example below, a created `person` record assigned to a parameter is reused in a query in a completely different namespace and database.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
error = "'Thrown error: Database record `person:billy` already exists'"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "'Thrown error: Database record `person:billy` already exists'"

*/

LET $billy = CREATE ONLY person:billy SET name = "Billy";
-- Fails as `person:billy` already exists
CREATE person CONTENT $billy;

USE NAMESPACE other_namespace;
USE DATABASE other_database;
-- Succeeds as `person:billy` does not yet exist in this namespace and database
CREATE person CONTENT $billy;
```

Parameters can be defined using SurrealQL as shown above, or can be passed in using the client libraries as request variables.

## Redefining and shadowing parameters

Parameters in SurrealQL are immutable. The same parameter can be redefined using a `LET` statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "'Sypha'"

*/

LET $my_name = "Alucard";
LET $my_name = "Sypha";
RETURN $my_name;
```

```surql title="Output"
'Sypha'
```

Before SurrealDB 3.0, the `=` on its own was used as syntactic sugar for a `LET` statement. This has since been deprecated in order to make it clearer that parameters can be redeclared, but not modified.

<Tabs>
  <TabItem label="Before 3.X" default>
```surql
LET $my_name = "Alucard";
$my_name = "Sypha";
RETURN $my_name;
```

```surql title="Output"
'Sypha'
```
</TabItem>
  <TabItem label="Since 3.X">
```surql
LET $my_name = "Alucard";
$my_name = "Sypha";
RETURN $my_name;
```

```surql title="Output"
'There was a problem with the database: Parse error: Variable declaration without `let` is deprecated
 --> [4:1]
  |
4 | $my_name = "Sypha";
  | ^^^^^^^^^^^^^^^^^^^ replace with `let $my_name = ..`
'
```
  </TabItem>
</Tabs>

If the parameter is redefined inside another scope, the original value will be shadowed. Shadowing refers to when a value is temporarily obstructed by a new value of the same name until the new scope has completed.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[1, 2, 3, 4]"

[[test.results]]
value = "[[1, 2], [3, 4]]"

*/

LET $nums = [
    [1,2],
    [3,4]
];

{
    LET $nums = $nums.flatten();
    -- Flattened into a single array,
    -- so $nums is shadowed as [1,2,3,4]
    RETURN $nums;
};

-- Returns original unflattened $nums:
-- [[1,2], [3,4]]
RETURN $nums;
```

Even a parameter defined using a [`DEFINE PARAM`](/docs/surrealql/statements/define/param) statement can be shadowed.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

DEFINE PARAM $USERNAME VALUE "user@user.com";

LET $USERNAME = "some other email";
```

However, the parameter `$USERNAME` in this case is still defined as its original value, as can be seen via an [`INFO FOR DB`](/docs/surrealql/statements/info) statement.

```surql
{
	accesses: {},
	analyzers: {},
	apis: {},
	configs: {},
	functions: {},
	models: {},
	params: {
		USERNAME: "DEFINE PARAM $USERNAME VALUE 'user@user.com' PERMISSIONS FULL"
	},
	tables: {},
	users: {}
}
```

As the shadowed `$USERNAME` parameter will persist over the length of the connection, the parameter `$USERNAME` will once again show up as its original defined value if the connection is discontinued and restarted.

## Defining parameters within client libraries

SurrealDB's client libraries allow parameters to be passed in as JSON values, which are then converted to SurrealDB data types when the query is run. The following example show a variable being used within a SurrealQL query from the JavaScript library.

```javascript
let people = await surreal.query("SELECT * FROM article WHERE status INSIDE $status", {
	status: ["live", "draft"],
});
```

## Reserved variable names

SurrealDB automatically predefines certain variables depending on the type of operation being performed. For example, `$this` and `$parent` are automatically predefined for subqueries so that the fields of one can be compared to another if necessary. In addition, the predefined variables `$access`, `$auth`, `$token`, and `$session` are protected variables used to give access to parts of the current database configuration and can never be overwritten.

```surql
/**[test]

[[test.results]]
error = ""Thrown error: 'access' is a protected variable and cannot be set""

[[test.results]]
error = ""Thrown error: 'auth' is a protected variable and cannot be set""

[[test.results]]
error = ""Thrown error: 'token' is a protected variable and cannot be set""

[[test.results]]
error = ""Thrown error: 'session' is a protected variable and cannot be set""

*/

LET $access = true;
LET $auth = 10;
LET $token = "Mytoken";
LET $session = rand::int(0, 100);
```

```surql title="Output"
-------- Query 1 --------

"'access' is a protected variable and cannot be set"

-------- Query 2 --------

"'auth' is a protected variable and cannot be set"

-------- Query 3 --------

"'token' is a protected variable and cannot be set"

-------- Query 4 --------

"'session' is a protected variable and cannot be set"
```

Other predefined variables listed below are not specifically protected, but should not be used in order to avoid unexpected behaviour.

### $access

Represents the name of the access method used to authenticate the current session.

```surql
IF $access = "admin" { SELECT * FROM account }
ELSE IF $access = "user" { SELECT * FROM $auth.account }
ELSE {}
```

### $action, $file, $target

These three parameters are used in the context of the permissions of a [`DEFINE BUCKET`](/docs/surrealql/statements/define/bucket) statement.

* `$action` represents the type of operation: one of "Put", "Get", "Head", "Delete", "Copy", "Rename", "Exists", and "List".
* `$file` represents the path to the file being accessed.
* `$target` represents the target file ref in copy/rename operations.

### $auth

Represents the currently authenticated record user.

```surql
DEFINE TABLE user SCHEMAFULL
    PERMISSIONS
        FOR select, update, delete WHERE id = $auth.id;
```

### $before, $after

Represent the values before and after a mutation on a field.

```surql
/**[test]

[[test.results]]
value = "[{ id: cat:f148lyh3zygwenur9nck, name: 'Mr. Meow', nicknames: ['Mr. Cuddlebun'] }]"
skip-record-id-key = true

[[test.results]]
value = "[{ after: { id: cat:f148lyh3zygwenur9nck, name: 'Mr. Meow', nicknames: ['Mr. Cuddlebun', 'Snuggles'] }, before: { id: cat:f148lyh3zygwenur9nck, name: 'Mr. Meow', nicknames: ['Mr. Cuddlebun'] } }]"
skip-record-id-key = true

*/

CREATE cat SET name = "Mr. Meow", nicknames = ["Mr. Cuddlebun"];
UPDATE cat SET nicknames += "Snuggles" WHERE name = "Mr. Meow" RETURN $before, $after;
```

```surql title="Response"
[
    {
        "after": {
            "id": "cat:6p71csv2zqianixf0dkz",
            "name": "Mr. Meow",
            "nicknames": [
                "Mr. Cuddlebun",
                "Snuggles"
            ]
        },
        "before": {
            "id": "cat:6p71csv2zqianixf0dkz",
            "name": "Mr. Meow",
            "nicknames": [
                "Mr. Cuddlebun"
            ]
        }
    }
]
```

### $event

Represents the type of table event triggered on an event. This parameter will be one of either `"CREATE"`, `"UPDATE"`, or `"DELETE"`.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE EVENT user_created ON TABLE user WHEN $event = "CREATE" THEN (
    CREATE log SET table = "user", event = $event, created_at = time::now()
);
```

### $input

Represents the initially inputted value in a field definition, as the value clause could have modified the $value variable.

```surql
/**[test]

[[test.results]]
value = "[{ historical_data: [], id: city:london, population: 8900000, year: 2019 }]"

[[test.results]]
value = "[{ historical_data: [{ population: 8900000, year: 2019 }], id: city:london, population: 9600000, year: 2023 }]"

*/

CREATE city:london SET
    population = 8900000,
    year = 2019,
    historical_data = [];

INSERT INTO city [
    { id: "london", population: 9600000, year: 2023 }
]
ON DUPLICATE KEY UPDATE
-- Stick old data into historical_data
historical_data += {
    year: year,
    population: population
},
-- Then update current record with the new input using $input
population = $input.population,
year = $input.year;
```

```surql output="Response"
[
    {
        "historical_data": [
            {
                "population": 8900000,
                "year": 2019
            }
        ],
        "id": "city:london",
        "population": 9600000,
        "year": 2023
    }
]
```

### $parent, $this

`$this` represents the current record in a subquery, and `$parent` its parent.

```surql
/**[test]

[[test.results]]
value = "[{ id: user:uz4nrrdn0xybrceh4bm9, member_of: 'group1', name: 'User1' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: user:07o9ep802fiorrr936u5, member_of: 'group1', name: 'User2' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: user:ij9yjba7n2428yz8nui0, member_of: 'group1', name: 'User3' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ group_members: ['User2', 'User3', 'User1'], name: 'User1' }]"

*/

CREATE user SET name = "User1", member_of = "group1";
CREATE user SET name = "User2", member_of = "group1";
CREATE user SET name = "User3", member_of = "group1";
SELECT name, 
    (SELECT VALUE name FROM user WHERE member_of = $parent.member_of)
    AS group_members
    FROM user
    WHERE name = "User1";
```

```surql title="Response"
[
    {
        "group_members": [
            "User1",
            "User3",
            "User2"
        ],
        "name": "User1"
    }
]
```

```surql
/**[test]

[[test.results]]
value = "[{ id: person:trgs6t98z3j5zlxsx1x5, name: 'John Doe' }, { id: person:xiysvpvqvglklrwy9tt5, name: 'John Doe' }, { id: person:qdpkqcb8gu5tt8jocuc8, name: 'Jane Doe' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: person:qdpkqcb8gu5tt8jocuc8, name: 'Jane Doe', people_with_same_name: [person:qdpkqcb8gu5tt8jocuc8] }, { id: person:trgs6t98z3j5zlxsx1x5, name: 'John Doe', people_with_same_name: [person:trgs6t98z3j5zlxsx1x5, person:xiysvpvqvglklrwy9tt5] }, { id: person:xiysvpvqvglklrwy9tt5, name: 'John Doe', people_with_same_name: [person:trgs6t98z3j5zlxsx1x5, person:xiysvpvqvglklrwy9tt5] }]"
skip-record-id-key = true

*/

INSERT INTO person (name) VALUES ("John Doe"), ("John Doe"), ("Jane Doe");
SELECT 
    *,
    (SELECT VALUE id FROM person WHERE $this.name = $parent.name) AS 
    people_with_same_name
    FROM person;
```

```surql title="Response"
[
    {
        "id": "person:hwffcckiv61ylwiw43yf",
        "name": "John Doe",
        "people_with_same_name": [
            "person:hwffcckiv61ylwiw43yf",
            "person:tmscoy7bjj20xki0fld5"
        ]
    },
    {
        "id": "person:tmscoy7bjj20xki0fld5",
        "name": "John Doe",
        "people_with_same_name": [
            "person:hwffcckiv61ylwiw43yf",
            "person:tmscoy7bjj20xki0fld5"
        ]
    },
    {
        "id": "person:y7mdf3912rf5gynvxc7q",
        "name": "Jane Doe",
        "people_with_same_name": [
            "person:y7mdf3912rf5gynvxc7q"
        ]
    }
]
```

### $reference

This parameter represents the reference in question inside an [`ON DELETE`](/docs/surrealql/datamodel/references#specifying-deletion-behaviour) clause for record references.

### $request

This parameter represents the value of a request to a custom API defined using the [`DEFINE API`](/docs/surrealql/statements/define/api) statement.

```surql
DEFINE API OVERWRITE "/test"
    FOR get, post 
        MIDDLEWARE
            api::req::raw_body(false)
        THEN {
            RETURN {
                status: 404,
                body: $request.body,
                headers: {
                    'bla': '123'
                }
            };
        };
```

The `$request` parameter may contain values at the following fields: `body`, `headers`, `method`, `query`, and `params`.

### $session

Represents values from the session functions as an object.

You can learn more about those values from the [security parameters](/docs/surrealdb/security/authentication#session) section.

```surql
CREATE user SET 
    name = "Some User",
    on_database = $session.db;
```

```surql title="Response"
[
    {
        "id": "user:wa3ajflozlqoyurc4i4v",
        "name": "Some User",
        "on_database": "database"
    }
]
```

### $token

Represents values held inside the JWT token used for the current session.

You can learn more about those values from the [security parameters](/docs/surrealdb/security/authentication#token) section.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE TABLE user SCHEMAFULL
  PERMISSIONS FOR select, update, delete, create
  WHERE $access = "users"
  AND email = $token.email;
```

### $value

Represents the value after a mutation on a field (identical to $after in the case of an event).

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE EVENT email ON TABLE user WHEN $before.email != $after.email THEN (
    CREATE event SET 
        user = $value.id,
        time = time::now(),
        value = $after.email,
        action = 'email_changed'
);
```

## Improvements to parameters and expressions in statements

<Since v="v3.0.0-alpha.10" />

Parameters and expressions have traditionally only been available in a limited fashion in SurrealQL statements. As of the alpha versions of SurrealDB 3.0, work is undergoing to allow parameters and expressions to be used in many places that were not possible before.

Some examples of this are:

### DEFINE statements

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ language_en: 'DEFINE TABLE language_en TYPE NORMAL SCHEMAFULL PERMISSIONS NONE', language_ie: 'DEFINE TABLE language_ie TYPE NORMAL SCHEMAFULL PERMISSIONS NONE', language_ja: 'DEFINE TABLE language_ja TYPE NORMAL SCHEMAFULL PERMISSIONS NONE', language_uk: 'DEFINE TABLE language_uk TYPE NORMAL SCHEMAFULL PERMISSIONS NONE', user: "DEFINE TABLE user TYPE NORMAL SCHEMAFULL PERMISSIONS FOR select, create, update, delete WHERE $access = 'users' AND email = $token.email" }"

*/

FOR $language IN ["en", "ja", "uk", "ie"] {
    DEFINE TABLE "language_" + $language SCHEMAFULL;
};

(INFO FOR DB).tables;
```

```surql title="Output"
{
	language_en: 'DEFINE TABLE language_en TYPE NORMAL SCHEMAFULL PERMISSIONS NONE',
	language_ie: 'DEFINE TABLE language_ie TYPE NORMAL SCHEMAFULL PERMISSIONS NONE',
	language_ja: 'DEFINE TABLE language_ja TYPE NORMAL SCHEMAFULL PERMISSIONS NONE',
	language_uk: 'DEFINE TABLE language_uk TYPE NORMAL SCHEMAFULL PERMISSIONS NONE'
}
```

### REMOVE statements

Parameterization in `REMOVE` statements is particularly useful in the context of testing.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

FOR $table IN ["test_user", "test_client"] {
    DEFINE TABLE $table;
    // Do some tests
    REMOVE TABLE $table;
};
```

The following example shows an example of a test that might be performed using a `REMOVE FIELD` statement. Here, the `INFO FOR TABLE` statement is used to dynamically capture the defined fields of a table, followed by the [object::keys()](/docs/surrealql/functions/database/object#objectkeys) function to retrieve each field as a string. The fields can then be removed one by one inside a `REMOVE FIELD` statement, with the time elapsed logged in a separate table.

```surql
DEFINE FIELD string_test ON test TYPE string;
DEFINE FIELD int_test ON test TYPE int;
DEFINE FIELD datetime_test ON test TYPE datetime;

CREATE |test:10000| SET 
    string_test = rand::string(10),
    int_test = rand::int(),
    datetime_test = rand::time()
RETURN NONE;

FOR $field IN (INFO FOR TABLE test).fields.keys() {
    LET $now = time::now();
    REMOVE FIELD $field ON test;
    LET $elapsed = time::now() - $now;
    CREATE log SET results = { field_name: $field, removed_in: $elapsed }
};
```

### The TIMEOUT clause in queries

```surql
DEFINE FUNCTION fn::get_timeout() -> duration {
    // Do some HTTP call to get status
    // Simulate the output with rand::enum() function
    rand::enum(100ms, 1s, 5s)
};

SELECT * FROM person TIMEOUT fn::get_timeout();
```

### The OMIT clause in queries

```surql
/**[test]

[[test.results]]
value = "[{ age: 19, id: person:v5tk0ctrk8vjgpsjsr2n, name: 'Galen', surname: 'Pathwarden' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ age: 19, surname: 'Pathwarden' }]"

*/

CREATE person SET name = "Galen", surname = "Pathwarden", age = 19;

SELECT * OMIT type::fields(["name", "id"]) FROM person;
```

```surql title="Output"
[
	{
		age: 19,
		surname: 'Pathwarden'
	}
]
```


================================================
FILE: src/content/doc-surrealql/transactions.mdx
================================================
---
sidebar_position: 7
sidebar_label: Transactions
title: Transactions | SurrealQL
description: Each statement within SurrealDB is run within its own transaction, or within client defined transactions that can contain multiple statements.
---

# Transactions

Each statement within SurrealDB is run within its own transaction by default. If a set of changes need to be made together, then groups of statements can be run together as a single transaction. If all of the statements within a transaction succeed, and the transaction is successful, then all of the data modifications made during the transaction are committed and become a permanent part of the database. If a transaction encounters errors and must be cancelled or rolled back, then any data modification made within the transaction is rolled back, and will not become a permanent part of the database.

## Starting a transaction

The `BEGIN` or `BEGIN TRANSACTION` statement starts a transaction in which multiple statements can be run together.

```surql title="Starting a transaction"
BEGIN [ TRANSACTION ];
```

The following query shows example usage of this statement.

```surql title="Example usage of BEGIN TRANSACTION"
/**[test]

[[test.results]]
value = "[{ balance: 135605.16f, id: account:one }]"

[[test.results]]
value = "[{ balance: 91031.31f, id: account:two }]"

[[test.results]]
value = "[{ balance: 135905.16f, id: account:one }]"

[[test.results]]
value = "[{ balance: 90731.31f, id: account:two }]"

*/

-- Start a new database transaction. Transactions are a way to ensure multiple operations
-- either all succeed or all fail, maintaining data integrity.
BEGIN TRANSACTION;

-- Create a new account with the ID 'one' and set its initial balance to 135605.16
CREATE account:one SET balance = 135605.16;

-- Create another new account with the ID 'two' and set its initial balance to 91031.31
CREATE account:two SET balance = 91031.31;

-- Update the balance of account 'one' by adding 300.00 to the current balance.
-- This could represent a deposit or other form of credit on the balance property.
UPDATE account:one SET balance += 300.00;

-- Update the balance of account 'two' by subtracting 300.00 from the current balance.
-- This could represent a withdrawal or other form of debit on the balance property.
UPDATE account:two SET balance -= 300.00;

-- Finalize the transaction. This will apply the changes to the database. If there was an error
-- during any of the previous steps within the transaction, all changes would be rolled back and
-- the database would remain in its initial state.
COMMIT TRANSACTION;
```

## Committing a transaction

The [COMMIT](/docs/surrealql/statements/commit) statement is used to commit a set of statements within a transaction, ensuring that all data modifications become a permanent part of the database.

```surql title="Committing a transaction"
COMMIT [ TRANSACTION ];
```

The following query shows example usage of this statement.

```surql title="Example usage of COMMIT TRANSACTION"
/**[test]

[[test.results]]
value = "[{ balance: 135605.16f, id: account:one }]"

[[test.results]]
value = "[{ balance: 91031.31f, id: account:two }]"

[[test.results]]
value = "[{ balance: 135905.16f, id: account:one }]"

[[test.results]]
value = "[{ balance: 90731.31f, id: account:two }]"

*/

BEGIN TRANSACTION;

-- Setup accounts
CREATE account:one SET balance = 135605.16;
CREATE account:two SET balance = 91031.31;

-- Move money
UPDATE account:one SET balance += 300.00;
UPDATE account:two SET balance -= 300.00;

-- Finalise all changes
COMMIT TRANSACTION;
```

## Cancelling a transaction

The [CANCEL](/docs/surrealql/statements/cancel) statement can be used to cancel a set of statements within a transaction, reverting or rolling back any data modification made within the transaction as a whole.

```surql title="Cancelling a transaction"
CANCEL [ TRANSACTION ];
```

The following query shows example usage of this statement.

```surql title="Example usage of CANCEL TRANSACTION"
/**[test]

[[test.results]]
error = "'Thrown error: The query was not executed due to a cancelled transaction'"

[[test.results]]
error = "'Thrown error: The query was not executed due to a cancelled transaction'"

[[test.results]]
error = "'Thrown error: The query was not executed due to a cancelled transaction'"

[[test.results]]
error = "'Thrown error: The query was not executed due to a cancelled transaction'"

*/

BEGIN TRANSACTION;

-- Setup accounts
CREATE account:one SET balance = 135605.16;
CREATE account:two SET balance = 91031.31;

-- Move money
UPDATE account:one SET balance += 300.00;
UPDATE account:two SET balance -= 300.00;

-- Rollback all changes
CANCEL TRANSACTION;
```

## THROW to conditionally cancel a transaction

While transactions are automatically rolled back if an error occurs in any of its statements, [THROW](/docs/surrealql/statements/throw) can also be used to explicitly break out of a transaction at any point. `THROW` can be followed by any value which serves as the error message, usually a string.

```surql
BEGIN TRANSACTION;

CREATE account:one SET dollars =  100;
CREATE account:two SET dollars =  100;

LET $transfer_amount = 150;
UPDATE account:one SET dollars -= $transfer_amount;
UPDATE account:two SET dollars += $transfer_amount;
IF account:one.dollars < 0 {
    THROW "Insufficient funds, would have $" + <string>account:one.dollars + " after transfer"
};
COMMIT TRANSACTION;
SELECT * FROM account;
```

```surql title="Output when $transfer_amount set to 150"
'An error occurred: Insufficient funds, would have $-50 after transfer'
```

```surql title="Output when $transfer_amount set to 50"
[
	{
		dollars: 50,
		id: account:one
	},
	{
		dollars: 150,
		id: account:two
	}
]
```

## Using transactions to test code for errors

As failed transactions automatically roll back any changes made, a transaction with a final `THROW` statement can be used as a confirmation that no errors have taken place inside a group of queries.

Take the following example that creates a unique index and then inserts some records to make sure that the database logic is functioning as expected. However, as names are not necessarily unique, the index soon gives an error and cancels the transaction before `THROW` can be reached.

```surql
BEGIN TRANSACTION;
DEFINE INDEX unique_name ON TABLE person FIELDS name UNIQUE;

INSERT INTO person [
    { name: 'Agatha Christie', born: d'1890-09-15' },
    { name: 'Billy Billerson', born: d'1979-09-11' },
	-- Pretend there are is 10,000 more objects here
    { name: 'Agatha Christie', born: d'1955-05-15' },
];

THROW "Reached the end";
COMMIT TRANSACTION;
```

The output is not the expected 'An error occurred: Reached the end' message, showing that not all queries were successful.

```surql title="Output"
"Database index `unique_name` already contains 'Agatha Christie', with record `person:qs4bpvl96sf9x40b3567`"
```

If the index is redefined to be less strict, the statetements will work and the expected output will be reached, confirming that no errors occurred during the test.

```surql
BEGIN TRANSACTION;
DEFINE INDEX OVERWRITE unique_person ON TABLE person FIELDS name, born UNIQUE;

INSERT INTO person [
    { name: 'Agatha Christie', born: d'1890-09-15' },
    { name: 'Billy Billerson', born: d'1979-09-11' },
    { name: 'Agatha Christie', born: d'1955-05-15' },
];

THROW "Reached the end";
COMMIT TRANSACTION;
```

```surql title="Expected output"
'An error occurred: Reached the end'
```


================================================
FILE: src/content/doc-surrealql/clauses/explain.mdx
================================================
---
sidebar_position: 1
sidebar_label: EXPLAIN
title: EXPLAIN clause | SurrealQL
description: The `EXPLAIN` clause is used to explain the query plan of a query.
---


# `EXPLAIN` clause

The `EXPLAIN` clause is used to explain the query plan of a query. It is particularly useful when you want to understand how a query is executed and how it is optimized by the database.

When `EXPLAIN` is used, the statement returns an explanation, essentially revealing the execution plan to provide transparency and understanding of the query performance.
## Syntax

```syntax title="Clause Syntax"
@query EXPLAIN [FULL]
```

Using the `EXPLAIN` clause in addition to the `FULL` keyword is expeciallly useful when you want to understand the performance of a query and can provide more details when debugging.

## Examples

For example, consider the performance of the following query when the field `email` is not indexed. We can see that the execution plan will iterate over the whole table.

```surql title="Index not used"
/**[test]

[[test.results]]
value = "[{ address: '1 Bagshot Row', email: 'tobie@surrealdb.com', id: person:tobie, name: 'Tobie' }]"

[[test.results]]
value = "[{ detail: { direction: 'forward', table: 'person' }, operation: 'Iterate Table' }, { detail: { type: 'Memory' }, operation: 'Collector' }]"

[[test.results]]
value = "[{ detail: { direction: 'forward', table: 'person' }, operation: 'Iterate Table' }, { detail: { type: 'Memory' }, operation: 'Collector' }, { detail: { type: 'KeysAndValues' }, operation: 'RecordStrategy' }, { detail: { count: 1 }, operation: 'Fetch' }]"

*/

CREATE person:tobie SET
	name = "Tobie",
	address = "1 Bagshot Row",
	email = "tobie@surrealdb.com";

SELECT * FROM person WHERE email='tobie@surrealdb.com' EXPLAIN;
SELECT * FROM person WHERE email='tobie@surrealdb.com' EXPLAIN FULL;
```

```surql title="Output"
-------- Query --------

[
	{
		detail: {
			direction: 'forward',
			table: 'person'
		},
		operation: 'Iterate Table'
	},
	{
		detail: {
			type: 'Memory'
		},
		operation: 'Collector'
	}
]

-------- Query --------

[
	{
		detail: {
			direction: 'forward',
			table: 'person'
		},
		operation: 'Iterate Table'
	},
	{
		detail: {
			type: 'Memory'
		},
		operation: 'Collector'
	},
	{
		detail: {
			type: 'KeysAndValues'
		},
		operation: 'RecordStrategy'
	},
	{
		detail: {
			count: 1
		},
		operation: 'Fetch'
	}
]
```

On the other hand, here is the result when the field `email` is indexed. We can see that the execution plan will use the index to retrieve the record.

```surql title="Index used"
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ address: '1 Bagshot Row', email: 'tobie@surrealdb.com', id: person:tobie, name: 'Tobie' }]"

[[test.results]]
value = "[{ detail: { plan: { index: 'fast_email', operator: '=', value: 'tobie@surrealdb.com' }, table: 'person' }, operation: 'Iterate Index' }, { detail: { type: 'Memory' }, operation: 'Collector' }]"

[[test.results]]
value = "[{ detail: { plan: { index: 'fast_email', operator: '=', value: 'tobie@surrealdb.com' }, table: 'person' }, operation: 'Iterate Index' }, { detail: { type: 'Memory' }, operation: 'Collector' }, { detail: { type: 'KeysAndValues' }, operation: 'RecordStrategy' }, { detail: { count: 1 }, operation: 'Fetch' }]"

*/

DEFINE INDEX fast_email ON TABLE person FIELDS email;

CREATE person:tobie SET
	name = "Tobie",
	address = "1 Bagshot Row",
	email = "tobie@surrealdb.com";

SELECT * FROM person WHERE email='tobie@surrealdb.com' EXPLAIN;
SELECT * FROM person WHERE email='tobie@surrealdb.com' EXPLAIN FULL;    
```

```surql title="Output"
-------- Query --------

[
	{
		detail: {
			plan: {
				index: 'fast_email',
				operator: '=',
				value: 'tobie@surrealdb.com'
			},
			table: 'person'
		},
		operation: 'Iterate Index'
	},
	{
		detail: {
			type: 'Memory'
		},
		operation: 'Collector'
	}
]

-------- Query --------

[
	{
		detail: {
			plan: {
				index: 'fast_email',
				operator: '=',
				value: 'tobie@surrealdb.com'
			},
			table: 'person'
		},
		operation: 'Iterate Index'
	},
	{
		detail: {
			type: 'Memory'
		},
		operation: 'Collector'
	},
	{
		detail: {
			type: 'KeysAndValues'
		},
		operation: 'RecordStrategy'
	},
	{
		detail: {
			count: 1
		},
		operation: 'Fetch'
	}
]
```


================================================
FILE: src/content/doc-surrealql/clauses/fetch.mdx
================================================
---
sidebar_position: 1
sidebar_label: FETCH
title: FETCH clause | SurrealQL
description: The `FETCH` clause is used to fetch records from a table.
---
import SurrealistMini from "@components/SurrealistMini.astro";

# `FETCH` clause

The `FETCH` clause is used to retrieve related records or data from other tables in a single query. This is particularly useful when you want to gather data that is linked through relationships ([record links](/docs/surrealql/datamodel/records) or [graph edges](/docs/surrealql/statements/relate)) without having to perform multiple separate queries.

## Benefits of Using the `FETCH` Clause

- Efficiency: By using the FETCH clause, you can reduce the number of queries needed to gather related data. This can lead to performance improvements, especially when dealing with complex data models with multiple relationships.

- Simplified Queries: It simplifies your queries by allowing you to specify related data to be fetched directly within the same query. This makes your code cleaner and easier to understand.

- Reduced Network Overhead: Fetching related data in a single query reduces the number of round trips to the database, which can decrease network latency and improve the overall speed of your application.

- Consistency: By fetching related data in one go, you ensure that the data is consistent and up-to-date at the time of retrieval, reducing the risk of discrepancies that might occur if data is fetched in separate queries.

## Example Usage

Suppose you have a person table and a post table, where each post is related to a person. You can use the FETCH clause to retrieve a person along with their posts in a single query:

```surql
SELECT * FROM person FETCH posts;
```

In this example, `posts` would be a related field in the `person` table that links to the `post` table. The `FETCH` clause allows you to retrieve all posts associated with each person in the result set.

Overall, the `FETCH` clause in SurrealQL is a powerful tool for optimizing data retrieval and simplifying query logic when working with related data.

In addition to fetching related records, the `FETCH` clause can also be used to replace record ids with their actual record values. Consider the following example:

<SurrealistMini
	resultMode="single"
	setup={`
		CREATE category SET name = 'Technology', created_at = time::now();
		CREATE person:john SET
			name.first = 'John',
			name.last = 'Adams',
			name.full = string::join(' ', name.first, name.last),
			age = 29,
			admin = true,
			signup_at = time::now();
		CREATE article SET
			created_at = time::now(),
			author = person:john,
			title = 'Lorem ipsum dolor',
			text = 'Donec eleifend, nunc vitae commodo accumsan, mauris est fringilla.',
			category = (SELECT VALUE id FROM ONLY category WHERE name = 'Technology' LIMIT 1);
	`}
	query={`
		SELECT title, category, author.name.full AS author_name FROM article
		WHERE author.age < 30
		FETCH author, category;
	`}
/>

## Without the `FETCH` clause

<SurrealistMini
	resultMode="single"
	setup={`
		CREATE category SET name = 'Technology', created_at = time::now();
		CREATE person:john SET
			name.first = 'John',
			name.last = 'Adams',
			name.full = string::join(' ', name.first, name.last),
			age = 29,
			admin = true,
			signup_at = time::now();
		CREATE article SET
			created_at = time::now(),
			author = person:john,
			title = 'Lorem ipsum dolor',
			text = 'Donec eleifend, nunc vitae commodo accumsan, mauris est fringilla.',
			category = (SELECT VALUE id FROM ONLY category WHERE name = 'Technology' LIMIT 1);
	`}
	query={`
		SELECT title, category, author.name.full AS author_name FROM article
		WHERE author.age < 30;
	`}
/>






================================================
FILE: src/content/doc-surrealql/clauses/from.mdx
================================================
---
sidebar_position: 1
sidebar_label: FROM
title: FROM clause | SurrealQL
description: The `FROM` clause is used to specify the table or view to query.
---

# `FROM` clause

The `FROM` clause is used to specify the table or view to query. It can also be used to specify targets beyond just a single table or record name.

## Syntax

```syntax title="Clause Syntax"
STATEMENT
    [FROM [ONLY] @targets;]
```

## Data retrieval 

One of the most common use cases for the `FROM` clause is to specify the table or view to query. You can use this clause to pull data from single or multiple tables.

```surql title="All the ways you can use the FROM clause"
-- Selects all records from both 'user' and 'admin' tables.
SELECT * FROM user, admin;

-- Selects all records from the table named in the variable '$table',
-- but only if the 'admin' field of those records is true.
-- Equivalent to 'SELECT * FROM user WHERE admin = true'.
LET $table = "user";
SELECT * FROM type::table($table) WHERE admin = true;

-- Selects a single record from:
-- * the table named in the variable '$table',
-- * and the identifier named in the variable '$id'.
-- This query is equivalent to 'SELECT * FROM user:admin'.
LET $table = "user";
LET $id = "admin";
SELECT * FROM type::record($table, $id);

-- Selects all records for specific users 'tobie' and 'jaime',
-- as well as all records for the company 'surrealdb'.
SELECT * FROM user:tobie, user:jaime, company:surrealdb;

-- Selects records from a list of identifiers. The identifiers can be numerical,
-- string, or specific records such as 'person:lrym5gur8hzws72ux5fa'.
SELECT * FROM [3648937, "test", person:lrym5gur8hzws72ux5fa, person:4luro9170uwcv1xrfvby];

-- Selects data from an object that includes a 'person' key,
-- which is associated with a specific person record, and an 'embedded' key set to true.
SELECT * FROM { person: person:lrym5gur8hzws72ux5fa, embedded: true };

-- This command first performs a subquery, which selects all 'user' records and adds a
-- computed 'adult' field that is true if the user's 'age' is 18 or older.
-- The main query then selects all records from this subquery where 'adult' is true.
SELECT * FROM (SELECT age >= 18 AS adult FROM user) WHERE adult = true;
```

### Using the `ONLY` keyword

The `ONLY` keyword can be used to specify that only the specified targets should be retrieved. This is useful when you want to retrieve data from a single table or view. The `ONLY` keyword can be used in conjunction with the `LIMIT` clause to specify that only the specified number of records should be retrieved. 

This keyword can be particularly useful with SDKs as it can guaranteed to have just a single object and that makes it nicer to deserialise.

```surql title="Using the ONLY keyword"
-- Select only the 'user' table.
SELECT * FROM ONLY user:one;

-- Selects only the first 10 records from the 'user' table.
SELECT * FROM ONLY user LIMIT 10;
```







================================================
FILE: src/content/doc-surrealql/clauses/group-by.mdx
================================================
---
sidebar_position: 1
sidebar_label: GROUP BY
title: GROUP BY clause | SurrealQL
description: The `GROUP BY` clause is used to group records by one or more columns.
---

import SurrealistMini from "@components/SurrealistMini.astro";

# `GROUP BY` clause

The `GROUP BY` clause is used in SurrealQL to aggregate data based on one or more columns. It is particularly useful when you want to perform calculations on groups of data, such as counting the number of records, calculating averages, or finding sums for each group. 

This is often used in reporting and data analysis to summarize data in a meaningful way. More specifically, it is used to:

- Aggregating Data: When you need to calculate aggregate values like SUM, COUNT, AVG, MIN, or MAX for each group of data.
- Data Summarization: When you want to summarize data into categories or groups.
- Reporting: When generating reports that require grouped data, such as sales reports by region or department.

## Syntax

```syntax title="Clause Syntax"
GROUP BY @fields
```

## Data representation


```surql
SELECT
    product_id,
    region,
    math::sum(amount) AS total_sales
FROM
    sales
GROUP BY
    product_id, region;
```

Explanation:
- `SELECT product_id, region, math::sum(amount) AS total_sales`: This selects the product_id and region columns and calculates the total sales amount for each group. The `AS` clause is used to rename the calculated column to `total_sales`.

- `FROM sales`: This specifies the table from which to retrieve the data. Using the `FROM` clause, we specify the table `sales` to retrieve the data from.

- `GROUP BY product_id, region`: This groups the results by product_id and region, so the SUM function calculates the total sales for each unique combination of product_id and region.

This query will return a result set where each row represents a unique combination of `product_id` and `region`, along with the total sales amount for that combination. This is useful for understanding how different products are performing in different regions.

<SurrealistMini
	resultMode="single"
	setup={`
INSERT INTO rams [
    { gender: "M", age: 20, country: "Japan" },
    { gender: "M", age: 25, country: "Japan" },
    { gender: "F", age: 23, country: "US" },
    { gender: "F", age: 30, country: "US" },
    { gender: "F", age: 25, country: "Korea" },
    { gender: "F", age: 45, country: "UK" },
];
	`}
	query={`
		SELECT
	count() AS total,
	math::mean(age) AS average_age,
	gender,
	country
FROM rams
GROUP BY gender, country;
	`}
/>






================================================
FILE: src/content/doc-surrealql/clauses/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Clauses
title: Clauses | SurrealQL
description: Clauses are used to 
---

# Clauses

In SurrealQL, clauses can be used to alter the way a query is executed. They are used in the following ways: 

- [`EXPLAIN`](/docs/surrealql/clauses/explain): Explain the query plan.
- [`FETCH`](/docs/surrealql/clauses/fetch): Fetch all the fields of related records.
- [`FROM`](/docs/surrealql/clauses/from): Specify the table(s) or other target(s) to query from.
- [`GROUP BY`](/docs/surrealql/clauses/group-by): Group the results by a set of fields.
- [`LIMIT`](/docs/surrealql/clauses/limit): Limit the number of results.
- [`OMIT`](/docs/surrealql/clauses/omit): Omit related records.
- [`ORDER BY`](/docs/surrealql/clauses/order-by): Specify the sort order of the results.
- [`SPLIT`](/docs/surrealql/clauses/split): Split the results into a set of subqueries.
- [`WHERE`](/docs/surrealql/clauses/where): Specify a condition that acts as a filter.
- [`WITH`](/docs/surrealql/clauses/with): Replace the default table iterator with an index iterator.





================================================
FILE: src/content/doc-surrealql/clauses/limit.mdx
================================================
---
sidebar_position: 1
sidebar_label: LIMIT
title: LIMIT clause | SurrealQL
description: The `LIMIT` clause is used to limit the number of records returned by a query.
---


# `LIMIT` clause

The `LIMIT` clause is used to limit the number of records returned by a query. It is particularly useful when you want to retrieve a specific number of records from a table. 

When using the `LIMIT` clause, it is possible to paginate results by using the `START` clause to start from a specific record from the result set. It is important to note that the `START` count starts from 0.

## Syntax

```syntax title="Clause Syntax"
LIMIT @number [START @start 0]
```

## Examples

```surql
-- Select the first 10 records
SELECT * FROM person LIMIT 10;

-- Start at record 50 and select the following 10 records
SELECT * FROM person LIMIT 10 START 50;
```

```surql
/**[test]

[[test.results]]
value = "[5, 6, 7, 8, 9]"

*/

-- Select the first 5 records from the array
SELECT * FROM [1,2,3,4,5,6,7,8,9,10] LIMIT 5 START 4;
```

```surql title="Result"
[
	5,
	6,
	7,
	8,
	9
]
```

The `LIMIT` clause followed by `1` is often used along with the `ONLY` clause to satisfy the requirement that only up to a single record can be returned.

```surql
-- Record IDs are unique so guaranteed to be no more than 1
SELECT * FROM ONLY person:jamie;

-- Error because no guarantee that this will return a single record
SELECT * FROM ONLY person WHERE name = "Jaime";

-- Add `LIMIT 1` to ensure that only up to one record will be returned
SELECT * FROM ONLY person WHERE name = "Jaime" LIMIT 1;
```




================================================
FILE: src/content/doc-surrealql/clauses/omit.mdx
================================================
---
sidebar_position: 1
sidebar_label: OMIT
title: OMIT clause | SurrealQL
description: The `OMIT` clause is used to omit fields from the result set 
---

# `OMIT` clause

The `OMIT` clause is used to omit fields from the result set which can be particularly useful when querying large datasets.

## Syntax

```syntax title="Clause Syntax"
OMIT @fields FROM @table
```

## Examples

```surql
/**[test]

[[test.results]]
value = "[{ id: person:tobie, name: 'Tobie', opts: { enabled: true, security: 'secure' }, password: '123456' }]"

[[test.results]]
value = "[{ id: person:jaime, name: 'Jaime', opts: { enabled: false, security: 'secure' }, password: 'asdfgh' }]"

[[test.results]]
value = "[{ id: person:jaime, name: 'Jaime', opts: { enabled: false, security: 'secure' }, password: 'asdfgh' }, { id: person:tobie, name: 'Tobie', opts: { enabled: true, security: 'secure' }, password: '123456' }]"

[[test.results]]
value = "[{ id: person:jaime, name: 'Jaime', opts: { enabled: false } }, { id: person:tobie, name: 'Tobie', opts: { enabled: true } }]"

[[test.results]]
value = "[{ id: person:jaime, name: 'Jaime', opts: {  } }, { id: person:tobie, name: 'Tobie', opts: {  } }]"

*/

CREATE person:tobie SET
	name = 'Tobie',
	password = '123456',
	opts.security = 'secure',
	opts.enabled = true;
CREATE person:jaime SET
	name = 'Jaime',
	password = 'asdfgh',
	opts.security = 'secure',
	opts.enabled = false;

SELECT * FROM person;
-- Omit the password field and security field in the options object
SELECT * OMIT password, opts.security FROM person;

-- Using destructuring syntax (since 2.0.0)
SELECT * OMIT password, opts.{ security, enabled } FROM person;
```

```surql title= "Return fields"

-------- Query 3 (132.138µs) --------

[
	{
		id: person:jaime,
		name: 'Jaime',
		opts: {
			enabled: false,
			security: 'secure'
		},
		password: 'asdfgh'
	},
	{
		id: person:tobie,
		name: 'Tobie',
		opts: {
			enabled: true,
			security: 'secure'
		},
		password: '123456'
	}
]

-------- Query 4 (61.876µs) --------

[
	{
		id: person:jaime,
		name: 'Jaime',
		opts: {
			enabled: false
		}
	},
	{
		id: person:tobie,
		name: 'Tobie',
		opts: {
			enabled: true
		}
	}
]

-------- Query 5 (52.152µs) --------

[
	{
		id: person:jaime,
		name: 'Jaime',
		opts: {}
	},
	{
		id: person:tobie,
		name: 'Tobie',
		opts: {}
	}
]
```





================================================
FILE: src/content/doc-surrealql/clauses/order-by.mdx
================================================
---
sidebar_position: 1
sidebar_label: ORDER BY
title: ORDER BY clause | SurrealQL
description: The `ORDER BY` clause specifies the sort order of the records in a table.
---

# `ORDER BY` clause

To sort records, SurrealDB allows ordering on multiple fields and nested fields. Use the `ORDER BY` clause to specify a comma-separated list of field names that should be used to order the resulting records. 

The `ASC` and `DESC` keywords can be used to specify whether results should be sorted in an ascending or descending manner. The `COLLATE` keyword can be used to use Unicode collation when ordering text in string values, ensuring that different cases, and different languages are sorted in a consistent manner. Finally, the `NUMERIC` can be used to correctly sort text which contains numeric values.

It is also worth noting that `COLLATE` ignores unicode order. e.g. 'á' comes after 'z' by default (Unicode sorting) but with `COLLATE` 'á' comes before 'z'.

## Syntax

```syntax title="Clause Syntax"
[ ORDER [ BY ] 
	@field [ COLLATE ] [ NUMERIC ] [ ASC | DESC ], ...
	| RAND() ]
]
```

## Examples


```surql
SELECT * FROM <table> ORDER BY <field> ASC;
```

```surql 

-- Order records randomly
SELECT * FROM <table> ORDER BY rand();

-- Order records descending by a single field
SELECT * FROM <table> ORDER BY <field> DESC;

-- Order records by multiple fields independently
SELECT * FROM <table> ORDER BY <field> ASC, <field2> DESC;

-- Order text fields with lexical collation instead of Unicode order
SELECT * FROM <table> ORDER BY <field> COLLATE ASC;

-- Order text fields with which include numeric values
SELECT * FROM <table> ORDER BY <field> NUMERIC ASC;

-- COLLATE and NUMERIC can be used together
SELECT * FROM <table> ORDER BY <field> COLLATE NUMERIC ASC;
```


================================================
FILE: src/content/doc-surrealql/clauses/split.mdx
================================================
---
sidebar_position: 1
sidebar_label: SPLIT
title: SPLIT clause | SurrealQL
description: The SPLIT clause in SurrealQL is used to split the results of a query based on a specific field, particularly when dealing with arrays.
---

# `SPLIT` clause

The `SPLIT` clause in SurrealQL is used to split the results of a query based on a specific field, particularly when dealing with arrays. This is useful in scenarios where you want to treat each element of an array as a separate row in the result set. It can be particularly helpful in data analysis contexts where you need to work with individual elements of an array separately.

## Syntax

```syntax title="Clause Syntax"
SPLIT [ON] @field
```

Suppose you have a user table with a field emails that contains an array of email addresses for each user. You want to list each email address as a separate record.

Here's how you can use the SPLIT clause in SurrealQL:

```surql
/**[test]

[[test.results]]
value = "[{ emails: ['john@example.com', 'doe@example.com'], id: user:jhjsg6c9ta32gdut36b8, name: 'John Doe' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ emails: 'john@example.com', id: user:jhjsg6c9ta32gdut36b8, name: 'John Doe' }, { emails: 'doe@example.com', id: user:jhjsg6c9ta32gdut36b8, name: 'John Doe' }]"
skip-record-id-key = true

*/
CREATE user SET
    name = "John Doe",
    emails = ["john@example.com", "doe@example.com"];

-- Split the results by each value in the emails array
SELECT * FROM user SPLIT emails;
```

Explanation:
- `CREATE user SET ...`: This creates a user record with a name and an array of email addresses.
- `SELECT * FROM user SPLIT emails`: This query selects all fields from the user table and splits the results based on the emails field. Each email address in the `emails` array will now be in a field of the same name that only contains a single value.

Output:
The output of the query will be:

```surql
[
	{
		emails: 'john@example.com',
		id: user:unjgil312jvvxfbdj706,
		name: 'John Doe'
	},
	{
		emails: 'doe@example.com',
		id: user:unjgil312jvvxfbdj706,
		name: 'John Doe'
	}
]
```

## Using `SPLIT` to restructure collected paths

One practical use case with `SPLIT` is returning every possible combination of the relations inside multiple graph paths. For instance, take the following data below that represents the relations between Canada the country, its provinces, and their cities.

```surql
/**[test]

[[test.results]]
value = "[{ id: country:canada }]"

[[test.results]]
value = "[{ id: province:bc }, { id: province:alberta }]"

[[test.results]]
value = "[{ id: city:vancouver }, { id: city:victoria }, { id: city:edmonton }, { id: city:calgary }]"

[[test.results]]
value = "[{ id: in:5bgf21urlmudhbv87weh, in: city:vancouver, out: province:bc }, { id: in:nt3jd2nxdf28t1eeg7uz, in: city:victoria, out: province:bc }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: in:6iqjlca9vrnrcotwfb0a, in: city:edmonton, out: province:alberta }, { id: in:56xr5okh0jbmd5d34r0a, in: city:calgary, out: province:alberta }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: in:gr88pyx3de7nrsm63uo2, in: province:bc, out: country:canada }, { id: in:fidjczbmblc01syn4gzd, in: province:alberta, out: country:canada }]"
skip-record-id-key = true

*/

CREATE country:canada;
CREATE province:bc, province:alberta;
CREATE city:vancouver, city:victoria, city:edmonton, city:calgary;

RELATE [city:vancouver, city:victoria]->in->province:bc;
RELATE [city:edmonton, city:calgary]->in->province:alberta;
RELATE [province:bc, province:alberta]->in->country:canada;
```

A graph query on both of these paths shows all of the provinces and cities.

```surql
SELECT 
    id AS country,
    <-in<-province AS provinces,
    <-in<-province<-in<-city AS cities FROM ONLY country:canada;
```

```surql title="Output"
{
	cities: [
		city:calgary,
		city:edmonton,
		city:vancouver,
		city:victoria
	],
	country: country:canada,
	provinces: [
		province:alberta,
		province:bc
	]
}
```

Using `SPLIT` in this case transforms the output from a collection of paths centred on the `country:canada` record into an array of objects, each representing every possible combination of cities and provinces inside the country.

```surql
SELECT
    id AS country,
    <-in<-province AS province,
    <-in<-province<-in<-city AS city FROM country:canada
    SPLIT city, province;
```

```surql title="Output"
[
	{
		city: city:calgary,
		country: country:canada,
		province: province:alberta
	},
	{
		city: city:calgary,
		country: country:canada,
		province: province:bc
	},
	{
		city: city:edmonton,
		country: country:canada,
		province: province:alberta
	},
	{
		city: city:edmonton,
		country: country:canada,
		province: province:bc
	},
	{
		city: city:vancouver,
		country: country:canada,
		province: province:alberta
	},
	{
		city: city:vancouver,
		country: country:canada,
		province: province:bc
	},
	{
		city: city:victoria,
		country: country:canada,
		province: province:alberta
	},
	{
		city: city:victoria,
		country: country:canada,
		province: province:bc
	}
]
```

An example of the same query then mapped into a set of unique keys for serialization:

```surql
(SELECT
    id,
    <-in<-province AS province,
    <-in<-province<-in<-city AS city FROM country:canada
    SPLIT city, province)
.map(|$obj| 
    <string>$obj.id.id() 
    + '|' 
    + <string>$obj.province.id() 
    + '|' 
    + <string>$obj.city.id()
);
```

```surql title="Output"
[
	'canada|alberta|calgary',
	'canada|bc|calgary',
	'canada|alberta|edmonton',
	'canada|bc|edmonton',
	'canada|alberta|vancouver',
	'canada|bc|vancouver',
	'canada|alberta|victoria',
	'canada|bc|victoria'
]
```


================================================
FILE: src/content/doc-surrealql/clauses/where.mdx
================================================
---
sidebar_position: 1
sidebar_label: WHERE
title: WHERE clause | SurrealQL
description: The `WHERE` clause can be used to specify a condition that acts as a filter. 
---

# `WHERE` clause

The `WHERE` clause can be used to specify a condition that acts as a filter. You can use the `WHERE` clause to either filter the result of the FROM clause in a `SELECT` statement or specify which rows to operate on in an `UPDATE`, `MERGE`, or `DELETE` statement.

It can also be used in special cases when working with conditons in [`DEFINE FUNCTION`](/docs/surrealql/statements/define/access) statement or when asserting access control in [`DEFINE TABLE`](/docs/surrealql/statements/define/table) & [`DEFINE FIELD`](/docs/surrealql/statements/define/field) statements.

## Syntax

```syntax title="Clause Syntax"
STATEMENT
    [WHERE condition;]

```

## Conditional record selection

The most common use case for the `WHERE` clause is to filter the result of the `SELECT` statement. It is particularly useful when you want to select a subset of records from a table based on a condition.

```surql
SELECT @fields FROM <TABLE_NAME> WHERE <CONDITION> = <VALUE>;
```

When fetching records from a table, the `WHERE` clause is used to filter the records that are returned.

## Conditional record alteration

The `WHERE` clause can also be used to specify which records to operate on in an `UPDATE`, `MERGE`, or `DELETE` statement.

```surql
UPDATE [TABLE_NAME] SET [FIELDS] WHERE [CONDITION] = [VALUE];
```


## Setting conditions in `DEFINE FUNCTION` statements

```surql
/**[test]

[[test.results]]
value = "NONE"

*/
-- Define a function that checks if a relation exists between two nodes
DEFINE FUNCTION fn::relation_exists(
	$in: record,
	$tb: string,
	$out: record
) {
	-- Check if a relation exists between the two nodes.
	LET $results = SELECT VALUE id FROM type::table($tb) WHERE in = $in AND out = $out;
	-- Return true if a relation exists, false otherwise
    RETURN array::len($results) > 0;
};
```

## Setting permissions conditions in `DEFINE TABLE` statements 

The `WHERE` clause can be used to specify the conditions for the permissions of a table and based on the conditions, the permissions are applied to the table CRUD operations.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/
-- Specify access permissions for the 'post' table
DEFINE TABLE post SCHEMALESS
	PERMISSIONS
		FOR select
			-- Published posts can be selected
			WHERE published = true
			-- A user can select all their own posts
			OR user = $auth.id
		FOR create, update
			-- A user can create or update their own posts
			WHERE user = $auth.id
		FOR delete
			-- A user can delete their own posts
			WHERE user = $auth.id
			-- Or an admin can delete any posts
			OR $auth.admin = true
;
```

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Define a relation table, and constrain the type of relation which can be stored
DEFINE TABLE assigned_to SCHEMAFULL TYPE RELATION IN tag OUT sticky
    PERMISSIONS
        FOR create, select, update, delete
            WHERE in.owner == $auth.id AND out.author == $auth.id;
```


================================================
FILE: src/content/doc-surrealql/clauses/with.mdx
================================================
---
sidebar_position: 1
sidebar_label: WITH
title: WITH clause | SurrealQL
description: The `WITH` clause is used to select records from a table with an index, which is a pre-computed lookup table for faster queries.
---

# `WITH` clause


When retrieving data from a table, the query planner can replace the standard table iterator with one or several index iterators based on the structure and requirements of the query. This is particularly useful when querying large datasets, as it can significantly reduce the time it takes to retrieve the data.

However, there may be situations where manual control over these potential optimizations is desired or required. 

The `WITH` clause is used to replace the default table iterator with an index iterator. In cases where the cardinality of an index can be high, potentially even equal to the number of records in the table, the sum of the records iterated by several indexes may end up being larger than the number of records obtained by iterating over the table. 

In such cases, if there are different index possibilities, the most probable optimal choice would be to use the index known with the lowest cardinality.

The query planner can replace the standard table iterator with one or several index iterators based on the structure and requirements of the query.

> [!NOTE]
> If you are using a `SELECT` statement, the `WITH` clause is used to specify the index to use for the query. You can define an index using the [`DEFINE INDEX`](/docs/surrealql/statements/define/indexes) statement. Also see the [`DEFINE ANALYZER`](/docs/surrealql/statements/define/analyzer) statement for more information on optimizing query performance with full-text search.

## Syntax

```syntax title="Clause Syntax"
[ WITH [ NOINDEX | INDEX @indexes ... ]]
```

This clause can be used in the following ways:

- `WITH NOINDEX`: forces the query planner to use the table iterator. (Default)
- `WITH INDEX @indexes`: restricts the query planner to using only the specified index(es)


```surql
-- forces the query planner to use the specified index(es):
SELECT * FROM person
WITH INDEX ft_email
WHERE
	email = 'tobie@surrealdb.com' AND
	company = 'SurrealDB';

-- forces the usage of the table iterator
SELECT name FROM person WITH NOINDEX WHERE job = 'engineer' AND gender = 'm';
```






================================================
FILE: src/content/doc-surrealql/datamodel/arrays.mdx
================================================
---
sidebar_position: 2
sidebar_label: Arrays
title: Arrays | SurrealQL
description: Records in SurrealDB can store arrays of values, with no limit to the depth of the arrays

---

import Since from "@components/shared/Since.astro";

# Arrays

An array is a collection of values contained inside `[]` (square brackets), each of which is stored at a certain index. Individual indexes and slices of indexes can be accesses using the same square bracket syntax.

```surql
/**[test]

[[test.results]]
value = "[1, 2, 3, 4, 5]"

[[test.results]]
value = "1"

[[test.results]]
value = "[1, 2, 3]"

*/

-- Return a full array
RETURN [1,2,3,4,5];
-- Return the first ("zeroeth") item
RETURN [1,2,3,4,5][0];
-- Return indexes 0 up to and including 2 of an array
RETURN [1,2,3,4,5][0..=2];
```

```surql title="Output"
-------- Query 2 (200µs) --------

[
	1,
	2,
	3,
	4,
	5
]

-------- Query 3 (99.999µs) --------

1

-------- Query 4 (100.001µs) --------

[
	1,
	2,
	3
]
```

Working with arrays is one of the most important skills when working with SurrealDB, as [`SELECT`](/docs/surrealql/statements/select) statements return an array of values by default unless the `ONLY` keyword is used on an array that contains a single item.

```surql
/**[test]

[[test.results]]
value = "[9]"

[[test.results]]
value = "9"

[[test.results]]
error = "'Expected a single result output when using the ONLY keyword'"

*/

-- Even this returns an array
SELECT * FROM 9;
-- Use the `ONLY` clause to return a single item
SELECT * FROM ONLY 9;
-- Error: array has more than one item
SELECT * FROM ONLY [1,9];
```

```surql title="Output"
-------- Query 1  --------

[
	9
]

-------- Query 2 --------

9

-------- Query 3 --------

'Expected a single result output when using the ONLY keyword'
```

Similar to Object-based Record IDs, records in SurrealDB can store arrays of values, with no limit to the depth of the arrays. Arrays can store any value stored within them, and can store different value types within the same array.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:0l7qs8rfxw32q8namhnx, results: [{ date: '2017-06-18T08:00:00Z', name: 'Algorithmics', score: 76 }, { date: '2018-03-21T08:00:00Z', name: 'Concurrent Programming', score: 83 }, { date: '2018-09-17T08:00:00Z', name: 'Advanced Computer Science 101', score: 69 }, { date: '2019-04-20T08:00:00Z', name: 'Distributed Databases', score: 73 }] }]"
skip-record-id-key = true

*/

CREATE person SET results = [
	{ score: 76, date: "2017-06-18T08:00:00Z", name: "Algorithmics" },
	{ score: 83, date: "2018-03-21T08:00:00Z", name: "Concurrent Programming" },
	{ score: 69, date: "2018-09-17T08:00:00Z", name: "Advanced Computer Science 101" },
	{ score: 73, date: "2019-04-20T08:00:00Z", name: "Distributed Databases" },
];
```

A maximum number of items can be specified for an array.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
error = ""Couldn't coerce value for field `employees` of `team:2pjsv6kmzs0x06ortqfl`: Expected `array<record<employee>,5>` but found an collection of length `6`""

*/

DEFINE FIELD employees ON TABLE team TYPE array<record<employee>, 5>;
CREATE team SET employees = [
	employee:one, 
	employee:two, 
	employee:three, 
	employee:four, 
	employee:five, 
	employee:doesnt_belong
];
```

```surql title="Response"
"Couldn't coerce value for field `employees` of `team:2pjsv6kmzs0x06ortqfl`: Expected `array<record<employee>,5>` but found an collection of length `6`"
```

## Mapping and filtering on arrays

The `[]` operator after an array can also be used to filter the items inside an array. The parameter `$this` is used to refer to each individual item, while `WHERE` (or its alias `?`, a question mark) is used to set the condition for the item to pass the filter.

```surql
/**[test]

[[test.results]]
value = "[true, true]"

*/
[true, false, true][WHERE $this = true];
```

```surql title="Output"
[true, true]
```

If a `WHERE` or `?` clause finds an item that by itself is not equal to `true` or `false`, it will check the item's [truthiness](/docs/surrealql/datamodel/values#values-and-truthiness) to determine whether to pass it on or not.

```surql
/**[test]

[[test.results]]
value = "[1, 2]"

*/

[1,2,NONE][? $this];

-- [1, 2]
```

Filtering can be repeated if desired.

```surql
/**[test]

[[test.results]]
value = "[{ first_mayor: 'Papa Smurf', name: 'Smurfville', population: 55 }]"

*/

[
    {
        name: "Boston",
        population: NONE,
        first_mayor: "John Phillips"
    },
    {
        name: "Smurfville",
        population: 55,
        first_mayor: "Papa Smurf"
    },
    {
        name: "Harrisburg",
        population: 50183,
        first_mayor: NONE
    }
][WHERE $this.population]
 [WHERE $this.first_mayor];
```

```surql title="Output"
[
	{
		first_mayor: 'Papa Smurf',
		name: 'Smurfville',
		population: 55
	}
]
```

## Sets

A `set` is a subtype of an array, identical in all respects except that the values inside it are automatically deduplicated.

```surql
/**[test]

[[test.results]]
value = "[1, 2]"

*/

RETURN <set>[1,1,2];

-- Returns [1,2]
```

As such, a field defined as a `set` can take an `array` as its input and vice versa. This next example shows the [`object::keys()`](/docs/surrealql/functions/database/object#objectkeys) function, which returns an array, used to populate a field defined as an `option<set<string>>`.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ cards: { clubs: ['queen', '10'], diamonds: ['king'], hearts: ['jack', '2'], spades: [] }, id: hand:mrzw5p2yyad6dzym9pk0, suits: ['clubs', 'diamonds', 'hearts', 'spades'] }]"
skip-record-id-key = true

*/

DEFINE FIELD suits ON TABLE hand TYPE option<set<string>> VALUE object::keys(cards);

CREATE hand SET cards = {
    clubs: [
        "queen", "10"
    ],
    hearts: [
        "jack", "2"    
    ],
    spades: [
        
    ],
    diamonds: [
        "king"
    ]
};
```

```surql title="Output"
[
	{
		cards: {
			clubs: [
				'queen',
				'10'
			],
			diamonds: [
				'king'
			],
			hearts: [
				'jack',
				'2'
			],
			spades: []
		},
		id: hand:1jjihflcim7iisi7z55x,
		suits: [
			'clubs',
			'diamonds',
			'hearts',
			'spades'
		]
	}
]
```

<Since v="v2.0.0" />

## Filtering and mapping with array functions

SurrealDB also includes a number of methods for arrays that make it easier to filter and map. These methods take a closure (an anonymous function) that works in a similar way to the `$this` parameter above.

Here is an example of the `array::filter()` method being used in contrast to the classic `WHERE` syntax. Note that the parameter name inside the closure is named by the user, so `$val` in the example below could be `$v` or `$some_val` or anything else.

```surql
/**[test]

[[test.results]]
value = "[3, 5]"

[[test.results]]
value = "[3, 5]"

*/

[1,3,5].filter(|$val| $val > 2);
[1,3,5][WHERE $this > 2];

-- [3,5]
```

While the [array functions](/docs/surrealql/functions/database/array) section of the documentation contains the full details of each function, the following examples provide a glimpse into how they are commonly used.

The [`array::map()`](/docs/surrealql/functions/database/array#arraymap) function provides access to each item in an array, allowing an opearation to be performed on it before being passed on.

```surql
/**[test]

[[test.results]]
value = "[2, 3, 4]"

*/

[1,2,3].map(|$item| $item + 1);

-- [2,3,4]
```

If desired, a second parameter can be passed in that holds the index of the item.

```surql
/**[test]

[[test.results]]
value = "['At index 0 we got a 1!', 'At index 1 we got a 2!', 'At index 2 we got a 3!']"

*/

[1,2,3].map(|$v, $i| "At index " + <string>$i + " we got a " + <string>$v + "!");
```

```surql title="Output"
[
	'At index 0 we got a 1!',
	'At index 1 we got a 2!',
	'At index 2 we got a 3!'
]
```

Chaining these methods one after another is a convenient way to validate and modify data in a single statement. The example below removes any items with a `NONE`, checks to see if a the location data is a valid geometric point, and then returns the remaining items as objects with a different structure.

```surql
/**[test]

[[test.results]]
value = "[{ coordinates: (98, 65.7), item: 0, name: 'Some city' }, { coordinates: (0, 0.1), item: 1, name: 'Other city' }]"

*/

[
	NONE,
	{
		at: (98, 65.7),
		name: "Some city"
	},
	{
		at: (-190.7, 0),
		name: NONE
	},
    {
        name: "Other city",
        at: (0.0, 0.1)
    },
	{
        name: "Nonexistent city",
        at: (200.0, 66.5)
    }
]
    .filter(|$v| $v != NONE AND $v.name != NONE)
    .filter(|$v| $v.at.is_valid())
    .map(|$v, $i| {
        item: $i,
        name: $v.name,
        coordinates: $v.at
    });
```

```surql title="Output"
[
	{
		coordinates: (98, 65.7),
		item: 0,
		name: 'Some city'
	},
	{
		coordinates: (0, 0.1),
		item: 1,
		name: 'Other city'
	}
]
```

## Adding arrays

<Since v="v3.0.0-alpha.3" />

An array can be added to another array, resulting in a single array consisting of the items of the first followed by those of the second. This is identical to the `array::concat()` function.

```surql
/**[test]

[[test.results]]
value = "[1, 2, 3, 4]"

[[test.results]]
value = "[1, 2, 3, 4]"

*/

[1,2] + [3,4];
[1,2].concat([3,4]);
```

```surql title="Output"
[1,2,3,4]
```


================================================
FILE: src/content/doc-surrealql/datamodel/booleans.mdx
================================================
---
sidebar_position: 3
sidebar_label: Booleans
title: Booleans | SurrealQL
description: Boolean values in SurrealDB can be used to mark whether a field is true or false

---

# Booleans

Boolean values can be used to mark whether a field is `true` or `false`.

```surql
CREATE person SET newsletter = false, interested = true;
```

Many SurrealDB operators and functions return booleans.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:jhn1rlhusqypyyyy0gjg, name: 'Billy', name_is_billy: true, name_is_long: false }]"
skip-record-id-key = true

*/


CREATE person SET 
    name = "Billy", 
    name_is_billy = name = "Billy",
    name_is_long = string::len(name) > 10;
```

```surql title="Response"
[
	{
		id: person:7j4t4higwb141v1v2xum,
		name: 'Billy',
		name_is_billy: true,
		name_is_long: false
	}
]
```

Boolean values can be written in anycase.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:1vyseg5ig08xn1ie3h43, interested: true, newsletter: false, very_interested: true }]"
skip-record-id-key = true

*/

CREATE person SET 
    newsletter = FALSE,
    interested = True,
    very_interested = trUE;
```

## Booleans in `WHERE` clauses

When performing a query on the database, accessing a record's ID directly or using a [record range](/docs/surrealql/datamodel/ids#record-ranges) allows performance to be significantly sped up by avoiding the table scan which is used when a `WHERE` clause is included.

However, if a `WHERE` clause is unavoidable, performance can still be improved by simplifying the portion after the clause as much as possible. As a boolean is the simplest possible datatype, having a boolean field that can be used in a `WHERE` clause can significantly improve performance compared to a more complex operation.

```surql
/**[test]

[[test.results]]
value = "[]"

[[test.results]]
value = "[]"

[[test.results]]
value = "[{ data_length: 3, id: person:one, is_short: true, random_data: 'HI!' }]"

[[test.results]]
value = "[{ data_length: 3, id: person:one, is_short: true, random_data: 'HI!' }]"

[[test.results]]
value = "[{ data_length: 3, id: person:one, is_short: true, random_data: 'HI!' }]"

[[test.results]]
value = "[{ data_length: 3, id: person:one, is_short: true, random_data: 'HI!' }]"

*/
-- Fill up the database a bit with 10,000 records
CREATE |person:10000| SET
    random_data = rand::string(1000),
    data_length = random_data.len(),
    is_short = data_length < 10 RETURN NONE;
-- Add one outlier
CREATE person:one SET
    random_data = "HI!",
    data_length = random_data.len(),
    is_short = data_length < 10 RETURN NONE;

-- Function call + compare operation: slowest
SELECT * FROM person WHERE random_data.len() < 10;
-- Compare operation: much faster
SELECT * FROM person WHERE data_length < 10;
-- Boolean check: even faster
SELECT * FROM person WHERE is_short;
-- Direct record access: almost instantaneous
SELECT * FROM person:one;
```


================================================
FILE: src/content/doc-surrealql/datamodel/bytes.mdx
================================================
---
sidebar_position: 4
sidebar_label: Bytes
title: Bytes | SurrealQL
description: A value that represents the bytes used ubiquitously in computer hardware.

---

import Since from '@components/shared/Since.astro'

# Bytes

Bytes can be created by casting from a string, and are displayed using hexidecimal encoding.

```surql
/**[test]

[[test.results]]
value = "b"4920616D20736F6D65206279746573""

*/

<bytes>"I am some bytes";
```

```surql title="Output"
b"4920616D20736F6D65206279746573"
```

## Conversion from other types

<Since v="v3.0.0-alpha.1" />

Since SurrealDB 2.3.0, conversions can be performed between bytes, strings, and arrays.

```surql
/**[test]

[[test.results]]
value = "'cellar door'"

[[test.results]]
value = "[72, 111, 98, 98, 105, 116, 115]""

*/

-- array<int> to bytes to string
<string><bytes>[ 99, 101, 108, 108, 97, 114, 32, 100, 111, 111, 114 ];
-- string to bytes to array<int>
<array><bytes>"Hobbits";
```

```surql title="Output"
-------- Query --------

'cellar door'

-------- Query --------

[ 72, 111, 98, 98, 105, 116, 115 ]
```

## Byte strings

<Since v="v3.0.0-alpha.1" />

A string preceded by a `b` prefix can be turned into bytes as long as the string represents a hexidecimal value.

```surql
b"486F6262697473";

<string>b"486F6262697473";

<string>b"This won't work though";
```

```surql title="Output"
-------- Query --------

b"486F6262697473";

-------- Query --------

'Hobbits'

-------- Query --------

"There was a problem with the database: Parse error: Unexpected character `T` expected hexidecimal digit
 --> [1:11]
  |
1 | <string>b\"This won't work though\";
  |           ^ 
"
```


================================================
FILE: src/content/doc-surrealql/datamodel/casting.mdx
================================================
---
sidebar_position: 5
sidebar_label: Casting
title: Casting | SurrealQL
description: In the SurrealDB type system, values can be converted to other values efficiently.

---

import Table from '@components/shared/Table.astro'

# Casting

In the SurrealDB type system, values can be converted to other values efficiently. This is useful if input is specified in a query which must be of a certain type, or if a user may have provided a parameter with an incorrect type.

<Table>
    <thead>
        <tr>
            <th scope="col" class="w-40">Type</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#array"><code>&lt;array&gt;</code></a>
            </td>
            <td scope="row" data-label="Description">
                Casts the subsequent value into an array
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#arrayt"><code>&lt;array&lt;T&gt;&gt;</code></a>
            </td>
            <td scope="row" data-label="Description">
                Casts the subsequent value into an array of <code>T</code>
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#bool"><code>&lt;bool&gt;</code></a>
            </td>
            <td scope="row" data-label="Description">
                Casts the subsequent value into a boolean
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#datetime"><code>&lt;datetime&gt;</code></a>
            </td>
            <td scope="row" data-label="Description">
                Casts the subsequent value into a datetime
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#decimal"><code>&lt;decimal&gt;</code></a>
            </td>
            <td scope="row" data-label="Description">
                Casts the subsequent value into a decimal
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#duration"><code>&lt;duration&gt;</code></a>
            </td>
            <td scope="row" data-label="Description">
                Casts the subsequent value into a duration
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#float"><code>&lt;float&gt;</code></a>
            </td>
            <td scope="row" data-label="Description">
                Casts the subsequent value into a float
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#int"><code>&lt;int&gt;</code></a>
            </td>
            <td scope="row" data-label="Description">
                Casts the subsequent value into a int
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#number"><code>&lt;number&gt;</code></a>
            </td>
            <td scope="row" data-label="Description">
                Casts the subsequent value into a decimal
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#record"><code>&lt;record&gt;</code></a>
            </td>
            <td scope="row" data-label="Description">
                Casts the subsequent value into a record
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#recordt"><code>&lt;record&lt;T&gt;&gt;</code></a>
            </td>
            <td scope="row" data-label="Description">
                Casts the subsequent value into a record of <code>T</code>
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#set"><code>&lt;set&gt;</code></a>
            </td>
            <td scope="row" data-label="Description">
                Casts the subsequent value into a set
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#string"><code>&lt;string&gt;</code></a>
            </td>
            <td scope="row" data-label="Description">
                Casts the subsequent value into a string
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#regex"><code>&lt;regex&gt;</code></a>
            </td>
            <td scope="row" data-label="Description">
                Casts the subsequent value into a regular expression
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#uuid"><code>&lt;uuid&gt;</code></a>
            </td>
            <td scope="row" data-label="Description">
                Casts the subsequent value into a UUID
            </td>
        </tr>
    </tbody>
</Table>

## `<array>`

The `<array>` casting function converts a range into an array.

```surql
/**[test]

[[test.results]]
value = "[1, 2, 3]"

*/

RETURN <array> 1..=3;

[1, 2, 3]
```

## `<array<T>>`

The `<array<T>>` casting function converts a value into an array of the specified type.

>[!NOTE]
>When using this casting function, the value must be an array and each element in the array will be cast to the specified type. 

```surql
/**[test]

[[test.results]]
value = "[42, 314, 271, 137, 141]"

*/

RETURN <array<int>> ["42", "314", "271", "137", "141"];

[42, 314, 271, 137, 141]
```

```surql
/**[test]

[[test.results]]
value = "['42', '314', '271', '137', '141']"

*/

RETURN <array<string>> [42, 314, 271, 137, 141];

['42', '314', '271', '137', '141']
```

A cast into an array of more than one possible type can also be used. In this case, the cast will attempt to cast into the possible types in order. As such, the `string` in the first query below will be cast into a `datetime` but not in the second.

```surql
/**[test]

[[test.results]]
value = "[[d'2020-09-09T00:00:00Z', '21 Jan 2020'], ['2020-09-09', '21 Jan 2020']]"

*/

RETURN [
  <array<datetime|string>>["2020-09-09", "21 Jan 2020"],
  <array<string|datetime>>["2020-09-09", "21 Jan 2020"]
];
```

```surql title="Output"
[
	[
		d'2020-09-09T00:00:00Z',
		'21 Jan 2020'
	],
	[
		'2020-09-09',
		'21 Jan 2020'
	]
]
```

An example of even more complex casting which attempts to cast each item in the input array into a `record<user>`, then `record<person>`, then `array<record<user>>`, and finally `string`.

```surql
/**[test]

[[test.results]]
value = "['person:one', 'user:two', "['user:three', 'user:four']", 'not_a_person_or_user']"

*/

RETURN <array<record<user | person> | array<record<user>> | string>> [
	'person:one',
	'user:two',
	[
		'user:three',
		'user:four'
	],
	'not_a_person_or_user'
];
```

```surql title="Output"
[
	person:one,
	user:two,
	[
		user:three,
		user:four
	],
	'not_a_person_or_user'
]
```

## `<bool>`

The `<bool` casting function converts a value into a boolean.

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN <bool> "true";

true
```

```surql
/**[test]

[[test.results]]
value = "false"

*/

RETURN <bool> "false";

false
```

## `<datetime>`

The `<datetime>` casting function converts a value into a datetime.

```surql
/**[test]

[[test.results]]
value = "d'2025-06-07T00:00:00Z'"

*/

RETURN <datetime> "2025-06-07";

d'2025-06-07T00:00:00Z'
```

## `<decimal>`

The `<decimal>` casting function converts a value into a decimal which allows for 128 bits of precision.

```surql
RETURN <decimal> "13.5729484672938472938410938456";
-- 13.572948467293847293841093846dec
```

Decimal casting should generally not be used to convert from floats with a large number of digits after the decimal point, because the input to the right will first be turned into a less precise float before the cast is performed.

```surql
RETURN <decimal> 13.572948467293847293841093845679289;
-- 13.57294846729385dec

RETURN <decimal> 1.193847193847193847193487E11;
-- 119384719384.7194dec
```

In this case, the `dec` suffix is preferable as it will instruct the database to treat the **input** as a decimal, rather than create a float to then cast into a decimal.

```surql
13.572948467293847293841093845679289dec;
-- 13.572948467293847293841093846dec

1.193847193847193847193487E11dec;
-- 1.193847193847193847193487E11dec;
```

## `<duration>`

The `<duration>` casting function converts a value into a duration.

```surql
/**[test]

[[test.results]]
value = "1h30m"

*/

RETURN <duration> "1h30m";

1h30m
```

<br />

## `<float>`

The `<float>` casting function converts a value into a floating point number. Floating point numbers by nature have a limited amount of precision.

```surql
/**[test]

[[test.results]]
value = "13.572948467293847f"

*/

RETURN <float> 13.572948467293847293841093845679289;

13.572948467293847f
```

```surql
/**[test]

[[test.results]]
value = "13.572948467293847f"

*/

RETURN <float> "13.572948467293847293841093845679289";

13.572948467293847
```

## `<int>`

The `<int>` casting function converts a value into an integer.

```surql
/**[test]

[[test.results]]
value = "53"

*/

RETURN <int> 53;

53
```

## `<number>`

The `<number>` casting function converts a value into a `number`.

```surql
RETURN <number> 13.572948467293847293841093845679289;

"13.572948467293847293841093845679289"
```

```surql
RETURN <number> "13.572948467293847293841093845679289";

"13.572948467293847293841093845679289"
```

```surql
RETURN <number> 1.193847193847193847193487E11;

"119384719384.7193847193487"
```

## `<record>`

The `<record>` casting function converts a value into a record.

Keep in mind when using this casting function that if the equivalent record id does not exist, it will not return anything.

```surql
SELECT id FROM <record> (s"person:hrebrffwm4sr2yifglta");
```

```surql title="Output"
{ id: person:hrebrffwm4sr2yifglta }
```

## `<record<T>>`

The `<record<T>>` casting function converts a value into a record.

Keep in mind when using this casting function that if the equivalent record id does not exist, it will not return anything.

```surql
SELECT id FROM <record> (s"person:hrebrffwm4sr2yifglta");

{ id: person:hrebrffwm4sr2yifglta }
```

A cast into a number of possible record types can also be used.

```surql
/**[test]

[[test.results]]
value = "[user:one, [person:one, user:two]]"

*/

RETURN [
  <record<user|person>>"user:one",
  <array<record<user|person>>>["person:one", "user:two"]
];
```

```surql title="Output"
[
	user:one,
	[
		person:one,
		user:two
	]
]
```

## `<set>` and `<set<T>>`

The `<set>` casting function converts a value into a set. As a set is simply an array with deduplicated items, all of the examples in the [section for arrays](/docs/surrealql/datamodel/casting#array) will work.

```surql
/**[test]

[[test.results]]
value = "[[d'2020-09-09T00:00:00Z', '21 Jan 2020'], ['2020-09-09', '21 Jan 2020']]"

*/

RETURN [
  <set<datetime|string>>["2020-09-09", "21 Jan 2020"],
  <set<string|datetime>>["2020-09-09", "21 Jan 2020"]
];
```

```surql title="Output"
[
	[
		d'2020-09-09T00:00:00Z',
		'21 Jan 2020'
	],
	[
		'2020-09-09',
		'21 Jan 2020'
	]
]
```

Using a `<set>` cast on an existing array is functionally identical to using the [`array::distinct()`](/docs/surrealql/functions/database/array#arraydistinct) function.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[[1, 3, 4], [1, 3, 4]]"

*/

LET $array = [1,1,3,4,4,4,4,4,4];

RETURN [
    $array.distinct(),
    <set>$array
];
```

```surql title="Output"
[
	[
		1,
		3,
		4
	],
	[
		1,
		3,
		4
	]
]
```

## `<string>`

The `<string>` casting function converts a value into a string.

```surql
/**[test]

[[test.results]]
value = "'true'"

*/

RETURN <string> true;

'true'
```

```surql
/**[test]

[[test.results]]
value = "'1.3463f'"

*/

RETURN <string> 1.3463;

'1.3463f'
```

```surql
/**[test]

[[test.results]]
value = "'false'"

*/

RETURN <string> false;

"false"
```

## `<regex>`

The `<regex>` casting function converts a value into a regular expression.

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN <regex> "a|b" = "a";

true
```

```surql
/**[test]

[[test.results]]
value = "false"

*/

RETURN <regex> "a|b" = "c";

false
```

## `<uuid>`

The `<uuid>` casting function converts a value into a UUID.

```surql
SELECT id FROM <uuid> "a8f30d8b-db67-47ec-8b38-ef703e05ad1b";

[ u'a8f30d8b-db67-47ec-8b38-ef703e05ad1b' ]
```

## General notes on casting

### Syntax and order

As the parser ignores spaces and new lines, casting syntax can include spaces or new lines as desired.

```surql
/**[test]

[[test.results]]
value = "['9.1', true, '15h']"

[[test.results]]
value = "['9.1', true, '15h']"

*/

-- Surrealist formatted syntax
RETURN  <array<bool | string | float>> [
	'9.1',
	'true',
	15h
];

-- Maybe someone's preferred syntax
RETURN <array
        <bool | string | float>
      >
[ '9.1', 'true', 15h ];
```

When more than one cast type is specified, SurrealDB will attempt to convert into the type in the order specified. In the example above, while the input `'9.1'` could have been converted to a float, the type `string` comes first in the cast syntax and thus `'9.1'` remains as a string.

```surql title="Output"
[
	'9.1',
	true,
	'15h'
]
```

### Casting vs. affixes

SurrealDB uses a number of affixes to force the parser to treat an input as a certain type instead of another. These affixes may seem at first glance to be identical to casts, as the following queries show.

```surql
/**[test]

[[test.results]]
value = "person:one"

[[test.results]]
value = "person:one"

[[test.results]]
value = "person:one"

[[test.results]]
value = "'person:one'"

[[test.results]]
value = "98dec"

[[test.results]]
value = "98dec"

[[test.results]]
value = "98"

*/

-- All return a record person:one
RETURN r"person:one";
RETURN <record>"person:one";
RETURN <record<person>>"person:one";
-- Returns a string 'person:one'
RETURN "person:one";

-- Both return a decimal 98dec
RETURN 98dec;
RETURN <decimal>98;
-- Returns an int 98
RETURN 98;
```

However, casts and affixes work in different ways:

* A cast is a way to convert from one type into another.
* An affix is an instruction to the parser to treat an input as a certain type.

These differences become clear when working with input that is less than ideal or does not work with a certain type. For example, floats by nature become imprecise after a certain number of digits.

```surql
/**[test]

[[test.results]]
value = "[8.888f, 8.88888888888889f]"

*/

RETURN [
  8.888,
  8.8888888888888888
];
```

```surql title="Output"
[
	8.888f,
	8.88888888888889f
]
```

In this case, a `decimal` can be used which will allow a greater number of digits after the decimal point. However, casting the above numbers into a `decimal` will result in the same inaccurate output.

```surql
/**[test]

[[test.results]]
value = "[8.888dec, 8.88888888888889dec]"

*/

RETURN [
	<decimal>8.888,
	<decimal>8.888888888888888
];
```

```surql title="Output"
[
	8.888dec,
	8.88888888888889dec
]
```

This is because the parser will first treat the number as a float and then cast it into a `decimal`.

However, using the `dec` suffix will inform the parser that the entire input is to be treated as a `decimal` and it will never pass through a stage in which it is a float.

```surql
/**[test]

[[test.results]]
value = "[8.888dec, 8.888888888888888dec]"

*/

RETURN [
	8.888dec,
	8.888888888888888dec
];
```

```surql title="Output"
[
	8.888dec,
	8.888888888888888dec
]
```

Similarly, an attempt to cast a number that is too large for an `int` into a `decimal` will not work, as the parser will first attempt to handle the number on the right before moving on to the cast.

```surql
/**[test]

[test.results]
parsing-error = """Failed to parse number: number too large to fit in target type
 --> [1:10]
  |
1 | <decimal>9999999999999999999;
  |          ^^^^^^^^^^^^^^^^^^^"""

*/

<decimal>9999999999999999999;
```

```surql title="Output"
Parse error: Failed to parse number: number too large to fit in target type
```

However, if the same number is followed by the `dec` suffix, the parser will be aware that the input is meant to be treated as a `decimal` from the outset and the query will succeed.

```surql
/**[test]

[[test.results]]
value = "9999999999999999999dec"

*/

RETURN 9999999999999999999dec;
```



================================================
FILE: src/content/doc-surrealql/datamodel/closures.mdx
================================================
---
sidebar_position: 6
sidebar_label: Closures
title: Closures | SurrealQL
description: Anonymous functions in SurrealDB allow you to define small, reusable pieces of logic that can be used throughout your queries.
---
import Since from '@components/shared/Since.astro'

# Anonymous Functions

<Since v="v2.0.0" />

```syntax title="SurrealQL Syntax"
$@parameter = |@parameters| @expression;
```

One of the powerful features now available in SurrealDB is the ability to define anonymous functions. These functions can be used to encapsulate reusable logic and can be called from within your queries. Below are some examples demonstrating their capabilities:

## Basic Function Definitions

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "4"

[[test.results]]
value = "NONE"

[[test.results]]
value = "'Hello, World!'"

*/

-- Define an anonymous function that doubles a number
LET $double = |$n: number| $n * 2;
RETURN $double(2);  -- Returns 4

-- Define a function that concatenates two strings
LET $concat = |$a: string, $b: string| $a + $b;
RETURN $concat("Hello, ", "World!");  -- Returns "Hello, World!"
```

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "'Hello, Alice!'"

*/

-- Define a function that greets a person
LET $greet = |$name: string| -> string { "Hello, " + $name + "!" };
RETURN $greet("Alice");   -- Returns "Hello, Alice!"
```

## Error Handling and Type Enforcement

You can also enforce type constraints within your functions to prevent type mismatches:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "'HELLO'"

[[test.results]]
error = "'Incorrect arguments for function ANONYMOUS(). Expected a value of type 'string' for argument $text'"

[[test.results]]
value = "NONE"

[[test.results]]
value = "16"

[[test.results]]
error = "'Incorrect arguments for function ANONYMOUS(). Expected a value of type 'number' for argument $num'"

*/

-- Define a function with a return type
LET $to_upper = |$text: string| -> string { string::uppercase($text) };
RETURN $to_upper("hello");  -- Returns "HELLO"
RETURN $to_upper(123);      -- Error: type mismatch

-- Define a function that accepts only numbers
LET $square = |$num: number| $num * $num;
RETURN $square(4);    -- Returns 16
RETURN $square("4");  -- Error: type mismatch
```

## Closures in functions

Many of SurrealDB's functions allow a closure to be passed in, making it easy to use complex logic on a value or the elements of an array.

The `chain` function which performs an operation on a value before passing it on:

```surql
/**[test]

[[test.results]]
value = "2000"

*/

"Two"
    .replace("Two", "2")
    .chain(|$num| <number>$num * 1000);
```

```surql title="Response"
2000
```

The following example shows a chain of array functions used to remove useless data, followed by a check to see if all items in the array match a certain condition, and then a cast into another type. The [`array::filter`](/docs/surrealql/functions/database/array#arrayfilter) call in the middle ensures that the [`string::len`](/docs/surrealql/functions/database/string#stringlen) function that follows is being called on string values.

```surql
/**[test]

[[test.results]]
value = "'true'"

*/

[NONE, NONE, "good data", "Also good", "important", NULL]
    .filter(|$v| $v.is_string())
    .all(|$s| $s.len() > 5)
    .chain(|$v| <string>$v);
```

```surql title="Response"
'true'
```

## Capturing parameters

<Since v="v3.0.0-alpha.11" />

The original implementation of closures did not allow them to capture parameters (variables) in their scope. Strictly speaking, this made them simple anonymous functions as closures did not "enclose" anything.

```surql
LET $okay_nums = [1,2,3];

-- Returns [] because $okay_nums not present inside the closure
[1,5,6,7,0].filter(|$n| $n IN $okay_nums);
```

This has since been resolved, allowing a parameter declared outside a closure to be recognized inside it.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[[1]]"

*/

LET $okay_nums = [1,2,3];

[1,5,6,7,0].filter(|$n| $n IN $okay_nums);
```

## Conclusion

These anonymous functions provide a flexible way to define small, reusable pieces of logic that can be used throughout your queries. By leveraging them, you can write more modular and maintainable SurrealQL code.



================================================
FILE: src/content/doc-surrealql/datamodel/datetimes.mdx
================================================
---
sidebar_position: 7
sidebar_label: Datetimes
title: Datetimes | SurrealQL
description: SurrealDB has native support for datetimes with nanosecond precision. SurrealDB is able to parse datetimes from strings.

---

# Datetimes

SurrealDB has native support for datetimes with nanosecond precision. SurrealDB automatically parses and understands datetimes which are written as strings in the SurrealQL language. Times must also be formatted in [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format.


> [!NOTE]
> As of `v2.0.0`, SurrealDB no longer eagerly converts a string into a datetime. An implicit `d` prefix or cast using `<datetime>` is required instead.

```surql
/**[test]

[[test.results]]
value = "[{ id: event:s9mfw7f45qhlzs0ogche, time: d'2023-07-03T07:18:52Z' }]"
skip-record-id-key = true

*/

CREATE event SET time = d"2023-07-03T07:18:52Z";
```

SurrealDB handles all datetimes with nanosecond precision.

```surql
/**[test]

[[test.results]]
value = "[{ id: event:g7cdb2ny6qozzsrlp9qj, time: d'2023-07-03T07:18:52.841147Z' }]"
skip-record-id-key = true

*/

CREATE event SET time = d"2023-07-03T07:18:52.841147Z";
```

SurrealDB handles all timezones, and automatically converts and stores datetimes as a UTC date.

```surql
/**[test]

[[test.results]]
value = "[{ id: event:wieqqme8hybzpnh043d2, time: d'2023-07-03T05:18:52.841147Z' }]"
skip-record-id-key = true

*/

CREATE event SET time = d"2023-07-03T07:18:52.841147+02:00";
```

A `datetime` can also be created by using `<datetime>` to cast from a string.

With correct input:

```surql
/**[test]

[[test.results]]
value = "[{ id: event:9r69r6c6ovkky3pg7oko, time: d'2023-07-03T07:18:52.841147Z' }]"
skip-record-id-key = true

*/

CREATE event SET time = <datetime>"2023-07-03T07:18:52.841147Z";
```

```surql title="Response"
[{ id: event:jwm8ncmfi30nrxdf24ws, time: d'2023-07-03T07:18:52.841147Z' }]
```

With incorrect input (missing final Z):

```surql
/**[test]

[[test.results]]
error = "'"Expected `datetime` but found a `'2023-07-03T07:18:52.841147'`"'"

*/

CREATE event SET time = <datetime>"2023-07-03T07:18:52.841147";
```

```surql title="Response"
"Expected a datetime but cannot convert '2023-07-03T07:18:52.841147' into a datetime"
```

As a convenience, a date containing a year, month and day but no time will also parse correctly as a datetime.

```surql
/**[test]

[[test.results]]
value = "[{ id: event:ob9p04agl2aoqipet339, time: d'2024-04-03T00:00:00Z' }]"
skip-record-id-key = true

*/

CREATE event SET time = <datetime>"2024-04-03";
```

```surql title="Response"
[{ id: event:4t50wjjlne9v8km2qcwq, time: d'2024-04-03T00:00:00Z' }]
```

## Datetime types in `DEFINE FIELD` statements

Defining a field with a set `datetime` type will ensure that datetimes are properly formatted and not passed on as simple strings.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
error = ""Couldn't coerce value for field `time` of `event:qv8qcjf0w9oowekl36w6`: Expected `datetime` but found `'2023-07-03T07:18:52.841147'`""

*/

DEFINE FIELD time ON event TYPE datetime;
// highlight-next-line
CREATE event SET time = "2023-07-03T07:18:52.841147";
```

```surql title="Response"
"Couldn't coerce value for field `time` of `event:qv8qcjf0w9oowekl36w6`: Expected `datetime` but found `'2023-07-03T07:18:52.841147'`"
```

The above query will fail because the datetime is not cast as a datetime type. The correct query is:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: event:w2lhv58f7c9z7xo4nqkq, time: d'2023-07-03T07:18:52.841140Z' }]"
skip-record-id-key = true

*/

DEFINE FIELD time ON event TYPE datetime;
// highlight-next-line
CREATE event SET time = d"2023-07-03T07:18:52.84114Z";
```

```surql title="Response"
[
    { 
        id: event:w2lhv58f7c9z7xo4nqkq, 
        time: d'2023-07-03T07:18:52.841140Z' 
    }
]
```

### Datetime comparison
A datetime can be compared with another using the advanced SurrealDB operators.

```surql
SELECT * FROM d"2023-07-03T07:18:52Z" < d"2023-07-03T07:18:52.84114Z";
```
    
```surql title="Response"
    [[true]]
```

## Durations and datetimes

A duration can be used to alter a datetime.

```surql
/**[test]

[[test.results]]
value = "[{ id: event:nyk8onbwm2e1n8z32rj9, time: d'2023-07-17T07:18:52Z' }]"
skip-record-id-key = true

*/

CREATE event SET time = d"2023-07-03T07:18:52Z" + 2w;
```
    
    ```surql title="Response"
    [[{ id: event:`9ey7v8r0fd46xblf9dsf`, time: d'2023-07-17T07:18:52Z' }]] 
    ```

Multi-part durations can also be used to modify datetimes.

```surql
/**[test]

[[test.results]]
value = "[{ id: event:5uuzy32t48yutxyszi7p, time: d'2023-07-03T08:49:14.191147Z' }]"
skip-record-id-key = true

*/

CREATE event SET time = d"2023-07-03T07:18:52.841147Z" + 1h30m20s1350ms;
```

```surql title="Response"
[[{ id: event:`9ey7v8r0fd46xblf9dsf`, time: d'2023-07-03T08:49:14.191147Z' }]]
```

### Duration units

Durations can be specified in any of the following units:

<table>
    <thead>
    <tr>
        <th scope="col">Unit</th>
        <th scope="col">Description</th>
    </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Type">ns</td>
            <td scope="row" data-label="Description">Nanoseconds</td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">us</td>
            <td scope="row" data-label="Description">Microseconds, alternative: µs</td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">ms</td>
            <td scope="row" data-label="Description">Milliseconds</td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">s</td>
            <td scope="row" data-label="Description">Seconds</td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">m</td>
            <td scope="row" data-label="Description">Minutes</td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">h</td>
            <td scope="row" data-label="Description">Hours</td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">d</td>
            <td scope="row" data-label="Description">Days</td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">w</td>
            <td scope="row" data-label="Description">Weeks</td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">y</td>
            <td scope="row" data-label="Description">Years</td>
        </tr>
    </tbody>
</table>

## Next steps
You've now seen how to store, modify, and handle dates and times in SurrealDB. For more advanced functionality, take a look at the [time](/docs/surrealql/functions/database/time) functions, which enable extracting, altering, rounding, and grouping datetimes into specific time intervals.



================================================
FILE: src/content/doc-surrealql/datamodel/files.mdx
================================================
---
sidebar_position: 8
sidebar_label: Files
title: Files | SurrealQL
description: SurrealDB allows a bucket to be declared locally or globally to work with files.

---

import Since from '@components/shared/Since.astro'

# Files

<Since v="v3.0.0-alpha.1" />

Files are accessed by a path, which is prefixed with an `f` to differentiate it from a regular string.

Some examples of file pointers:

```surql
/**[test]

[[test.results]]
value = "f"bucket:/some/key/to/a/file.txt""

*/

f"bucket:/some/key/to/a/file.txt";
f"bucket:/some/key/with\ escaped";
```

To work with the files that can be accessed through these pointers, use the following:

* A [`DEFINE BUCKET`](/docs/surrealql/statements/define/bucket) statement to set up the bucket to hold the files
* [Files functions](/docs/surrealql/functions/database/file) such as `file::put()` and `file::get()`

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "b"536F6D65207465787420696E73696465""

[[test.results]]
value = "'Some text inside'"

*/

DEFINE BUCKET my_bucket BACKEND "memory";
f"my_bucket:/some_file.txt".put("Some text inside");
f"my_bucket:/some_file.txt".get();
<string>f"my_bucket:/some_file.txt".get();
```

```surql title="Output"
-------- Query --------

b"536F6D65207465787420696E73696465"

-------- Query --------

'Some text inside'
```

## Using files for ad-hoc memory storage

A combination of files and SurrealDB's [encoding functions](/docs/surrealql/functions/database/encoding#encodingcbordecode) can be used to set up ad-hoc memory storage. This can be convenient when running an instance that saves data to disk but prefers to keep certain items in memory.

The following example shows how this pattern might be used for temporary storage such as a user's shopping cart during a single session.

```surql
-- Set up the in-memory backend
DEFINE BUCKET shopping_carts BACKEND "memory";

-- Convenience functions to save, decode back into
-- SurrealQL type, and delete
DEFINE FUNCTION fn::save_file($file_name: string, $input: any) {
    LET $file = type::file("shopping_carts", $file_name);
    $file.put(encoding::cbor::encode($input));
};

DEFINE FUNCTION fn::get_file($file_name: string) {
    encoding::cbor::decode(type::file("shopping_carts", $file_name).get())
};

DEFINE FUNCTION fn::delete_file($file_name: string) {
    type::file("shopping_carts", $file_name).delete();
};

-- Save current shoppingcart
fn::save_file("temp_cart_user_24567", {
    items: ["shirt1"],
    last_updated: time::now()
});

fn::get_file("temp_shopping_cart_user_24567");
-- Returns { items: ['shirt1', 'deck_of_cards'], last_updated: d'2025-11-20T01:03:24.141080Z' }

-- User adds item, save over file with newer information
fn::save_file("temp_cart_user_24567", {
    items: ["shirt1", "deck_of_cards"],
    last_updated: time::now()
});

fn::get_file("temp_cart_user_24567");
-- Returns { items: ['shirt1', 'deck_of_cards'], last_updated: d'2025-11-20T01:06:02.752429Z' }

-- Session is over, delete temp file
fn::delete_file("temp_cart_user_24567");
```


================================================
FILE: src/content/doc-surrealql/datamodel/formatters.mdx
================================================
---
sidebar_position: 9
sidebar_label: Formatters
title: Formatters | SurrealQL
description: Formatting functions in SurrealQL accept certain text formats for date/time formatting.

---

# Formatters

The [string::is_datetime](/docs/surrealql/functions/database/string#stringisdatetime) and [time::format](/docs/surrealql/functions/database/time#timeformat) functions in SurrealQL accept certain text formats for date/time formatting. The possible formats are listed below.

### Date formatters

<table>
<thead>
  <tr>
    <th scope="col">Specifier</th>
    <th scope="col">Example</th>
    <th scope="col">Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td scope="row" data-label="Specifier">%Y</td>
    <td scope="row" data-label="Example">2001</td>
    <td scope="row" data-label="Description">The full proleptic Gregorian year, zero-padded to 4 digits.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%C</td>
    <td scope="row" data-label="Example">20</td>
    <td scope="row" data-label="Description">The proleptic Gregorian year divided by 100, zero-padded to 2 digits.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%y</td>
    <td scope="row" data-label="Example">01</td>
    <td scope="row" data-label="Description">The proleptic Gregorian year modulo 100, zero-padded to 2 digits.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%m</td>
    <td scope="row" data-label="Example">07</td>
    <td scope="row" data-label="Description">Month number (01 to 12), zero-padded to 2 digits.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%b</td>
    <td scope="row" data-label="Example">Jul</td>
    <td scope="row" data-label="Description">Abbreviated month name. Always 3 letters.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%B</td>
    <td scope="row" data-label="Example">July</td>
    <td scope="row" data-label="Description">Full month name.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%h</td>
    <td scope="row" data-label="Example">Jul</td>
    <td scope="row" data-label="Description">Same as %b.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%d</td>
    <td scope="row" data-label="Example">08</td>
    <td scope="row" data-label="Description">Day number (01 to 31), zero-padded to 2 digits.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%e</td>
    <td scope="row" data-label="Example">8</td>
    <td scope="row" data-label="Description">Same as %d but space-padded. Same as %_d.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%a</td>
    <td scope="row" data-label="Example">Sun</td>
    <td scope="row" data-label="Description">Abbreviated weekday name. Always 3 letters.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%A</td>
    <td scope="row" data-label="Example">Sunday</td>
    <td scope="row" data-label="Description">Full weekday name.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%w</td>
    <td scope="row" data-label="Example">0</td>
    <td scope="row" data-label="Description">Day of the week. Sunday = 0, Monday = 1, ..., Saturday = 6.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%u</td>
    <td scope="row" data-label="Example">7</td>
    <td scope="row" data-label="Description">Day of the week. Monday = 1, Tuesday = 2, ..., Sunday = 7. ([RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339))</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%U</td>
    <td scope="row" data-label="Example">28</td>
    <td scope="row" data-label="Description">Week number starting with Sunday (00 to 53), zero-padded to 2 digits.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%W</td>
    <td scope="row" data-label="Example">27</td>
    <td scope="row" data-label="Description">Same as %U, but week 1 starts with the first Monday in that year instead.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%G</td>
    <td scope="row" data-label="Example">2001</td>
    <td scope="row" data-label="Description">Same as %Y but uses the year number in [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) week date.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%g</td>
    <td scope="row" data-label="Example">01</td>
    <td scope="row" data-label="Description">Same as %y but uses the year number in [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) week date.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%V</td>
    <td scope="row" data-label="Example">27</td>
    <td scope="row" data-label="Description">Same as %U but uses the week number in [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) week date (01 to 53).</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%j</td>
    <td scope="row" data-label="Example">189</td>
    <td scope="row" data-label="Description">Day of the year (001 to 366), zero-padded to 3 digits.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%D</td>
    <td scope="row" data-label="Example">07/08/01</td>
    <td scope="row" data-label="Description">Month-day-year format. Same as %m/%d/%y.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%x</td>
    <td scope="row" data-label="Example">07/08/01</td>
    <td scope="row" data-label="Description">Locale's date representation.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%F</td>
    <td scope="row" data-label="Example">2001-07-08</td>
    <td scope="row" data-label="Description">Year-month-day format ([RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339)). Same as %Y-%m-%d.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%v</td>
    <td scope="row" data-label="Example">8-Jul-2001</td>
    <td scope="row" data-label="Description">Day-month-year format. Same as %e-%b-%Y.</td>
  </tr>
</tbody>
</table>

### Time formatters

<table>
<thead>
  <tr>
    <th scope="col">Specifier</th>
    <th scope="col">Example</th>
    <th scope="col">Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td scope="row" data-label="Specifier">%H</td>
    <td scope="row" data-label="Example">00</td>
    <td scope="row" data-label="Description">Hour number (00 to 23), zero-padded to 2 digits.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%k</td>
    <td scope="row" data-label="Example">0</td>
    <td scope="row" data-label="Description">Same as %H but space-padded. Same as %_H.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%I</td>
    <td scope="row" data-label="Example">12</td>
    <td scope="row" data-label="Description">Hour number in 12-hour clocks (01 to 12), zero-padded to 2 digits.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%l</td>
    <td scope="row" data-label="Example">12</td>
    <td scope="row" data-label="Description">Same as %I but space-padded. Same as %_I.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%P</td>
    <td scope="row" data-label="Example">am</td>
    <td scope="row" data-label="Description">am or pm in 12-hour clocks.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%p</td>
    <td scope="row" data-label="Example">AM</td>
    <td scope="row" data-label="Description">AM or PM in 12-hour clocks.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%M</td>
    <td scope="row" data-label="Example">34</td>
    <td scope="row" data-label="Description">Minute number (00 to 59), zero-padded to 2 digits.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%S</td>
    <td scope="row" data-label="Example">60</td>
    <td scope="row" data-label="Description">Second number (00 to 60), zero-padded to 2 digits.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%f</td>
    <td scope="row" data-label="Example">026490000</td>
    <td scope="row" data-label="Description">The fractional seconds (in nanoseconds) since last whole second.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%.f</td>
    <td scope="row" data-label="Example">.026490</td>
    <td scope="row" data-label="Description">Similar to %f but left-aligned.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%.3f</td>
    <td scope="row" data-label="Example">.026</td>
    <td scope="row" data-label="Description">Similar to .%f but left-aligned but fixed to a length of 3.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%.6f</td>
    <td scope="row" data-label="Example">.026490</td>
    <td scope="row" data-label="Description">Similar to .%f but left-aligned but fixed to a length of 6.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%.9f</td>
    <td scope="row" data-label="Example">.026490000</td>
    <td scope="row" data-label="Description">Similar to .%f but left-aligned but fixed to a length of 9.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%3f</td>
    <td scope="row" data-label="Example">026</td>
    <td scope="row" data-label="Description">Similar to %.3f but without the leading dot.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%6f</td>
    <td scope="row" data-label="Example">026490</td>
    <td scope="row" data-label="Description">Similar to %.6f but without the leading dot.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%9f</td>
    <td scope="row" data-label="Example">026490000</td>
    <td scope="row" data-label="Description">Similar to %.9f but without the leading dot.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%R</td>
    <td scope="row" data-label="Example">00:34</td>
    <td scope="row" data-label="Description">Hour-minute format. Same as %H:%M.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%T</td>
    <td scope="row" data-label="Example">00:34:59</td>
    <td scope="row" data-label="Description">Hour-minute-second format. Same as %H:%M:%S.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%X</td>
    <td scope="row" data-label="Example">00:34:59</td>
    <td scope="row" data-label="Description">Locale's time representation.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%r</td>
    <td scope="row" data-label="Example">12:34:59 AM</td>
    <td scope="row" data-label="Description">Hour-minute-second format in 12-hour clocks. Same as %I:%M:%S %p.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%x</td>
    <td scope="row" data-label="Example">07/08/01</td>
    <td scope="row" data-label="Description">Locale's date representation.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%F</td>
    <td scope="row" data-label="Example">2001-07-08</td>
    <td scope="row" data-label="Description">Year-month-day format ([RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339)). Same as %Y-%m-%d.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%v</td>
    <td scope="row" data-label="Example">8-Jul-2001</td>
    <td scope="row" data-label="Description">Day-month-year format. Same as %e-%b-%Y.</td>
  </tr>
</tbody>
</table>

### Timezones formatters

<table>
  <thead>
    <tr>
      <th scope="col">Specifier</th>
      <th scope="col">Example</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Specifier">%Z</td>
      <td scope="row" data-label="Example">ACST</td>
      <td scope="row" data-label="Description">Local time zone name.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Specifier">%z</td>
      <td scope="row" data-label="Example">+0930</td>
      <td scope="row" data-label="Description">Offset from the local time to UTC (with UTC being +0000).</td>
    </tr>
    <tr>
      <td scope="row" data-label="Specifier">%:z</td>
      <td scope="row" data-label="Example">+09:30</td>
      <td scope="row" data-label="Description">Same as %z but with a colon.</td>
    </tr>
  </tbody>
</table>

### Date & time formatters

<table>
<thead>
  <tr>
    <th scope="col">Specifier</th>
    <th scope="col">Example</th>
    <th scope="col">Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td scope="row" data-label="Specifier">%c</td>
    <td scope="row" data-label="Example">Sun Jul 8 00:34:59 2001</td>
    <td scope="row" data-label="Description">Locale's date and time.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%+</td>
    <td scope="row" data-label="Example">2001-07-08T00:34:59.026490+09:30</td>
    <td scope="row" data-label="Description">[RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) / RFC 3339 date &amp; time format.</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%s</td>
    <td scope="row" data-label="Example">994518299</td>
    <td scope="row" data-label="Description">UNIX timestamp, the number of seconds since 1970-01-01T00:00:00.</td>
  </tr>
</tbody>
</table>

### Other formatters

<table>
<thead>
  <tr>
    <th scope="col">Specifier</th>
    <th scope="col">Example</th>
    <th scope="col">Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td scope="row" data-label="Specifier">%t</td>
    <td scope="row" data-label="Example">-</td>
    <td scope="row" data-label="Description">Literal tab (\t).</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%n</td>
    <td scope="row" data-label="Example">-</td>
    <td scope="row" data-label="Description">Literal newline (\n).</td>
  </tr>
  <tr>
    <td scope="row" data-label="Specifier">%%</td>
    <td scope="row" data-label="Example">-</td>
    <td scope="row" data-label="Description">Literal percent sign.</td>
  </tr>
</tbody>
</table>

## Examples

Seeing if an input with a date and time conforms to an expected format:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_datetime("5sep2024pm012345.6789", "%d%b%Y%p%I%M%S%.f");
```

```surql title="Response"
true
```

Another example with a different format:

```surql
/**[test]

[[test.results]]
value = "false"

*/

RETURN string::is_datetime("23:56:00 2015-09-05", "%Y-%m-%d %H:%M");
```

```surql title="Response"
false
```

Using a formatter to generate a string from a datetime:

```surql
/**[test]

[[test.results]]
value = "'2021-11-01'"

*/

RETURN time::format(d"2021-11-01T08:30:17+00:00", "%Y-%m-%d");
```

```surql title="Response"
"2021-11-01"
```


================================================
FILE: src/content/doc-surrealql/datamodel/futures.mdx
================================================
---
sidebar_position: 10
sidebar_label: Futures
title: Futures | SurrealQL
description: Futures are values which are only computed when the data is selected and returned to the client.

---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Futures

> [!NOTE]
> The `future` type is only available up to SurrealDB version 3.0.0-alpha.7. Since version 3.0.0-alpha.8, it has been replaced by [defined fields using the `COMPUTED` clause](/docs/surrealql/statements/define/field#computed-fields). Most examples in this page include the equivalent using the `COMPUTED` clause for reference.

Futures are values which are only computed when the data is selected and returned to the client. Futures can be stored inside records, to enable dynamic values which are always calculated when queried.

### Simple futures

Any value or expression can be used inside a future. This value will be dynamically computed on every access to the record.

<Tabs>
<TabItem label="Legacy future type">

```surql
CREATE person SET accessed_date = <future> { time::now() };
```

</TabItem>

<TabItem label="With COMPUTED clause">

```surql
-- Only used inside a DEFINE FIELD statement
DEFINE FIELD accessed_date ON person COMPUTED time::now();
```

</TabItem>
</Tabs>

## Futures inside schema definitions

A future can be added to a schema definition as well.

<Tabs>
<TabItem label="Legacy future type">

```surql
DEFINE FIELD accessed_at ON TABLE user VALUE <future> { time::now() };

CREATE user:one;
SELECT * FROM ONLY user:one;
-- Sleep for one second
SLEEP 1s;
-- `accessed_at` is a different value now
SELECT * FROM ONLY user:one;
```

</TabItem>

<TabItem label="With COMPUTED clause">

```surql
DEFINE FIELD accessed_at ON TABLE user COMPUTED time::now();

CREATE user:one;
SELECT * FROM ONLY user:one;
-- Sleep for one second
SLEEP 1s;
-- `accessed_at` is a different value now
SELECT * FROM ONLY user:one;
```

</TabItem>

</Tabs>

This differs from a `VALUE` clause which is only calculated when it is modified (created or updated), but is not recalculated during a `SELECT` query which does not modify a record.

```surql
DEFINE FIELD updated ON TABLE user VALUE time::now();

CREATE user:one;
SELECT * FROM ONLY user:one;
-- Sleep for one second
SLEEP 1s;
-- `updated` is still the same
SELECT * FROM ONLY user:one;
```

## Futures depending on statements

If the value of a future is the result of a statement, it must be wrapped in parentheses.

<Tabs>
<TabItem label="Legacy future type">

```surql
DEFINE FIELD random_movie
    ON app_screen
    VALUE <future> { (SELECT * FROM ONLY movie ORDER BY RAND() LIMIT 1) };
```

</TabItem>
<TabItem label="With COMPUTED clause">

```surql
-- No need for parentheses
DEFINE FIELD random_movie
    ON app_screen
    COMPUTED SELECT * FROM ONLY movie ORDER BY RAND() LIMIT 1;
```

</TabItem>
</Tabs>

If your statement is wrapped in parentheses, you need to access the fields using the $parent variable.

```surql
DEFINE FIELD OVERWRITE followers
    ON user
    VALUE <future> { (SELECT VALUE count FROM ONLY follower_count WHERE user = $parent.id LIMIT 1) ?? 0 };
```

## Avoiding infinite recursion

When defining a future on a field, be sure to avoid any statements that would cause infinite recursion. In the following example, the `random_friend` field is defined by a statement that uses a `SELECT` statement on all the fields of the same `person` table, one of which will also use the same `future` to compute its value.

```surql
CREATE |person:10| SET name = "Person " + <string>id.id() RETURN NONE;

DEFINE FIELD random_friend
    ON person
    VALUE <future> { (SELECT * FROM ONLY person ORDER BY RAND() LIMIT 1) };

CREATE person;
```

```surql title="Output"
'Reached excessive computation depth due to functions, subqueries, or futures'
```

A `SELECT` query that does not access the field defined by a future will avoid the infinite recursion.

```surql
CREATE |person:10| SET name = "Person " + <string>id.id() RETURN NONE;

DEFINE FIELD random_friend
    ON person
    VALUE <future> { (SELECT VALUE name FROM ONLY person ORDER BY RAND() LIMIT 1) };

CREATE person;
```

```surql title="Output"
[
	{
		id: person:4o973bouhd6xrj8l2x69,
		random_friend: 'Person imoy71qbhnsgjtczybiq'
	}
]
```

## Next steps

You've now seen how to create dynamically computed properties on records, using either simple values, and values which depend on local and remote record fields. Take a look at the next chapter to understand how types can be cast and converted to other types.



================================================
FILE: src/content/doc-surrealql/datamodel/geometries.mdx
================================================
---
sidebar_position: 11
sidebar_label: Geometries
title: Geometries | SurrealQL
description: SurrealDB makes working with GeoJSON easy, with support for Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, and Collection values.

---

# Geometries

SurrealDB makes working with GeoJSON easy, with support for `Point`, `LineString`, `Polygon`, `MultiPoint`, `MultiLineString`, `MultiPolygon`, and `Collection` values. SurrealQL automatically detects GeoJSON objects converting them into a single data type.

<table>
<thead>
  <tr>
    <th scope="col">Type</th>
    <th scope="col">Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td scope="row" data-label="Type"><a href="#point"><code>Point</code></a></td>
    <td scope="row" data-label="Description">A geolocation point with longitude and latitude</td>
  </tr>
  <tr>
    <td scope="row" data-label="Type"><a href="#LineString"><code>LineString</code></a></td>
    <td scope="row" data-label="Description">A GeoJSON LineString value for storing a geometric path</td>
  </tr>
  <tr>
    <td scope="row" data-label="Type"><a href="#polygon"><code>Polygon</code></a></td>
    <td scope="row" data-label="Description">A GeoJSON Polygon value for storing a geometric area</td>
  </tr>
  <tr>
    <td scope="row" data-label="Type"><a href="#multipoint"><code>MultiPoint</code></a></td>
    <td scope="row" data-label="Description">A value which contains multiple geometry points</td>
  </tr>
  <tr>
    <td scope="row" data-label="Type"><a href="#multilinestring"><code>MultiLineString</code></a></td>
    <td scope="row" data-label="Description">A value which contains multiple geometry lines</td>
  </tr>
  <tr>
    <td scope="row" data-label="Type"><a href="#multipolygon"><code>MultiPolygon</code></a></td>
    <td scope="row" data-label="Description">A value which contains multiple geometry polygons</td>
  </tr>
  <tr>
    <td scope="row" data-label="Type"><a href="#collection"><code>Collection</code></a></td>
    <td scope="row" data-label="Description">A value which contains multiple different geometry types</td>
  </tr>
</tbody>
</table>

## `Point`

> [!NOTE]
> Points are defined according to the GeoJSON spec, which specificies longitude before latitude. Many sites provide location data in the opposite order, so be sure to confirm that any data being used to create a `Point` is in the order `(longitude, latitude)`.

The simplest form of GeoJSON that SurrealDB supports is a geolocation point. These can be written using two different formats. The first format is a simple 2-element tuple (longitude, latitude).

```surql
/**[test]

[[test.results]]
value = "[{ centre: (-0.118092, 51.509865), id: city:london }]"

*/

CREATE city:london SET centre = (-0.118092, 51.509865);
```

In addition, SurrealDB supports entering GeoJSON points using the traditional format.

> [!NOTE]
> No other properties must be present in the Point object.

```surql
/**[test]

[[test.results]]
value = "[{ centre: (-0.118092, 51.509865), id: city:london }]"

*/

CREATE city:london SET centre = {
    type: "Point",
    coordinates: [-0.118092, 51.509865],
};
```

<br />

## `LineString`

A GeoJSON LineString value for storing a geometric path.

> [!NOTE]
> No other properties must be present in the LineString object.

```surql
/**[test]

[[test.results]]
value = "[{ distance: { type: 'LineString', coordinates: [[-0.118092, 51.509865], [0.1785278, 51.37692386]] }, id: city:london }]"

*/

CREATE city:london SET distance = {
    type: "LineString",
    coordinates: [[-0.118092, 51.509865],[0.1785278, 51.37692386]],
};
```

<br />

## `Polygon`

A GeoJSON Polygon value for storing a geometric area.

> [!NOTE]
> No other properties must be present in the Polygon object.

```surql
/**[test]

[[test.results]]
value = "[{ boundary: { type: 'Polygon', coordinates: [[[-0.38314819, 51.37692386], [0.1785278, 51.37692386], [0.1785278, 51.6146057], [-0.38314819, 51.6146057], [-0.38314819, 51.37692386]]] }, id: city:london }]"

*/

CREATE city:london SET boundary = {
	type: "Polygon",
	coordinates: [[
		[-0.38314819, 51.37692386], [0.1785278, 51.37692386],
		[0.1785278, 51.61460570], [-0.38314819, 51.61460570],
		[-0.38314819, 51.37692386]
	]]
};
```

<br />

## `MultiPoint`

MultiPoints can be used to store multiple geometry points in a single value.

> [!NOTE]
> No other properties must be present in the MultiPoint object.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:tobie, locations: { type: 'MultiPoint', coordinates: [[10, 11.2], [10.5, 11.9]] } }]"

*/

CREATE person:tobie SET locations = {
	type: "MultiPoint",
	coordinates: [
		[10.0, 11.2],
		[10.5, 11.9]
	],
};
```

<br />

## `MultiLineString`

A MultiLineString can be used to store multiple geometry lines in a single value.

> [!NOTE]
> No other properties must be present in the MultiLineString object.

```surql
/**[test]

[[test.results]]
value = "[{ id: travel:yellowstone, routes: { type: 'MultiLineString', coordinates: [[[10, 11.2], [10.5, 11.9]], [[11, 12.2], [11.5, 12.9], [12, 13]]] } }]"

*/

CREATE travel:yellowstone SET routes = {
	type: "MultiLineString",
	coordinates: [
		[ [10.0, 11.2], [10.5, 11.9] ],
		[ [11.0, 12.2], [11.5, 12.9], [12.0, 13.0] ]
	]
}
```

<br />

## `MultiPolygon`

MultiPolygons can be used to store multiple geometry polygons in a single value.


> [!NOTE]
> No other properties must be present in the MultiPolygon object.

```surql
/**[test]

[[test.results]]
value = "[{ id: university:oxford, locations: { type: 'MultiPolygon', coordinates: [[[[10, 11.2], [10.5, 11.9], [10.8, 12], [10, 11.2]]], [[[9, 11.2], [10.5, 11.9], [10.3, 13], [9, 11.2]]]] } }]"

*/

CREATE university:oxford SET locations = {
	type: "MultiPolygon",
	coordinates: [
		[
			[ [10.0, 11.2], [10.5, 11.9], [10.8, 12.0], [10.0, 11.2] ]
		],
		[
			[ [9.0, 11.2], [10.5, 11.9], [10.3, 13.0], [9.0, 11.2] ]
		]
	]
};
```

<br />

## `Collection`

Collections can be used to store multiple different geometry types in a single value.

> [!NOTE]
> No other properties must be present in the Collection object.

```surql
/**[test]

[[test.results]]
value = "[{ buildings: { type: 'GeometryCollection', geometries: [{ type: 'MultiPoint', coordinates: [[10, 11.2], [10.5, 11.9]] }, { type: 'Polygon', coordinates: [[[-0.38314819, 51.37692386], [0.1785278, 51.37692386], [0.1785278, 51.6146057], [-0.38314819, 51.6146057], [-0.38314819, 51.37692386]]] }, { type: 'MultiPolygon', coordinates: [[[[10, 11.2], [10.5, 11.9], [10.8, 12], [10, 11.2]]], [[[9, 11.2], [10.5, 11.9], [10.3, 13], [9, 11.2]]]] }] }, id: university:oxford }]"

*/

CREATE university:oxford SET buildings = {
	type: "GeometryCollection",
	geometries: [
		{
			type: "MultiPoint",
			coordinates: [
				[10.0, 11.2],
				[10.5, 11.9]
			],
		},
		{
			type: "Polygon",
			coordinates: [[
				[-0.38314819, 51.37692386], [0.1785278, 51.37692386],
				[0.1785278, 51.61460570], [-0.38314819, 51.61460570],
				[-0.38314819, 51.37692386]
			]]
		},
		{
			type: "MultiPolygon",
			coordinates: [
				[
					[ [10.0, 11.2], [10.5, 11.9], [10.8, 12.0], [10.0, 11.2] ]
				],
				[
					[ [9.0, 11.2], [10.5, 11.9], [10.3, 13.0], [9.0, 11.2] ]
				]
			]
		}
	]
};
```

<br />

## Example

The following example includes five records from [an open database](https://public.opendatasoft.com/explore/dataset/geonames-all-cities-with-a-population-1000/export/?disjunctive.cou_name_en&sort=name) with cities worldwide that have of a population of at least 1000. The queries below create a `city` record from each entry that includes their name, location, and name. Next, it uses the [`geo::distance`](/docs/surrealql/functions/database/geo#geodistance) function to find their two closest neighbours, relating them via the `close_to` relation table. The final query can be viewed in traditional form to see each city's neighbours, or on Surrealist's [graph view](/blog/visualizing-your-data-with-surrealists-graph-view) to see a visual representation of the network of closely linked cities.

```surql
DEFINE TABLE city SCHEMAFULL;
DEFINE FIELD name ON city TYPE string;
DEFINE FIELD location ON city TYPE point;

FOR $city IN [{"geoname_id": "5881639", "name": "100 Mile House", "ascii_name": "100 Mile House", "feature_class": "P", "feature_code": "PPL", "country_code": "CA", "cou_name_en": "Canada", "country_code_2": null, "admin1_code": "02", "admin2_code": "5941", "admin3_code": "5941005", "admin4_code": null, "population": 1980, "elevation": null, "dem": 928, "timezone": "America/Vancouver", "modification_date": "2019-11-26", "label_en": "Canada", "coordinates": {"lon": -121.28594, "lat": 51.64982}},{"geoname_id": "5896969", "name": "Beaverlodge", "ascii_name": "Beaverlodge", "feature_class": "P", "feature_code": "PPL", "country_code": "CA", "cou_name_en": "Canada", "country_code_2": null, "admin1_code": "01", "admin2_code": "4819009", "admin3_code": null, "admin4_code": null, "population": 2219, "elevation": null, "dem": 723, "timezone": "America/Edmonton", "modification_date": "2024-02-28", "label_en": "Canada", "coordinates": {"lon": -119.43605, "lat": 55.21664}},{"geoname_id": "5911606", "name": "Burnaby", "ascii_name": "Burnaby", "feature_class": "P", "feature_code": "PPLA3", "country_code": "CA", "cou_name_en": "Canada", "country_code_2": null, "admin1_code": "02", "admin2_code": "5915", "admin3_code": "5915025", "admin4_code": null, "population": 202799, "elevation": null, "dem": 87, "timezone": "America/Vancouver", "modification_date": "2019-02-26", "label_en": "Canada", "coordinates": {"lon": -122.95263, "lat": 49.26636}},{"geoname_id": "5920996", "name": "Chertsey", "ascii_name": "Chertsey", "feature_class": "P", "feature_code": "PPL", "country_code": "CA", "cou_name_en": "Canada", "country_code_2": null, "admin1_code": "10", "admin2_code": "14", "admin3_code": "62047", "admin4_code": null, "population": 4836, "elevation": null, "dem": 251, "timezone": "America/Toronto", "modification_date": "2016-06-22", "label_en": "Canada", "coordinates": {"lon": -73.89095, "lat": 46.07109}},{"geoname_id": "5941905", "name": "Dorset Park", "ascii_name": "Dorset Park", "alternate_names": null, "feature_class": "P", "feature_code": "PPLX", "country_code": "CA", "cou_name_en": "Canada", "country_code_2": null, "admin1_code": "08", "admin2_code": "3520", "admin3_code": null, "admin4_code": null, "population": 25003, "elevation": null, "dem": 164, "timezone": "America/Toronto", "modification_date": "2020-05-02", "label_en": "Canada", "coordinates": {"lon": -79.28215, "lat": 43.75386}}]

{
    CREATE type::record("city", <int>$city.geoname_id) SET
		location = <point>[$city.coordinates.lon, $city.coordinates.lat],
		name = $city.name;        
};

FOR $city IN SELECT * FROM city {
    LET $this_location = $city.location;
    LET $closest = 
		(SELECT id, location, geo::distance($this_location, location) AS distance FROM city
	ORDER BY distance ASC
	LIMIT 3
		).filter(|$c| $c.distance != 0);
    FOR $closest IN $closest {
      RELATE $city->close_to->$closest SET
	  	distance = geo::distance($city.location, $closest.location);
    };
};

SELECT name, id, ->close_to->city AS neighbours FROM city;
```

## Next steps

You've now seen how to use geometries to store locations, paths, and polygonal areas in SurrealDB. For more advanced functionality, take a look at the [operators](/docs/surrealql/operators) and [geo](/docs/surrealql/functions/database/geo) functions, which enable area, distance, and bearing geometric calculations, and the ability to detect whether geometries contain or intersect other geometry types.



================================================
FILE: src/content/doc-surrealql/datamodel/idioms.mdx
================================================
---
sidebar_position: 12
sidebar_label: Idioms
title: Idioms | SurrealQL
description: Accessing and manipulating data using idioms (paths) in SurrealQL.
---

import Since from '@components/shared/Since.astro'
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Idioms

Idioms in SurrealQL provide a powerful and flexible way to access and manipulate data within records using paths. They allow you to navigate through nested data structures, access fields, array elements, call methods, and perform complex queries with ease. Idioms are similar to expressions in other query languages that provide a path to data within documents or records.

An idiom is composed of a sequence of **parts** that define the path to a value within a record or data structure. Each part specifies how to navigate to the next piece of data. Idioms can be used in various parts of SurrealQL. The most common usecase is in data retrival queries such as `SELECT` statements, but they can also be used in the `WHERE` clause, `SET` clause, and more.

An idiom is made up of one or more **parts**, each of which can be one of several types:

- [**Field**](#field-access): Access a field by name.
- [**Index**](#index-access): Access an element of an array by its index.
- [**All**](#all-elements): Access all elements or fields.
- [**Last**](#last-element): Access the last element of an array.
- [**Where**](#where-filter): Filter elements based on a condition.
- [**Method**](#method-chaining): Call a method on the current data.
- [**Graph**](#graph-navigation): Navigate through graph relationships.
- [**Destructure**](#destructuring): Destructure nested objects.
- [**Optional**](#optional-parts): Indicate that the following part is optional.
- [**Recurse**](#recursive-paths): Recursively traverse paths such as graph and record links.

In this section, we'll explore each part in detail with examples to help you understand how to use idioms in SurrealQL.

## Field Access

Since SurrealDB is, at its core, a document database, each record is stored on an underlying key-value store storage engine, with the ability to store arbitrary arrays, objects, and many other types of data. To access a field in an object, use a dot `.` followed by the field name. 

This is mostly helpful when accessing fields within a record, but can also be used to access fields within an array.

For example, using the `CREATE` statement to add a record into the `person` table:


```surql title="Query"
/**[test]

[[test.results]]
value = "[{ address: { city: 'New York', country: 'USA' }, age: 30, id: person:oakmq2g0njddr5ysmils, name: 'John Doe' }]"
skip-record-id-key = true

*/

CREATE person CONTENT {
    name: "John Doe",
    age: 30,
    address: {
      city: "New York",
      country: "USA"
    }
};
```
```surql title="Response"
[
	{
		address: {
			city: 'New York',
			country: 'USA'
		},
		age: 30,
		id: person:g87bnds1gcgrnoj4p5q3,
		name: 'John Doe'
	}
]
```

To access the `city` field within the `address` object, you can use the following idiom:

```surql title="Query"
SELECT address.city FROM person;
```

```surql title="Response"
[
  {
    "address": {
      "city": "New York"
    }
  }
]
```
In this example, `person.name` is an idiom that accesses the `name` field of the `person` record.

## Index Access

To access an element in an array by its index, use square brackets `[]` with the index inside. For example, let's say we have a `school` record with some student results. 

```surql title="Query"
/**[test]

[[test.results]]
value = "[{ id: student:m1rdvvs0el37kiifume4, results: [{ date: '2017-06-18T08:00:00Z', name: 'Algorithmics', score: 76 }, { date: '2018-03-21T08:00:00Z', name: 'Concurrent Programming', score: 83 }, { date: '2018-09-17T08:00:00Z', name: 'Advanced Computer Science 101', score: 69 }, { date: '2019-04-20T08:00:00Z', name: 'Distributed Databases', score: 73 }] }]"
skip-record-id-key = true

*/

CREATE student SET results = [
	{ score: 76, date: "2017-06-18T08:00:00Z", name: "Algorithmics" },
	{ score: 83, date: "2018-03-21T08:00:00Z", name: "Concurrent Programming" },
	{ score: 69, date: "2018-09-17T08:00:00Z", name: "Advanced Computer Science 101" },
	{ score: 73, date: "2019-04-20T08:00:00Z", name: "Distributed Databases" },
];
```

```surql title="Response"
[
	{
		id: student:urxaykt4qkbr8rs2o68j,
		results: [
			{
				date: '2017-06-18T08:00:00Z',
				name: 'Algorithmics',
				score: 76
			},
			{
				date: '2018-03-21T08:00:00Z',
				name: 'Concurrent Programming',
				score: 83
			},
			{
				date: '2018-09-17T08:00:00Z',
				name: 'Advanced Computer Science 101',
				score: 69
			},
			{
				date: '2019-04-20T08:00:00Z',
				name: 'Distributed Databases',
				score: 73
			}
		]
	}
]
```

To access the first student in the `results` array, you can use the following idiom:


```surql
SELECT results[0].score FROM student;
```

```surql title="Response"
[
  {
    results: [
      { score: 76 }
    ]
  }
]
```

Here, `results[0].score` accesses the score of the first student in the `results` array. 

## All Elements

To access all elements in an array or all fields in an object, use `.*`. This is useful when you want to access all the elements in an array or all the fields in an object. 

```surql 
SELECT results.* FROM student;
```

```surql title="Response"
{
	results: [
		{
			date: '2017-06-18T08:00:00Z',
			name: 'Algorithmics',
			score: 76
		},
		{
			date: '2018-03-21T08:00:00Z',
			name: 'Concurrent Programming',
			score: 83
		},
		{
			date: '2018-09-17T08:00:00Z',
			name: 'Advanced Computer Science 101',
			score: 69
		},
		{
			date: '2019-04-20T08:00:00Z',
			name: 'Distributed Databases',
			score: 73
		}
	]
};
```

This idiom selects all elements in the `score` array.

The `.*` idiom is often seen in definitions and error messages.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ events: {  }, fields: { friends: 'DEFINE FIELD friends ON person TYPE array<record<person>> PERMISSIONS FULL', "friends.*": 'DEFINE FIELD friends.* ON person TYPE record<person> PERMISSIONS FULL' }, indexes: {  }, lives: {  }, tables: {  } }"

*/

DEFINE FIELD friends ON TABLE person TYPE array<record<person>>;
INFO FOR TABLE person;
```

The output for `INFO FOR TABLE person` includes an automatically generated definition for `friends.*`, namely every item inside the `friends` field.

```surql
{
	events: {},
	fields: {
		friends: 'DEFINE FIELD friends ON person TYPE array<record<person>> PERMISSIONS FULL',
		"friends.*": 'DEFINE FIELD friends.* ON person TYPE record<person> PERMISSIONS FULL'
	},
	indexes: {},
	lives: {},
	tables: {}
};
```

### Using `.*` to return values

<Since v="v2.1.0" />

The `.*` idiom in SurrealDB allows you to target all values in an object or all entries in an array. It can be used in various contexts such as querying, field definitions, and data manipulation. This section explains the behavior of `.*` with practical examples.

### Accessing all values in an object

When applied to an object, `.*` returns an array containing all the values of the object's properties.

```surql
/**[test]

[[test.results]]
value = "{ a: 1, b: 2 }"

*/
 { a: 1, b: 2 }.*;
```

<Tabs>
<TabItem value = "SurrealDB 2.x" label="SurrealDB 2.x">

```surql title="Response"
[1, 2]
```

</TabItem>

<TabItem value = "SurrealDB 3.x" label="SurrealDB 3.x">

```surql title="Response"
{ a: 1, b: 2 }
```

</TabItem>

</Tabs>


To see just the values of this object, the [`object::values()`](/docs/surrealql/functions/database/object#objectvalues) function can be used.

```surql
/**[test]

[[test.results]]
value = "[1, 2]"

*/

{ a: 1, b: 2 }.values();

-- [1, 2]
```

#### Defining Fields with `.*`

You can define fields using `.*` to specify constraints or types for all properties within an object field.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

DEFINE FIELD obj ON test TYPE object;
DEFINE FIELD obj.* ON test TYPE number;
```

Here, we define a field `obj` of type `object` on the `test` table, and then specify that all properties within `obj` (`obj.*`) must be of type `number`.

With this done, attempting to insert a non-number value into any property of `obj` will result in an error.

```surql
CREATE test:1 SET obj.a = 'a';

// Error
"Couldn't coerce value for field `obj.*` of `test:1`: Expected `number` but found `'a'`"
```

#### Using `.*` in Different Contexts

Depending on where `.*` is used, it can have different effects on the order of operations. 

For example, if we want to return all the properties of the `person:tobie` record, we can do the following:

```surql
/**[test]

[[test.results]]
value = "{ id: person:tobie, name: 'Tobie' }"

[[test.results]]
value = "{ id: person:tobie, name: 'Tobie' }"

[[test.results]]
value = "{ id: person:tobie, name: 'Tobie' }"

[[test.results]]
value = "{ id: person:tobie, name: 'Tobie' }"

[[test.results]]
value = "{ id: person:tobie, name: 'Tobie' }"

*/

CREATE ONLY person:tobie SET name = 'Tobie';
SELECT * FROM ONLY person:tobie.*;    -- This works
SELECT * FROM ONLY (person:tobie.*);  -- Equivalent to above
SELECT * FROM ONLY { id: person:tobie, name: 'tobie' }; -- Equivalent to above
(SELECT * FROM ONLY person:tobie).*; -- Equivalent to above
```

```surql title="Output"
{
	id: person:tobie,
	name: 'tobie'
}
```

## Last Element

Addionally to access the last element of an array, use `[$]`. Refereing to the `student` record above, we can access the last element of the `results` array using the following idiom:

```surql
SELECT results[$].score FROM student;
```
```surql title="Response"
[
	{
		results: {
			score: 73
		}
	}
]
```

This idiom accesses the last element of the `score` array.

## Method chaining

<Since v="v2.0.0" />

To call a method on the current data, use a dot `.` followed by the method name and parentheses `()` with arguments. SurrealDB supports method chaining, so you can call multiple methods (functions) on the same data. Learn more about [method chaining](/docs/surrealql/functions/database#method-syntax) in the functions section.

For example, let's create a new `person` record and then call `uppercase()` on its name field.

```surql
/**[test]

[[test.results]]
value = "[{ address: { city: 'New York', country: 'USA' }, age: 30, id: person:hfmq0ckvi2u842jqqx9w, name: 'John Doe' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ address: { city: 'New York', country: 'USA' }, age: 30, id: person:hfmq0ckvi2u842jqqx9w, name: 'JOHN DOE' }]"
skip-record-id-key = true

*/

CREATE person CONTENT {
    name: "John Doe",
    age: 30,
    address: {
      city: "New York",
      country: "USA"
    }
};

SELECT *, name.uppercase() FROM person;
```

```surql title="Response"
[
  {
    "person": {
      "name": "John Doe",
      "age": 30,
      "address": {
        "city": "New York",
        "country": "USA"
      }
    }
  }
]
```

In the example above, `uppercase()` is a method called on `person.name` to convert it to uppercase. Although this method is called as `.uppercase()`, it is actually the [`string::uppercase()`](/docs/surrealql/functions/database/string#stringuppercase) function that is called. 

SurrealDB will automatically recognize that the idiom part `.uppercase()` refers to the `string::uppercase()` function and call this function when the query is executed. What this means is that the following two queries are equivilent:

```surql title="Using method chaining"
SELECT *, name.uppercase() FROM person;
```

```surql title="Using function"
SELECT *, string::uppercase(name) FROM person;
```

To learn more about string method chaining in SurrealQL, see the [string functions](/docs/surrealql/functions/database/string#method-chaining) section.

## Graph Navigation

SurrealDB can also be used in the context of graph databases, where data is stored and navigated using graph traversal idioms. The [`RELATE` statement](/docs/surrealql/statements/relate) is used to create relationships between records. This allows you to traverse related records efficiently without needing to pull data from multiple tables and merging that data together using SQL JOINs.


For example, let's consider the following data:

```surql title="Create a new planet, city, and explorer records"
/**[test]

[[test.results]]
value = "[{ id: planet:unknown_planet }]"

[[test.results]]
value = "[{ id: city:el_dorado, name: 'El Dorado' }]"

[[test.results]]
value = "[{ id: explorer:drake, name: 'Drake' }]"

[[test.results]]
value = "[{ id: explorer:local_guide, name: 'Local Guide' }]"

[[test.results]]
value = "[{ id: discovered:4y6p19onn8a0zlgf80rg, in: explorer:drake, out: planet:unknown_planet }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: visited:lnjo8yonp28501y75slq, in: explorer:drake, out: city:el_dorado }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: assisted:5cr7hphseo7t2m87yhwd, in: explorer:local_guide, out: explorer:drake }]"
skip-record-id-key = true

*/

CREATE planet:unknown_planet;
CREATE city:el_dorado          SET name = "El Dorado";
CREATE explorer:drake          SET name = "Drake";
CREATE explorer:local_guide    SET name = "Local Guide";

RELATE explorer:drake->discovered->planet:unknown_planet;
RELATE explorer:drake->visited->city:el_dorado;
RELATE explorer:local_guide->assisted->explorer:drake;

```

```surql title="Retrieve all relationships from Drake"
SELECT 
    *,
    ->? AS actions,
    <-? AS was,
    <->? AS involved_in
FROM explorer:drake;
```

```surql title="Response"
[
	{
		actions: [
			discovered:sh9zbsz5u705cxv6qgoi,
			visited:hmtttiqqfa4mt9is1a7j
		],
		involved_in: [
			assisted:1pv8k3p1wpuf0guf5bvm,
			discovered:sh9zbsz5u705cxv6qgoi,
			visited:hmtttiqqfa4mt9is1a7j
		],
		id: explorer:drake,
		was: [
			assisted:1pv8k3p1wpuf0guf5bvm
		],
		name: 'Drake'
	}
]
```

Explanation:

- `*`: Selects all fields of `explorer:drake`.
- `->? AS actions`: Retrieves all outgoing relationships from Drake and aliases them as actions.
- `<-? AS was`: Retrieves all incoming relationships to Drake and aliases them as was.
- `<->? AS involved_in`: Retrieves all relationships connected to Drake, regardless of direction, and aliases them as `involved_in`.


## Destructuring

<Since v="v2.0.0" />

When working with nested data, you can destructure objects using the `.` and `{ ... }` idioms.

For example, 

```surql title="Create a new person record"
/**[test]

[[test.results]]
value = "[{ age: 21, id: person:1, name: 'John', obj: { a: 1, b: 2, c: { d: 3, e: 4, f: 5 } } }]"

*/


CREATE person:1 SET name = 'John', age = 21, obj = { a: 1, b: 2, c: { d: 3, e: 4, f: 5 } };
```

```surql title="Response"
[
	{
		age: 21,
		id: person:1,
		name: 'John',
		obj: {
			a: 1,
			b: 2,
			c: {
				d: 3,
				e: 4,
				f: 5
			}
		}
	}
]
```

```surql
SELECT obj.{ a, c.{ e, f } } FROM ONLY person:1;
```

```surql title="Response"
{
	obj: {
		a: 1,
		c: {
			e: 4,
			f: 5
		}
	}
}
```
You can also OMIT fields that you don't want to destructure using the `OMIT` clause.

```surql 
SELECT * OMIT obj.c.{ d, f } FROM ONLY person:1;
```


```surql title="Response"
[
	{
		age: 21,
		id: person:1,
		name: 'John',
		obj: {
			a: 1,
			b: 2,
			c: {
				e: 4
			}
		}
	}
]
```

Extending the example in the [Graph Navigation](#graph-navigation) section, we can use the `->` idiom to navigate through the graph and destructure the `city` field. 

```surql
SELECT ->visited->city.{name, id}
FROM explorer:drake;
```

```surql title="Response"
[
	{
		"->visited": {
			"->city": [
				{
					id: city:el_dorado,
					name: 'El Dorado'
				}
			]
		}
	}
]
```

### Using aliases when destructuring

The keyword `AS` is necessary inside `SELECT` statements when [using an alias](/docs/surrealql/statements/select#basic-usage) (a new name for a field).

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ location: (50, -5.4), num_people: 500 }"

*/


LET $town = {
    location: (50.0, -5.4),
    population: 500
};

SELECT 
	location,
	population AS num_people
FROM ONLY $town;
```

```surql title="Output"
{
	location: (50, -5.4),
	num_people: 500
}
```

However, as destructuring involves defining the output shape of a new object, no `AS` keyword is needed. Instead, only the names of the fields are needed. Aliasing is done by choosing a new name, a `:` and the path to the value.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ location: (50, -5.4), num_people: 500 }"

*/

LET $town = {
    location: (50.0, -5.4),
    population: 500
};

RETURN $town.{
    location,
    num_people: population
};
```

Conceptually, this is somewhat close to a `RETURN` statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ location: (50, -5.4), num_people: 500 }"

*/

LET $town = {
    location: (50.0, -5.4),
    population: 500
};

RETURN {
    location: $town.location,
    num_people: $town.population,
};
```

### Destructuring the current item in a SELECT query

<Since v="v2.1.0" />

The current record in a `SELECT` query can be accessed and destructured using the `@` operator.

```surql
/**[test]

[[test.results]]
value = "[{ id: star:sun, name: 'The Sun' }]"

[[test.results]]
value = "[{ id: planet:earth, name: 'Earth' }]"

[[test.results]]
value = "[{ id: planet:earth, name: 'Earth', orbits: [star:sun] }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: planet:earth, name: 'Earth', orbits: [star:sun] }]"

[[test.results]]
value = "[{ id: planet:earth, name: 'Earth', orbits: [star:sun] }]"

*/

, [{ id: planet:earth, name: 'Earth', orbits: [star:sun] }]]
CREATE star:sun SET name = "The Sun";
CREATE planet:earth SET name = "Earth";
RELATE planet:earth->orbits->star:sun;

-- Regular SELECT query
SELECT 
    name,
    id,
    ->orbits->star AS orbits
FROM planet;

-- SELECT query using `@` and destructuring
SELECT @.{
    name,
    id,
    orbits: ->orbits->star
} FROM planet;
```

While the difference between the two methods is often cosmetic - aside from the note on aliases mentioned just above - using `@` to access the current record does lead to a different style of query that may be preferable. While a regular `SELECT` query first returns an array of results that can then be operated on, a `SELECT` query that uses `@` to access the current record can perform these operations first.

```surql
-- Use the .values() method to turn each record into
-- an array of values, then return all inside an array
SELECT @.{
    name,
    id,
    orbits: ->orbits->star
}.values()
    FROM planet;

-- Grab all records first, then use .map() to convert
-- each one into an array of values
(SELECT 
    name,
    id,
    ->orbits->star AS orbits
FROM planet)
    .map(|$obj| $obj.values());
```

Most importantly, however, the `@` operator is often necessary when using [recursive paths](#recursive-paths).

### Using expressions while destructuring

<Since v="v3.0.0-alpha.1" />

While the fields inside a destructuring operation have always been accessible, expressions were not. As of version `3.0.0.alpha-1`, this limitation no longer exists.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:one, name: 'Aeon' }]"

[[test.results]]
value = "{ accessed_at: d'2025-10-02T06:18:26.751462Z', name: 'Aeon', name_length: 4 }"
skip-datetime = true

*/

CREATE person:one SET name = "Aeon";

person:one.{
    name,
	-- worked because 'name' can be accessed
    name_length: name.len(),
	-- an expression: did not work before, works now
    accessed_at: time::now()
};
```

```surql title="Output"
{
	accessed_at: d'2025-04-24T05:11:20.101Z',
	name: 'Aeon',
	name_length: 4
}
```

Expressions inside a destructuring operation have the same [predefined parameters](/docs/surrealql/parameters#parent-this) as any other expression, such as `$this` to the current object and `$parent` to the previous one.

```surql
/**[test]

[[test.results]]
value = "[{ age: 18, id: person:one }]"

[[test.results]]
value = "[{ age: 40, id: person:two }]"

[[test.results]]
value = "[{ age: 18, id: person:three }]"

[[test.results]]
value = "{ age: 18, id: person:one, same_age: [{ age: 18, id: person:one }, { age: 18, id: person:three }] }"

[[test.results]]
value = "{ age: 18, id: person:one, same_age: [{ age: 18, id: person:three }] }"

*/

CREATE person:one SET age = 18;
CREATE person:two SET age = 40;
CREATE person:three SET age = 18;

-- Find all 'person' records of the same age as 'person:one'
-- Here 'person:one' is the $parent of the inner operation
person:one.{
	id,
    age,
    same_age: SELECT * FROM person WHERE age = $parent.age
};

-- Now use array::complement to filter out the 'person:one' current record,
-- which is the parameter $this
person:one.{
	id,
    age,
    same_age: array::complement(SELECT * FROM person WHERE age = $parent.age, [$this])
};
```

```surql title="Output"
-------- Query --------

{
	age: 18,
	id: person:one,
	same_age: [
		{
			age: 18,
			id: person:one
		},
		{
			age: 18,
			id: person:three
		}
	]
}

-------- Query --------

{
	age: 18,
	id: person:one,
	same_age: [
		{
			age: 18,
			id: person:three
		}
	]
}
```

## Optional Parts

<Since v="v2.0.0" />

> [!NOTE]
> Until SurrealDB 3.0.0-alpha.16, this operator was a single `?` question mark. Since this version, it was changed to `.?` to avoid conflicts with the `??` operator when parsing.

The `.?` operator is used to indicate that a part is optional (it may not exist) it also allows you to safely access nested data without having to check if the nested data exists and exit an idiom path early when the result is NONE.

```surql
SELECT person.spouse.?.name FROM person;
```

This idiom safely accesses `person.spouse.name` if `spouse` exists; otherwise, it returns `NONE`.

## Using Optional Parts

If some `person` records have a `spouse` field and others do not:

```surql
SELECT name, spouse.?.name AS spouse_name FROM person;
```

This idiom will return `NONE` for `spouse_name` if the `spouse` field is not present.

## Recursive paths

<Since v="v2.1.0" />

A recursive path allows record link or graph traversal down to a specified depth, as opposed to manually putting together a query to navigate down each level.

Using recursive graph traversal can be thought of as the equivalent of "show me all the third-generation descendants of Mr. Brown" as opposed to "show me the children and children's children and children's children's children of Mr. Brown".

The following shows a recursive query that returns the names of people known by records that the record `person:tobie` knows.

```surql
-- Get all names of people second to Tobie
person:tobie.{2}(->friends_with->person).name;
```

As the syntax of recursive queries tends to be complex to the untrained eye, this section will explain them in order of difficulty, beginning with what queries were necessary before recursive paths were added in SurrealDB version 2.1.

### Overview

Take the following example that creates one planet, two countries, two states/provinces in each of these countries, and two cities in each of those states/provinces. The `CREATE` statements are followed by `UPDATE` statements to set record links between them, and `RELATE` to create bidirectional graph relations between them.

```surql
CREATE
	// One planet
	planet:earth,
	// Two countries
	country:us, country:canada,
	// Four states/provinces
	state:california, state:texas,
	province:ontario, province:bc,
	// Eight cities
	city:los_angeles, city:san_francisco,
	city:houston,     city:dallas,
	city:vancouver,   city:victoria,
	city:toronto,     city:ottawa
	// Give them each names like 'earth', 'us', 'bc', etc.
	SET name = id.id();

// Record and graph links from planet to country
UPDATE planet:earth     SET next = [country:us, country:canada];
RELATE planet:earth     ->has->    [country:us, country:canada];

// Record and graph links from country to state/province
UPDATE country:us       SET next = [state:california, state:texas];
UPDATE country:canada   SET next = [province:ontario, province:bc];
RELATE country:us       ->has->    [state:california, state:texas];
RELATE country:canada   ->has->    [province:bc, province:ontario];

// Record and graph links from state/province to city
UPDATE state:california SET next = [city:los_angeles, city:san_francisco];
UPDATE state:texas      SET next = [city:houston, city:dallas];
UPDATE province:ontario SET next = [city:toronto, city:ottawa];
UPDATE province:bc      SET next = [city:vancouver, city:victoria];
RELATE state:california ->has->    [city:los_angeles, city:san_francisco];
RELATE state:texas      ->has->    [city:houston, city:dallas];
RELATE province:bc      ->has->    [city:vancouver, city:victoria];
RELATE province:ontario ->has->    [city:toronto, city:ottawa];
```

Before version `2.1.0`, traversing each of these paths could only be done manually, requiring a good deal of typing and knowing the exact depth to traverse.

Here is an example using record links:

```surql
SELECT 
	next AS countries,
	next.next AS states_provinces,
	next.next.next AS cities
FROM planet:earth;
```

```surql title="Response"
[
	{
		cities: [
			[
				[
					city:los_angeles,
					city:san_francisco
				],
				[
					city:houston,
					city:dallas
				]
			],
			[
				[
					city:toronto,
					city:ottawa
				],
				[
					city:vancouver,
					city:victoria
				]
			]
		],
		countries: [
			country:us,
			country:canada
		],
		states_provinces: [
			[
				state:california,
				state:texas
			],
			[
				province:ontario,
				province:bc
			]
		]
	}
]
```

And here is an example using graph links.

```surql
SELECT 
	-- Show all `country` records located at `out`
	->has->country AS countries,
	-- Show all `province` or `state` records located at `out`	
	->has->country->has->(province, state) AS state_provinces,
	-- Or use (?) to show any type of record located at `out`
	->has->(?)->has->(?)->has->(?) AS cities
FROM planet:earth;
```

```surql title="Output"
[
	{
		cities: [
			city:toronto,
			city:ottawa,
			city:vancouver,
			city:victoria,
			city:dallas,
			city:houston,
			city:los_angeles,
			city:san_francisco
		],
		countries: [
			country:canada,
			country:us
		],
		state_provinces: [
			province:ontario,
			province:bc,
			state:texas,
			state:california
		]
	}
]
```

### Basics of recursive paths

Using a recursive path allows you to instead set the number of steps to follow instead of manually typing. A recursive path is made by isolating `{}` braces in between two dots, inside which the number of steps is indicated.

```surql
-- Two steps down the record links at the `next` field
planet:earth.{2}.next;
-- Two steps down the `has` graph relation
planet:earth.{2}->has->(?);
```

```surql title="Output"
[
	state:california,
	state:texas,
	province:ontario,
	province:bc
]
```

The number of steps can be any integer from 1 to 256.

```surql
-- 'Found 0 for bound but expected at least 1.'
planet:earth.{0}->has->(?);
-- 'Found 500 for bound but expected 256 at most.'
planet:earth.{500}->has->(?);
```

A range can be inserted into the braces to indicate a desired minimum and maximum depth. 

```surql
-- Returns [] because no 4th-level relations exist
planet:earth.{4}->has->(?);
-- Returns `city` records located at depth 3
planet:earth.{1..4}->has->(?);
-- Open-ended range: also returns `city` records at depth 3
planet:earth.{..}->has->(?);
```

```surql title="Output"
[
	city:toronto,
	city:ottawa,
	city:vancouver,
	city:victoria,
	city:dallas,
	city:houston,
	city:los_angeles,
	city:san_francisco
]
```

### Using () to provide instructions at each depth

Parentheses can be added to a recursive query. To explain their use, consider the following example that attempts to traverse up to a depth of 3 and return the `name` of the records at that level.

```surql
planet:earth.{1..3}->has->(?).name;
```

Unfortunately, the output shows that the query stopped at a depth of one. This is because the query is instructing the database to recurse the entire `->has->(?).name` path between 1 and 3 times, but after the first recursion it has reached a string. And a string on its own is of no use in a `->has->(?)` graph query which expects a record ID.

```surql title="Output"
[
	'canada',
	'us'
]
```

In fact, the above query is equivalent to the following statement which encloses `->has->(?).name` in parentheses.

```surql
planet:earth.{1..3}(->has->(?).name);
```

To make the query work, we can shrink the area enclosed in the parentheses to `->has->(?)`, isolating the part to recurse before moving on to `.name`. It will repeat as many times as instructed and only then move on to the `name` field.

```surql
planet:earth.{1..3}(->has->(?)).name;
```

```surql title="Output"
[
	'toronto',
	'ottawa',
	'vancouver',
	'victoria',
	'dallas',
	'houston',
	'los_angeles',
	'san_francisco'
]
```

The syntax for the query above can be broken down as follows.

```surql
-- starting point
planet:earth
-- desired depth
	.{1..3}
-- instructions for current document
	(->has->(?))
-- leftover idiom path
	.{name, id};
```

### Using `@` to refer to the current record

The `@` symbol is used in recursive queries to refer to the current document. This is needed in recursive `SELECT` queries, as without it there is no way to know the context.

```surql title="Unparsable queries"
-- Parse error: what is the `.` referring to?
-- DB: "Call recursive query on a `planet`? Its `name` field? Something else?"
SELECT .{1..3}(->has->(?)) FROM planet;

-- A similar query that can't be parsed
-- DB: "Call .len() on what?"
SELECT .len() FROM planet;
```

Adding `@` allows the parser to know that the current `planet` record is the starting point for the rest of the query.

```surql title="Parsable queries"
-- Will now call `.{1..3}(has->(?))` on every planet record it finds
SELECT @.{1..3}(->has->(?)) AS cities FROM planet;
-- Will now call `.len()` on every `name` field it finds
SELECT name.len()           AS length FROM planet;
```

### Using `{}` and `.@` to combine results

Inside the structure of a recursive graph query, the `@` symbol is used in the form of `.@` at the end of a path to inform the database that this is the path to be repeated during the recursion. This allows not just the fields on the final depth of the query to be returned, but each one along the way as well.

```surql
planet:earth
	.{1..2}
	.{
		name, 
		id,
-- Query with ->has->(?) on the current record
		contains: ->has->(?).@
	};
```

```surql title="Output"
{
	contains: [
		{
			contains: [
				province:ontario,
				province:bc
			],
			id: country:canada,
			name: 'canada'
		},
		{
			contains: [
				state:texas,
				state:california
			],
			id: country:us,
			name: 'us'
		}
	],
	id: planet:earth,
	name: 'earth'
}
```

The following two rules of thumb are a good way to understand how the syntax inside the structure of the query.

* The individual fields inside a recursive query are simply populated at each point,
* The field with `.@` is used as the gateway to the next depth.

To see this visually, here is the unfolded output of the query above. The `name` and `id` fields appear at each point, while `contains` is used to move on to the next depth.

```surql
-- Original query
planet:earth.{1..2}.{ name, id, contains: ->has->(?).@ };

-- Unfolds to:
planet:earth
	.{
		name, 
		id,
		contains: ->has->(?).{
		  name, 
		  id,
		  contains: ->has->(?)
	    }
	};
```

Similarly, only one `.@` can be present inside such a query, as this is the path that is used to follow the recursive query until the end.

```surql
planet:earth
	.{1..2}
	.{
		name, 
		id,
-- Query with ->has->(?) on the current record
		contains: ->has->(?).@,
        contains2: ->has->(?).@
	};
```

```surql
'Tried to use a `@` repeat recurse symbol in a position where it is not supported'
```

Here are some more simple examples of recursive queries and notes on the output they generate.

```surql
/**[test]

[[test.results]]
value = "[{ friends: [person:jaime, person:micha], id: person:tobie, name: 'Tobie' }, { friends: [person:mary], id: person:jaime, name: 'Jaime' }, { friends: [person:john], id: person:micha, name: 'Micha' }, { id: person:john, name: 'John' }, { id: person:mary, name: 'Mary' }, { id: person:tim, name: 'Tim' }]"

[[test.results]]
value = "[{ id: knows:1, in: person:tobie, out: person:jaime }, { id: knows:2, in: person:tobie, out: person:micha }, { id: knows:3, in: person:micha, out: person:john }, { id: knows:4, in: person:jaime, out: person:mary }, { id: knows:5, in: person:mary, out: person:tim }]"

[[test.results]]
value = "['Tim']"

[[test.results]]
value = "['Tim']"

[[test.results]]
value = "['Tim']"

[[test.results]]
value = "['Tim']"

[[test.results]]
value = "{ connections: [{ connections: [{ connections: [{ connections: [], id: person:tim, name: 'Tim' }], id: person:mary, name: 'Mary' }], id: person:jaime, name: 'Jaime' }, { connections: [{ connections: [], id: person:john, name: 'John' }], id: person:micha, name: 'Micha' }], id: person:tobie, name: 'Tobie' }"

[[test.results]]
value = "[{ names_2nds: ['Tim'] }, { names_2nds: [] }, { names_2nds: ['Tim'] }, { names_2nds: ['John'] }, { names_2nds: [] }, { names_2nds: ['Tim'] }]]"

[[test.results]]
value = ""

*/

INSERT INTO person [
	{ id: person:tobie, name: 'Tobie', friends: [person:jaime, person:micha] },
	{ id: person:jaime, name: 'Jaime', friends: [person:mary] },
	{ id: person:micha, name: 'Micha', friends: [person:john] },
	{ id: person:john, name: 'John' },
	{ id: person:mary, name: 'Mary' },
	{ id: person:tim, name: 'Tim' },
];

INSERT RELATION INTO knows [
	{ id: knows:1, in: person:tobie, out: person:jaime },
	{ id: knows:2, in: person:tobie, out: person:micha },
	{ id: knows:3, in: person:micha, out: person:john },
	{ id: knows:4, in: person:jaime, out: person:mary },
	{ id: knows:5, in: person:mary, out: person:tim },
];

-- Any depth
person:tobie.{..}(->knows->person).name;

-- Minimum 2, maximum 5 iterations of recursion (or either)
person:tobie.{2..6}(->knows->person).name;
person:tobie.{2..}(->knows->person).name;
person:tobie.{..6}(->knows->person).name;

-- Generate complex recursive tree structures:
-- Fetches connections up to 3 levels deep, 
-- collecting their name, id, and connections along the way
-- 3 levels, because the first iteration is used to collect
-- the details for person:tobie
person:tobie.{..4}.{ id, name, connections: ->knows->person.@ };

-- @ is a shortcut to the current document, and acts as a shorthand to start an idiom path.
-- The "." can optionally be omitted
SELECT @{1..4}(->knows->person).name AS names_2nds FROM person;

-- Recursive idioms work with any idiom parts, not limited to graphs
-- Here, we recursively fetch friends and then collect their names
person:tobie.{1..5}(.friend).name;
```

### Behaviour of recursive queries

Recursive queries follow a few rules to determine how far to traverse and what to return. They are:

* `NONE`, `NULL`, and arrays which are empty or contain only `NONE` and/or `NULL` are considered a dead end.
* An iteration with the same value as the previous one is also considered a dead end.
* If an iteration with a dead end does not reach the minimum depth, it returns `NONE`.
* If it has already passed the minimum depth, it returns the last valid value.
* During each iteration, if it encounters an array value, all dead end values are automatically filtered out, ensuring no empty paths are included.

### Filtering recursive fields

Recursive syntax is not just useful in creating recursive queries, but parsing them as well. Take the following example that creates some `person` records, gives each of them two friends, and then traverses the `friends_with` graph for the first `person` records to find its friends, friends of friends, and friends of friends of friends. Since every level except the last contains another `connections` field, adding a `.{some_number}.connections` to a `RETURN` statement is all that is needed to drill down to a certain depth.

```surql
CREATE |person:1..21| SET name = id.id() RETURN NONE;
FOR $person IN SELECT * FROM person {
    LET $friends = (SELECT * FROM person WHERE id != $person.id ORDER BY rand() LIMIT 2);
    RELATE $person->friends_with->$friends;
};

LET $third_degree = person:1.{..3}.{ id, connections: ->friends_with->person.@ };
// Object containing array of arrays of arrays of 'person'
RETURN $third_degree;
// All connections: an array of arrays of arrays of 'person'
RETURN $third_degree.connections;
// Secondary connections: an array of arrays of 'person'
RETURN $third_degree.{2}.connections;
// Tertiary connections: an array of 'person'
RETURN $third_degree.{3}.connections;
// Tertiary connections with aliased fields and original 'person' info
RETURN $third_degree.{
		original_person: id, 
		third_degree_friends: connections.{2}.connections
};
```

Possible output of the final query:

```surql title="Output for third_degree_friends query"
{
	original_person: person:1,
	third_degree_friends: [
		person:13,
		person:3,
		person:14,
		person:10,
		person:8,
		person:3,
		person:3,
		person:14
	]
}
```

### Path and unique node collection, shortest path

<Since v="v2.2.0" />

SurrealDB has a number of built-in algorithms that allow recursive queries to collect all paths, all unique nodes, and to find the shortest path to a record. These can be used by adding the following keywords to the part of the recursive syntax that specifies the depth to recurse:

* `{..+path}`: used to collect all walked paths.
* `{..+collect}`: used to collect all unique nodes walked.
* `{..+shortest=record:id}`: used to find the shortest path to a specified record id, such as `person:tobie` or `person:one`.

The originating (first) record is excluded from these paths by default. However, it can be included by adding `+inclusive` to the syntax above.

* `{..+path+inclusive}`
* `{..+collect+inclusive}`
* `{..+shortest=record:id+inclusive}`

To demonstrate the output of these three algorithms, take the following example showing a small network of friends. The network begins with `person:you`, followed by two friends (`person:friend1`, `person:friend2`), then three acquaintances known by these friends (`person:acquaintance1`, `person:acquaintance2`, `person:acquaintance3`), and finally a movie star (`person:star`) who is known by only one of the acquaintances.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:you, name: 'you' }, { id: person:friend1, name: 'friend1' }, { id: person:friend2, name: 'friend2' }, { id: person:acquaintance1, name: 'acquaintance1' }, { id: person:acquaintance2, name: 'acquaintance2' }, { id: person:acquaintance3, name: 'acquaintance3' }, { id: person:star, name: 'star' }]"

[[test.results]]
value = "[{ id: knows:i8twxf1ghl053391z54j, in: person:you, out: person:friend1 }, { id: knows:071ho0yn3tol4kgwu0fn, in: person:you, out: person:friend2 }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: knows:8fnyab57dotlu2572uc8, in: person:friend1, out: person:friend2 }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: knows:0u34elv08i9ci7igim0f, in: person:friend2, out: person:acquaintance1 }, { id: knows:hgosmpddbv6nuohsgj8p, in: person:friend2, out: person:acquaintance2 }, { id: knows:c04oc5168ubocheihbtu, in: person:friend2, out: person:acquaintance3 }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: knows:d0s3lq6ynweqaryh567o, in: person:acquaintance3, out: person:star }]"
skip-record-id-key = true

*/

CREATE 
	person:you, 
	person:friend1, person:friend2, 
	person:acquaintance1, person:acquaintance2, person:acquaintance3, 
	person:star
-- Give each of them a name like 'you', 'friend1', etc.
SET name = id.id();

-- You have two friends
RELATE person:you->knows->[person:friend1, person:friend2];
-- The first friend is shy and only knows one other person
RELATE person:friend1->knows->person:friend2;
-- The second friend is very social and knows many people you barely know
RELATE person:friend2->knows->[person:acquaintance1, person:acquaintance2, person:acquaintance3];
-- One of those people knows the movie star
RELATE person:acquaintance3->knows->person:star;
```

This representation of this small network of friends allows us to visualize the issues that these three algorithms solve. Using `+path` will output all of the possible paths from `person:you`, `+collect` will collect all of the records in this network, and `+shortest=person:star` will find the shortest path.

```
‎
								  ┌───────►  person:friend1  
     ┌───►person:acquaintance1    │                                                                    
     │                │           │                                                
     │                │           ┼───►person:acquaintance2    person:star   
person:you            │           │                                 ▲        
     │                ▼           │                                 │        
     └────────► person:friend2────┤                                 │        
                                  └───►person:acquaintance3─────────┘                      
```

After specifying an algorithm to use, such as `{..+path}`, add the path that should be followed, in this case `->knows->person`.

#### +path

Adding `+path` will output all of the possible paths starting from `person:you`.

```surql
person:you.{..+path}->knows->person;
```

```surql title="Output"
[
	[
		person:friend2,
		person:acquaintance2
	],
	[
		person:friend2,
		person:acquaintance1
	],
	[
		person:friend1,
		person:friend2,
		person:acquaintance2
	],
	[
		person:friend1,
		person:friend2,
		person:acquaintance1
	],
	[
		person:friend2,
		person:acquaintance3,
		person:star
	],
	[
		person:friend1,
		person:friend2,
		person:acquaintance3,
		person:star
	]
]
```

#### +shortest

As the output of the previous example is fairly short, we can see that there are two ways to get from `person:one` to the movie star at `person:star`, one of which is one step shorter than the other.

To get the database to find the shortest path instead, change the algorithm to `+shortest=person:star`.

```surql
person:you.{..+shortest=person:star}->knows->person;
```

```surql title="Output"
[
	person:friend2,
	person:acquaintance3,
	person:star
]
```

The part after `+shortest` can also take a parameter if it is a record ID. The following example will return the same result as the previous one.

```surql
LET $you = SELECT VALUE id FROM ONLY person WHERE name = 'you' LIMIT 1;
LET $star = SELECT VALUE id FROM ONLY person WHERE name = 'star' LIMIT 1;
$you.{..+shortest=$star}->knows->person;
```

#### +collect

Using `+collect` will collect all of the unique collected records. As this collection is created by moving recursively one level at a time, the output will show the closest connections first and least close connections at the end.

```surql
person:you.{..+collect}->knows->person;
```

```surql title="Output"
[
	person:friend1,
	person:friend2,
	person:acquaintance2,
	person:acquaintance1,
	person:acquaintance3,
	person:star
]
```

#### +inclusive

Adding `+inclusive` will show the same output, except that the original `person:one` record will also be present.

```surql
person:you.{..+shortest=person:star+inclusive}->knows->person;
person:you.{..+collect+inclusive}->knows->person;
```

```surql title="Output"
-------- Query --------

[
	person:you,
	person:friend2,
	person:acquaintance3,
	person:star
]

-------- Query --------

[
	person:you,
	person:friend1,
	person:friend2,
	person:acquaintance2,
	person:acquaintance1,
	person:acquaintance3,
	person:star
]
```

#### Other notes

The unbounded syntax `..` can be replaced with a bounded range to ensure that the recursive query only goes down to a certain depth. For example, using `..2` with `+collect` will show all first- and second-degree relations starting from `person:you`:

```surql
person:you.{..2+collect}->knows->person;
```

```surql title="All first- and second-degree relations"
[
	person:friend1,
	person:friend2,
	person:acquaintance2,
	person:acquaintance1,
	person:acquaintance3
]
```

Doing the same with `+shortest=person:star` will return an empty array, because there is no path from `person:you` to `person:star` that only requires two hops.

```surql
person:you.{..2+shortest=person:star}->knows->person;
```

```surql title="Output"
[]
```

As shown in [a previous section](#using--to-provide-instructions-at-each-depth), parentheses can be used to show which path should be repeated during the recursion. After the path inside the parentheses, the destructuring operator, methods and so on can be used to modify the output. The query can also be written over multiple lines if desired.

```surql
-- Start with you
person:you
-- Get the shortest path
	.{..+shortest=person:star+inclusive}
-- by following ->knows->person
	(->knows->person)
-- then grab the names
	.name
-- and capitalize each one
	.map(|$n| $n.uppercase());
```

```surql title="Output"
[
	'YOU',
	'FRIEND2',
	'ACQUAINTANCE3',
	'STAR'
]
```

#### Do not use `.@` with algorithms

As these three methods use their own algorithms to follow a path, any attempt to construct your own path using `.@` will result in an error. For example, choosing `+path` along with a field `connections: ->knows->person.@` will return an error because `+path` on its own will use its own recursive planner to output every possible path as an array of arrays, while `->knowns->person.@` is an instruction to put together arrays of each record and the next result from the `->knows->person` path at any possible depth.

```surql
person:you.{..+path}.{
    id,
    connections: ->knows->person.@
};
```

```surql
'Can not construct a recursion plan when an instruction is provided'
```

Here is the output of both of these queries at a single depth to show the difference in output.

```surql
person:you.{..1}.{
    id,
    connections: ->knows->person.@
};

person:you.{..1+path}->knows->person;
```

```surql title="Output"
-------- Query --------

{
	connections: [
		person:friend2,
		person:friend1
	],
	id: person:you
}

-------- Query --------

[
	[
		person:friend2
	],
	[
		person:friend1
	]
]
```

#### Example using record links

As is the case with other recursive queries, these three algorithms can be used in the same way with any other path that can be repeated, such as record links. The following example shows the same network of friends as the one above, except that it uses record links instead of graph queries. To traverse these paths, a simple `.knows` is all that is required.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:you, knows: [person:friend1, person:friend2] }]"

[[test.results]]
value = "[{ id: person:friend1, knows: [person:friend2] }]"

[[test.results]]
value = "[{ id: person:friend2, knows: [person:acquaintance1, person:acquaintance2, person:acquaintance3] }]"

[[test.results]]
value = "[{ id: person:acquaintance1 }, { id: person:acquaintance2 }, { id: person:star }]"

[[test.results]]
value = "[{ id: person:acquaintance3, knows: [person:star] }]"

[[test.results]]
value = "[person:friend2, person:acquaintance3, person:star]"

[[test.results]]
value = "[[person:friend2, person:acquaintance1], [person:friend2, person:acquaintance2], [person:friend1, person:friend2, person:acquaintance1], [person:friend1, person:friend2, person:acquaintance2], [person:friend2, person:acquaintance3, person:star], [person:friend1, person:friend2, person:acquaintance3, person:star]]"

[[test.results]]
value = "[person:friend1, person:friend2, person:acquaintance1, person:acquaintance2, person:acquaintance3, person:star]"

*/

CREATE person:you SET knows = [person:friend1, person:friend2];
CREATE person:friend1 SET knows = [person:friend2];
CREATE person:friend2 SET knows = [person:acquaintance1, person:acquaintance2, person:acquaintance3];
CREATE person:acquaintance1, person:acquaintance2, person:star;
CREATE person:acquaintance3 SET knows = [person:star];

person:you.{..+shortest=person:star}.knows;
person:you.{..+path}.knows;
person:you.{..+collect}.knows;
```

# Combining Idiom Parts

Idioms can combine multiple parts to navigate complex data structures seamlessly.

Suppose we have the following data:

```surql title="Create a new person record"
/**[test]

[[test.results]]
value = "[{ friends: [{ age: 25, id: 'person:6', name: 'Frank' }, { age: 19, id: 'person:7', name: 'Grace' }, { age: 17, id: 'person:8', name: 'Heidi' }], id: person:5, name: 'Eve' }]"

*/

CREATE person:5 CONTENT {
    name: "Eve",
    friends: [
        {
            id: "person:6",
            name: "Frank",
            age: 25
        },
        {
            id: "person:7",
            name: "Grace",
            age: 19
        },
        {
            id: "person:8",
            name: "Heidi",
            age: 17
        }
    ]
};
```

```surql title="Response"
[
	{
		friends: [
			{
				age: 25,
				id: 'person:6',
				name: 'Frank'
			},
			{
				age: 19,
				id: 'person:7',
				name: 'Grace'
			},
			{
				age: 17,
				id: 'person:8',
				name: 'Heidi'
			}
		],
		id: person:5,
		name: 'Eve'
	}
]
```

To get the names of friends who are over 18:

```surql
SELECT friends[WHERE age > 18].name FROM person WHERE id = r'person:5';
```

```surql title="Response"
[
	{
		friends: {
			name: [
				'Frank',
				'Grace'
			]
		}
	}
]
```

# Notes on Idioms

- **Chaining**: Idioms can be chained to traverse deeply nested structures.
- **Performance**: Be mindful of performance when using complex idioms; indexing fields can help.
- **NONE Safety**: Use optional parts (`?`) to handle `NONE` or missing data gracefully.
- **Methods**: Leverage built-in methods for data manipulation within idioms.
- **Type Casting**: Use type casting if necessary to ensure data is in the correct format.

# Best Practices

- **Use Destructuring**: When selecting multiple fields, destructuring improves readability.
- **Limit Optional Parts**: Use optional parts judiciously to avoid masking data issues.
- **Validate Data**: Ensure data conforms to expected structures, especially when dealing with optional fields.
- **Index Fields**: Index fields that are frequently accessed or used in `WHERE` clauses for better performance.

# Summary

Idioms in SurrealQL are a powerful tool for navigating and manipulating data within your database. By understanding and effectively using idiom parts, you can write expressive and efficient queries that handle complex data structures with ease. Whether you're accessing nested fields, filtering arrays, or traversing graph relationships, idioms provide the flexibility you need to interact with your data seamlessly.



================================================
FILE: src/content/doc-surrealql/datamodel/ids.mdx
================================================
---
sidebar_position: 17
sidebar_label: Record IDs
title: Record IDs | SurrealQL
description: In SurrealDB, document record IDs store both the table name, and the record ID.

---

# Record IDs

> [!NOTE]
> As of `v2.0.0`, SurrealDB no longer eagerly converts a string into a record. An [implicit `r` prefix or cast](/docs/surrealql/datamodel/casting#casting-vs-affixes) is required instead.

SurrealDB record IDs are composed of a table name and a record identifier separated by a `:` in between, allowing for a simple and consistent way to reference records across the database. Record IDs are used to uniquely identify records within a table, to [query](/docs/surrealql/statements/select), [update](/docs/surrealql/statements/update), and [delete](/docs/surrealql/statements/delete) records, and serve as [links](/docs/surrealql/datamodel/records) from one record to another.

Record IDs can be constructed from a number of ways, including [alphanumeric text](/docs/surrealql/datamodel/ids#text-record-ids), complex Unicode text and symbols, [numbers](/docs/surrealql/datamodel/ids#numeric-record-ids), arrays, objects, [built-in ID generation functions](/docs/surrealql/datamodel/ids#random-ids), and [a function to generate an ID from values](/docs/surrealql/functions/database/type#typerecord).


All of the following are examples of valid record IDs in SurrealQL.

```surql
company:surrealdb
company:w6xb3izpgvz4n0gow6q7
reaction:`🤪`
weather:['London', d'2025-02-14T01:52:50.375Z']
```

As all record IDs are unique, trying to create a new record with an existing record ID will return an error. To create a record or modify it if the ID already exists, use an [`UPSERT`](/docs/surrealql/statements/upsert) statement or an [`INSERT`](/docs/surrealql/statements/insert#example-usage) statement with an `ON DUPLICATE KEY UPDATE` clause.

## Types of Record IDs

### Random IDs

When you [create a record](/docs/surrealql/statements/create) without specifying the full ID, a random identifier is assigned after the table name. This differs from the traditional default of auto-increment or serial IDs that many developers are used to.

```surql
/**[test]

[[test.results]]
value = "[{ id: company:igtjgekhxfbd9km14j7t }]"
skip-record-id-key = true

*/


CREATE company;
```

```surql title="Output"
[
	{
		id: company:ezs644u19mae2p68404j
	}
]
```

Record IDs can be generated with a number of built-in ID generation functions, which are cryptographically secure and suitable for dispersion across a distributed datastore. These include a 20 digit alphanumeric ID (the default), sequentially incrementing and temporally sortable ULID Record identifiers, and UUID version 7 Record identifiers.

```surql
/**[test]

[[test.results]]
value = "[{ celsius: 37.5f, id: temperature:f8xh13smeqhbg7h9o1rw, time: d'2025-10-03T01:03:27.756064Z' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ celsius: 37.5f, id: temperature:a5wxgrluu3n0qxrgkfb9, time: d'2025-10-03T01:03:27.756317Z' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ celsius: 37.5f, id: temperature:01K6KSGTGCZ631S0325WPW3KF1, time: d'2025-10-03T01:03:27.756405Z' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ celsius: 37.5f, id: temperature:u'0199a798-6a0c-7f51-8b87-e856013f98ec', time: d'2025-10-03T01:03:27.756501Z' }]"
skip-record-id-key = true

*/


// Generate a random record ID 20 characters in length
// Charset: `abcdefghijklmnopqrstuvwxyz0123456789`
CREATE temperature:rand() SET time = time::now(), celsius = 37.5;
// Identical to the above CREATE statement, because
// :rand() is the default random ID format
CREATE temperature SET time = time::now(), celsius = 37.5;

// Generate a ULID-based record ID
CREATE temperature:ulid() SET time = time::now(), celsius = 37.5;
// Generate a UUIDv7-based record ID
CREATE temperature:uuid() SET time = time::now(), celsius = 37.5;
```

### Text Record IDs

Text record IDs can contain letters, numbers and `_` characters.

```surql
/**[test]

[[test.results]]
value = "[{ id: company:surrealdb, name: 'SurrealDB' }]"

[[test.results]]
value = "[{ id: user_version_2025:aajz3qh1nk0b27tztsa7, name: 'Alucard' }]"
skip-record-id-key = true

*/

CREATE company:surrealdb SET name = 'SurrealDB';
CREATE user_version_2025 SET name = 'Alucard';
```

To create a record ID with complex characters, use <code>`</code> (backticks) around the table name and/or record identifier.

```surql
/**[test]

[[test.results]]
value = "[{ author: person:tobie, id: article:⟨8424486b-85b3-4448-ac8d-5d51083391c7⟩, time: d'2025-10-03T01:06:17.050210Z' }]"

[[test.results]]
value = "[{ author: person:⟨Lech_Wałęsa⟩, id: ⟨Artykuł⟩:100 }]"

*/

CREATE article:`8424486b-85b3-4448-ac8d-5d51083391c7` SET
    time = time::now(),
    author = person:tobie;

CREATE `Artykuł`:100 SET
    author = person:`Lech_Wałęsa`;
```

The parts of record IDs with complex characters will display enclosed by <code>`</code> backticks.

```surql title="Output"
-------- Query --------

[
	{
		author: person:tobie,
		id: article:`8424486b-85b3-4448-ac8d-5d51083391c7`,
		time: d'2025-02-18T01:48:46.364Z'
	}
]

-------- Query --------

[
	{
		author: person:`Lech_Wałęsa`,
		id: `Artykuł`:100
	}
]
```

### Numeric Record IDs

If you create a record ID with a number as a string, it will be stored with <code>`</code> backticks to differentiate it from a number.

```surql
/**[test]

[[test.results]]
value = "[{ id: article:10 }]"

[[test.results]]
value = "[{ id: article:⟨10⟩ }]"

[[test.results]]
value = "[{ id: article:article10 }]"

[[test.results]]
value = "[article:10, article:⟨10⟩, article:article10]"

*/

CREATE article SET id = 10;
CREATE article SET id = "10";
CREATE article SET id = "article10";
SELECT VALUE id FROM article;
```

As the record ID `article:10` is different from ```article:`10` ```, no errors are returned when creating and both records turn up in the output of the `SELECT` statement. Meanwhile, the article with the identifier `article10` does not use backticks as there is no `article10` number to differentiate it from.

```surql title="Output"
[
	article:10,
	article:`10`,
    article:article10
]
```

If a numeric value is specified without any decimal point suffix and is within the range `-9223372036854775808` to `9223372036854775807` then the value will be parsed, stored, and treated as a 64-bit signed integer.

Any numeric numbers outside of the range of a signed 64-bit integer will be stored as a string.

```surql
/**[test]

[[test.results]]
value = "[{ celsius: 37.5f, id: temperature:17493, time: d'2025-10-03T01:09:50.155406Z' }]"

[[test.results]]
value = "[{ events: ['Galactic senate convenes', 'Mr. Bean still waits in a field'], id: year:⟨29878977097987987979232⟩ }]"

*/

CREATE temperature:17493 SET time = time::now(), celsius = 37.5;
CREATE year:29878977097987987979232 SET
    events = [
        "Galactic senate convenes",
        "Mr. Bean still waits in a field"
    ];
```

```surql title="Output"
-------- Query --------

[
	{
		celsius: 37.5f,
		id: temperature:17493,
		time: d'2025-02-17T06:21:08.911Z'
	}
]

-------- Query s--------

[
	{
		events: [
			'Galactic senate convenes',
			'Mr. Bean still waits in a field'
		],
		id: year:`29878977097987987979232`
	}
]
```

### Array-based Record IDs

Record IDs can be constructed out of arrays and even objects. This sort of record ID is most used when you have a field or two that will be used to look up records inside a [record range](/docs/surrealql/datamodel/ids#record-ranges), which is extremely performant. This is in contrast to using a `WHERE` clause to filter, which involves a table scan.

Records in SurrealDB can store arrays of values, with no limit to the depth of the arrays. Arrays can store any value stored within them, and can store different value types within the same array.

```surql
/**[test]

[[test.results]]
value = "[{ conditions: 'cloudy', id: weather:['London', d'2025-02-13T05:00:00Z'], temperature: 5.7f }]"

*/

CREATE weather:['London', d'2025-02-13T05:00:00Z'] SET
    temperature = 5.7,
    conditions = "cloudy";
```

```surql title="Output"
[
	{
		conditions: 'cloudy',
		id: weather:[
			'London',
			d'2025-02-13T05:00:00Z'
		],
		temperature: 5.7f
	}
]
```

### Why record ranges are performant

The main reason why record ranges are so performant is simply because the database knows ahead of time in which area to look for records in a query, and therefore has a smaller "surface area" to work in.

This can be demonstrated by seeing what happens when a single record range query encompasses all of the records in a database. The example below creates 10,000 `player` records that have an array-based record ID that begins with `'mage'`, allowing them to be used in a record range query, as well as a field called `class` that is also `'mage'`, which will be used in a `WHERE` clause to compare performance.

Interestingly, in this case a record range query is only somewhat more performant. This is because both queries end up iterating over 10,000 records, with the only difference being that the query with a `WHERE` clause also checks to see if the value of the `class` field is equal to `'mage'`.

```surql
FOR $_ IN 0..10000 {
    CREATE player:['mage', rand::id()] SET class = 'mage';
};

LET $_ = SELECT * FROM player:['mage', NONE]..['mage', ..];
LET $_ = SELECT * FROM player WHERE class = 'mage';
```

If the number of `player` records is extended to a larger number of classes, however, the difference in performance will be much larger. In this case the record range query is still only iterating a relatively small surface area of 10,000 records, while the second one has ten times this number to go through in addition to the `WHERE` clause on top.

```surql
FOR $_ IN 0..10000 {
  CREATE player:['mage', rand::id()] SET class = 'mage';
  CREATE player:['barbarian', rand::id()] SET class = 'barbarian';
  CREATE player:['rogue', rand::id()]     SET class = 'rogue';
  CREATE player:['bard', rand::id()]      SET class = 'bard';
  CREATE player:['sage', rand::id()]      SET class = 'sage';
  CREATE player:['psionic', rand::id()]   SET class = 'psionic';
  CREATE player:['thief', rand::id()]     SET class = 'thief';
  CREATE player:['paladin', rand::id()]   SET class = 'paladin';
  CREATE player:['ranger', rand::id()]    SET class = 'ranger';
  CREATE player:['cleric', rand::id()]    SET class = 'cleric';
};

LET $_ = SELECT * FROM player:['mage', NONE]..['mage', ..];
LET $_ = SELECT * FROM player WHERE class = 'mage';
```

### IDs made with parameters and function calls

Parameters and function calls can be used inside array- and object-based record IDs in the same way as on standalone arrays and objects.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ conditions: 'cloudy', id: weather:['Seoul', d'2025-10-03T01:11:38.204589Z'], temperature: -2.3f }]"
skip-datetime = true

[[test.results]]
value = "[{ conditions: 'cloudy', id: weather:['London', d'2025-10-03T01:11:38.204961Z'], temperature: 5.3f }]"
skip-datetime = true

*/

LET $now = time::now();

CREATE weather:['Seoul', $now] SET
    temperature = -2.3,
    conditions = "cloudy";

CREATE weather:['London', time::now()] SET
    temperature = 5.3,
    conditions = "cloudy";
```

To create a record that uses a parameter or function call as its entire record identifier, the [`type::record()`](/docs/surrealql/functions/database/type#typerecord) function can be used. (Note: this function was known as `type::thing()` before SurrealDB 3.0)

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ city: 'London', id: weather:⟨2025-10-03T01:13:14.238633Z⟩ }]"
skip-record-id-key = true

*/

LET $now = time::now();

CREATE type::record("weather", $now) SET city = 'London';
```

```surql title="Output"
[
	{
		city: 'London',
		id: weather:`2025-02-18T02:30:08.563Z`
	}
]
```

## Defining record IDs in a schema

The type name of a record ID is `record`, which by default allows any sort of record. This type can be set inside a [`DEFINE FIELD`](/docs/surrealql/statements/define/field) statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ friends: [person:one, person:two], id: person:663uogu8gnw31irybeer, possessions: [book:one, house:one] }]"
skip-record-id-key = true

*/

DEFINE FIELD possessions ON TABLE person TYPE option<array<record>>;
DEFINE FIELD friends ON TABLE person TYPE option<array<record<person>>>;

CREATE person SET
    possessions = [ book:one, house:one],
    friends = [ person:one, person:two ];
```

Be sure to use just `record` instead of `record<any>`, as `<any>` here would imply actual records of a table called `any`.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
match = "$error = "Couldn't coerce value for field `possessions` of `person:*`: Expected `none | array<record<any>>` but found `[book:one, house:one]`""
error = true

[[test.results]]
value = "[{ id: person:u6qd2t4ij2h45bkf2gk4, possessions: [any:one, any:two] }]"
skip-record-id-key = true

*/

DEFINE FIELD possessions ON TABLE person TYPE option<array<record<any>>>;

-- Won't work, 'book' and 'house' are not of table 'any'
CREATE person SET
    possessions = [ book:one, house:one ];

-- Actually expects this, which is probably
-- not what the DEFINE FIELD intended
CREATE person SET
    possessions = [ any:one, any:two ];
```

## Record ranges

SurrealDB supports the ability to query a range of records, using the record ID. Record ID range queries retrieve records using the natural sorting order of the record IDs, making a table scan unnecessary. These range queries can be used to query a range of records in a timeseries context.

```surql
-- Select all person records with IDs between the given range
SELECT * FROM person:1..1000;

-- Select all records for a particular location, inclusive
SELECT * FROM temperature:['London', NONE]..=['London', ..];

-- Select all temperature records with IDs less than a maximum value
SELECT * FROM temperature:..['London', '2022-08-29T08:09:31'];

-- Select all temperature records with IDs greater than a minimum value
SELECT * FROM temperature:['London', '2022-08-29T08:03:39']..;

-- Select all temperature records with IDs between the specified range
SELECT * FROM temperature:['London', '2022-08-29T08:03:39']..['London', '2022-08-29T08:09:31'];
```

The following example shows the difference in performance between a regular query that uses a `WHERE` clause and a record range scan.

```surql
FOR $num IN 0..=100000 {
  CREATE person SET id = $num, num = $num  
};

-- Assign the output to an unused parameter
-- to avoid excessive output
LET $_ = SELECT * FROM person WHERE num IN 0..=1000;
LET $_ = SELECT * FROM person:0..=1000;
```

## Tips and best practices for record IDs

### Why choose the right record ID format

Choosing an apt record ID format is especially important because record IDs is SurrealQL are immutable. Take the following `user` records for example:

```surql
FOR $i IN 0..5 {
    CREATE user SET user_num = $i, name = "User number " + <string>user_num;
};
```

Each of these `user` records will have a random ID, such as `user:wvjqjc5ebqvfg3aw7g61`. If a decision is made to move away from random IDs to some other form, such as an incrementing number, this will have to be done manually.

```surql
FOR $user IN SELECT * FROM user {
    -- Use type::record to make a record ID
    -- from the user_num field
    CREATE type::record("user", $user.user_num);
    -- Then delete the old user
    DELETE $user;
};

SELECT * FROM user;
```

The final query returning just the IDs shows that they have been recreated with new IDs.

```surql title="Output"
[
	{
		id: user:0,
		name: 'User number 0'
	},
	{
		id: user:1,
		name: 'User number 1'
	},
	{
		id: user:2,
		name: 'User number 2'
	},
	{
		id: user:3,
		name: 'User number 3'
	},
	{
		id: user:4,
		name: 'User number 4'
	}
]
```

However, record IDs are also used as [record links](/docs/surrealql/datamodel/records) and to create [graph relations](/docs/surrealql/statements/relate). If this is the case, more work will have to be done in order to recreate the former state.

The following example shows five `user` records, which each have a 50% chance of liking each of the other users.

```surql
FOR $i IN 0..5 {
    CREATE user SET user_num = $i, name = "User number " + <string>user_num;
};

LET $users = SELECT * FROM user;
FOR $user IN $users {
    LET $others = array::complement($users, [$user.id]);
    FOR $counterpart IN $others {
        IF rand::bool() {
            RELATE $user->likes->$counterpart;
        }
    }
};
```

Finding out the current relational state can be done with a query like the following which shows all of the graph tables in which a record is located at the `in` or `out` point. The `?` is a wildcard operator, returning any and all tables found at this point of the graph query.

```surql
SELECT
    id,
    ->?->? AS did, 
    <-?<-? AS done_to
FROM user;
```

```surql title="Output"
[
	{
		did: [
			user:zwfnk4by9gmopf6eeqm0
		],
		done_to: [
			user:d6bx6sch5li8qmhq3ljl,
			user:ekovipptanvmgr8f48v6
		],
		id: user:6ycb63zr0k3cpzwel1ga
	},
	{
		did: [
			user:ekovipptanvmgr8f48v6,
			user:6ycb63zr0k3cpzwel1ga,
			user:zk7tpaduzaiuswll58sg
		],
		done_to: [],
		id: user:d6bx6sch5li8qmhq3ljl
	}
    -- and so on..
]
```

Surrealist's [graph visualization view](/blog/whats-new-in-surrealist-3-2#graph-visualisation) can help as well.

![Surrealist's graph view showing possible output from the previous randomized query in which each of the five user records may or may not like another user. In this case, the output resembles a rhombus with an extra line jutting out from the top left.](graph_view.png)

With this in mind, here are some of the items to keep in mind when deciding what sort of record ID format to use.

### Meaningful sortable IDs are faster to query

Records are returned in ascending record ID order by default. As the following query shows, a `SELECT` statement on a large number of `user` records with random IDs will show those with record identifiers starting with a large number of zeroes. While the IDs are sortable, the IDs themselves are completely random.

```surql
CREATE |user:200000| RETURN NONE;
SELECT VALUE id FROM user LIMIT 4;
```

```surql title="Output"
[
	user:0001th0nnywnczi7mrvk,
	user:000t5r3y7u8stqtecvht,
	user:000tjk1nbi1it1bedplc,
	user:001dfral92ltbdznypcd
]
```

For a large number of records, pagination can be used to retrieve a certain amount of records at a time.

```surql
-- Returns the same four records as above
SELECT VALUE id FROM user START 0 LIMIT 2;
SELECT VALUE id FROM user START 2 LIMIT 2;
```

```surql title="Output"
-------- Query --------

[
	user:0001th0nnywnczi7mrvk,
	user:000t5r3y7u8stqtecvht
]

-------- Query --------

[
	user:001dfral92ltbdznypcd,
	user:001hv9g1uzh32nophrpo
]
```

As record ranges are very performant, consider moving any fields that may be used in a `WHERE` clause into the ID itself.

In the following example, a number of `user` records are created using the default random ID, plus a `num` field that tracks in which order the user was created.

```surql
FOR $num IN 0..100 {
    CREATE user SET num = $num;
    sleep(1ms); -- Simulate a bit of time between user creation
};

SELECT * FROM user WHERE num IN 50..=51;
SELECT * FROM user START 50 LIMIT 2;
```

As the output from the `SELECT` statements show, a `WHERE` clause is needed to find two users starting at a `num` of 50, as `START 50` starts based on the user of the record ID, which is entirely random.

```surql
-------- Query --------

[
	{
		id: user:pqpeg0edt8kpda907o01,
		num: 50
	},
	{
		id: user:ty6qr7zyob5dh882it08,
		num: 51
	}
]

-------- Query --------

[
	{
		id: user:hvfp5m5ty7n2k95dbamv,
		num: 70
	},
	{
		id: user:hvfumcmmveuolg4e2h26,
		num: 36
	}
]
```

Using a ULID in this case will allow the IDs to remain random, but still sorted by date of creation.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: user:01K6KTHCCJW7ZA6NWBZEFEVDC9, num: 50 }, { id: user:01K6KTHCCNRMN565T2H6JW70D6, num: 51 }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: user:01K6KTHCCJW7ZA6NWBZEFEVDC9, num: 50 }, { id: user:01K6KTHCCNRMN565T2H6JW70D6, num: 51 }]"
skip-record-id-key = true

*/

FOR $num IN 0..100 {
    CREATE user:ulid() SET num = $num;
    sleep(1ms);
};

SELECT * FROM user WHERE num IN 50..=51;
SELECT * FROM user START 50 LIMIT 2;
```

Not only is the `START 50 LIMIT 2` query more performant, but the entire `num` field could be removed if its only use is to return records by order of creation.

```surql title="Same record IDs for both queries this time"
-------- Query --------

[
	{
		id: user:01JM1AHN7DDN7XM5KZ2RR2YM1S,
		num: 50
	},
	{
		id: user:01JM1AHN7FS4A3B6RNFCF64H90,
		num: 51
	}
]

-------- Query --------

[
	{
		id: user:01JM1AHN7DDN7XM5KZ2RR2YM1S,
		num: 50
	},
	{
		id: user:01JM1AHN7FS4A3B6RNFCF64H90,
		num: 51
	}
]
```

### Move exact matches in array-based record IDs to the front

Take the following `event` records which can be queried as a perfomant record range.

```surql
/**[test]

[[test.results]]
value = "[{ id: event:[d'2025-05-05T08:00:00Z', user:one, 'debug'], info: 'Logged in' }]"

[[test.results]]
value = "[{ id: event:[d'2025-05-05T08:10:00Z', user:one, 'debug'], info: 'Logged out' }]"

[[test.results]]
value = "[{ id: event:[d'2025-05-05T08:01:00Z', user:two, 'debug'], info: 'Logged in' }]"

*/

CREATE event:[d'2025-05-05T08:00:00Z', user:one, "debug"] SET info = "Logged in";
CREATE event:[d'2025-05-05T08:10:00Z', user:one, "debug"] SET info = "Logged out";
CREATE event:[d'2025-05-05T08:01:00Z', user:two, "debug"] SET info = "Logged in";
```

The ordering of the ID in this case is likely not ideal, because the first item in the array, a `datetime`, will be the first to be evaluated in a range scan. A query such as the one below on a range of dates will effectively ignore the second and third parts of the ID.

```surql
SELECT * FROM event:[d'2025-05-05', user:one, "debug"]..[d'2025-05-06', user:one, "debug"];

-- Same result! user name and "debug" are irrelevant
-- SELECT * FROM event:[d'2025-05-05']..[d'2025-05-06'];
```

```surql title="Output"
[
	{
		id: event:[
			d'2025-05-05T08:00:00Z',
			user:one,
			'debug'
		],
		info: 'Logged in'
	},
	{
		id: event:[
			d'2025-05-05T08:01:00Z',
			user:two,
			'debug'
		],
		info: 'Logged in'
	},
	{
		id: event:[
			d'2025-05-05T08:10:00Z',
			user:one,
			'debug'
		],
		info: 'Logged out'
	}
]
```

Instead, the parts of the array that are more likely to be exactly matched (such as `user:one` and `"debug"`) should be moved to the front.

```surql
/**[test]

[[test.results]]
value = "[{ id: event:[user:one, 'debug', d'2025-05-05T08:00:00Z'], info: 'Logged in' }]"

[[test.results]]
value = "[{ id: event:[user:one, 'debug', d'2025-05-05T08:10:00Z'], info: 'Logged out' }]"

[[test.results]]
value = "[{ id: event:[user:two, 'debug', d'2025-05-05T08:01:00Z'], info: 'Logged in' }]"

*/


CREATE event:[user:one, "debug", d'2025-05-05T08:00:00Z'] SET info = "Logged in";
CREATE event:[user:one, "debug", d'2025-05-05T08:10:00Z'] SET info = "Logged out";
CREATE event:[user:two, "debug", d'2025-05-05T08:01:00Z'] SET info = "Logged in";
```

Using this format, queries can now be performed for a certain user and logging level, over a range of datetimes.

```surql
-- Only returns events for user:one and "debug"
SELECT * FROM event:[user:one, "debug", d'2025-05-05']..[user:one, "debug", d'2025-05-06'];
```

```surql title="Output"
[
	{
		id: event:[
			user:one,
			'debug',
			d'2025-05-05T08:00:00Z'
		],
		info: 'Logged in'
	},
	{
		id: event:[
			user:one,
			'debug',
			d'2025-05-05T08:10:00Z'
		],
		info: 'Logged out'
	}
]
```

### Auto-incrementing IDs

While SurrealDB does not use auto-incrementing IDs by default, this behaviour can be achieved in a number of ways. One is to use the [`record::id()`](/docs/surrealql/functions/database/record#recordid) function on the latest record, which returns the latter part of a record ID (the '1' in the record ID `person:1`). This can then be followed up with the [`type::record()`](/docs/surrealql/functions/database/type#typerecord) function to create a new record ID.

```surql
-- Create records from person:1 to person:10
CREATE |person:1..11|;
LET $latest = SELECT VALUE id FROM ONLY person ORDER BY id DESC LIMIT 1;
CREATE type::record("person", $latest.id() + 1);
```

```surql title="Output"
[
	{
		id: person:11
	}
]
```

When dealing with a large number of records, a more performant option is to use a separate record that holds a single value representing the latest ID. An [`UPSERT`](/docs/surrealql/statements/upsert) statement is best here, which will allow the counter to be initialized if it does not yet exist, and updated otherwise. This is best done [inside a manual transaction](/docs/surrealql/statements/begin) so that the latest ID will be rolled back if any failures occur when creating the next record.

```surql
/**[test]

[[test.results]]
value = "[{ id: person_id:counter, num: 1 }]"

[[test.results]]
value = "[{ id: person:1 }]"

[[test.results]]
error = "'The query was not executed due to a failed transaction'"

[[test.results]]
error = ""Expected `datetime` but found a `'2025_01+01'`""

[[test.results]]
value = "1"

*/

BEGIN TRANSACTION;
UPSERT person_id:counter SET num += 1;
-- Creates a person:1
CREATE type::record("person", person_id:counter.num);
COMMIT TRANSACTION;

BEGIN TRANSACTION;
-- Latest ID is now 2
UPSERT person_id:counter SET num += 1;
-- Whoops, invalid datetime format
-- Transaction fails and all changes are rolled back
CREATE type::record("person", person_id:counter.num) SET created_at = <datetime>'2025_01+01';
COMMIT TRANSACTION;

-- Latest ID is still 1
RETURN person_id:counter.num;
```

### Record IDs are record links

As a record ID is a pointer to all of the data of a record, a single record ID is enough to access all of a record's fields. This behaviour is the key to the convenience of [record links](/docs/surrealql/datamodel/records) in SurrealDB, as holding a record ID is all that is needed for one record to have a link to another.

When using a standalone record ID as a record pointer, be sure to use the record ID itself.

```surql
/**[test]

[[test.results]]
value = "[{ data: { data: 'for', demonstration: 'purposes', some: 'demo' }, id: person:1 }]"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: person:1 }]"

*/

CREATE person:1 SET data = {
    some: "demo",
    data: "for",
    demonstration: "purposes"
};

LET $record = SELECT id FROM person:1;
SELECT * FROM $record;
```

The output of the above query is just the `id` field on its own, as the `$record` parameter is an object with an `id` field, not the `id` field (the pointer) itself.

```surql title="Output"
[
	{
		id: person:1
	}
]
```

To rectify this, `id.*` can be used to follow the pointer to the entire data for the record.

```surql
SELECT id.* FROM $record;
```

```surql title="Output"
[
	{
		id: {
			data: {
				data: 'for',
				demonstration: 'purposes',
				some: 'demo'
			},
			id: person:1
		}
	}
]
```

## Limitations

At present, the `VALUE` clause cannot be used inside a [`DEFINE FIELD`](/docs/surrealql/statements/define/field) statement.

```surql
/**[test]

[[test.results]]
error = "'Cannot use the `VALUE` keyword on the `id` field.'"

*/

DEFINE FIELD id ON user VALUE rand::int(1, 1000000000) READONLY;
```

```surql title="Output"
[
	{
		id: user:9ixn3oei6o532c2qyixa
	}
]
```

To achieve the desired behaviour, the `id` field can be set inside the statement to create the record.

```surql
/**[test]

[[test.results]]
value = "[{ id: user:639167349 }]"
skip-record-id-key = true

*/


CREATE user SET id = rand::int(1, 1000000000);
```

## Learn more

Learn more about record IDs [in this blogpost](/blog/the-life-changing-magic-of-surrealdb-record-ids#the-performance-at-scale) and on this [youtube video](https://www.youtube.com/watch?v=c0cqmWRYP8c).



================================================
FILE: src/content/doc-surrealql/datamodel/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Data types
title: Data types | SurrealQL
description: SurrealQL allows you to describe data with specific data types. These data types are used to validate data and to generate the appropriate database schema.

---

import Table from '@components/shared/Table.astro'

# Data types

SurrealQL allows you to describe data with specific data types. These data types are used to validate data and to generate the appropriate database schema.

<Table>
    <thead>
        <tr>
            <th scope="col" class="w-40">Type</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Type">
                <code>any</code>
            </td>
            <td scope="row" data-label="Description">
                Use this when you explicitly don't want to specify the field's data type. The field will allow any data type supported by SurrealDB.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>array</code>
            </td>
            <td scope="row" data-label="Description">
                An array of items.
                The array type also allows you to define which types can be stored in the array and the max length.
                <ul>
                    <li><code>array</code></li>
                    <li><code>array&lt;string&gt;</code></li>
                    <li><code>array&lt;string, 10&gt;</code></li>
                </ul>
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>bool</code>
            </td>
            <td scope="row" data-label="Description">
                Describes whether something is truthy or not.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#bytes"><code>bytes</code></a>
            </td>
            <td scope="row" data-label="Description">
                Stores a value in a byte array.
                <ul>
                    <li><code>&lt;bytes&gt;value</code></li>
                    <li><code>bytes</code></li>
                </ul>
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>datetime</code>
            </td>
            <td scope="row" data-label="Description">
                An [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) compliant data type that stores a date with time and time zone.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>decimal</code>
            </td>
            <td scope="row" data-label="Description">
                Uses BigDecimal for storing any real number with arbitrary precision.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>duration</code>
            </td>
            <td scope="row" data-label="Description">
                Store a value representing a length of time. Can be added or subtracted from datetimes or other durations.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>float</code>
            </td>
            <td scope="row" data-label="Description">
                Store a value in a 64 bit float.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="#geometry"><code>geometry</code></a>
            </td>
            <td scope="row" data-label="Description">
                <a href="https://www.rfc-editor.org/rfc/rfc7946" target="_blank" title="Link to RFC 7946">RFC 7946</a> compliant data type for storing geometry in the <a href="https://geojson.org/" target="_blank" title="Link to the GeoJson website">GeoJson format</a>.
                <ul>
                    <li><code>geometry&lt;feature&gt;</code></li>
                    <li><code>geometry&lt;point&gt;</code></li>
                    <li><code>geometry&lt;line&gt;</code></li>
                    <li><code>geometry&lt;polygon&gt;</code></li>
                    <li><code>geometry&lt;multipoint&gt;</code></li>
                    <li><code>geometry&lt;multiline&gt;</code></li>
                    <li><code>geometry&lt;multipolygon&gt;</code></li>
                    <li><code>geometry&lt;collection&gt;</code></li>
                </ul>
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>int</code>
            </td>
            <td scope="row" data-label="Description">
                Store a value in a 64 bit integer.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>number</code>
            </td>
            <td scope="row" data-label="Description">
                Store numbers without specifying the type.
                SurrealDB will detect the type of number and store it using the minimal number of bytes.
                For numbers passed in as a string, this field will store the number in a BigDecimal.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>object</code>
            </td>
            <td scope="row" data-label="Description">
                Store formatted objects containing values of any supported type with no limit to object depth or nesting.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>regex</code>
            </td>
            <td scope="row" data-label="Description">
                A compiled regular expression that can be used for matching strings.
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <a href="/docs/surrealql/datamodel/literals"><code>literal</code></a>
            </td>
            <td scope="row" data-label="Description">
                A value that may have multiple representations or formats, similar to an enum or a union type. Can be composed of strings, numbers, objects, arrays, or durations.
                <ul>
                    <li><code>"a" | "b"</code></li>
                    <li><code>[number, "abc"]</code></li>
                    <li><code>123 | 456 | string | 1y1m1d</code></li>
                </ul>
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>option</code>
            </td>
            <td scope="row" data-label="Description">
                Makes types optional and guarantees the field to be either empty (NONE), or a number.
                <ul>
                    <li><code>option&lt;number&gt;</code> </li>
                </ul>
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>range</code>
            </td>
            <td scope="row" data-label="Description">
                A range of possible values. Lower and upper bounds can be set, in the absence of which the range becomes open-ended. A range of integers can be used in a FOR loop.
                <ul>
                    <li><code>0..10</code> </li>
                    <li><code>0..=10</code> </li>
                    <li><code>..10</code> </li>
                    <li><code>'a'..'z'</code> </li>
                </ul>
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>record</code>
            </td>
            <td scope="row" data-label="Description">
                Store a reference to another record. The value must be a Record ID. Add the record name inside angle brackets to restrict the reference to only certain record names.
                <ul>
                    <li><code>record</code></li>
                    <li><code>record&lt;user&gt;</code></li>
                    <li><code>record&lt;user | administrator&gt;</code></li>
                </ul>
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>set</code>
            </td>
            <td scope="row" data-label="Description">
                A set of items. 
                The set type also allows you to define which types can be stored in the set and the max length.
                Items are automatically deduplicated.
                <ul>
                    <li><code>set</code></li>
                    <li><code>set&lt;string&gt;</code></li>
                    <li><code>set&lt;string, 10&gt;</code></li>
                </ul>
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Type">
                <code>string</code>
            </td>
            <td scope="row" data-label="Description">
                Describes a text-like value.
            </td>
        </tr>
    </tbody>
</Table>

## Examples

### geometry

```surql
-- Define a field with a single type
DEFINE FIELD location ON TABLE restaurant TYPE geometry<point>;
-- Define a field with any geometric type
DEFINE FIELD area ON TABLE restaurant TYPE geometry<feature>;
-- Define a field with specific geometric types
DEFINE FIELD area ON TABLE restaurant TYPE geometry<polygon|multipolygon|collection>;
```

### bytes

```surql
-- Define a field with a single type
DEFINE FIELD image ON TABLE product TYPE bytes;

-- Create a record with a bytes field and set the value
CREATE foo SET value = <bytes>"bar";

```



================================================
FILE: src/content/doc-surrealql/datamodel/literals.mdx
================================================
---
sidebar_position: 12
sidebar_label: Literals
title: Literals | SurrealQL
description: A value that may have multiple representations or formats.

---

import Since from '@components/shared/Since.astro'

# Literals

<Since v="v2.0.0" />

A literal is a value that may have multiple representations or formats, similar to an enum or a union type. A literal can be composed of strings, numbers, objects, arrays, or durations.

## Examples

A literal can be as simple as a declaration that a parameter must be a certain value.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
error = ""Tried to set `$nine`, but couldn't coerce value: Expected `9` but found `10`""

*/

LET $nine: 9 = 9;
LET $nine: 9 = 10;
```

```surql title="Response"
-------- Query --------

NONE

-------- Query --------

"Tried to set `$nine`, but couldn't coerce value: Expected `9` but found `10`"
```

Using `|` allows a literal to be a number of possible options.

```surql
/**[test]

[[test.results]]
error = ""Tried to set `$nine`, but couldn't coerce value: Expected `9 | '9' | 'nine'` but found `'Nein'`""

*/

LET $nine: 9 | "9" | "nine" = "Nein";
```

```surql title="Response"
"Tried to set `$nine`, but couldn't coerce value: Expected `9 | '9' | 'nine'` but found `'Nein'`"
```

A literal can contain possible types in addition to possible values.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

LET $flexible_param: datetime | uuid | "N/A" = "N/A";
LET $flexible_param: datetime | uuid | "N/A" = <datetime>"2024-09-01";
```

Literals that include the option to be an array or an object can contain rich data.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

LET $status: "Ok" | { err: string } = { err: "Forgot to plug it in" };
```

## Literals in database schema

Literals can be defined inside a database schema by using a [DEFINE FIELD](/docs/surrealql/statements/define/field) statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ error_info: { error: 'Deprecated', message: "You shouldn't use this anymore" }, id: information:obqulsqif466kp1t3agq }]"
skip-record-id-key = true

[[test.results]]
error = ""Couldn't coerce value for field `error_info` of `information:qbohn4wu4l2t81wj2fb3`: Expected `{ error: 'Continue' } | { error: 'RetryWithId', id: string } | { error: 'Deprecated', message: string }` but found `\"You shouldn't use this anymore\"`""

*/

DEFINE FIELD error_info ON TABLE information TYPE
      { error: "Continue" }
    | { error: "RetryWithId", id: string }
    | { error: "Deprecated", message: string };

CREATE information SET
	error_info = { error: "Deprecated", message: "You shouldn't use this anymore" };
-- Doesn't conform to definition, will not work
CREATE information SET
	error_info = "You shouldn't use this anymore";
```

```surql title="Response"
-------- Query --------

[
	{
		error_info: {
			error: 'Deprecated',
			message: "You shouldn't use this anymore"
		},
		id: info:pkckjrri8q1pg12unyuo
	}
]

-------- Query --------

"Couldn't coerce value for field `error_info` of `information:qbohn4wu4l2t81wj2fb3`: Expected `{ error: 'Continue' } | { error: 'RetryWithId', id: string } | { error: 'Deprecated', message: string }` but found `\"You shouldn't use this anymore\"`"
```

## Matching on literals

While SurrealQL does not have a `match` or `switch` operator, `IF LET` statements can be used to match on a literal, particularly if each possible type is an object. The following shows a similar example to the above except that each object begins with a field containing the name of the type of error.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE FIELD error_info ON TABLE information TYPE
	{ Continue:    { message: "" }} |
	{ Retry: { error: "Retrying", after: duration }} |
	{ Deprecated:  { message: string }};
```

Next, we will [define a function](/docs/surrealql/statements/define/function) to handle this field and return a certain type of message depending on the error. Note the following:

* The `LET` statement in the first line is simply to shorten the path to the information contained inside `error_info`
* `IF LET` statement works here because [IF](/docs/surrealql/statements/throw) involves a check for [truthiness](/docs/surrealql/datamodel/values#values-and-truthiness), returning `true` as long as it finds a value that is not none, empty, or zero.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE FUNCTION fn::handle_error($data: record<information>) -> string {
	LET $err = $data.error_info;
	RETURN IF $err.Continue {
		"Continue"
	}
	ELSE IF $err.Retry {
		sleep($err.Retry.after);
		"Now retrying again"
	}
	ELSE IF $err.Deprecated {
		$err.Deprecated.message
	}
};
```

With the function set up, the `info` records can be inserted and run one at a time through the function.

```surql
INSERT INTO information [
	{ error_info: { Continue: { message: "" } }},
	{ error_info: { Retry: { error: "Retrying", after: 1s } }},
	{ error_info: { Deprecated: { message: "Thought I said you shouldn't use this anymore" } }}
];

LET $info = SELECT * FROM information;
fn::handle_error($info[0].id);
fn::handle_error($info[1].id);
fn::handle_error($info[2].id);
```

```surql title="Output"
-------- Query --------

'Continue'

-------- Query --------

-- After waiting 1 second
'Now retrying again'

-------- Query --------

"Thought I said you shouldn't use this anymore"
```



================================================
FILE: src/content/doc-surrealql/datamodel/none-and-null.mdx
================================================
---
sidebar_position: 13
sidebar_label: None and Null
title: None and Null | SurrealQL
description: SurrealDB uses two types called None and Null to represent two different ways in which data may not exist.

---

import Since from "@components/shared/Since.astro";

# None and null

SurrealDB uses two types called `None` and `Null` to represent two different ways in which data may not exist. While these may appear similar, they have different meanings and are used in different contexts.

## None values

`None` is used to denote that "something does not exist", for example, a field which is not present on a record.
Because of this, values of `None` can not be stored within records, meaning uses of `None` are typically limited to SurrealQL statements
where it is used to denote a value or response that does not exist.

### Example

Setting a record field to `None` is analogous to using `UNSET` to remove the field entirely. While inside the query it may appear that `None` is being written to the `children` field, what is actually happening is that the `children` field is being removed from the record.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:two }]"

[[test.results]]
value = "[{ children: [person:two], id: person:one }]"

[[test.results]]
value = "[{ id: person:one }]"

[[test.results]]
value = "[{ id: person:one }, { id: person:two }]"

*/

CREATE person:two;
CREATE person:one SET children = [person:two];
UPDATE person:one SET children = NONE;
SELECT * FROM person;
```



```surql title="Output"
[
  { id: person:one },
  { id: person:two }
]
```

## Null values

`Null` values are used to denote that "something exists, but has no value". This is useful when a field is present on a record, but the value of that field is unknown or not applicable. Unlike `None`, `Null` is written into records and can be stored as a value.

### Example

Setting a record field to `Null` will create the field on the record, but denotes that the field is considered empty. In this example, the `children` field is present on the record, but the value of that field is `null`.

```surql
/**[test]

[[test.results]]
value = "[{ children: NULL, id: person:dgwjn0ldg8ep3e8y39jw }]"
skip-record-id-key = true

*/

CREATE person SET children = null;
```



```surql title="Output"
[
  { 
    children: NULL, 
    id: person:dgwjn0ldg8ep3e8y39jw
  }
]
```

## When to use None or Null

How you use `None` or `Null` is largely dependent on the context in which you are working.

If you are writing SurrealQL and need to denote something that does not exist, such as the absence of a field, use `None`.

If you are working with data and need to represent a value which is empty, use `Null`. This is particularly useful when needing to deserialize SurrealQL output into a type in another programming language that requires a field name to be present.

## NONE as a datatype

<Since v="v3.0.0-alpha.8" />

Since SurrealDB 3.0, NONE has been usable as a datatype of its own. This allows syntax like the following to be used without returning a parsing error.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

DEFINE FUNCTION fn::do_stuff() -> NONE {
  // Code that should return nothing
};

DEFINE FIELD middle_name ON TABLE user TYPE string | NONE; // Equivalent to option<string>

DEFINE FIELD value ON temperature TYPE float | decimal | NONE; // Equivalent to option<float|decimal>
```


================================================
FILE: src/content/doc-surrealql/datamodel/numbers.mdx
================================================
---
sidebar_position: 14
sidebar_label: Numbers
title: Numbers | SurrealQL
description: In SurrealDB, numbers can be one of three types - 64-bit integers, 64-bit floating point numbers, or 128-bit decimal numbers.

---

# Numbers

In SurrealDB, numbers can be one of three types: 64-bit integers, 64-bit floating point numbers, or 128-bit decimal numbers.

## Integer numbers
If a numeric value is specified without a decimal point and is within the range `-9223372036854775808` to `9223372036854775807` then the value will be parsed, stored, and treated as a 64-bit integer.

```surql
/**[test]

[[test.results]]
value = "[{ id: event:j3tdh7wrm2kv1ymbbsek, year: 2022 }]"
skip-record-id-key = true

*/

CREATE event SET year = 2022;
```

## Floating point numbers
If a number value is specified with a decimal point, or is outside of the maximum range specified above, then the number will automatically be parsed, stored, and treated as a 64-bit floating point value. This ensures efficiency when performing mathematical calculations within SurrealDB.

```surql
/**[test]

[[test.results]]
value = "[{ id: event:5h756te17xakgdzfbghe, temperature: 41.5f }]"
skip-record-id-key = true

*/

CREATE event SET temperature = 41.5;
```

## Decimal numbers
To opt into 128-bit decimal numbers when specifying numeric values, you can use the `dec` suffix.

```surql
/**[test]

[[test.results]]
value = "[{ id: product:64vljvh12gdfwolgfhux, price: 99.99dec }]"
skip-record-id-key = true

*/

CREATE product SET price = 99.99dec;
```

The `dec` suffix is an instruction to the parser and not a cast, and is thus preferred when making a decimal.

```surql
/**[test]

[[test.results]]
value = "3.888888888888889dec"

[[test.results]]
value = "3.8888888888888888dec"

*/

-- Creates the imprecise float 3.888888888888889 and casts it into a decimal as 3.888888888888889dec
RETURN <decimal>3.8888888888888888;
-- Uses the input 3.8888888888888888 to directly create a decimal
RETURN 3.8888888888888888dec;
```

## Using a specific numeric type
To use a specific type when specifying numeric values, you can cast the value to a specific numeric type or use the appropriate suffix.

```surql
/**[test]

[[test.results]]
value = "[{ horizon: 34dec, id: event:8vpjsysxnskyfuh9ve87, temperature: 46.5f, year: 2022 }]"
skip-record-id-key = true

*/

CREATE event SET
	year = <int> 2022,
	temperature = <float> 41.5 + 5f,
	horizon = <decimal> 31 + 3dec
;
```

## Numeric precision
Different numeric types can be compared and used together in calculations.

The benefits of floating point numeric values are speed and storage size, but there is a limit to the numeric precision.

```surql
/**[test]

[[test.results]]
value = "13.571938471938472f"

*/

RETURN 13.5719384719384719385639856394139476937756394756;

-- 13.571938471938472f
```

In addition, when using floating point numbers specifically, mathematical operations can result in a loss of precision (as is normal with other databases).

```surql
/**[test]

[[test.results]]
value = "0.9999999999999999f"

*/

RETURN 0.3 + 0.3 + 0.3 + 0.1;

-- 0.9999999999999999f
```

Common rounding errors can be avoided by performing calculations using decimals.

```surql
/**[test]

[[test.results]]
value = "1.0dec"

*/

RETURN 0.3dec + 0.3dec + 0.3dec + 0.1dec;

-- 1.0dec
```

## Mathematical constants
A set of floating point numeric constants are available in SurrealDB. Constant names are case insensitive, and can be specified with either lowercase or capital letters, or a mixture of both.

```surql
/**[test]

[[test.results]]
value = "[{ circumference: 10, id: circle:uvw3g4dli4x77xejcjej }]"
skip-record-id-key = true

[[test.results]]
value = "[{ circumference: 10, id: circle:uvw3g4dli4x77xejcjej, radius: 15.707963267948966f }]"
skip-record-id-key = true

*/

CREATE circle SET circumference = 10;
UPDATE circle SET radius = circumference / ( 2 * MATH::PI );
```

<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Constant</th>
            <th colspan="2" scope="col">Description</th>
            <th colspan="2" scope="col">Value</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::E</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Euler’s number (e)
            </td>
            <td colspan="2" scope="row" data-label="Value">
                2.718281828459045
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::FRAC_1_PI</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                1/π
            </td>
            <td colspan="2" scope="row" data-label="Value">
                0.3183098861837907
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::FRAC_1_SQRT_2</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                1/sqrt(2)
            </td>
            <td colspan="2" scope="row" data-label="Value">
                0.7071067811865476
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::FRAC_2_PI</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                2/π
            </td>
            <td colspan="2" scope="row" data-label="Value">
                0.6366197723675814
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::FRAC_2_SQRT_PI</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                2/sqrt(π)
            </td>
            <td colspan="2" scope="row" data-label="Value">
                1.1283791670955126
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::FRAC_PI_2</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                π/2
            </td>
            <td colspan="2" scope="row" data-label="Value">
            1.5707963267948966
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::FRAC_PI_3</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                π/3
            </td>
            <td colspan="2" scope="row" data-label="Value">
                1.0471975511965979
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::FRAC_PI_4</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                π/4
            </td>
            <td colspan="2" scope="row" data-label="Value">
                0.7853981633974483
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::FRAC_PI_6</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                π/6
            </td>
            <td colspan="2" scope="row" data-label="Value">
                0.5235987755982989
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::FRAC_PI_8</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                π/8
            </td>
            <td colspan="2" scope="row" data-label="Value">
                0.39269908169872414
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::INF</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Positive infinity
            </td>
            <td colspan="2" scope="row" data-label="Value">
                inf
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::LN_10</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                ln(10)
            </td>
            <td colspan="2" scope="row" data-label="Value">
                2.302585092994046
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::LN_2</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                ln(2)
            </td>
            <td colspan="2" scope="row" data-label="Value">
                0.6931471805599453
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::LOG10_2</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                log<sub>10</sub>(2)
            </td>
            <td colspan="2" scope="row" data-label="Value">
                0.3010299956639812
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::LOG10_E</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                log<sub>10</sub>(e)
            </td>
            <td colspan="2" scope="row" data-label="Value">
                0.4342944819032518
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::LOG2_10</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                log<sub>2</sub>(10)
            </td>
            <td colspan="2" scope="row" data-label="Value">
            3.321928094887362
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::LOG2_E</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                log<sub>2</sub>(e)
            </td>
            <td colspan="2" scope="row" data-label="Value">
                1.4426950408889634
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::NEG_INF</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Negative infinity
            </td>
            <td colspan="2" scope="row" data-label="Value">
                -inf
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::PI</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Archimedes’ constant (π)
            </td>
            <td colspan="2" scope="row" data-label="Value">
                3.141592653589793
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::SQRT_2</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                sqrt(2)
            </td>
            <td colspan="2" scope="row" data-label="Value">
            1.4142135623730951
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Constant">
                <code>MATH::TAU</code>
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The full circle constant (τ)
            </td>
            <td colspan="2" scope="row" data-label="Value">
                6.283185307179586
            </td>
        </tr>
    </tbody>
</table>

## Next steps
You've now seen how to use numeric values in SurrealDB. For more advanced functionality, take a look at the operators and math functions, which enable advanced calculations on numeric values and sets of numeric values.



================================================
FILE: src/content/doc-surrealql/datamodel/objects.mdx
================================================
---
sidebar_position: 15
sidebar_label: Objects
title: Objects | SurrealQL
description: SurrealDB records can store objects, with no limit to the depth of any nested objects or values within.

---

import Since from '@components/shared/Since.astro'

# Objects

An object is a collection of named fields and values.

As a record is essentially an object with a required [`id` field](/docs/surrealql/datamodel/ids) that can be created, updated, or deleted, they can be worked with in almost exactly the same way as a standalone object.

A field of an object can be of any value type, including another object, with no limit to the depth of any nested objects or values within. This allows objects and arrays tno be stored within each other in order to model complex data scenarios.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:ix25bwtvcx5s543eejrk, metadata: { activities: ['clicked link', 'contact form', 'read email', 'viewed website', 'viewed website', 'viewed website', 'read email'], information: { age: 23, gender: 'm' }, interest_level: 83.67f, marketing: true } }]"
skip-record-id-key = true

*/

CREATE person SET metadata = {
	interest_level: 83.67,
	information: {
		age: 23,
		gender: 'm',
	},
	marketing: true,
	activities: [
		"clicked link",
		"contact form",
		"read email",
		"viewed website",
		"viewed website",
		"viewed website",
		"read email",
	]
};
```

## Field names

### Valid field names

Similar to record IDs, field names can be constructed from ASCII characters, underscores, and numbers. To create a field name with complex characters, backticks can be used.

```surql
/**[test]

[[test.results]]
value = "{ id: user:3lgc83vechgblizli263, my_name: 'name' }"
skip-record-id-key = true

[[test.results]]
value = "{ id: user:nyzy7aeyup2ygt33ci95, "mi_nómine😊": 'name' }"
skip-record-id-key = true

*/

CREATE ONLY user SET my_name = 'name';
CREATE ONLY user SET `mi_nómine😊` = 'name';
```

```surql title="Output"
-------- Query --------

{
	id: user:nronupvxvdm7r1n5hlzm,
	my_name: 'name'
}

-------- Query 2 --------

{
	id: user:eb5pu7u9g67dy773hsv9,
	"mi_nómine😊": 'name'
}
```

Inside a standalone object, non-ASCII field names can also be set by using a string.

```surql
/**[test]

[[test.results]]
value = "{ "mi nómine": 'Edgar' }"

*/

SELECT * FROM ONLY {
    "mi nómine": "Edgar"
};
```

```surql title="Output"
{
	"mi nómine": 'Edgar'
}
```

### Automatically generated field names

A field created from an operation will have a field name that represents the operation(s) used to construct it.

```surql
/**[test]

[[test.results]]
value = "[{ "[math::min(temps), math::max(temps)]": [-5, 9], "math::mean": 4f }]"

*/

SELECT
    math::mean(temps),
    [ math::min(temps), math::max(temps) ]
FROM { temps: [-5, 8, 9] };
```

```surql title="Output"
[
    {
        "[math::min(temps), math::max(temps)]": [
            -5,
            9
        ],
        "math::mean": 4f
    }
]
```

Using `AS` allows these automatically calculated field names to be replaced with custom names.

```surql
/**[test]

[[test.results]]
value = "[{ avg_temps: [-5, 9], mean_temps: 4f }]"

*/

SELECT
    math::mean(temps) AS mean_temps,
    [ math::min(temps), math::max(temps) ] AS avg_temps
FROM { temps: [-5, 8, 9] };
```

```surql title="Output"
[
    {
        "avg_temps": [
            -5,
            9
        ],
        "mean_temps": 4
    }
]
```

## Extending objects and removing fields

<Since v="v3.0.0-alpha.3" />

Two objects can be merged by using either the `+` operator or the `object::extend()` function. Any fields in the second object will be added to the first object, thereby updating any existing fields and adding new fields to those that were not present.

```surql
/**[test]

[[test.results]]
value = "{ name: 'Venus', orbital_period: 1y31w1d22h, radius: 6051.8f }"

[[test.results]]
value = "{ name: 'Venus', orbital_period: 1y31w1d22h, radius: 6051.8f }"

*/

{ name: "Venus", radius: 6000 } + { radius: 6051.8, orbital_period: 1y31w1d22h };
{ name: "Venus", radius: 6000 }.extend({ radius: 6051.8, orbital_period: 1y31w1d22h });
```

```surql title="Output"
-------- Query 1 --------

{
	name: 'Venus',
	orbital_period: 1y31w1d22h,
	radius: 6051.8f
}

-------- Query 2 --------

{
	name: 'Venus',
	orbital_period: 1y31w1d22h,
	radius: 6051.8f
}
```

Fields of an object can be removed with the `object::remove()` function, which takes either a single string or an array of strings of the field names to remove.

```surql
/**[test]

[[test.results]]
value = "{ name: 'Venus', orbital_period: 1y31w1d22h }"

[[test.results]]
value = "{ name: 'Venus' }"

*/
{ name: 'Venus', orbital_period: 1y31w1d22h, radius: 6051.8 }.remove("radius");
{ name: 'Venus', orbital_period: 1y31w1d22h, radius: 6051.8 }.remove(["radius", "orbital_period"]);
```

```surql title="Output"
-------- Query 1 --------

{
	name: 'Venus',
	orbital_period: 1y31w1d22h
}

-------- Query 2 --------

{
	name: 'Venus'
}
```

## See also

* [Object functions](/docs/surrealql/functions/database/object)
* [Destructuring nested objects](/docs/surrealql/datamodel/idioms#destructuring)


================================================
FILE: src/content/doc-surrealql/datamodel/ranges.mdx
================================================
---
sidebar_position: 16
sidebar_label: Ranges
title: Ranges | SurrealQL
description: A range of possible values.

---

import Since from '@components/shared/Since.astro'

# Ranges

<Since v="v2.0.0" />

A range is composed of `..` and possible delimiters to set the maximum and minimum possible values. The default syntax includes the lower limit and excludes the upper limit. A `=` can be used to make the upper limit inclusive, and `>` can be used to make the lower limit exclusive.

```surql
/**[test]

[[test.results]]
value = "0..10"

[[test.results]]
value = "0..=10"

[[test.results]]
value = "0>..10"

[[test.results]]
value = "0>..=10"

*/

-- From 0 up to 9
0..10;
-- From 0 up to 10
0..=10;
-- From 1 to 9
0>..10;
-- From 1 to 10
0>..=10;
```

A range becomes open ended if a delimiter is not specified.

```surql
/**[test]

[[test.results]]
value = "0.."

[[test.results]]
value = "0>.."

[[test.results]]
value = "..10"

[[test.results]]
value = "..=100"

[[test.results]]
value = ".."

*/

-- Anything from 0 and up
0..;
-- Anything from 1 and up
0>..;
-- Anything up to 99
..100;
-- Anything up to 100
..=100;
-- An infinite range
..;
```

A range can be constructed from any type of value. This is most useful when comparing one value to another.

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "false"

[[test.results]]
value = "false"

[[test.results]]
value = "false"

*/


-- All true
'g' IN 'a'..'z';
d"2024-01-01" IN d"2020-01-01"..=d"2025-01-01";
['London', d"2022-02-02", 5.7] IN ['London', d"2020-01-01"]..=['London', d"2024-12-31"];

-- All false
"ㅋㅋㅋ" IN "a".."z";
d"2028-01-01" IN d"2020-01-01"..=d"2025-01-01";
['Philadelphia', d"2022-02-02", 5.7] IN ['London', d"2020-01-01"]..=['London', d"2024-12-31"];
```

## Ranges in FOR loops

Ranges of integers have the added convenience of being able to be used in a [FOR loop](/docs/surrealql/statements/for).

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

FOR $year IN 0..=2024 {
    CREATE historical_events SET
        for_year = $year,
        events = "To be added";
}
```

## Ranges in WHERE clauses

A range can be used in a `WHERE` clause in place of operators like `<` and `>`. This is especially useful when checking for a number that must be within a certain range. Using a range carries two main benefits. One is that it produces shorter code that is easier to read and maintain.

```surql
SELECT * FROM person WHERE age >= 18 AND age <= 65;
SELECT * FROM person WHERE age IN 18..=65;
```

Another benefit is performance. The following code should show a modest but measurable improvement in performance between the first and second `SELECT` statement, as only one condition needs to be checked instead of two.

```surql
CREATE |person:20000| SET age = (rand::float() * 120).round() RETURN NONE;

-- Assign output to a parameter so the SELECT output is not displayed
LET $_ = SELECT * FROM person WHERE age > 18 AND age < 65;
LET $_ = SELECT * FROM person WHERE age in 18..=65;
```

## Casting and functional usage

A range can be cast into an array.

```surql
/**[test]

[[test.results]]
value = "[1, 2]"

*/

<array> 1..3;
```

```surql title="Output"
[
	1,
	2
]
```

This opens up a range of functional programming patterns that are made possible by SurrealDB's [array functions](/docs/surrealql/functions/database/array), many of which can use [anonymous functions](/docs/surrealql/datamodel/closures) (closures) to perform an operation on each item in the array.

```surql
/**[test]

[[test.results]]
value = "[{ original: 130, square_root: 11.40175425099138f }, { original: 140, square_root: 11.832159566199232f }]"

*/

-- Construct an array
(<array> 1..=100)
-- Turn it into an array that increments by 10
    .map(|$v| $v * 10)
-- Turn each number into a object with original and square root value
    .map(|$v| { original: $v, square_root: math::sqrt($v) })
-- Keep only those with square roots in between 11 and 12
    .filter(|$obj| $obj.square_root IN 11..12);
```

```surql title="Output"
[
	{
		original: 130,
		square_root: 11.40175425099138f
	},
	{
		original: 140,
		square_root: 11.832159566199232f
	}
]
```

## Ranges in mock syntax for `CREATE` statements

<Since v="v3.0.0-alpha.11" />

`CREATE` statements have always been able to work on more than one record by enclosing either a single number or a range-like operator between two `||` bars.

```surql title="Before 3.0.0"
-- Create 10 person records with random IDs
CREATE |person:10|;
-- Create `person` records from person:1 to person:10
CREATE |person:1..10|;
```

Originally an internal syntax for mock testing, this syntax become known to the user community and is now commonly used. However, the original syntax differed from true ranges in always being inclusive, in that `1..10` was treated as "from 1 up to and including 10". A change has since been made to have the mock syntax take a true range with a syntax equivalent to that demonstrated in this page.

```surql title="Since 3.0.0"
-- All of these create ten records from person:1 to person:10
CREATE |person:1..=10|;
CREATE |person:1..11|;
CREATE |person:0>..11|;
CREATE |person:0>..=10|;
```


================================================
FILE: src/content/doc-surrealql/datamodel/records.mdx
================================================
---
sidebar_position: 18
sidebar_label: Record links
title: Record links | SurrealQL
description: One of the most powerful features of SurrealDB is the ability to traverse from record-to-record without the need for traditional SQL JOINs. Each record ID points directly to a specific record in the database.

---

# Record links

One of the most powerful features of SurrealDB is the ability to traverse from record-to-record without the need for traditional SQL JOINs. Each record ID points directly to a specific record in the database, without needing to run a table scan query. Record IDs can be stored within other records, allowing them to be linked together.

## Creating a record
When you create a record without specifying the id, then a randomly generated id is created and used for the record id.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:lva0fwhgqxuk0m88ktn1, name: 'Tobie' }]"
skip-record-id-key = true

*/

CREATE person SET name = 'Tobie';

-- person:aio58g22n3upq16hsani
```

It's also possible to specify a specific record id when creating or updating records.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:tester, name: 'Tobie' }]"

*/

CREATE person:tester SET name = 'Tobie';

-- person:tester
```

## Select directly off of Record IDs

Because Record IDs are their own datatype in SurrealQL, you are able to select directly off of them.

```surql
/**[test]

[[test.results]]
value = "[{ email: 'tobie@surrealdb.com', id: person:tobie, name: 'Tobie', opts: { enabled: true } }]"

[[test.results]]
value = "{ email: 'tobie@surrealdb.com', id: person:tobie, name: 'Tobie', opts: { enabled: true } }"

[[test.results]]
value = "{ email: 'tobie@surrealdb.com', name: 'Tobie' }"

*/

CREATE person:tobie SET name = 'Tobie', email = 'tobie@surrealdb.com', opts.enabled = true;

-- Select the whole record
person:tobie.*;

-- Select specific fields (since 2.0.0)
person:tobie.{ name, email };
```

## Storing record links within records

Records ids can be stored directly within other records, either as top-level properties, or nested within objects or arrays.

```surql
/**[test]

[[test.results]]
value = "[{ friends: [person:tobie, person:simon], id: person:jaime, name: 'Jaime' }]"

[[test.results]]
value = "[{ friends: [person:simon, person:marcus], id: person:tobie, name: 'Tobie' }]"

[[test.results]]
value = "[{ friends: [person:jaime, person:tobie], id: person:simon, name: 'Simon' }]"

[[test.results]]
value = "[{ friends: [person:tobie], id: person:marcus, name: 'Marcus' }]"

*/

CREATE person:jaime SET name = 'Jaime', friends = [person:tobie, person:simon];
CREATE person:tobie SET name = 'Tobie', friends = [person:simon, person:marcus];
CREATE person:simon SET name = 'Simon', friends = [person:jaime, person:tobie];
CREATE person:marcus SET name = 'Marcus', friends = [person:tobie];
```

## Fetching remote records from within records

Nested field traversal can be used to fetch the properties from the remote records, as if the record was embedded within the record being queried.

```surql
SELECT friends.name FROM person:tobie;
[
	{
		friends: {
			name: ["Simon", "Marcus"]
		}
	}
]
```

There is no limit to the number of remote traversals that can be performed in a query. Using `.` dot notation, SurrealDB does not differentiate between nested object properties, or remote records, and will fetch remote records asynchronously when needed for a query.

```surql
SELECT friends.friends.friends.name FROM person:tobie;
[
	{
		friends: {
			friends: {
				friends: {
					name: [
						[ ["Tobie", "Simon"], ["Simon", "Marcus"] ],
						[ ["Simon", "Marcus"] ]
					]
				}
			}
		}
	}
]
```

## Next steps

You've now seen how to create records using randomly generated ids, or specific record ids. This is just the beginning! The power and flexibility which is possible with the remote record fetching functionality within queries opens up a whole new set of possibilities for storing and querying traditional data, and connected datasets. The next page follows up with a feature available in SurrealDB since version 2.2.0: the ability to use record links in a bidirectional manner thanks to reference tracking.

Also check out this explainer video on using record links in SurrealDB:


<iframe width="100%" src="https://www.youtube.com/embed/TyX45cyZ-W0?si=S9M59afDEiqxeC5d" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" style={{aspectRatio: 1.7, paddingTop: '20px'}} allowfullscreen></iframe>




================================================
FILE: src/content/doc-surrealql/datamodel/references.mdx
================================================
---
sidebar_position: 19
sidebar_label: Record references
title: Record references | SurrealQL
description: Record references allow you to link records together, enabling you to traverse from one record to another.

---

import Since from '@components/shared/Since.astro'

# Record references

<Since v="v2.2.0" />

## Basic concepts

Reference tracking begins by adding a `REFERENCE` clause to any `DEFINE FIELD` statement, as long as the field is a top-level field of type `record` or array of records.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE FIELD comics ON person TYPE option<array<record<comic_book>>> REFERENCE;
-- Also works as `option` desugars to this syntax
DEFINE FIELD comics ON person TYPE array<record<comic_book>> | NONE REFERENCE;

-- `comics` field might not be a record, does not work
DEFINE FIELD comics ON person TYPE array<record<comic_book>> | string REFERENCE;
-- Not top-level field, does not work
DEFINE FIELD metadata.comics ON person TYPE array<record<comic_book>> REFERENCE;
```

This incoming record can then be picked up with the `<~` syntax that works in the same way that graph queries do.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ comics: [comic_book:one], id: person:mat, name: 'Mat' }]"

[[test.results]]
value = "[{ comics: [comic_book:one], id: person:nynaeve, name: 'Nynaeve' }]"

[[test.results]]
value = "[{ id: comic_book:one, title: 'Loki, God of Stories' }]"

[[test.results]]
value = "[{ id: comic_book:one, owners: [person:mat, person:nynaeve], title: 'Loki, God of Stories' }]"

[[test.results]]
value = "[{ id: comic_book:one, owners: [{ id: person:mat, name: 'Mat' }, { id: person:nynaeve, name: 'Nynaeve' }], title: 'Loki, God of Stories' }]"

*/

DEFINE FIELD comics ON person TYPE option<array<record<comic_book>>> REFERENCE;
CREATE person:mat SET 
	name = "Mat", 
	comics = [comic_book:one];
CREATE person:nynaeve SET 
	name = "Nynaeve", 
	comics = [comic_book:one];
CREATE comic_book:one SET title = "Loki, God of Stories";

SELECT 
	*, 
	<~person AS owners
FROM comic_book;

SELECT 
	*, 
	<~person.{ id, name } AS owners
FROM comic_book;
```

```surql title="Output"
-------- Query --------

[
	{
		id: comic_book:one,
		owners: [
			person:mat,
			person:nynaeve
		],
		title: 'Loki, God of Stories'
	}
]

-------- Query --------

[
	{
		id: comic_book:one,
		owners: [
			{
				id: person:mat,
				name: 'Mat'
			},
			{
				id: person:nynaeve,
				name: 'Nynaeve'
			}
		],
		title: 'Loki, God of Stories'
	}
]
```

## Specifying linking tables

Incoming references can also be declared in a schema.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ comics: [comic_book:one], id: person:one }, { comics: [comic_book:one], id: person:two }]"

[[test.results]]
value = "[{ id: publisher:one, products: [comic_book:one, book:one] }]"

[[test.results]]
value = "[{ id: comic_book:one, owners: [person:one, person:two], publishers: [publisher:one], title: 'Loki, God of Stories' }]"

[[test.results]]
value = "[{ id: comic_book:one, owners: [person:one, person:two], publishers: [publisher:one], title: 'Loki, God of Stories' }]"

*/

DEFINE FIELD comics ON person TYPE option<array<record<comic_book>>> REFERENCE;
DEFINE FIELD products ON publisher TYPE option<array<record<comic_book|book>>> REFERENCE;
DEFINE FIELD owners ON comic_book COMPUTED <~person;
DEFINE FIELD publishers ON comic_book COMPUTED <~publisher;

CREATE person:one, person:two SET comics = [comic_book:one];
CREATE publisher:one SET products = [comic_book:one, book:one];
CREATE comic_book:one SET title = "Loki, God of Stories";
SELECT * FROM comic_book;
```

```surql title="Output"
[
	{
		id: comic_book:one,
		owners: [
			person:one,
			person:two
		],
		publishers: [
			publisher:one
		],
		title: 'Loki, God of Stories'
	}
]
```

A field of type `references` can be further narrowed down to specify not just the table name, but also the field name of the referencing record. This can be done by enclosing the part after `<~` in parentheses, adding the `FIELD` keyword and naming the field or fields via which incoming references will be shown.

```surql
DEFINE FIELD comics ON person TYPE option<array<record<comic_book>>> REFERENCE;
DEFINE FIELD borrowed_comics ON person TYPE option<array<record<comic_book>>> REFERENCE;
DEFINE FIELD owned_by ON comic_book COMPUTED <~(person FIELD comics);
DEFINE FIELD borrowed_by ON comic_book COMPUTED <~(person FIELD borrowed_comics);
DEFINE FIELD all_readers ON comic_book COMPUTED <~(person FIELD comics borrowed_comics);

CREATE person:one SET comics = [comic_book:one];
CREATE person:two SET borrowed_comics = [comic_book:one];
CREATE comic_book:one SET title = "Loki, God of Stories";
SELECT * FROM comic_book;
```

```surql title="Output"
[
	{
		all_readers: [ person:one, person:two ],
		borrowed_by: [ person:two ],
		id: comic_book:one,
		owned_by: [ person:one ],
		title: 'Loki, God of Stories'
	}
]
```

## Specifying deletion behaviour

When working with record links, it is very likely that you will want some behaviour to happen when a referencing link is deleted. Take the following example of a `person` who owns a `comic_book`, which is later deleted. Despite the deletion, a follow-up `SELECT * FROM person` still shows the comic book.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: comic_book:one, owned_by: [], title: 'Loki, God of Stories' }]"

[[test.results]]
value = "[{ comics: [comic_book:one], id: person:one }]"

[[test.results]]
value = "[]"

[[test.results]]
value = "[{ comics: [comic_book:one], id: person:one }]"

*/

DEFINE FIELD comics ON person TYPE option<array<record<comic_book>>> REFERENCE;
DEFINE FIELD owned_by ON comic_book COMPUTED <~person;

CREATE comic_book:one SET title = "Loki, God of Stories";
CREATE person:one SET comics = [comic_book:one];
DELETE comic_book:one;
SELECT * FROM person;
```

```surql title="Output"
[
	{
		comics: [
			comic_book:one
		],
		id: person:one
	}
]
```

A query using `INFO FOR TABLE person` shows that the actual statement created using `REFERENCE` does not finish at this point, but includes the clause `ON DELETE IGNORE`. This is the default behaviour for references.

```surql
{
	events: {},
	fields: {
		comics: 'DEFINE FIELD comics ON person TYPE none | array<record<comic_book>> REFERENCE ON DELETE IGNORE PERMISSIONS FULL',
		"comics.*": 'DEFINE FIELD comics.* ON person TYPE record<comic_book> REFERENCE ON DELETE IGNORE PERMISSIONS FULL'
	},
	indexes: {},
	lives: {},
	tables: {}
}
```

This `ON DELETE` clause can be modified to have some other behaviour when a reference is deleted.

### ON DELETE IGNORE

As shown in the previous section, `ON DELETE IGNORE` is the default behaviour for references and this clause will be added automatically if not specified. It can be added manually to a statement to hint to others reading the code that this behaviour is desired.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ friended_by: [], friends: [person:two], id: person:one }]"

[[test.results]]
value = "[{ friended_by: [person:one], id: person:two }]"

[[test.results]]
value = "[]"

[[test.results]]
value = "{ friended_by: [], id: person:two }"

*/

-- Default, behaviour, so identical to:
-- DEFINE FIELD friends ON person TYPE option<array<record<person>>> REFERENCE;
DEFINE FIELD friends ON person TYPE option<array<record<person>>> REFERENCE ON DELETE IGNORE;
DEFINE FIELD friended_by ON person COMPUTED <~person;

CREATE person:one SET friends = [person:two];
CREATE person:two;
DELETE person:one;
person:two.*;
```

As the deletion of `person:one` is ignored when calculating the `friended_by` field, it will still show `person:one` even though the record itself has been deleted.

```surql
{
	friended_by: [
		person:one
	],
	id: person:two
}
```

### ON DELETE UNSET

`ON DELETE UNSET` will unset (remove) any linked records that are deleted. This can be thought of as the opposite of `ON DELETE IGNORE`.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: person:one }], [{ comments: [comment:rkvpjc0l9iruy21k89su], id: person:one }]"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ comments: [comment:rkvpjc0l9iruy21k89su, comment:tu5f72ouuydjvycg41st], id: person:one }]"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[]"

[[test.results]]
value = "[{ author: [person:one], id: comment:rkvpjc0l9iruy21k89su, text: 'Estonia is bigger than I expected!' }]"

*/

DEFINE FIELD comments ON person TYPE option<array<record<comment>>> REFERENCE ON DELETE UNSET;
DEFINE FIELD author ON comment COMPUTED <~person;

CREATE person:one;
UPDATE person:one SET comments += (CREATE ONLY comment SET text = "Estonia is bigger than I expected!").id;
-- Give this one a parameter name so it can be deleted later
LET $comment = CREATE ONLY comment SET text = "I don't get the joke here?";
UPDATE person:one SET comments += $comment.id;
-- Now delete it
DELETE $comment;
-- Only one comment shows up for person:one now
person:one.comments.*.*;
```

```surql title="Output of person:one queries"
-------- Query --------

[
	{
		comments: [
			comment:gj1kb2e3tedn7kjcxxja,
			comment:6sztlhd6fhgc91dg2lby
		],
		id: person:one
	}
]

-------- Query --------

[
	{
		author: [
			person:one
		],
		id: comment:gj1kb2e3tedn7kjcxxja,
		text: 'Estonia is bigger than I expected!'
	}
]
```

### ON DELETE CASCADE

The `ON DELETE CASCADE` will cause a record to be deleted if any record it references is deleted. This is useful for records that should not exist if a record that links to them no longer exists.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ comments: [], id: person:one }]"

[[test.results]]
value = "[{ author: person:one, id: comment:4u9gw4bl2q63zuos3v1y, text: '5/10 for this blog post. The problems I have with it are...' }]"

[[test.results]]
value = "[{ author: person:one, id: comment:em2543ghwy9k921eob3d, text: 'WOW! I never knew you could cut a rope with an arrow.' }]"

[[test.results]]
value = "[{ author: person:one, id: comment:4u9gw4bl2q63zuos3v1y, text: '5/10 for this blog post. The problems I have with it are...' }, { author: person:one, id: comment:em2543ghwy9k921eob3d, text: 'WOW! I never knew you could cut a rope with an arrow.' }]"

[[test.results]]
value = "[]"

[[test.results]]
value = "[]"

*/

DEFINE FIELD author ON comment TYPE record<person> REFERENCE ON DELETE CASCADE;
DEFINE FIELD comments ON person COMPUTED <~comment;

CREATE person:one;
CREATE comment SET author = person:one, text = "5/10 for this blog post. The problems I have with it are...";
CREATE comment SET author = person:one, text = "WOW! I never knew you could cut a rope with an arrow.";

-- Show all the details of comments for 'person:one'
person:one.comments.*.*;
DELETE person:one;
-- Comments no longer exist
SELECT * FROM comment;
```

```surql title="Output"
-------- Query --------

[
	{
		author: person:one,
		id: comment:8msvp0egg8cdlyu4vvn9,
		text: 'WOW! I never knew you could cut a rope with an arrow.'
	},
	{
		author: person:one,
		id: comment:i72qfjy59vbn81hk6lrm,
		text: '5/10 for this blog post. The problems I have with it are...'
	}
]

-------- Query --------

[]

-------- Query --------

[]
```

### ON DELETE REJECT

`ON DELETE REJECT` will outright make it impossible to delete a record that is referenced from somewhere else. For example, consider the case in which a house should not be demolished (deleted) until it has been disconnected from utilities such as gas, water, electricity, and so on. This can be simulated in a schema by adding a `REFERENCE ON DELETE REJECT` to the `utility` table, making it impossible for any `house` to be deleted if they link to it.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: house:one, using: [] }]"

[[test.results]]
value = "[{ connected_to: [house:one], id: utility:gas }, { connected_to: [house:one], id: utility:water }]"

*/

DEFINE FIELD connected_to ON utility TYPE option<array<record<house>>> REFERENCE ON DELETE REJECT;
DEFINE FIELD using ON house COMPUTED <~utility;

CREATE house:one;
CREATE utility:gas, utility:water SET connected_to = [house:one];
```

At this point, the `using` field on `house:one` automatically picks up the two references. Due to these references, the `house` record cannot be deleted.

```surql
house:one.*;
DELETE house:one;
```

```surql title="Output"
-------- Query --------

{
	id: house:one,
	using: [
		utility:gas,
		utility:water
	]
}

-------- Query --------

'Cannot delete `house:one` as it is referenced by `utility:gas` with an ON DELETE REJECT clause'
```

To delete the `house`, the `connected_to` references will first have to be removed.

```surql
UPDATE utility:gas   SET connected_to -= house:one;
UPDATE utility:water SET connected_to -= house:one;

DELETE house:one;
```

Note that an `ON DELETE UNSET` for a required field is effectively the same as an `ON DELETE REJECT`. In both of the following two cases, a `person` that has any referencing `comment` records will not be able to be deleted.

```surql
-- Non-optional field that attempts an UNSET when referencing 'person' is deleted
DEFINE FIELD author ON comment TYPE record<person> REFERENCE ON DELETE UNSET;
LET $person = CREATE ONLY person;
CREATE comment SET text = "Cats are so much better at climbing UP a tree than down! Lol", author = $person.id;
DELETE person;

-- Optional field which rejects the deletion of a referencing 'person'
DEFINE FIELD author ON comment TYPE option<record<person>> REFERENCE ON DELETE REJECT;
LET $person = CREATE ONLY person;
CREATE comment SET text = "Cats are so much better at climbing UP a tree than down! Lol", author = $person.id;
DELETE person;
```

The error message in these two cases will differ, but the behaviour is the same.

```surql
-------- Query --------

"An error occured while updating references for `person:97sfkadd56hqhimbf69m`: Couldn't coerce value for field `author` of `comment:kkigvk5knsoeg53p08n1`: Expected `record<person>` but found `NONE`"

-------- Query --------

'Cannot delete `person:3fm76xztvfab99eq780l` as it is referenced by `comment:ig0ogusbm64cier5ovv9` with an ON DELETE REJECT clause'
```

### ON DELETE THEN

The `ON DELETE THEN` clause allows for custom logic when a reference is deleted. This clause includes a parameters called `$this` to refer to the record in question, and `$reference` for the reference.

In the following example, a `person` record's `comments` field will remove any comments when they are deleted, but also add the same comment to a different field called `deleted_comments`.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ comments: [comment:7g857mbox5rdqvjuezxf], id: person:one }]"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ comments: [comment:7g857mbox5rdqvjuezxf, comment:o7qgd26uruvf3hracvrh], id: person:one }]"

[[test.results]]
value = "[]"

[[test.results]]
value = "[{ comments: [comment:7g857mbox5rdqvjuezxf], deleted_comments: [comment:o7qgd26uruvf3hracvrh], id: person:one }]"

*/

DEFINE FIELD comments ON person TYPE option<array<record<comment>>> REFERENCE ON DELETE THEN {
    UPDATE $this SET
        deleted_comments += $reference,
        comments -= $reference;
};
DEFINE FIELD author ON comment COMPUTED <~person;

CREATE person:one SET comments += (CREATE ONLY comment SET text = "Estonia is bigger than I expected!").id;
LET $comment = CREATE ONLY comment SET text = "I don't get the joke here?";
UPDATE person:one SET comments += $comment.id;
DELETE $comment;
SELECT * FROM person:one;
```

```surql title="person:one before and after comment is deleted"
-------- Query --------

[
	{
		comments: [
			comment:lbeyh2icushpwo0ak5ux,
			comment:90tdnyoa14cge2ocmep7
		],
		id: person:one
	}
]

-------- Query --------

[
	{
		comments: [
			comment:lbeyh2icushpwo0ak5ux
		],
		deleted_comments: [
			comment:90tdnyoa14cge2ocmep7
		],
		id: person:one
	}
]
```


================================================
FILE: src/content/doc-surrealql/datamodel/regex.mdx
================================================
---
sidebar_position: 20
sidebar_label: Regex
title: Regex | SurrealQL
description: The regex type can 

---

import Since from '@components/shared/Since.astro'

# Regex

<Since v="v3.0.0-alpha.1" />

A `regex` can be created by casting from a string.

The following examples all return `true`.

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

*/

-- Either 'a' or 'b'
<regex> "a|b" = "a";

-- Either color or colour
<regex> "col(o|ou)r" = "colour";

-- Case-insensitive match on English color, colour, or French couleur
<regex> "((?i)col(o|ou)r|couleur)" = "COULEUR";
```

While `regex` was added as a standalone type in version 2.3.0, regex matching has always been available via the [`string::matches()`](/docs/surrealql/functions/database/string#stringmatches) function.

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

*/

string::matches("a", "a|b");
string::matches("colour", "col(o|ou)r");
string::matches("COULEUR", "((?i)col(o|ou)r|couleur)");
```


================================================
FILE: src/content/doc-surrealql/datamodel/sets.mdx
================================================
---
sidebar_position: 21
sidebar_label: Sets
title: Sets | SurrealQL
description: A set is a collection type of deduplicated values that can have a maximum size limit.

---

# Sets

A set is similar to an array, but deduplicates items.

```surql
/**
[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: traveler:one, visited: [country:canada, country:usa, country:korea, country:japan] }]"

[[test.results]]
value = "[{ id: traveler:one, visited: [country:canada, country:usa, country:korea, country:japan, country:uk] }]"

[[test.results]]
value = "[{ id: traveler:one, visited: [country:canada, country:usa, country:korea, country:japan, country:uk] }]"

*/

DEFINE FIELD visited ON TABLE traveler TYPE set<record<country>>;
CREATE traveler:one SET visited = [country:canada, country:usa, country:korea, country:japan];
-- Traveler comes back from a trip
UPDATE traveler:one SET visited += country:uk;
-- And again
UPDATE traveler:one SET visited += country:uk;
```

```surql title="Response"
[
	{
		id: traveler:one,
		visited: [
			country:canada,
			country:usa,
			country:korea,
			country:japan,
			country:uk
		]
	}
]
```

Internally, a set is identical to an array – even inside a schema definition. The only difference is that a field defined as a set will never hold a duplicate item. Otherwise, a field defined as an `array` can take a `set` as input and vice versa.

```surql
/**
[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ bank_accounts: [55555, 98787], id: customer:pomuloehpaqko7kl3wjn, languages: ['en', 'ja', 'kr'] }]"
skip-record-id-key = true

*/

DEFINE FIELD bank_accounts ON TABLE customer TYPE set<int>;
DEFINE FIELD languages ON TABLE customer TYPE array<string>;

CREATE customer SET
    bank_accounts = [
      55555,
      55555,
      98787
    ],
    languages = <set>[
        "en",
        "ja",
        "kr",
        "kr"
    ];
```

```surql title="Output"
[
	{
		bank_accounts: [
			55555,
			98787
		],
		id: customer:uv6mn62t8td9vzvfogh4,
		languages: [
			'en',
			'ja',
			'kr'
		]
	}
]
```

Casting into a `set` can be a convenient way to deduplicate items in the same way that the [`array::distinct()`](/docs/surrealql/functions/database/array#arraydistinct) function is used.

```surql
/**
[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[[1, 3, 4], [1, 3, 4]]"

*/

LET $array = [1,1,3,4,4,4,4,4,4];

RETURN [
    $array.distinct(),
    <set>$array
];
```

```surql title="Output"
[
	[
		1,
		3,
		4
	],
	[
		1,
		3,
		4
	]
]
```

For all other behaviour and uses of a set, please see [the page on arrays](/docs/surrealql/datamodel/arrays).


================================================
FILE: src/content/doc-surrealql/datamodel/strings.mdx
================================================
---
sidebar_position: 22
sidebar_label: Strings
title: Strings | SurrealQL
description: Strings can be used to store text values. All string values can include Unicode values, emojis, tab characters, and line breaks.

---

import Image from "@components/Image.astro";
import Since from '@components/shared/Since.astro'

import LightImageParseError from "@img/image/light/surrealql-parse-error.png";
import DarkImageParseError from "@img/image/dark/surrealql-parse-error.png";

# Strings

Strings can be used to store text values. All string values can include Unicode values, emojis, tab characters, and line breaks.

```surql
/**
[test]

[[test.results]]
value = "[{ id: person:95uvwaw161b9qqquxixf, text: 'Lorem ipsum dolor sit amet' }]"
skip-record-id-key = true

**/

CREATE person SET text = 'Lorem ipsum dolor sit amet';
```

Strings can be created using single quotation marks, or double quotation marks.

```surql
/**
[test]

[[test.results]]
value = "[{ id: person:7qrqr6tyodgwngpx73b1, text: 'Lorem ipsum dolor sit amet' }]"
skip-record-id-key = true

**/

CREATE person SET text = "Lorem ipsum dolor sit amet";
```

Any string in SurrealDB can include Unicode text.

```surql
/**
[test]

[[test.results]]
value = "[{ id: person:6tazjj7yko5ot2lujpfk, text: 'I ❤️ SurrealDB' }]"
skip-record-id-key = true

**/

CREATE person SET text = "I ❤️ SurrealDB";
```

Strings can also include line breaks.

```surql
/**
[test]

[[test.results]]
value = "[{ id: person:v4lgc1sfs4xegf86gfcv, text: 'This
is
over
multiple
lines' }]"
skip-record-id-key = true

**/

CREATE person SET text = "This
is
over
multiple
lines";
```

## Specifying data type literal values using string prefixes

<Since v="v1.1.0" />

### Overview

In SurrealQL, there are several data types for which literal values are specified using string values, with a prefix indicating the intended type for the value to be interpreted as.

Previously, in SurrealQL version `1.0`, literal values of these types were simply specified using a string without any prefix, and SurrealDB would eagerly convert the strings into the relevant data type in any case where the string matched the format expected for that type. However, since SurrealQL version `2.0`, strings are no longer eagerly converted into other data types. Instead, if you want to specify a literal value of one of these data types, you must explicitly use a string with the appropriate prefix.

### String literal values using the `s` prefix {#string}

The string prefix `s` explicitly tells the parser that the contents of the string are just a string. Since SurrealQL version `2.0`, all strings without a prefix will be plain strings. So the two versions of the same string with and wihout the `s` prefix in the following queries are equivalent:

```surql
/**
[test]

[[test.results]]
value = "'5:20'"

[[test.results]]
value = "'5:20'"

[[test.results]]
value = "true"

**/

RETURN "5:20";
RETURN s"5:20";
RETURN "5:20" == s"5:20";
```
```surql title="Response"
-------- Query 1 --------

'5:20'

-------- Query 2 --------

'5:20'

-------- Query 3 --------

true
```


### Record ID literal values using the `r` prefix {#record}

The `r` prefix tells the parser that the contents of the string represent a [`record ID`](/docs/surrealql/datamodel/ids). The parser expects record IDs to have the following format: `table_name:record ID`.

> [!NOTE]
> As of SurrealDB 2.0, without the `r` prefix the type of the value will be `string`.

Here is an example of a record ID literal value, specified using a string with the `r` prefix.

```surql
/**
[test]

[[test.results]]
value = "person:john"

**/

RETURN r"person:john";
```

```surql title="Response"
-------- Query 1 --------

person:john
```

In the example below, using the [`type::is_string()`](/docs/surrealql/functions/database/type#typeis_string) and [`type::is_record()`](/docs/surrealql/functions/database/type#typeis_record) functions respectively, you can check the type of the string.

```surql
/**
[test]

[[test.results]]
value = "true"

[[test.results]]
value = "false"

[[test.results]]
value = "true"

**/

RETURN type::is_string("person:john");
RETURN type::is_record("person:john");
RETURN type::is_record(r"person:john");
```
```surql title="Response"
-------- Query 1 --------

true

-------- Query 2 --------

false

-------- Query 3 --------

true
```

### Datetime literal values using the `d` prefix {#datetime}

The `d` prefix tells the parser that the contents of the string represent a [`datetime`](/docs/surrealql/datamodel/datetimes). The parser expects `datetime` values to have a valid [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format. Here are a few examples:


```surql
/**
[test]

[[test.results]]
value = "d'2023-11-28T11:41:20.262Z'"

[[test.results]]
value = "d'2023-11-28T07:41:20.262Z'"

[[test.results]]
value = "d'2023-11-28T15:41:20.262Z'"

[[test.results]]
value = "d'2023-11-28T11:41:20Z'"

[[test.results]]
value = "d'2023-11-28T07:41:20Z'"

**/

RETURN d"2023-11-28T11:41:20.262Z";       --- Sub-second precision included, timezone defaulted to UTC
RETURN d"2023-11-28T11:41:20.262+04:00";  --- Sub-second precision included, timezone specified as UTC + 4:00
RETURN d"2023-11-28T11:41:20.262-04:00";  --- Sub-second precision included, timezone specified as UTC - 4:00
RETURN d"2023-11-28T11:41:20Z";           --- Sub-second precision excluded, timezone defaulted to UTC
RETURN d"2023-11-28T11:41:20+04:00";      --- Sub-second precision excluded, timezone specified as UTC + 4:00
```
```surql title="Response"
-------- Query 1 --------

d'2023-11-28T11:41:20.262Z'

-------- Query 2 --------

d'2023-11-28T07:41:20.262Z'

-------- Query 3 --------

d'2023-11-28T15:41:20.262Z'

-------- Query 4 --------

d'2023-11-28T11:41:20Z'

-------- Query 5 --------

d'2023-11-28T07:41:20Z'
```

### UUID literal values with the `u` prefix {#uuid}

The `u` prefix tells the parser that the contents of the string represent a [`uuid`](/docs/surrealql/datamodel/uuid). The parser expects `uuid` values to follow the format of an UUID, `ffffffff-ffff-ffff-ffff-ffffffffffff`, where each non-hyphen character can be a digit (0-9) or a letter between `a` and `f` (representing a single hexadecimal digit).

```surql
/**
[test]

[[test.results]]
value = "u'8c54161f-d4fe-4a74-9409-ed1e137040c1'"

**/

RETURN u"8c54161f-d4fe-4a74-9409-ed1e137040c1";
```

```surql title="Response"
-------- Query 1 --------

u'8c54161f-d4fe-4a74-9409-ed1e137040c1'
```

### Byte values using the `b` prefix {#bytes}

```surql
/**
[test]

[[test.results]]
value = "b"0099AAFF""

**/

b"0099aaff"
```

### File paths using the `f` prefix {#files}

```surql
f"bucket:/some/key/to/a/file.txt";
f"bucket:/some/key/with\ escaped";
f"bucket:/some/key".put(b"00aa");
f"bucket:/some/key".get();
```

### String prefixes vs. casting

String prefixes seem outwardly similar to casting, but differ in behaviour. A string prefix is an instruction to the parser to treat an input in a certain way, whereas a cast is an instruction to the database to convert one type into another.

As a result, incorrect input with a cast will generate an error:

```surql
// Change _ to - in both examples to fix the input
RETURN <uuid>"018f0e6a_9b95-7ecc-8a38-aea7bf3627dd";
RETURN <datetime>"2024_06-06T12:00:00Z";
```
```surql title="Response"
-------- Query 1 --------

"Expected a uuid but cannot convert '018f0e6a-9b95-7ecc-8a38-aea7bf3627d' into a uuid"

-------- Query 2 --------

"Expected a datetime but cannot convert '2024-06-06T12:00:00' into a datetime"
```

But the same input using a string prefix will not even parse until the input is valid.

```surql
// Will not parse in either case until _ is changed to -
RETURN u"018f0e6a_9b95-7ecc-8a38-aea7bf3627dd";
RETURN d"2024_06-06T12:00:00Z";
```

This also allows for immediate error messages on which part of the input is incorrect. As seen in the image below, the parser is able to inform the user that an underscore at column 18 is the issue.

<Image
  alt="A screenshot showing how a string prefix allows incorrect UUID input to be identified before a query can be run. In this case, the parser is able to inform the user that an underscore at column 18 is the issue."
  src={{
    light: LightImageParseError,
    dark: DarkImageParseError,
  }}
/>



================================================
FILE: src/content/doc-surrealql/datamodel/uuid.mdx
================================================
---
sidebar_position: 23
sidebar_label: UUIDs
title: UUIDs | SurrealQL
description: UUID values in SurrealQL represent UUID values

---

# UUIDs

UUIDs represent UUID v4 and v7 values. They can be obtained via either the:
- [`rand::uuid::*` functions](/docs/surrealql/functions/database/rand#randuuidv4)
- [casted from strings](/docs/surrealql/datamodel/casting#uuid)
- or via [string prefixes](/docs/surrealql/datamodel/strings#uuid)


> [!NOTE]
> As of `v2.0.0`, SurrealDB no longer eagerly converts a string into a UUID. An implicit `u` prefix or cast using `<uuid>` is required instead.

```surql
/**[test]

[[test.results]]
value = "u'4048a7ac-9c1a-486e-9a12-e39d76670eac'"
skip-uuid = true

[[test.results]]
value = "u'0199a85c-5e24-7901-9053-9d898d881d9e'"
skip-uuid = true

[[test.results]]
value = "u'a8f30d8b-db67-47ec-8b38-ef703e05ad1b'"

[[test.results]]
value = "u'a8f30d8b-db67-47ec-8b38-ef703e05ad1b'"

*/

rand::uuid::v4();
rand::uuid::v7();
<uuid> "a8f30d8b-db67-47ec-8b38-ef703e05ad1b";
u"a8f30d8b-db67-47ec-8b38-ef703e05ad1b";
```



================================================
FILE: src/content/doc-surrealql/datamodel/values.mdx
================================================
---
sidebar_position: 24
sidebar_label: Values
title: Values | SurrealQL
description: Every type in SurrealDB is a value

---

# Values

Each of the types mentioned in the data model is a subset of an all-encompassing type called a value.

## Comparing and ordering values

While it is unsurprising that a data type can be compared with itself, it may be surprising that different types can also be compared with each other.

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

*/

RETURN 9 > 1;            // Returns true
RETURN [] > time::now(); // Also returns true
```

This comparison is possible because every type in SurrealDB is a subset of value, and a comparison of any type with another is also simply a comparison of a value with another value. The order of values from least to greatest is:

* `none`
* `null`
* `bool`
* `number`
* `string`
* `duration`
* `datetime`
* `uuid`
* `array`
* `set`
* `object`
* `geometry`
* `bytes`
* `table`
* `record`
* `file`
* `regex`
* `range`

As a result, all of the following return `true`.

```surql
/**[test]

[[test.results]]
value = "[true, true, true, true, true, true, true, true, true, true, true, true]"

*/

RETURN [
    null > none,
    true > null,
    1 > true,
    'a' > 999999999,
    1m > 'a',
    time::now() > 1m,
    rand::uuid() > time::now(),
    [ 9, 10 ] > rand::uuid(),
    { 9, 10 } > [ 9, 10 ],
    {} > { 9, 10 },
    (9.9, 9.9) > {},
    <bytes>"Aeon" > (9.9, 9.9),
    type::table("person") > <bytes>"Aeon",
    person:one > type::table("person"),
    f"file://myfile.txt" > person:one,
    <regex>"a|b" > f"file://myfile.txt",
    0..10 > <regex>"a|b",
    || > 0.. 10
];
```

Being able to compare a value with any other value is what makes SurrealDB's record range syntax possible.

```surql
/**[test]

[[test.results]]
value = "[{ id: time_data:[d'2024-07-23T00:00:00Z'] }]"

[[test.results]]
value = "[{ id: time_data:[d'2024-07-24T00:00:00Z'] }]"

[[test.results]]
value = "[{ id: time_data:[d'2024-07-25T00:00:00Z'] }]"

[[test.results]]
value = "[{ id: time_data:[d'2024-07-24T00:00:00Z'] }]"

[[test.results]]
value = "[{ id: time_data:[d'2024-07-24T00:00:00Z'] }, { id: time_data:[d'2024-07-25T00:00:00Z'] }]"

[[test.results]]
value = "[{ id: time_data:[d'2024-07-23T00:00:00Z'] }, { id: time_data:[d'2024-07-24T00:00:00Z'] }, { id: time_data:[d'2024-07-25T00:00:00Z'] }]"

*/

CREATE time_data:[d'2024-07-23T00:00:00.000Z'];
CREATE time_data:[d'2024-07-24T00:00:00.000Z'];
CREATE time_data:[d'2024-07-25T00:00:00.000Z'];
-- Records from the 24th to the 25th
SELECT * FROM time_data:[d'2024-07-24']..[d'2024-07-25'];
-- Records from the 24th
SELECT * FROM time_data:[d'2024-07-24']..;
-- All records
SELECT * FROM time_data:[NONE]..;
```

The `..` open-range syntax also represents an infinite value inside a record range query, making it the greatest possible value and the inverse of `NONE`, the lowest possible value. A part of a record range query that begins with `NONE` and ends with `..` will thus filter out nothing.

```surql
/**[test]

[[test.results]]
value = "[{ id: temperature:['London', d'2025-02-19T00:00:00Z'], val: 5.5f }]"

[[test.results]]
value = "[{ id: temperature:['London', d'2025-02-20T00:00:00Z'], val: 5.7f }]"

[[test.results]]
value = "[{ id: temperature:['London', d'2025-02-19T00:00:00Z'], val: 5.5f }, { id: temperature:['London', d'2025-02-20T00:00:00Z'], val: 5.7f }]"

*/

CREATE temperature:['London', d'2025-02-19T00:00:00.000Z'] SET val = 5.5;
CREATE temperature:['London', d'2025-02-20T00:00:00.000Z'] SET val = 5.7;

-- Return all records as long as index 0 = 'London'
SELECT * FROM temperature:['London', NONE]..=['London', ..];
```

```surql title="Output"
[
	{
		id: temperature:[
			'London',
			d'2025-02-19T00:00:00Z'
		],
		val: 5.5f
	},
	{
		id: temperature:[
			'London',
			d'2025-02-20T00:00:00Z'
		],
		val: 5.7f
	}
]
```

Inside a schema, the keyword `any` is used to denote any possible value.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE FIELD anything ON TABLE person TYPE any;
```

## Values and truthiness

Any value is considered to be truthy if it is not NONE, NULL, or a default value for the data type. A data type at its default value is one that is empty, such as an empty string or array or object, or a number set to 0.

The following example shows the result of the `array::all()` method, which checks to see if all of the items inside an array are truthy or not.

```surql
/**[test]

[[test.results]]
value = "false"

[[test.results]]
value = "false"

[[test.results]]
value = "true"

*/

RETURN array::all(["", 1, 2, 3]); // false because of ""
RETURN array::all([{}, 1, 2, 3]); // false because of {}
RETURN array::all(["SurrealDB", { is_nice_database: true }, 1, 2, 3]);  // true
```

As [the ! operator](/docs/surrealql/operators) reverses the truthiness of a value, a doubling of this operator can also be used to check for truthiness.

```surql
/**[test]

[[test.results]]
value = "[true, false, true, false, true, false]"

*/

RETURN [
    !!"Has a value", !!"",             // true, false
    !!true, !!false,                   // true, false
    !!{ is_nice_database: true }, !!{} // true, false
    ];
```


================================================
FILE: src/content/doc-surrealql/functions/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Functions
title: SurrealQL functions
description: SurrealDB allows for advanced functions with complicated logic, by allowing embedded functions to be written in JavaScript.
---

# Functions

SurrealDB offers a number of functions that can be used to perform complex logic. These functions are grouped into the following categories:

- [Database functions](/docs/surrealql/functions/database)
- [JavaScript functions](/docs/surrealql/functions/script)
- [SurrealML functions](/docs/surrealql/functions/ml)



================================================
FILE: src/content/doc-surrealql/functions/database/api.mdx
================================================
---
sidebar_position: 2
sidebar_label: API functions
title: API functions | SurrealQL
description: These functions can be used with the DEFINE API or DEFINE CONFIG statements.
---

# API functions

> [!NOTE]
> API middleware functions such as `api::req::max_body` cannot be used in an ad-hoc manner, such as via Surrealist or the CLI. Instead, they are passed in to a [`DEFINE API`](/docs/surrealql/statements/define/api) or [`DEFINE CONFIG API`](/docs/surrealql/statements/define/config) statement to be used as middleware when a request is received. The only function that can be run at any time is [`api::invoke`](#apiinvoke) which is used to test API endpoints.


> [!CAUTION]
> Currently, this is an experimental feature as such, it may be subject to breaking changes and may present unidentified security issues. Do not rely on this feature in production applications. To enable this, set the `SURREAL_CAPS_ALLOW_EXPERIMENTAL` [environment variable](/docs/surrealdb/cli/start) to `define_api`.
<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#apiinvoke"><code>api::invoke()</code></a></td>
      <td scope="row" data-label="Description">Invokes an `/api` endpoint and returns the result</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#apitimeout"><code>api::timeout()</code></a></td>
      <td scope="row" data-label="Description">Sets a timeout for requests made to a defined API endpoint</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#apireqmax_body"><code>api::req::max_body()</code></a></td>
      <td scope="row" data-label="Description">Sets the maximum body size in bytes for requests made to a defined API endpoint</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#apireqraw_body"><code>api::req::raw_body()</code></a></td>
      <td scope="row" data-label="Description">Sets whether to only take a raw (bytes or string) request body at a defined API endpoint</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#apiresheader"><code>api::res::header()</code></a></td>
      <td scope="row" data-label="Description">Adds a single header to an API endpoint response</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#apiresheaders"><code>api::res::headers()</code></a></td>
      <td scope="row" data-label="Description">Adds multiple headers to an API endpoint response</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#apiresraw_body"><code>api::res::raw_body()</code></a></td>
      <td scope="row" data-label="Description">Sets whether to only return an API endpoint response in bytes or a string</td>
    </tr>
  </tbody>
</table>

## `api::invoke`

```surql title="API DEFINITION"
api::invoke($path: string, $options: option<object>) -> object
```

The `api::invoke` function invokes a custom `/api` endpoint defined using a `DEFINE API` statement. While a `DEFINE API` statement creates an API endpoint at the `/api/:namespace/:database/:endpoint` path, this function is called when a namespace and database have already been decided, necessitating only the final path (such as `"/test"`) for it to be invoked.

The following two examples of the function assume that this `DEFINE API` statement has been used to set up the `"/test"` endpoint.

```surql title="Define API endpoint"
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE API "/test"
    FOR get 
        MIDDLEWARE
            api::req::raw_body(false)
        THEN {
            RETURN {
                status: 404,
                body: $request.body,
                headers: { the_time_is_now: <string>time::now() }
            };
        };
```

Calling the `api::invoke` function with just a path:

```surql title="Use defined endpoint"
api::invoke("/test");
```

```surql title="Output"
{
	body: NONE,
	headers: {
		the_time_is_now: '2025-02-25T11:49:30.732Z'
	},
	raw: false,
	status: 404
}
```

Calling the `api::invoke` function with a path and an object containing a body and headers:

```surql
api::invoke("/test", {
    body: <bytes> '{ "a": true }',
    headers: {
        "Content-Type": "application/json",
        Accept: "application/cbor",
    }
});
```

```surql title="Output"
{
	body: b"7B202261223A2074727565207D",
	headers: {
		the_time_is_now: '2025-02-25T11:51:18.910Z'
	},
	raw: false,
	status: 404
}
```

For more information and examples, see the page for the `DEFINE API` statement.

## `api::timeout`

The `api::timeout` function sets the maximum timeout for a request.

```surql title="API DEFINITION"
api::timeout(duration)
```

```surql title="Example"
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE API "/test"
    FOR get 
        MIDDLEWARE
            api::timeout(1s)
        THEN {
            RETURN {
                headers: {
                    "requested-at": <string>time::now()
                },
                body: SELECT * FROM person
            };
        };
```

## `api::req::max_body`

The `api::req::max_body` function sets the maximum allowed body size in bytes for a request made.

```surql title="API DEFINITION"
api::req::max_body(string)
```

The string argument for this function must be a number followed by the type of unit: `b`, `kb`, `mb`, `gb`, `tb`, or `pb`.

```surql title="Example"
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE API "/test"
    FOR get 
        MIDDLEWARE
            api::req::max_body("1000b")
        THEN {
            RETURN {
                status: 200,
                headers: {
                    "requested-at": <string>time::now()
                },
                body: SELECT * FROM person
            };
        };
```

## `api::req::raw_body`

The `api::req::raw_body` function sets whether to only accept a raw body composed of bytes, a setting which is normally set to `false`. If this function is called with no argument, it will be set to `true`.

A string can also be passed in, which will automatically be converted to bytes.

```surql title="API DEFINITION"
api::req::raw_body(option<bool>)
```

```surql title="Example"
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ body: [], headers: { "requested-at": '2025-10-03T05:03:56.805457Z' }, raw: false, status: 200 }"
skip-datetime = true

*/

DEFINE API "/test"
    FOR get 
        MIDDLEWARE
            api::req::raw_body(true)
        THEN {
            RETURN {
                status: 404,
                headers: {
                    "requested-at": <string>time::now()
                },
                body: SELECT * FROM person
            };
        };

-- Now must be invoked with a body in bytes
api::invoke("/test", {
    body: <bytes>"Hi plz send the information"
});
```

## `api::res::header`

The `api::res::header` function sets a single header for a response.

```surql title="API DEFINITION"
api::res::header($header_name: string, $val: value)
```

```surql title="Example"
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE API "/test"
    FOR get 
        MIDDLEWARE
            api::res::header("country-origin", "CA")
        THEN {
            RETURN {
                status: 200,
                headers: {
                    "requested-at": <string>time::now()
                },
                body: SELECT * FROM person
            };
        };
```

## `api::res::headers`

The `api::res::headers` function takes an object to set the headers for a response.

```surql title="API DEFINITION"
api::res::headers(object)
```

```surql title="Example"
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE API "/test"
    FOR get 
        MIDDLEWARE
            api::res::headers({
                "country-origin": "CA",
                "language": "FR"
            })
        THEN {
            RETURN {
                status: 200,
                headers: {
                    "requested-at": <string>time::now()
                },
                body: SELECT * FROM person
            };
        };
```

## `api::res::raw_body`

The `api::res::raw_body` function sets whether to send a raw body composed of bytes, a setting which is normally set to `false`. If this function is caled with no argument, it will be set to `true`.

```surql title="API DEFINITION"
api::res::raw_body(option<bool>)
```

```surql title="Example"
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE API "/test"
    FOR get 
        MIDDLEWARE
            api::res::raw_body(true)
        THEN {
            RETURN {
                headers: {
                    "requested-at": <string>time::now()
                },
                body: SELECT * FROM person
            };
        };
```


================================================
FILE: src/content/doc-surrealql/functions/database/array.mdx
================================================
---
sidebar_position: 3
sidebar_label: Array functions
title: Array functions | SurrealQL
description: These functions can be used when working with, and manipulating arrays of data.
---
import Since from '@components/shared/Since.astro'
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Array functions

These functions can be used when working with, and manipulating arrays of data.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayadd"><code>array::add()</code></a></td>
      <td scope="row" data-label="Description">Adds an item to an array if it doesn't exist</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayall"><code>array::all()</code></a></td>
      <td scope="row" data-label="Description">Checks whether all array values are truthy, or equal to a condition</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayany"><code>array::any()</code></a></td>
      <td scope="row" data-label="Description">Checks whether any array value is truthy, or equal to a condition</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayat"><code>array::at()</code></a></td>
      <td scope="row" data-label="Description">Returns value for X index, or in reverse for a negative index</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayappend"><code>array::append()</code></a></td>
      <td scope="row" data-label="Description">Appends an item to the end of an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayboolean_and"><code>array::boolean_and()</code></a></td>
      <td scope="row" data-label="Description">Perform the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND">AND</a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND"> </a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND">bitwise operations</a> on two arrays</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayboolean_or"><code>array::boolean_or()</code></a></td>
      <td scope="row" data-label="Description">Perform the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR">OR</a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR"> </a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR">bitwise operations</a> on two arrays</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayboolean_xor"><code>array::boolean_xor()</code></a></td>
      <td scope="row" data-label="Description">Perform the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR">XOR</a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR"> </a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR">bitwise operations</a> on two arrays</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayboolean_not"><code>array::boolean_not()</code></a></td>
      <td scope="row" data-label="Description">Perform the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT">NOT</a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT"> </a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT">bitwise operations</a> on an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraycombine"><code>array::combine()</code></a></td>
      <td scope="row" data-label="Description">Combines all values from two arrays together</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraycomplement"><code>array::complement()</code></a></td>
      <td scope="row" data-label="Description">Returns the complement of two arrays</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayclump"><code>array::clump()</code></a></td>
      <td scope="row" data-label="Description">Returns the original array split into multiple arrays of X size</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayconcat"><code>array::concat()</code></a></td>
      <td scope="row" data-label="Description">Returns the merged values from two arrays</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraydifference"><code>array::difference()</code></a></td>
      <td scope="row" data-label="Description">Returns the difference between two arrays</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraydistinct"><code>array::distinct()</code></a></td>
      <td scope="row" data-label="Description">Returns the unique items in an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayfill"><code>array::fill()</code></a></td>
      <td scope="row" data-label="Description">Fills an existing array of the same value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayfilter"><code>array::filter()</code></a></td>
      <td scope="row" data-label="Description">Filters out values that do not match a pattern</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayfilter_index"><code>array::filter_index()</code></a></td>
      <td scope="row" data-label="Description">Returns the indexes of all occurrences of all matching X value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayfind"><code>array::find()</code></a></td>
      <td scope="row" data-label="Description">Returns the first matching value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayfind_index"><code>array::find_index()</code></a></td>
      <td>Returns the index of the first occurrence of X value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayfirst"><code>array::first()</code></a></td>
      <td scope="row" data-label="Description">Returns the first item in an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayflatten"><code>array::flatten()</code></a></td>
      <td scope="row" data-label="Description">Flattens multiple arrays into a single array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayfold"><code>array::fold()</code></a></td>
      <td scope="row" data-label="Description">Applies an operation on an initial value plus every element in the array, returning the final result.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraygroup"><code>array::group()</code></a></td>
      <td scope="row" data-label="Description">Flattens and returns the unique items in an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayinsert"><code>array::insert()</code></a></td>
      <td scope="row" data-label="Description">Inserts an item at the end of an array, or in a specific position</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayintersect"><code>array::intersect()</code></a></td>
      <td scope="row" data-label="Description">Returns the values which intersect two arrays</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayis_empty"><code>array::is_empty()</code></a></td>
      <td scope="row" data-label="Description">Checks if an array is empty</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayjoin"><code>array::join()</code></a></td>
      <td scope="row" data-label="Description">Returns concatenated value of an array with a string in between.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraylast"><code>array::last()</code></a></td>
      <td scope="row" data-label="Description">Returns the last item in an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraylen"><code>array::len()</code></a></td>
      <td scope="row" data-label="Description">Returns the length of an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraylogical_and"><code>array::logical_and()</code></a></td>
      <td scope="row" data-label="Description">Performs the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND">AND</a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND"> </a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND">logical operations</a> on two arrays</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraylogical_or"><code>array::logical_or()</code></a></td>
      <td scope="row" data-label="Description">Performs the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR">OR</a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR"> </a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR">logical operations</a> on two arrays</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraylogical_xor"><code>array::logical_xor()</code></a></td>
      <td scope="row" data-label="Description">Performs the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR">XOR</a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR"> </a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR">logical operations</a> on two arrays</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraymap"><code>array::map()</code></a></td>
      <td scope="row" data-label="Description">Applies an operation to every item in an array and passes it on</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraymax"><code>array::max()</code></a></td>
      <td scope="row" data-label="Description">Returns the greatest item from an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraymatches"><code>array::matches()</code></a></td>
      <td scope="row" data-label="Description">Returns an array of booleans indicating which elements of the input array contain a specified value.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraymin"><code>array::min()</code></a></td>
      <td scope="row" data-label="Description">Returns the least item from an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraypop"><code>array::pop()</code></a></td>
      <td scope="row" data-label="Description">Returns the last item from an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayprepend"><code>array::prepend()</code></a></td>
      <td scope="row" data-label="Description">Prepends an item to the beginning of an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraypush"><code>array::push()</code></a></td>
      <td scope="row" data-label="Description">Appends an item to the end of an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayrange"><code>array::range()</code></a></td>
      <td scope="row" data-label="Description">Creates a number array from a range (start to end)</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayreduce"><code>array::reduce()</code></a></td>
      <td scope="row" data-label="Description">Applies an operation on every element in the array, returning the final result.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayremove"><code>array::remove()</code></a></td>
      <td scope="row" data-label="Description">Removes an item at a specific position from an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayrepeat"><code>array::repeat()</code></a></td>
      <td scope="row" data-label="Description">Creates an array a given size with a specified value used for each element.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayreverse"><code>array::reverse()</code></a></td>
      <td scope="row" data-label="Description">Reverses the sorting order of an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayshuffle"><code>array::sequence()</code></a></td>
      <td scope="row" data-label="Description">Creates an array of sequential integers</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayshuffle"><code>array::shuffle()</code></a></td>
      <td scope="row" data-label="Description">Randomly shuffles the contents of an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayslice"><code>array::slice()</code></a></td>
      <td scope="row" data-label="Description">Returns a slice of an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraysort"><code>array::sort()</code></a></td>
      <td scope="row" data-label="Description">Sorts the values in an array in ascending or descending order</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraysort_lexical"><code>array::sort_lexical()</code></a></td>
      <td scope="row" data-label="Description">Sorts the values in an array, with strings sorted lexically</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraysort_natural"><code>array::sort_natural()</code></a></td>
      <td scope="row" data-label="Description">Sorts the values in an array, with numeric strings sorted numerically</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraysort_natural_lexical"><code>array::sort_natural_lexical()</code></a></td>
      <td scope="row" data-label="Description">Sorts the values in an array, applying both natural numeric and lexical ordering to strings</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraysortasc"><code>array::sort::asc()</code></a></td>
      <td scope="row" data-label="Description">Sorts the values in an array in ascending order</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraysortdesc"><code>array::sort::desc()</code></a></td>
      <td scope="row" data-label="Description">Sorts the values in an array in descending order</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayswap"><code>array::swap()</code></a></td>
      <td scope="row" data-label="Description">Swaps two items in an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraytranspose"><code>array::transpose()</code></a></td>
      <td scope="row" data-label="Description">Performs 2d array transposition on arrays</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arrayunion"><code>array::union()</code></a></td>
      <td scope="row" data-label="Description">Returns the unique merged values from two arrays</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#arraywindows"><code>array::windows()</code></a></td>
      <td scope="row" data-label="Description">Returns a number of arrays of length `size` created by moving one index at a time down the original array</td>
    </tr>
  </tbody>
</table>

## `array::add`

The `array::add` function adds an item to an array only if it doesn't exist.

```surql title="API DEFINITION"
array::add(array, value) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "['one', 'two', 'three']"

*/


RETURN array::add(["one", "two"], "three");

-- ['one', 'two', 'three']
```

<br />

## `array::all`

When called on an array without any extra arguments, the `array::all` function checks whether all array values are [truthy](/docs/surrealql/datamodel/values#values-and-truthiness).

```surql title="API DEFINITION"
array::all(array) -> bool
array::all(array, value) -> bool
array::all(array, @closure) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "false"

[[test.results]]
value = "true"

*/

RETURN array::all([ 1, 2, 3, NONE, 'SurrealDB', 5 ]);
-- false

RETURN ["all", "clear"].all();
-- true
```

The `array::all` function can also be followed with a value or a [closure](/docs/surrealql/datamodel/closures) to check if all elements conform to a condition.

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "false"

*/

RETURN ["same", "same", "same"].all("same");
-- true

[
  "What's",
  "it",
  "got",
  "in",
  "its",
  "pocketses??"
].all(|$s| $s.len() > 1);
-- true

[1, 2, "SurrealDB"].all(|$var| $var.is_string());
-- false
```

The `array::all` function can also be called using its alias `array::every`.

```surql
[1, 2, 3].every(|$num| $num > 0);
-- true
```

<br />

## `array::any`

The `array::any` function checks whether any array values are [truthy](/docs/surrealql/datamodel/values#values-and-truthiness).

```surql title="API DEFINITION"
array::any(array) -> bool
array::any(array, value) -> bool
array::any(array, @closure) -> bool
```

When called on an array without any extra arguments, the `array::any` function checks whether any array values are [truthy](/docs/surrealql/datamodel/values#values-and-truthiness).

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "false"

*/

RETURN array::any([ 1, 2, 3, NONE, 'SurrealDB', 5 ]);
-- true

["", 0, NONE, NULL, [], {}].any();
-- false
```

The `array::any` function can also be followed with a value or a [closure](/docs/surrealql/datamodel/closures) to check if any elements conform to a condition.

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "false"

[[test.results]]
value = "true"

*/

RETURN ["same", "same?", "Dude, same!"].any("same");
-- true

[
  "What's",
  "it",
  "got",
  "in",
  "its",
  "pocketses??"
].any(|$s| $s.len() > 15);
-- false

[1, 2, "SurrealDB"].any(|$var| $var.is_string());
-- true
```

The `array::any` function can also be called using the aliases `array::some` and `array::includes`.

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "false"

*/

[1, 2, 3].some(|$num| $num > 2);
-- true

[1999, 2001, 2002].includes(2000);
-- false
```

<br />

## `array::at`

The `array::at` function returns the value at the specified index, or in reverse for a negative index.

```surql title="API DEFINITION"
array::at(array, index: int) -> any
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'r'"

*/

RETURN array::at(['s', 'u', 'r', 'r', 'e', 'a', 'l'], 2);

-- 'r'
```

You can also pass a negative index. This will perform the lookup in reverse:

```surql
/**[test]

[[test.results]]
value = "'e'"

*/

RETURN array::at(['s', 'u', 'r', 'r', 'e', 'a', 'l'], -3);

-- 'e'
```

<br />

## `array::append`

The `array::append` function appends a value to the end of an array.

```surql title="API DEFINITION"
array::append(array, value) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 2, 3, 4, 5]"

*/

RETURN array::append([1, 2, 3, 4], 5);

-- [1, 2, 3, 4, 5]
```

<br />

## `array::boolean_and`

The `array::boolean_and` function performs the [`AND` `bitwise operations`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND) on the input arrays per-element based on the element's truthiness.
If one array is shorter than the other it is considered null and thus false.

```surql title="API DEFINITION"
array::boolean_and(lh: array, rh: array)
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "false"

[[test.results]]
value = "true"

*/

RETURN array::boolean_and(["true", "false", 1, 1], ["true", "true", 0, "true"]);

-- [true, true, false, true]
```

For those that take two arrays, missing elements (if one array is shorter than the other) are considered `null` and thus false.

```surql
/**[test]

[[test.results]]
value = "false"

[[test.results]]
value = "false"

*/

RETURN array::boolean_and([true, true], [false]);

-- [ false, false ]
```

<br />

## `array::boolean_or`

The `array::boolean_or` function performs the [OR bitwise operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR) on the input arrays per-element based on the element's truthiness.
It takes two arrays and if one array is shorter than the other or missing, the output is considered null and thus false.

```surql title="API DEFINITION"
array::boolean_or(lh: array, rh: array)
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "false"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

*/

RETURN array::boolean_or([false, true, false, true], [false, false, true, true]);

-- [false, true, true, true]
```

<br />

## `array::boolean_xor`

The `array::boolean_xor` function performs the [XOR bitwise operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR).

```surql title="API DEFINITION"
array::boolean_xor(lh: array, rh: array)
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "false"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "false"

*/

RETURN array::boolean_xor([false, true, false, true], [false, false, true, true]);

-- [false, true, true, false]
```

<br />

## `array::boolean_not`

The `array::boolean_not` function performs the [`NOT bitwise operations`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT) on the input array(s) per-element based on the element's truthiness.
It takes in one array and it returns false if its single operand can be converted to true.

```surql title="API DEFINITION"
array::boolean_not(array)
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "false"

[[test.results]]
value = "true"

[[test.results]]
value = "false"

*/
RETURN array::boolean_not([ false, true, 0, 1 ]);

-- [true, false, true, false]
```

<br />

## `array::combine`

The `array::combine` function combines all values from two arrays together, returning an array of arrays.

```surql title="API DEFINITION"
array::combine(array, array) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[[[1, 2], [1, 3], [2, 2], [2, 3]]]"

*/

RETURN array::combine([1, 2], [2, 3]);

-- [ [1, 2], [1, 3], [2, 2], [2, 3] ]
```

<br />

## `array::complement`

The `array::complement` function returns the complement of two arrays, returning a single array containing items which are not in the second array.

```surql title="API DEFINITION"
array::complement(array, array) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 2]"

*/

RETURN array::complement([1, 2, 3, 4], [3, 4, 5, 6]);

-- [1, 2]
```

<br />

## `array::concat`

The `array::concat` function merges two arrays together, returning an array which may contain duplicate values. If you want to remove duplicate values from the resulting array, then use the [`array::union()`](/docs/surrealql/functions/database/array#arrayunion) function or cast it to a set using `<set>`.

```surql title="API DEFINITION"
array::concat(array, array) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 2, 3, 4, 3, 4, 5, 6]"

*/

RETURN array::concat([1, 2, 3, 4], [3, 4, 5, 6]);

-- [ 1, 2, 3, 4, 3, 4, 5, 6 ]
```

As of SurrealDB 3.0.0-alpha.3, the behaviour of this function can also be achieved using the `+` operator.

```surql
/**[test]

[[test.results]]
value = "[1, 2, 3, 4, 3, 4, 5, 6]"

*/

RETURN [1, 2, 3, 4] + [3, 4, 5, 6];

-- [ 1, 2, 3, 4, 3, 4, 5, 6 ]
```

<br />

## `array::clump`

The `array::clump` function returns the original array split into sub-arrays of `size`. The last sub-array may have a length less than the length of `size` if `size` does not divide equally into the original array.

```surql title="API DEFINITION"
array::clump(array, size: int) -> array
```
The following examples show this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[[1, 2], [3, 4]]"

[[test.results]]
value = "[[1, 2, 3], [4]]"

*/

LET $array = [1, 2, 3, 4];
RETURN array::clump($array, 2);
RETURN array::clump($array, 3);
```

```surql title="Response"
-- [ [ 1, 2], [3, 4] ]
-- [ [1, 2, 3], [4] ]
```

<br />

## `array::difference`

The `array::difference` function determines the difference between two arrays, returning a single array containing items which are not in both arrays.

```surql title="API DEFINITION"
array::difference(array, array) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 2, 5, 6]"

*/

RETURN array::difference([1, 2, 3, 4], [3, 4, 5, 6]);

-- [ 1, 2, 5, 6 ]
```

<br />

## `array::distinct`

The `array::distinct` function calculates the unique values in an array, returning a single array.

```surql title="API DEFINITION"
array::distinct(array) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 2, 3, 4]"

*/

RETURN array::distinct([ 1, 2, 1, 3, 3, 4 ]);

-- [ 1, 2, 3, 4 ]
```

<br />

## `array::fill`

<Since v="v2.0.0" />

The `array::fill` function replaces all values of an array with a new value.

```surql title="API DEFINITION"
array::fill(array, any) -> array
```

The function also accepts a third and a fourth parameter which allows you to replace only a portion of the source array.

```surql title="API DEFINITION"
array::fill(array, any, start: int, end: int) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[10, 10, 10, 10, 10]"

*/

RETURN array::fill([ 1, 2, 3, 4, 5 ], 10);

-- [ 10, 10, 10, 10, 10 ]
```

The following example shows how you can use this function with a starting position, and an ending position, which in this example will replace one item from the array:

```surql
/**[test]

[[test.results]]
value = "[1, 10, 3, 4, 5]"

*/

RETURN array::fill([ 1, NONE, 3, 4, 5 ], 10, 1, 2);

-- [ 1, 10, 3, 4, 5 ]
```

The following example shows how you can use this function with starting and ending negative positions, which in this example will replace one item from the array:

```surql
/**[test]

[[test.results]]
value = "[1, 2, 10, 4, 5]"

*/

RETURN array::fill([ 1, 2, NONE, 4, 5 ], 10, -3, -2);

-- [ 1, 2, 10, 4, 5 ]
```

<br />

## `array::filter`

The `array::filter` function filters out values in an array that do not match a pattern, returning only the ones that do match.

```surql title="API DEFINITION"
array::filter(array, value) -> array
array::filter(array, @closure) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 1]"

[[test.results]]
value = "[true, true, true]"

*/

RETURN array::filter([ 1, 2, 1, 3, 3, 4 ], 1);
-- [ 1, 1 ]

RETURN [true, false, false, false, true, true].filter(true);
-- [ true, true, true ]
```

The `array::filter` function can also take a [closure](/docs/surrealql/datamodel/closures) for more customized filtering.

```surql
/**[test]

[[test.results]]
value = "[{ importance: 10, message: 'I need some help with this query...' }, { importance: 100, message: 'Stuck on an island with two hours of battery life left. Can you...' }]"

*/

 [
    { importance: 10, message: "I need some help with this query..." },
    { importance: 0, message: "TEST Is this thing on?" },
    { importance: 5, message: "I have an idea. What if we..."},
    { importance: 100, message: "Stuck on an island with two hours of battery life left. Can you..."}
].filter(|$v| $v.importance > 5);
```

```surql title="Response"
[
	{
		importance: 10,
		message: 'I need some help with this query...'
	},
	{
		importance: 100,
		message: 'Stuck on an island with two hours of battery life left. Can you...'
	}
]
```

Note that the function checks whether the output of the inner closure [is truthy](/docs/surrealql/datamodel/values#values-and-truthiness), as opposed to only expecting a `bool`. As any and all values can be checked for truthiness, simply passing the closure argument as its output is enough to filter out values that are not truthy, such as `NONE` values and empty arrays.

```surql
/**[test]

[[test.results]]
value = "[1, 2, 3]"

*/

[1,2,3,NONE,0,"",{},[]].filter(|$v| $v);

-- [1, 2, 3]
```

A more real-life example of this pattern in which only the `person` records that have been seen by another are returned:

```surql
/**[test]

[[test.results]]
value = "[{ id: person:one }, { id: person:two }]"

[[test.results]]
value = "[{ id: sees:1906dfpey5ho324ot0if, in: person:one, out: person:two }]"

[[test.results]]
value = "[{ id: person:two, is_seen_by: [person:one] }]"

*/

CREATE person:one, person:two;
RELATE person:one->sees->person:two;

(SELECT 
  id, 
  <-sees<-person AS is_seen_by
FROM person)
    .filter(|$person| $person.is_seen_by);
```

```surql title="Response"
[
	{
		id: person:two,
		is_seen_by: [
			person:one
		]
	}
]
```

<br />

## `array::filter_index`

The `array::filter_index` function returns the indexes of all occurrences of all matching values.

```surql title="API DEFINITION"
array::filter_index(array, value) -> array
array::filter_index(array, @closure) -> array
```

The following examples show this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 3]"

[[test.results]]
value = "[0, 1, 3, 4]"

*/

RETURN array::filter_index(['a', 'b', 'c', 'b', 'a'], 'b');
-- [ 1, 3 ]

RETURN [0, 0, 1, 0, 0, 5, 1].filter_index(0);
-- [ 0, 1, 3, 4 ]
```

The `array::filter_index` function can also take a [closure](/docs/surrealql/datamodel/closures) for more customized filtering.

```surql
/**[test]

[[test.results]]
value = "[0, 3]"

*/

 [
    { importance: 10, message: "I need some help with this query..." },
    { importance: 0, message: "TEST Is this thing on?" },
    { importance: 5, message: "I have an idea. What if we..."},
    { importance: 100, message: "Stuck on an island with two hours of battery life left. Can you..."}
].filter_index(|$v| $v.importance > 5);
```

```surql title="Response"
[0, 3]
```

<br />

## `array::find`

The `array::find` function returns the first occurrence of `value` in the array or `NONE` if `array` does not contain `value`.

```surql title="API DEFINITION"
array::find(array, value) -> value | NONE
array::find(array, @closure) -> value | NONE
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'b'"

[[test.results]]
value = "NONE"

*/

RETURN array::find(['a', 'b', 'c', 'b', 'a'], 'b');
-- b

RETURN [1, 2, 3].find(4);
-- [NONE]
```

The `array::find` function is most useful when a [closure](/docs/surrealql/datamodel/closures) is passed in which allows for customized searching.


```surql
/**[test]

[[test.results]]
value = "5"

[[test.results]]
value = "{ intelligence: 15, name: 'Mardine', strength: 10 }"

*/

-- Find one number 3 or greater
RETURN [1, 2, 5].find(|$num| $num >= 3);

-- Find the first adventurer good enough for the task
[
    { strength: 15, intelligence: 6,  name: "Dom the Magnificent" },
    { strength: 10, intelligence: 15, name: "Mardine"             },
    { strength: 20, intelligence: 3,  name: "Gub gub"             },
    { strength: 10, intelligence: 18, name: "Lumin695"            }
].find(|$c| $c.strength > 9 AND $c.intelligence > 9);
```

```surql title="Response"
-------- Query --------

5

-------- Query --------

{
	intelligence: 15,
	name: 'Mardine',
	strength: 10
}
```

<br />

## `array::find_index`

The `array::find_index` function returns the index of the first occurrence of `value` in the array or `NONE` if `array` does not contain `value`.

```surql title="API DEFINITION"
array::find_index(array, value) -> number | NONE
array::find_index(array, @closure) -> number | NONE
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1"

[[test.results]]
value = "NONE"

*/

RETURN array::find_index(['a', 'b', 'c', 'b', 'a'], 'b');
-- 1

RETURN [1, 2, 3].find_index(4);
-- NONE
```

The `array::find_index` function can also take a [closure](/docs/surrealql/datamodel/closures) for more customized searching.

```surql
/**[test]

[[test.results]]
value = "2"

*/

RETURN [1, 2, 3].find_index(|$num| $num > 2);
-- 2
```

The `array::find_index` function also be called using the alias `array::index_of`.

```surql
/**[test]

[[test.results]]
value = "3"

*/

["cat", "badger", "dog", "octopus"].index_of("octopus");
-- 3
```

<br />

## `array::first`

The `array::first` function returns the first value from an array.

```surql title="API DEFINITION"
array::first(array) -> any
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'s'"

*/


RETURN array::first([ 's', 'u', 'r', 'r', 'e', 'a', 'l' ]);

-- 's'
```

<br />

## `array::flatten`

The `array::flatten` function flattens an array of arrays, returning a new array with all sub-array elements concatenated into it.

```surql title="API DEFINITION"
array::flatten(array) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 2, 3, 4, 'SurrealDB', 5, 6, [7, 8]]"

*/

RETURN array::flatten([ [1, 2], [3, 4], 'SurrealDB', [5, 6, [7, 8]] ]);
```

```surql title="Response"
[ 1, 2, 3, 4, 'SurrealDB', 5, 6, [7, 8] ]
```

<br />

## `array::fold`

<Since v="v2.1.0" />

The `array::fold` function returns a final value from the elements of an array by allowing an operation to be performed at each step of the way as each subsequent item in the array is encountered. To use `array::fold`, pass in an initial value, followed by parameter names for the current value and the next value and an operation to perform on them. If you only want to perform an operation on each item and do not need an initial value, use the [`array::reduce`](/docs/surrealql/functions/database/array#arrayreduce) function instead.

```surql title="API DEFINITION"
array::fold(array, initial_value, @closure) -> value
```

This function is commonly used to sum or subtract the items in an array from an initial value. 

```surql
/**[test]

[[test.results]]
value = "53"

*/

-- Returns 53
[10,12,10,15].fold(100, |$a, $b| $a - $b);
```

The function will then perform the following operation for each step of the way.

* `$a` = 100 (initial value), `$b` = 10 (first item in the array). Operation `$a - $b` = 90. 90 is passed on.
* `$a` = 90, `$b` = 12. Operation `$a - $b` = 78. 78 is passed on.
* `$a` = 84, `$b` = 10. Operation `$a - $b` = 74. 68 is passed on.
* `$a` = 74, `$b` = 15. Operation `$a - $b` = 53. No more items to operate on in the array, 53 is returned.

Another example showing `array::fold()` used to reverse a `string`:

```surql
/**[test]

[[test.results]]
value = "'gnirts sdrawrof a ma I'"

*/

"I am a forwards string"
  .split('')
  .fold("", |$one, $two| $two + $one);
```

```surql title="Output"
'gnirts sdrawrof a ma I'
```

Or to modify a string in some other way.

```surql
/**[test]

[[test.results]]
value = ""_I_don't_like_whitespace""

*/

"I don't like whitespace"
  .split(" ")
  .fold("", |$one, $two| $one + "_" + $two);
```

```surql title="Output"
"_I_don't_like_whitespace"
```

As the output above shows, it is often nice to know which item of the array one is working with. This function allows a third parameter to be passed in that keeps track of the index of the current item.

```surql
/**[test]

[[test.results]]
value = ""I_don't_like_whitespace""

*/

"I don't like whitespace"
  .split(" ")
  .fold("", |$one, $two, $index| IF $index = 0 { $one + $two } ELSE { $one + "_" + $two });
```

```surql title="Output"
"I_don't_like_whitespace"
```

The `array::fold()` function can be used to generate an array of values that can then be passed on to statements like [`INSERT`](/docs/surrealql/statements/insert) for bulk insertion.

```surql
INSERT INTO person (
  -- Create 1000 objects with a random ULID and incrementing number
    (<array>0..1000).fold([], |$v, $_, $i| {
    $v.append( { 
      id: rand::ulid(),
      person_num: $i
      });
    })
) RETURN NONE;
```

This function is also useful for aggregating the results of graph queries. The following shows a graph table called `to` that holds the distance from one city to another. The `array::fold()` function can then be used to pass an object along that tracks the first and last city, while accumulating the distance and number of trips along the way.

```surql
CREATE city:one, city:two, city:three;
RELATE city:one -> to -> city:two SET distance = 25.5;
RELATE city:two -> to -> city:three SET distance = 4.1;
[
	city:one,
	city:two,
	city:three
].map(|$v| { {
	city: $v,
	distance: 0,
	from: NONE,
	to: NONE,
	trips: 0
} }).fold({
	city: NONE,
	distance: 0,
	from: NONE,
	to: NONE,
	trips: 0
}, |$acc, $val, $i| {
	RETURN IF $i = 0 {
		{
			city: $val.city,
			distance: 0,
			from: $val.city,
			to: NONE,
			trips: $acc.trips + 1
		}
  }
	ELSE {
		{
			city: $val.city,
			distance: (SELECT VALUE distance FROM ONLY to WHERE in = $acc.city AND out = $val.city LIMIT 1) + $acc.distance,
			from: $acc.from,
			to: $val.city,
			trips: $acc.trips + 1
		}
  };
}).chain(|$v| { {
	distance: $v.distance,
	from: $v.from,
	to: $v.to,
	trips: $v.trips
} });
```

Final result:

```surql
{
	distance: 29.6f,
	from: city:one,
	to: city:three,
	trips: 3
}
```

## `array::group`

The `array::group` function flattens and returns the unique items in an array.

```surql title="API DEFINITION"
array::group(array) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 2, 3, 4, 5, 6, 7, 8, 9]"

*/

RETURN array::group([1, 2, 3, 4, [3, 5, 6], [2, 4, 5, 6], 7, 8, 8, 9]);

-- [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
```

<br />

## `array::insert`

The `array::insert` function inserts a value into an array at a specific position. A negative index can be provided to specify a position relative to the end of the array.

```surql title="API DEFINITION"
array::insert(array, value, number) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 2, 5, 3, 4]"

*/

RETURN array::insert([1, 2, 3, 4], 5, 2);

-- [ 1, 2, 5, 3, 4 ]
```

<br />

## `array::intersect`

The `array::intersect` function calculates the values which intersect two arrays, returning a single array containing the values which are in both arrays.

```surql title="API DEFINITION"
array::intersect(array, array) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = [3, 4]""

*/

RETURN array::intersect([1, 2, 3, 4], [3, 4, 5, 6]);

-- [ 3, 4 ]
```

<br />

## `array::is_empty`

<Since v="v2.0.0" />

The `array::is_empty` function checks whether the array contains values.

```surql title="API DEFINITION"
array::is_empty(array) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql title="An array that contain values"
/**[test]

[[test.results]]
value = "false"

*/

RETURN array::is_empty([1, 2, 3, 4]);

-- false
```

```surql title="An empty array"
/**[test]

[[test.results]]
value = "true"

*/

RETURN array::is_empty([]);

-- true
```

<br />

## `array::join`

The `array::join` function takes an array and a string as parameters and returns a concatenated string.

```surql title="API DEFINITION"
array::join(array, string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'again and again and again'"

*/

RETURN array::join(["again", "again", "again"], " and ");

-- "again and again and again"
```

<br />

## `array::last`

The `array::last` function returns the last value from an array.

```surql title="API DEFINITION"
array::last(array) -> any
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'l'"

*/

RETURN array::last([ 's', 'u', 'r', 'r', 'e', 'a', 'l' ]);

-- 'l'
```

<br />

## `array::len`

The `array::len` function calculates the length of an array, returning a number. This function includes all items when counting the number of items in the array. If you want to only count [truthy](/docs/surrealql/datamodel/values#values-and-truthiness) values, then use the [count()](/docs/surrealql/functions/database/count) function.

```surql title="API DEFINITION"
array::len(array) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "9"

*/

RETURN array::len([ 1, 2, 1, null, "something", 3, 3, 4, 0 ]);

-- 9
```

<br />

## `array::logical_and`

The `array::logical_and` function performs the [`AND` logical operation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND) element-wise between two arrays.
The resulting array will have a length of the longer of the two input arrays, where each element is the result of the logical `AND` operation performed between an element from the left hand side array and an element from the right hand side array.

When both of the compared elements are truthy, the resulting element will have the type and value of one of the two truthy values, prioritizing the value and type of the element from the left hand side (the first array).

When one or both of the compared elements are not truthy, the resulting element will have the type and value of one of the non-truthy value(s), prioritizing the value and type of the element from the left hand side (the first array).

```surql title="API DEFINITION"
array::logical_and(lh: array, rh: array)
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "false"

[[test.results]]
value = "false"

[[test.results]]
value = "false"

*/

RETURN array::logical_and([true, false, true, false], [true, true, false, false]);

-- [ true, false, false, false ]
```
For those that take two arrays, missing elements (if one array is shorter than the other) are considered `null` and thus false.

```surql
/**[test]

[[test.results]]
value = "0"

[[test.results]]
value = "NULL"

*/

RETURN array::logical_and([0, 1], [])

-- [ 0, NULL ]
```

<br />

## `array::logical_or`

The `array::logical_or` function performs the [`OR` logical operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR) element-wise between two arrays.

The resulting array will have a length of the longer of the two input arrays, where each element is the result of the logical `OR` operation performed between an element from the left hand side array and an element from the right hand side array.

When one or both of the compared elements are truthy, the resulting element will have the type and value of one of the two truthy value(s), prioritizing the value and type of the element from the left hand side (the first array).

When both of the compared elements are not truthy, the resulting element will have the type and value of one of the non-truthy values, prioritizing the value and type of the element from the left hand side (the first array).

```surql title="API DEFINITION"
array::logical_or(lh: array, rh: array)
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "false"

*/

RETURN array::logical_or([true, false, true, false], [true, true, false, false]);

-- [ true, true, true, false ]
```

If one of the arrays is empty, the first array is returned.

```surql
RETURN array::logical_or([0, 1], []);

[ 0, 1 ]
```

<br />

## `array::logical_xor`

The `array::logical_xor` function performs the [`XOR` logical operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR) element-wise between two arrays.

The resulting array will have a length of the longer of the two input arrays, where each element is the result of the logical `XOR` operation performed between an element from the left hand side array and an element from the right hand side array.

When exactly one of the compared elements is truthy, the resulting element will have the type and value of the truthy value.

When both of the compared elements are truthy, the resulting element will be the `bool` value `false`.

When neither of the compared elements are truthy, the resulting element will have the type and value of one of the non-truthy values, prioritizing the value and type of the element from the left hand side (the first array).

```surql title="API DEFINITION"
array::logical_xor(lh: array, rh: array)
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql

/**[test]

[[test.results]]
value = "false"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "false"

*/

RETURN array::logical_xor([true, false, true, false], [true, true, false, false]);

-- [ false, true, true, false ]
```

If one of the array is empty, the first array is returned.
```surql

/**[test]

[[test.results]]
value = "[0, 1]"

*/

RETURN array::logical_xor([0, 1], [])

-- [ 0, 1 ]
```

<br />

## `array::map`

The `array::map` function allows the user to call an [anonymous function](/docs/surrealql/datamodel/closures) (closure) that is performed on every item in the array before passing it on.

```surql title="API DEFINITION"
array::map(array, @closure) -> array;
```

The most basic use of `array::map` involves choosing a parameter name for each item in the array and a desired output. The following example gives each item the parameter name `$v`, which can then be used to double the value.

```surql

/**[test]

[[test.results]]
value = "[2, 4, 6]"

*/

[1, 2, 3].map(|$v| $v * 2);
```

```surql title="Response"
[
  2,
  4,
  6
]
```

An example of a longer operation that uses `{}` to allow the closure to take multiple lines of code:

```surql

/**[test]
[[test.results]]
value = "[{ is_even: false, value: 1 }, { is_even: true, value: 2 }, { is_even: false, value: 3 }]"

*/

["1", "2", "3"].map(|$val| {
  LET $num = <number>$val;
  LET $is_even = IF $num % 2 = 0 { true } ELSE { false };
  {
    value: $num,
    is_even: $is_even
  }
});
```

```surql title="Response"
[
	{
		is_even: false,
		value: 1
	},
	{
		is_even: true,
		value: 2
	},
	{
		is_even: false,
		value: 3
	}
]

```

The types for the closure arguments and output can be annotated for extra type safety. Take the following simple closure:

```surql

/**[test]
[[test.results]]
value = "[2.1f, 3.1f, 4.1f]"

*/

[1, 2, 3].map(|$num| $num + 1.1);
```

The output is `[2.1f, 3.1f, 4.1f]`.

However, if the `1.1` inside the function was actually a typo and should have been the integer 11, the following would have prevented it from running.

```surql

/**[test]
[[test.results]]
error = ""Couldn't coerce return value from function `ANONYMOUS`: Expected `int` but found `2.1f`""

*/

[1, 2, 3].map(|$num: int| -> int { $num + 1.1 });
```

```surql title="Response"
"Couldn't coerce return value from function `ANONYMOUS`: Expected `int` but found `2.1f`"
```

The `array::map` function also allows access to the index of each item if a second parameter is added.

```surql

/**[test]
[[test.results]]
value = "['0: first used in the year 876', '1: the number of moons in the sky', '2: also called a pair']"

*/

[
  ": first used in the year 876",
  ": the number of moons in the sky",
  ": also called a pair"
]
  .map(|$item, $index| <string>$index + $item);
```

```surql title="Response"
[
	'0: first used in the year 876',
	'1: the number of moons in the sky',
	'2: also called a pair'
]
```

The `array::map()` function can be used to generate an array of values that can then be passed on to statements like [`INSERT`](/docs/surrealql/statements/insert) for bulk insertion.

```surql
INSERT INTO person ((<array>0..=1000).map(|| {id: rand::ulid()}));
```

For a similar function that allows using a closure on entire values instead of each item in an array, see the [chain](/docs/surrealql/functions/database/value#chain) method.

## `array::max`

The `array::max` function returns the greatest value from an array of values.

```surql title="API DEFINITION"
array::max(array<any>) -> any
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql

/**[test]
[[test.results]]
value = "2"

*/

RETURN array::max([0, 1, 2]);

-- 2
```

As any value can be compared with another value, the array can be an array of any SurrealQL value.

```surql

/**[test]

[[test.results]]
value = "9.9f"

*/

array::max([NONE, NULL, 9, 9.9]);

-- 9.9f
```

See also:

* [`math::max`](/docs/surrealql/functions/database/math#mathmax), which extracts the greatest number from an array of numbers
* [`time::max`](/docs/surrealql/functions/database/time#timemax), which extracts the greatest datetime from an array of datetimes
* [How values are compared and ordered in SurrealDB](/docs/surrealql/datamodel/values#comparing-and-ordering-values)

## `array::matches`

The `array::matches` function returns an array of booleans indicating which elements of the input array contain a specified value.


```surql title="API DEFINITION"
array::matches(array, value) -> array<bool>
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql

/**[test]

[[test.results]]
value = "false"

[[test.results]]
value = "true"

[[test.results]]
value = "false"

*/

RETURN array::matches([0, 1, 2], 1);

-- [false, true, false]
```
The following example shows this function when the array contains objects.

```surql

/**[test]

[[test.results]]
value = "false"

[[test.results]]
value = "true"

*/

RETURN array::matches([{id: r"ohno:0"}, {id: r"ohno:1"}], {id: r"ohno:1"});

-- [false, true]
```

<br />

## `array::min`

The `array::min` function returns the least value from an array of values.

```surql title="API DEFINITION"
array::min(array<any>) -> any
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql

/**[test]
[[test.results]]
value = "0"

*/

RETURN array::min([0, 1, 2]);

-- 0
```

As any value can be compared with another value, the array can be an array of any SurrealQL value.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

array::min([NONE, NULL, 9, 9.9]);

NONE
```

See also:

* [`math::min`](/docs/surrealql/functions/database/math#mathmin), which extracts the least number from an array of numbers
* [`time::min`](/docs/surrealql/functions/database/time#timemin), which extracts the least datetime from an array of datetimes
* [How values are compared and ordered in SurrealDB](/docs/surrealql/datamodel/values#comparing-and-ordering-values)

## `array::pop`

The `array::pop` function removes a value from the end of an array and returns it. If the array is empty, NONE is returned.


```surql title="API DEFINITION"
array::pop(array) -> value
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "4"

*/

RETURN array::pop([ 1, 2, 3, 4 ]);

-- 4
```

<br />

## `array::prepend`

The `array::prepend` function prepends a value to the beginning of an array.


```surql title="API DEFINITION"
array::prepend(array, value) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[5, 1, 2, 3, 4]"

*/

RETURN array::prepend([1, 2, 3, 4], 5);

-- [ 5, 1, 2, 3, 4 ]
```

<br />

## `array::push`

The `array::push` function prepends a value to the end of an array.


```surql title="API DEFINITION"
array::push(array, value) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 2, 3, 4, 5]"

*/

RETURN array::push([1, 2, 3, 4], 5);

-- [ 1, 2, 3, 4, 5 ]
```

<br />

## `array::range`

<Since v="v2.0.0" />

The `array::range` function creates an array of numbers from a given range.

```surql title="API DEFINITION"
array::range(start: int, count: int) -> array
-- Also since 3.0.0-alpha.8
array::slice(array, range) -> array;
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 2, 3, 4, 5, 6, 7, 8, 9]"

*/

RETURN array::range(1, 10);

-- [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
```

```surql
/**[test]

[[test.results]]
value = "[1, 2, 3, 4, 5]"

*/

RETURN array::range(1..=5);

[ 1, 2, 3, 4, 5 ]
```

<br />

## `array::reduce`

<Since v="v2.1.0" />

The `array::reduce` function reduces the elements of an array to a single final value by allowing an operation to be performed at each step of the way as each subsequent item in the array is encountered. To use `array::reduce`, pass in parameter names for the current value and the next value and an operation to perform on them. If you need an initial value to pass in before the other items are operated on, use the [`array::fold`](/docs/surrealql/functions/database/array#arrayfold) function instead.

```surql title="API DEFINITION"
array::reduce(array, @closure) -> value
```

This function is commonly used to sum or perform some other mathematical operation on the items in an array.

```surql
/**[test]

[[test.results]]
value = "100"

*/

[10,20,30,40].reduce(|$a, $b| $a + $b);
```

The function will then perform the following operation for each step of the way.

* `$a` = 10, `$b` = 20. Operation `$a + $b` = 30. 30 is passed on.
* `$a` = 30, `$b` = 30. Operation `$a + $b` = 60. 60 is passed on.
* `$a` = 60, `$b` = 40. Operation `$a + $b` = 100. No more items to operate on in the array, 100 is returned.

Another example showing `array::reduce()` used to reverse a `string`:

```surql
/**[test]

[[test.results]]
value = "'gnirts sdrawrof a ma I'"

*/

"I am a forwards string"
  .split('')
  .reduce(|$one, $two| $two + $one);
```

```surql title="Output"
'gnirts sdrawrof a ma I'
```

Or to modify a string in some other way.

```surql
/**[test]

[[test.results]]
value = ""I_don't_like_whitespace""

*/

"I don't like whitespace"
  .split(" ")
  .reduce(|$one, $two| $one + "_" + $two);
```

```surql title="Output"
"I_don't_like_whitespace"
```

It is often nice to know which item of the array one is working with. The following example shows a reduce operation performed on an array, but only up to index 2. For any further indexes, the value is simply passed on.

```surql
/**[test]

[[test.results]]
value = "{ money: 11650, name: 'Daughter and Father and Grandfather and Great-grandmother' }"

*/

[
    {
        name: "Daughter",
        money: 100
    },
    {
        name: "Father",
        money: 1000
    },
    {
        name: "Grandfather",
        money: 550
    },
    {
        name: "Great-grandmother",
        money: 10000
    }
].reduce(|$one, $two, $index| IF $index > 2 { $one } ELSE {
    {
        name: $one.name + " and " + $two.name,
        money: $one.money + $two.money
    }
});
```

```surql title="Output"
{
	money: 1650,
	name: 'Daughter and Father and Grandfather'
}
```

## `array::remove`

The `array::remove` function removes an item from a specific position in an array. A negative index can be provided to specify a position relative to the end of the array.


```surql title="API DEFINITION"
array::remove(array, number) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 2, 4, 5]"

*/

RETURN array::remove([1, 2, 3, 4, 5], 2);

-- [ 1, 2, 4, 5 ]
```

The following examples shows this function using a negative index.
```surql
/**[test]

[[test.results]]
value = "[1, 2, 3, 5]"

*/

RETURN array::remove([1, 2, 3, 4, 5], -2);

-- [ 1, 2, 3, 5 ]
```

<br />

## `array::repeat`

<Since v="v2.0.0" />

The `array::repeat` function creates an array of a given size contain the specified value for each element.

```surql title="API DEFINITION"
array::repeat(any, count: int) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"

*/

RETURN array::repeat(1, 10);

-- [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
```

```surql
/**[test]

[[test.results]]
value = "['hello', 'hello']"

*/

RETURN array::repeat("hello", 2);

-- [ "hello", "hello" ]
```

<br />

## `array::reverse`

The `array::reverse` function reverses the sorting order of an array.


```surql title="API DEFINITION"
array::reverse(array) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[5, 4, 3, 2, 1]"

*/

RETURN array::reverse([ 1, 2, 3, 4, 5 ]);

-- [ 5, 4, 3, 2, 1 ]
```

<br />

## `array::sequence`

<Since v="v3.0.0-alpha.11" />

The `array::sequence` function creates an array of sequential integers.

```surql title="API DEFINITION"
array::shuffle(length: int) -> array
array::shuffle(start: int, length: int) -> array
```

A single number passed in as an argument will create an array beginning at 0 with a length of the number indicated.

```surql
array::sequence(5);
-- [0, 1, 2, 3, 4]
```

If a second argument is passed into this function, the first argument will be used as the starting point for the array and the second for the length.

```surql
array::sequence(-5, 6);
-- [-5, -4, -3, -2, -1, 0]
```

## `array::shuffle`

<Since v="v2.0.0" />

The `array::shuffle` function randomly shuffles the items of an array.

```surql title="API DEFINITION"
array::shuffle(array) -> array
```

The following example shows this function, and its possible output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[3, 5, 4, 1, 2]"

*/

RETURN array::shuffle([ 1, 2, 3, 4, 5 ]);

-- [ 2, 1, 4, 3, 5 ]
```

<br />

## `array::slice`

The `array::slice` function returns a slice of an array, based on a starting position, and a length or negative position.

```surql title="API DEFINITION"
array::slice(array, start: int, len: int) -> array
-- Also since 3.0.0-alpha.8
array::slice(array, range) -> array;
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[2, 3]"

*/

RETURN array::slice([ 1, 2, 3, 4, 5 ], 1, 3);

-- [2, 3]
```

The following example shows how you can use this function with a starting position, and a negative position, which will slice off the first and last element from the array:

```surql
/**[test]

[[test.results]]
value = "[2, 3, 4]"

*/

RETURN array::slice([ 1, 2, 3, 4, 5 ], 1, -1);

[ 2, 3, 4 ]
```

The following example shows how you can use this function with just a starting position, which will only slice from the beginning of the array:

```surql
/**[test]

[[test.results]]
value = "[3, 4, 5]"

*/

RETURN array::slice([ 1, 2, 3, 4, 5 ], 2);

-- [ 3, 4, 5 ]
```

The following example shows how you can use this function with just a negative position, which will only slice from the end of the array:

```surql
/**[test]

[[test.results]]
value = "[4, 5]"

*/

RETURN array::slice([ 1, 2, 3, 4, 5 ], -2);

-- [ 4, 5 ]
```

The following example shows how you can use this function with a negative position, and a length of the slice:

```surql
RETURN array::slice([ 1, 2, 3, 4, 5 ], -3, 2);

[ 3, 4 ]
```

An example of post SurrealDB 3.0 syntax in which the function can also take a range:

```surql
/**[test]

[[test.results]]
value = "['c', 'd']"

*/

['a', 'b', 'c', 'd', 'e'].slice(2..=3);

-- [ 'c', 'd' ]
```

<br />

## `array::sort`

The `array::sort` function sorts the values in an array in ascending or descending order.


```surql title="API DEFINITION"
array::sort(array) -> array
```

The function also accepts a second boolean parameter which determines the sorting direction. The second parameter can be `true` for ascending order, or `false` for descending order.

```surql title="API DEFINITION"
array::sort(array, bool) -> array
```
The function also accepts a second string parameter which determines the sorting direction. The second parameter can be `'asc'` for ascending order, or `'desc'` for descending order.

```surql title="API DEFINITION"
array::sort(array, string) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[NULL, 0, 1, 1, 2, 3, 3, 4, 'something']"

*/

RETURN array::sort([ 1, 2, 1, null, "something", 3, 3, 4, 0 ]);

-- [ null, 0, 1, 1, 2, 3, 3, 4, "something" ]
```

```surql
/**[test]

[[test.results]]
value = "['something', 4, 3, 3, 2, 1, 1, 0, NULL]"

*/

RETURN array::sort([1, 2, 1, null, "something", 3, 3, 4, 0], false);

-- [ "something", 4, 3, 3, 2, 1, 1, 9, null ]
```

```surql
/**[test]

[[test.results]]
value = "[NULL, 0, 1, 1, 2, 3, 3, 4, 'something']"

*/

RETURN array::sort([1, 2, 1, null, "something", 3, 3, 4, 0], "asc");

-- [ null, 0, 1, 1, 2, 3, 3, 4, "something" ]
```

```surql
/**[test]

[[test.results]]
value = "['something', 4, 3, 3, 2, 1, 1, 0, NULL]"

*/

RETURN array::sort([1, 2, 1, null, "something", 3, 3, 4, 0], "desc");

[ "something", 4, 3, 3, 2, 1, 1, 9, null ]
```

## `array::sort_lexical`

The `array::sort_natural_lexical` function sorts the values in an array in ascending or descending order, with alphabetical strings sorted in lexical order instead of unicode list order.

```surql title="API DEFINITION"
array::sort_lexical(array) -> array
```

The function also accepts a second boolean parameter which determines the sorting direction. The second parameter can be `true` for ascending order, or `false` for descending order.

```surql title="API DEFINITION"
array::sort_lexical(array, bool) -> array
```
The function also accepts a second string parameter which determines the sorting direction. The second parameter can be `'asc'` for ascending order, or `'desc'` for descending order.

```surql title="API DEFINITION"
array::sort_lexical(array, string) -> array
```

The following example shows that `array::sort_lexical` will sort strings in lexical (alphabetical) order instead of Unicode list order. As an accented 'Á' is listed later in Unicode than regular ASCII letters, the function `array::sort` will show the name 'Álvares' listed after the word 'senhor', but `array::sort_lexical` will show the name at the front of the array instead.

```surql
/**[test]

[[test.results]]
value = "['Obrigado', 'senhor', 'Álvares']"

[[test.results]]
value = "['Álvares', 'Obrigado', 'senhor']"

*/

['Obrigado', 'senhor', 'Álvares'].sort();
['Obrigado', 'senhor', 'Álvares'].sort_lexical();
```

```surql title="Output"
-------- Query 1 (443.209µs) --------

[ 'Obrigado', 'senhor', 'Álvares' ]

-------- Query 2 (457.542µs) --------

[ 'Álvares', 'Obrigado', 'senhor' ]
```

## `array::sort_natural`

The `array::sort_natural` function sorts the values in an array in ascending or descending order, with numeric strings sorted in numeric order instead of regular string order.

```surql title="API DEFINITION"
array::sort_natural(array) -> array
```

The function also accepts a second boolean parameter which determines the sorting direction. The second parameter can be `true` for ascending order, or `false` for descending order.

```surql title="API DEFINITION"
array::sort_natural(array, bool) -> array
```
The function also accepts a second string parameter which determines the sorting direction. The second parameter can be `'asc'` for ascending order, or `'desc'` for descending order.

```surql title="API DEFINITION"
array::sort_natural(array, string) -> array
```

The following example shows that `array::sort_natural` will sort numeric strings as if they were numbers. The `array::sort` function, on the other hand, treats a string like '3' as greater than '11' due to the first character in '3' being greater than '1'.

Note that strings sorted in numeric order will still appear after actual numbers, as [a string will always be greater than a number](/docs/surrealql/datamodel/values).

```surql
/**[test]

[[test.results]]
value = "[8, 9, 10, '11', '2.2', '3']"

[[test.results]]
value = "[8, 9, 10, '2.2', '3', '11']"

*/

[8, 9, 10, '3', '2.2', '11'].sort();
[8, 9, 10, '3', '2.2', '11'].sort_natural();
```

```surql title="Output"
-------- Query --------

[ 8, 9, 10, '11', '2.2', '3' ]

-------- Query 2 (332.667µs) --------

[ 8, 9, 10, '2.2', '3', '11' ]
```

## `array::sort_natural_lexical`


The `array::sort_natural_lexical` function sorts the values in an array in ascending or descending order, while sorting numeric strings in numeric order and alphabetical strings in lexical order.

```surql title="API DEFINITION"
array::sort_natural_lexical(array) -> array
```

The function also accepts a second boolean parameter which determines the sorting direction. The second parameter can be `true` for ascending order, or `false` for descending order.

```surql title="API DEFINITION"
array::sort_natural_lexical(array, bool) -> array
```
The function also accepts a second string parameter which determines the sorting direction. The second parameter can be `'asc'` for ascending order, or `'desc'` for descending order.

```surql title="API DEFINITION"
array::sort_natural_lexical(array, string) -> array
```

The following example shows that `array::sort_natural_lexical` will sort numeric strings as if they were numbers, and alphabetical strings in lexical order instead of Unicode order. The `array::sort` function, on the other hand, treats a string like '3' as greater than '11' due to the first character in '3' being greater than '1', and sorts the name 'Álvares' after the string 'senhor' because the 'Á' character comes after regular ASCII characters in Unicode.

```surql
/**[test]

[[test.results]]
value = "[8, 9, 10, '11', '2.2', '3', 'Obrigado', 'senhor', 'Álvares']"

[[test.results]]
value = "[8, 9, 10, '2.2', '3', '11', 'Álvares', 'Obrigado', 'senhor']"

*/

['Obrigado', 'senhor', 'Álvares', 8, 9, 10, '3', '2.2', '11'].sort();
['Obrigado', 'senhor', 'Álvares', 8, 9, 10, '3', '2.2', '11'].sort_natural_lexical();
```

```surql title="Output"
-------- Query --------

[ 8, 9, 10, '11', '2.2', '3', 'Obrigado', 'senhor', 'Álvares' ]

-------- Query 2 (332.667µs) --------

[ 8, 9, 10, '2.2', '3', '11', 'Álvares', 'Obrigado', 'senhor' ]
```

## `array::sort::asc`

The `array::sort::asc` function is a shorthand convenience function for the `array::sort` function, to sort values in an array in ascending order.


```surql title="API DEFINITION"
array::sort::asc(array) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[NULL, 0, 1, 1, 2, 3, 3, 4, 'something']"

*/

RETURN array::sort::asc([ 1, 2, 1, null, "something", 3, 3, 4, 0 ]);

-- [ null, 0, 1, 1, 2, 3, 3, 4, "something" ]
```

<br />

## `array::sort::desc`

The `array::sort::desc` function is a shorthand convenience function for the `array::sort` function, to sort values in an array in descending order.


```surql title="API DEFINITION"
array::sort::desc(array) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "['something', 4, 3, 3, 2, 1, 1, 0, NULL]"

*/

RETURN array::sort::desc([ 1, 2, 1, null, "something", 3, 3, 4, 0 ]);

-- [ "something", 4, 3, 3, 2, 1, 1, 9, null ]
```

<br />

## `array::swap`

<Since v="v2.0.0" />

The `array::swap` function swaps two values of an array based on indexes.


```surql title="API DEFINITION"
array::swap(array, from: int, to: int) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "["What's", 'it', 'got', 'in', 'its', 'pocketses?']"

*/

RETURN array::swap(["What's", "its", "got", "in", "it", "pocketses?"], 1, 4);
```

```surql title="Output"
[
	"What's",
	'it',
	'got',
	'in',
	'its',
	'pocketses?'
]
```

The following example shows how you can use this function with a positive index, and a negative index, which will swap the first and last element from the array:

```surql
/**[test]

[[test.results]]
value = "[5, 2, 3, 4, 1]"

*/

RETURN array::swap([ 1, 2, 3, 4, 5 ], 0, -1);

-- [ 5, 2, 3, 4, 1 ]
```

An error will be returned if any of the indexes are invalid that informs of range of possible indexes that can be used.

```surql
/**[test]

[[test.results]]
error = "'Incorrect arguments for function array::swap(). Argument 1 is out of range. Expected a number between -2 and 2'"

*/

RETURN array::swap([0, 1], 100, 1000000);
```

```surql title="Output"
'Incorrect arguments for function array::swap(). Argument 1 is out of range. Expected a number between -2 and 2'
```

<br />

## `array::transpose`

The `array::transpose` function is used to perform 2d array transposition but its behavior in cases of arrays of differing sizes can be best described as taking in multiple arrays and 'layering' them on top of each other.


```surql title="API DEFINITION"
array::transpose(array<array>) -> array<array>
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[[0, 2], [1, 3]]"

*/

RETURN array::transpose([[0, 1], [2, 3]]);

-- [ [0, 2], [1, 3] ]
```

The layering of the above example can be visualized as follows.

```
0 1
2 3
↓ ↓ 
0 1   
2 3
```

Imagining a Rubik's Cube is another easy way to conceptualize this function.

```surql
/**[test]

[[test.results]]
value = "[['🟦', '⬜', '🟧'], ['🟥', '🟦', '🟧'], ['🟩', '🟨', '🟥']]"

*/

RETURN array::transpose([
    ['🟦', '🟥', '🟩'],
    ['⬜', '🟦', '🟨'],
    ['🟧', '🟧', '🟥']
]);
```

The output shows the same blocks, but lined up top to bottom instead of left to right.

```surql
[
	[
		'🟦',
		'⬜',
		'🟧'
	],
	[
		'🟥',
		'🟦',
		'🟧'
	],
	[
		'🟩',
		'🟨',
		'🟥'
	]
]
```

Another example of the function used for the statistics of two people:

```surql
/**[test]

[[test.results]]
value = "[['Name', 'Billy', 'Alice'], ['Age', 25, 30]]"

*/

[["Name", "Age"], ["Billy", 25], ["Alice", 30]].transpose();
```

```surql title="Output"
[
	[
		'Name',
		'Billy',
		'Alice'
	],
	[
		'Age',
		25,
		30
	]
]
```

The logic of this function for arrays of differing length was improved in SurrealDB 2.2, in which `NONE` is now added at points in which no item is found at an index. Take the following movies for example, in which one — Groundhog Day — does not have a bad guy.

```surql
/**[test]

[[test.results]]
value = "[['Movie', 'Avengers: Infinity War', 'Groundhog Day', 'Star Wars'], ['Bad guy', 'Thanos', NONE, 'Palpatine']]"

*/

[
    ['Movie', 'Bad guy'], 
    ['Avengers: Infinity War', 'Thanos'], 
    ['Groundhog Day'],
    ['Star Wars', 'Palpatine']
].transpose();
```

<Tabs>
  <TabItem label="Output since 2.2" default>

```surql
[
	[
		'Movie',
		'Avengers: Infinity War',
		'Groundhog Day',
		'Star Wars'
	],
	[
		'Bad guy',
		'Thanos',
		NONE,
		'Palpatine'
	]
]
```
  </TabItem>

  <TabItem label="Output before 2.2" default>
```surql
[
	[
		'Movie',
		'Avengers: Infinity War',
		'Groundhog Day',
		'Star Wars'
	],
	[
		'Bad guy',
		'Thanos',
		'Palpatine'
	]
]
```
  </TabItem>
</Tabs>

This new behaviour allows transposed arrays to be transposed once more to restore the original output, except with `NONE` added in all the indexes that lack in any array.

```surql
/**[test]

[[test.results]]
value = "[['Movie', 'Bad guy'], ['Avengers: Infinity War', 'Thanos'], ['Groundhog Day', NONE], ['Star Wars', 'Palpatine']]"

*/

[
	[
		'Movie',
		'Bad guy'
	],
	[
		'Avengers: Infinity War',
		'Thanos'
	],
	[
		'Groundhog Day'
	],
	[
		'Star Wars',
		'Palpatine'
	]
].transpose().transpose();
```

```surql title="Output"
[
	[
		'Movie',
		'Bad guy'
	],
	[
		'Avengers: Infinity War',
		'Thanos'
	],
	[
		'Groundhog Day',
		NONE
	],
	[
		'Star Wars',
		'Palpatine'
	]
]
```

## `array::union`

The `array::union` function combines two arrays together, removing duplicate values, and returning a single array.


```surql title="API DEFINITION"
array::union(array, array) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 2, 6, 3, 4, 5]"

*/

RETURN array::union([1, 2, 1, 6], [1, 3, 4, 5, 6]);

-- [ 1, 2, 6, 3, 4, 5 ]
```

<br /><br />

## `array::windows`

<Since v="v2.0.0" />

```surql title="API DEFINITION"
array::windows(array, size: int) -> array
```

The `array::windows` function returns a number of arrays of length `size` created by moving one index at a time down the original array. The arrays returned are guaranteed to be of length `size`. As a result, the function will return an empty array if the length of the original array is not large enough to create a single output array.

The following examples show this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = ""[[1, 2], [2, 3], [3, 4]]

[[test.results]]
value = "[]"

*/

LET $array = [1, 2, 3, 4];
RETURN array::windows($array, 2);
RETURN array::windows($array, 5);
```

```surql title="Response"
[ [1, 2], [2, 3], [3, 4] ];
[];
```

An example of the same function used in a `RELATE` statement:

```surql
/**[test]

[[test.results]]
value = "[{ id: person:grandfather }, { id: person:father }, { id: person:son }]"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ grandsons: [], id: person:father, sons: [person:son] }, { grandsons: [person:son], id: person:grandfather, sons: [person:father] }, { grandsons: [], id: person:son, sons: [] }]"

*/

CREATE person:grandfather, person:father, person:son;

FOR $pair IN array::windows(["grandfather", "father", "son"], 2) {
    LET $first = type::record("person", $pair[0]);
    LET $second = type::record("person", $pair[1]);
    RELATE $first->father_of->$second;
};

SELECT 
  id, 
  ->father_of->person AS sons,
  ->father_of->person->father_of->person AS grandsons
FROM person;
```

## Method chaining

<Since v="v2.0.0" />

Method chaining allows functions to be called using the `.` dot operator on a value of a certain type instead of the full path of the function followed by the value.

```surql
/**[test]

[[test.results]]
value = "['Again', 'again', 'again']"

[[test.results]]
value = "['Again', 'again', 'again']"

*/

-- Traditional syntax
array::push(["Again", "again"], "again");

-- Method chaining syntax
["Again", "again"].push("again");
```

```surql title="Response"
["Again", "again", "again"]
```

This is particularly useful for readability when a function is called multiple times.

```surql
/**[test]

[[test.results]]
value = "'Again and again and again'"

[[test.results]]
value = "'Again and again and again'"

*/

-- Traditional syntax
array::join(array::push(["Again", "again"], "again"), " and ");

-- Method chaining syntax
["Again", "again"].push("again").join(" and ");
```

```surql title="Response"
"Again and again and again"
```



================================================
FILE: src/content/doc-surrealql/functions/database/bytes.mdx
================================================
---
sidebar_position: 4
sidebar_label: Bytes functions
title: Bytes functions | SurrealQL
description: These functions can be used when working with bytes.
---

# Bytes functions

These functions can be used when working with bytes in SurrealQL.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#byteslen"><code>bytes::len()</code></a></td>
      <td scope="row" data-label="Description">Gives the length in bytes</td>
    </tr>
  </tbody>
</table>

## `bytes::len`

The `bytes::len` function returns the length in bytes of a `bytes` value.


```surql title="API DEFINITION"
bytes::len(bytes) -> int
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[19, 67, 25]"

*/

RETURN [
    bytes::len(<bytes>"Simple ASCII string"),
    bytes::len(<bytes>"οὐ γὰρ δυνατόν ἐστιν ἔτι καθεύδειν"),
    bytes::len(<bytes>"청춘예찬 靑春禮讚")
];
```

```surql title="Output"
[ 19, 67, 25 ]
```


================================================
FILE: src/content/doc-surrealql/functions/database/count.mdx
================================================
---
sidebar_position: 5
sidebar_label: Count function
title: Count function | SurrealQL
description: This function can be used when counting field values and expressions.
---

import Since from '@components/shared/Since.astro'

# Count function

This function can be used when counting field values and expressions.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#count"><code>count()</code></a></td>
      <td scope="row" data-label="Description">Counts a row, or whether a given value is truthy</td>
    </tr>
  </tbody>
</table>

## `count`

The count function counts the number of times that the function is called. This is useful for returning the total number of rows in a SELECT statement with a `GROUP BY` clause.

```surql title="API DEFINITION"
count() -> 1
```
If a value is given as the first argument, then this function checks whether a given value is [truthy](/docs/surrealql/datamodel/values#values-and-truthiness). This is useful for returning the total number of rows, which match a certain condition, in a [`SELECT`](/docs/surrealql/statements/select) statement, with a GROUP BY clause.

```surql title="API DEFINITION"
count(any) -> number
```

If an array is given, this function counts the number of items in the array which are [truthy](/docs/surrealql/datamodel/values#values-and-truthiness). If, instead, you want to count the total number of items in the given array, then use the [`array::len()`](/docs/surrealql/functions/database/array#arraylen) function.

```surql title="API DEFINITION"
count(array) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql 
/**[test]

[[test.results]]
value = "1"

*/

RETURN count();

-- 1
```

```surql
/**[test]

[[test.results]]
value = "1"

*/

RETURN count(true);

-- 1
```

```surql
/**[test]

[[test.results]]
value = "false"

*/

RETURN count(10 > 15);

-- 0
```

```surql
/**[test]

[[test.results]]
value = "5"

*/

RETURN count([ 1, 2, 3, null, 0, false, (15 > 10), rand::uuid() ]);

5
```

The following examples show this function being used in a [`SELECT`](/docs/surrealql/statements/select) statement with a GROUP clause: 

```surql
/**[test]

[[test.results]]
value = "[{ count: 3 }]"

*/

SELECT 
	count() 
FROM [
	{ age: 33 }, 
	{ age: 45 }, 
	{ age: 39 }
] 
GROUP ALL;
```

```surql title="Response"
[
	{ count: 3 }
]
```

```surql
/**[test]

[[test.results]]
value = "[{ count: 2 }]"

*/

SELECT 
	count(age > 35) 
FROM [
	{ age: 33 }, 
	{ age: 45 }, 
	{ age: 39 }
] 
GROUP ALL;
```

```surql title="Response"
[
	{ count: 2 }
]
```

An advanced example of the count function can be seen below:

```surql
/**[test]

[[test.results]]
value = "[{ country: GBR, total: 2 }, { country: USA, total: 2 }]"

*/

SELECT
	country,
	count(age > 30) AS total
FROM [
	{ age: 33, country: 'GBR' },
	{ age: 45, country: 'GBR' },
	{ age: 39, country: 'USA' },
	{ age: 29, country: 'GBR' },
	{ age: 43, country: 'USA' }
]
GROUP BY country;
```

```surql title="Response"
[
	{
		country: 'GBR',
		total: 2
	},
	{
		country: 'USA',
		total: 2
	}
]
```

<br /><br />

## Using a `COUNT` index with `count()`

<Since v="v3.0.0-alpha.10" />

A `COUNT` index can be defined to speed up `count()` when used with a `GROUP ALL` clause. This allows `count()` to access a single stored value when it is called instead of iterating over the entire table.

```surql
/**[test]

[[test.results]]
value = "[{ id: user:dbb4iogxntigq3m11rdp }]"

[[test.results]]
value = "[{ count: 1 }]"

[[test.results]]
value = "[]"

[[test.results]]
value = "[{ count: 100001 }"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ count: 100001 }]"

*/

CREATE user;
-- One record in table, very fast
SELECT count() FROM user GROUP ALL;

-- 10,000 new records,
-- count() takes a bit longer than before
CREATE |user:10000| RETURN NONE;
SELECT count() FROM user GROUP ALL;

-- Add index, wait a moment for it to build
DEFINE INDEX user_count ON user COUNT;
-- count() very performant again
SELECT count() FROM user GROUP ALL;
```



================================================
FILE: src/content/doc-surrealql/functions/database/crypto.mdx
================================================
---
sidebar_position: 6
sidebar_label: Crypto functions
title: Crypto functions | SurrealQL
description: These functions can be used when hashing data, encrypting data, and for securely authenticating users into the database.
---

import Since from '@components/shared/Since.astro'

# Crypto functions

These functions can be used when hashing data, encrypting data, and for securely authenticating users into the database.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#cryptoblake3"><code>crypto::blake3()</code></a></td>
      <td scope="row" data-label="Description">Returns the blake3 hash of a value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#cryptojoaat"><code>crypto::joaat()</code></a></td>
      <td scope="row" data-label="Description">Returns the joaat hash of a value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#cryptomd5"><code>crypto::md5()</code></a></td>
      <td scope="row" data-label="Description">Returns the md5 hash of a value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#cryptosha1"><code>crypto::sha1()</code></a></td>
      <td scope="row" data-label="Description">Returns the sha1 hash of a value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#cryptosha256"><code>crypto::sha256()</code></a></td>
      <td scope="row" data-label="Description">Returns the sha256 hash of a value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#cryptosha512"><code>crypto::sha512()</code></a></td>
      <td scope="row" data-label="Description">Returns the sha512 hash of a value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#cryptoargon2compare"><code>crypto::argon2::compare()</code></a></td>
      <td scope="row" data-label="Description">Compares an argon2 hash to a password</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#cryptoargon2generate"><code>crypto::argon2::generate()</code></a></td>
      <td scope="row" data-label="Description">Generates a new argon2 hashed password</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#cryptobcryptcompare"><code>crypto::bcrypt::compare()</code></a></td>
      <td scope="row" data-label="Description">Compares an bcrypt hash to a password</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#cryptobcryptgenerate"><code>crypto::bcrypt::generate()</code></a></td>
      <td scope="row" data-label="Description">Generates a new bcrypt hashed password</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#cryptopbkdf2compare"><code>crypto::pbkdf2::compare()</code></a></td>
      <td scope="row" data-label="Description">Compares an pbkdf2 hash to a password</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#cryptopbkdf2generate"><code>crypto::pbkdf2::generate()</code></a></td>
      <td scope="row" data-label="Description">Generates a new pbkdf2 hashed password</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#cryptoscryptcompare"><code>crypto::scrypt::compare()</code></a></td>
      <td scope="row" data-label="Description">Compares an scrypt hash to a password</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#cryptoscryptgenerate"><code>crypto::scrypt::generate()</code></a></td>
      <td scope="row" data-label="Description">Generates a new scrypt hashed password</td>
    </tr>
  </tbody>
</table>

## `crypto::blake3`

<Since v="v2.0.0" />

The `crypto::blake3` function returns the blake3 hash of the input value.

```surql title="API DEFINITION"
crypto::blake3(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'f75ef30a80a78016f4a4da40ac56c858c0001b3a320118adc3785972901ddce6'"

*/

RETURN crypto::blake3("tobie");

-- '85052e9aab1b67b6622d94a08441b09fd5b7aca61ee360416d70de5da67d86ca'
```

<br />

## `crypto::joaat`

<Since v="v3.0.0-alpha.7" />

The `crypto::joaat` function returns the joaat hash of the input value.

```surql title="API DEFINITION"
crypto::joaat(string) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "2129482046"

*/

RETURN crypto::joaat("tobie");

-- 2129482046
```

<br />

## `crypto::md5`

The `crypto::md5` function returns the md5 hash of the input value.

```surql title="API DEFINITION"
crypto::md5(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'4768b3fc7ac751e03a614e2349abf3bf'"

*/

RETURN crypto::md5("tobie");

-- "4768b3fc7ac751e03a614e2349abf3bf"
```

<br />

## `crypto::sha1`

The `crypto::sha1` function returns the sha1 hash of the input value.

```surql title="API DEFINITION"
crypto::sha1(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'c6be709a1b6429472e0c5745b411f1693c4717be'"

*/

RETURN crypto::sha1("tobie");

-- "c6be709a1b6429472e0c5745b411f1693c4717be"
```

<br />

## `crypto::sha256`

The `crypto::sha256` function returns the sha256 hash of the input value.

```surql title="API DEFINITION"
crypto::sha256(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'33fe1859daba927ea5674813adc1cf34b9e2795f2b7e91602fae19c0d0c493af'"

*/

RETURN crypto::sha256("tobie");

-- "33fe1859daba927ea5674813adc1cf34b9e2795f2b7e91602fae19c0d0c493af"
```

<br />

## `crypto::sha512`

The `crypto::sha512` function returns the sha512 hash of the input value.

```surql title="API DEFINITION"
crypto::sha512(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'39f0160c946c4c53702112d6ef3eea7957ea8e1c78787a482a89f8b0a8860a20ecd543432e4a187d9fdcd1c415cf61008e51a7e8bf2f22ac77e458789c9cdccc'"

*/

RETURN crypto::sha512("tobie");

"39f0160c946c4c53702112d6ef3eea7957ea8e1c78787a482a89f8b0a8860a20ecd543432e4a187d9fdcd1c415cf61008e51a7e8bf2f22ac77e458789c9cdccc"
```

<br />

## `crypto::argon2::compare`

The `crypto::argon2::compare` function compares a hashed-and-salted argon2 password value with an unhashed password value.

```surql title="API DEFINITION"
crypto::argon2::compare(string, string) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
LET $hash = "$argon2id$v=19$m=4096,t=3,p=1$pbZ6yJ2rPJKk4pyEMVwslQ$jHzpsiB+3S/H+kwFXEcr10vmOiDkBkydVCSMfRxV7CA";
LET $pass = "this is a strong password";
RETURN crypto::argon2::compare($hash, $pass);

-- true
```

<br />

## `crypto::argon2::generate`

The `crypto::argon2::generate` function hashes and salts a password using the argon2 hashing algorithm.

> [!IMPORTANT]
> At this time, there is no way to customize the parameters for this function. This applies to: memory, iterations and parallelism.

```surql title="API DEFINITION"
crypto::argon2::generate(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN crypto::argon2::generate("this is a strong password");

"$argon2id$v=19$m=4096,t=3,p=1$pbZ6yJ2rPJKk4pyEMVwslQ$jHzpsiB+3S/H+kwFXEcr10vmOiDkBkydVCSMfRxV7CA"
```

<br />

## `crypto::bcrypt::compare`

The `crypto::bcrypt::compare` function compares a hashed-and-salted bcrypt password value with an unhashed password value.

```surql title="API DEFINITION"
crypto::bcrypt::compare(string, any) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
LET $hash = "$2b$12$OD7hrr1Hycyk8NUwOekYY.cogCICpUnwNvDZ9NiC1qCPHzpVAQ9BO";
LET $pass = "this is a strong password";
RETURN crypto::bcrypt::compare($hash, $pass);

true
```

<br />

## `crypto::bcrypt::generate`

The `crypto::bcrypt::generate` function hashes and salts a password using the bcrypt hashing algorithm.

> [!IMPORTANT]
> At this time, there is no way to customize the work factor for bcrypt.

```surql title="API DEFINITION"
crypto::bcrypt::generate(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN crypto::bcrypt::generate("this is a strong password");

"$2b$12$OD7hrr1Hycyk8NUwOekYY.cogCICpUnwNvDZ9NiC1qCPHzpVAQ9BO"
```

<br />

## `crypto::pbkdf2::compare`

The `crypto::pbkdf2::compare` function compares a hashed-and-salted pbkdf2 password value with an unhashed password value.

```surql title="API DEFINITION"
crypto::pbkdf2::compare(string, string) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
LET $hash = "$pbkdf2-sha256$i=10000,l=32$DBURRPJODKEt0IId1Lqe+w$Ve8Z00mibHDSKLbyKTceEBBcDpGoK0AEUl7QzDTIec4";
LET $pass = "this is a strong password";
RETURN crypto::pbkdf2::compare($hash, $pass);


true
```

<br />

## `crypto::pbkdf2::generate`

The `crypto::pbkdf2::generate` function hashes and salts a password using the pbkdf2 hashing algorithm.

> [!IMPORTANT]
> At this time, there is no way to customize the number of iterations for pbkdf2.

```surql title="API DEFINITION"
crypto::pbkdf2::generate(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN crypto::pbkdf2::generate("this is a strong password");

"$pbkdf2-sha256$i=10000,l=32$DBURRPJODKEt0IId1Lqe+w$Ve8Z00mibHDSKLbyKTceEB"
```

<br />

## `crypto::scrypt::compare`

The `crypto::scrypt::compare` function compares a hashed-and-salted scrypt password value with an unhashed password value.

```surql title="API DEFINITION"
crypto::scrypt::compare(string, string) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
LET $hash = "$scrypt$ln=15,r=8,p=1$8gl7bipl0FELTy46YJOBrw$eRcS1qR22GI8VHo58WOXn9JyfDivGo5yTJFvpDyivuw";
LET $pass = "this is a strong password";
RETURN crypto::scrypt::compare($hash, $pass);


true
```

<br />

## `crypto::scrypt::generate`

The `crypto::scrypt::generate` function hashes and salts a password using the scrypt hashing algorithm.

> [!IMPORTANT]
> At this time, there is no way to customize the parameters for this function. This applies to: cost parameter, block size and parallelism.

```surql title="API DEFINITION"
crypto::scrypt::generate(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN crypto::scrypt::generate("this is a strong password");

"$scrypt$ln=15,r=8,p=1$8gl7bipl0FELTy46YJOBrw$eRcS1qR22GI8VHo58WOXn9JyfDivGo5yTJFvpDyivuw"
```

<br /><br />



================================================
FILE: src/content/doc-surrealql/functions/database/duration.mdx
================================================
---
sidebar_position: 7
sidebar_label: Duration functions
title: Duration functions | SurrealQL
description: These functions can be used when converting between numeric and duration data.
---

import Since from '@components/shared/Since.astro'

# Duration functions

These functions can be used when converting between numeric and duration data.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationdays"><code>duration::days()</code></a></td>
      <td scope="row" data-label="Description">Counts how many days fit in a duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationhours"><code>duration::hours()</code></a></td>
      <td scope="row" data-label="Description">Counts how many hours fit in a duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationmax"><code>duration::max</code></a></td>
      <td scope="row" data-label="Description">Constant representing the greatest possible duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationmicros"><code>duration::micros()</code></a></td>
      <td scope="row" data-label="Description">Counts how many microseconds fit in a duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationmillis"><code>duration::millis()</code></a></td>
      <td scope="row" data-label="Description">Counts how many milliseconds fit in a duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationmins"><code>duration::mins()</code></a></td>
      <td scope="row" data-label="Description">Counts how many minutes fit in a duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationnanos"><code>duration::nanos()</code></a></td>
      <td scope="row" data-label="Description">Counts how many nanoseconds fit in a duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationsecs"><code>duration::secs()</code></a></td>
      <td scope="row" data-label="Description">Counts how many seconds fit in a duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationweeks"><code>duration::weeks()</code></a></td>
      <td scope="row" data-label="Description">Counts how many weeks fit in a duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationyears"><code>duration::years()</code></a></td>
      <td scope="row" data-label="Description">Counts how many years fit in a duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationfrom_days"><code>duration::from_days()</code></a></td>
      <td scope="row" data-label="Description">Converts a numeric amount of days into a duration that represents days</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationfrom_hours"><code>duration::from_hours()</code></a></td>
      <td scope="row" data-label="Description">Converts a numeric amount of hours into a duration that represents hours</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationfrom_micros"><code>duration::from_micros()</code></a></td>
      <td scope="row" data-label="Description">Converts a numeric amount of microseconds into a duration that represents microseconds</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationfrom_millis"><code>duration::from_millis()</code></a></td>
      <td scope="row" data-label="Description">Converts a numeric amount of milliseconds into a duration that represents milliseconds</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationfrom_mins"><code>duration::from_mins()</code></a></td>
      <td scope="row" data-label="Description">Converts a numeric amount of minutes into a duration that represents minutes</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationfrom_nanos"><code>duration::from_nanos()</code></a></td>
      <td scope="row" data-label="Description">Converts a numeric amount of nanoseconds into a duration that represents nanoseconds</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationfrom_secs"><code>duration::from_secs()</code></a></td>
      <td scope="row" data-label="Description">Converts a numeric amount of seconds into a duration that represents seconds</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#durationfrom_weeks"><code>duration::from_weeks()</code></a></td>
      <td scope="row" data-label="Description">Converts a numeric amount of weeks into a duration that represents weeks</td>
    </tr>
  </tbody>
</table>

## `duration::days`

The `duration::days` function counts how many days fit into a duration.

```surql title="API DEFINITION"
duration::days(duration) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "21"

*/

RETURN duration::days(3w);

-- 21
```

<br />

## `duration::hours`

The `duration::hours` function counts how many hours fit into a duration.


```surql title="API DEFINITION"
duration::hours(duration) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql

/**[test]

[[test.results]]
value = "504"

*/
RETURN duration::hours(3w);

-- 504
```

<br />

## `duration::max`

<Since v="v2.3.0" />

The `duration::max` constant represents the greatest possible duration that can be used.


```surql title="API DEFINITION"
duration::max -> duration
```

Some examples of the constant in use:

```surql
/**[test]

[[test.results]]
value = "584942417355y3w5d7h15s999ms999µs999ns"

[[test.results]]
error = "'Failed to compute: "584942417355y3w5d7h15s999ms999µs999ns + 1ns", as the operation results in an arithmetic overflow.'"

[[test.results]]
value = "true"

*/

duration::max;

duration::max + 1ns;

100y IN 0ns..duration::max
```

```surql title="Output"
-------- Query 1 --------

584942417355y3w5d7h15s999ms999µs999ns

-------- Query 2 --------
'Failed to compute: "584942417355y3w5d7h15s999ms999µs999ns + 1ns", as the operation results in an arithmetic overflow.'

-------- Query 3 --------
true
```

<br />

## `duration::micros`

The `duration::micros` function counts how many microseconds fit into a duration.


```surql title="API DEFINITION"
duration::micros(duration) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1814400000000"

*/
RETURN duration::micros(3w);

-- 1814400000000
```

<br />

## `duration::millis`

The `duration::millis` function counts how many milliseconds fit into a duration.

```surql title="API DEFINITION"
duration::millis(duration) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1814400000"

*/
RETURN duration::millis(3w);

-- 1814400000
```

<br />

## `duration::mins`

The `duration::mins` function counts how many minutes fit into a duration.


```surql title="API DEFINITION"
duration::mins(duration) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "30240"

*/
RETURN duration::mins(3w);

-- 30240
```

<br />

## `duration::nanos`

The `duration::nanos` function counts how many nanoseconds fit into a duration.


```surql title="API DEFINITION"
duration::nanos(duration) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1814400000000000"

*/
RETURN duration::nanos(3w);

-- 1814400000000000
```

<br />

## `duration::secs`

The `duration::secs` function counts how many seconds fit into a duration.

```surql title="API DEFINITION"
duration::secs(duration) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1814400"

*/
RETURN duration::secs(3w);

-- 1814400
```

<br />

## `duration::weeks`

The `duration::weeks` function counts how many weeks fit into a duration.

```surql title="API DEFINITION"
duration::weeks(duration) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql

/**[test]

[[test.results]]
value = "3"

*/
RETURN duration::weeks(3w);

-- 3
```

<br />

## `duration::years`

The `duration::years` function counts how many years fit into a duration.

```surql title="API DEFINITION"
duration::years(duration) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql

/**[test]

[[test.results]]
value = "5"

*/
RETURN duration::years(300w);

-- 5
```

<br />

## `duration::from_days`

The `duration::from_days` function counts how many years fit into a duration.

```surql title="API DEFINITION"
duration::from_days(number) -> duration
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql

/**[test]

[[test.results]]
value = "3d"

*/
RETURN duration::from_days(3);

-- 3d
```

<br />

## `duration::from_hours`

The `duration::from_hours` function converts a numeric amount of hours into a duration that represents hours.

```surql title="API DEFINITION"
duration::from_hours(number) -> duration
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "3h"

*/

RETURN duration::from_hours(3);

-- 3h
```

<br />

## `duration::from_micros`

The `duration::from_micros` function converts a numeric amount of microseconds into a duration that represents microseconds.

```surql title="API DEFINITION"
duration::from_micros(number) -> duration
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "3µs"

*/
RETURN duration::from_micros(3);

-- 3μs
```

<br />

## `duration::from_millis`

The `duration::from_millis` function converts a numeric amount of milliseconds into a duration that represents milliseconds.

```surql title="API DEFINITION"
duration::from_millis(number) -> duration
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "3ms"

*/

RETURN duration::from_millis(3);

-- 3ms
```

<br />

## `duration::from_mins`

The `duration::from_mins` function converts a numeric amount of minutes into a duration that represents minutes.

```surql title="API DEFINITION"
duration::from_mins(number) -> duration
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "3m"

*/

RETURN duration::from_mins(3);

-- 3m
```

<br />

## `duration::from_nanos`

The `duration::from_nanos` function converts a numeric amount of nanoseconds into a duration that represents nanoseconds.

```surql title="API DEFINITION"
duration::from_nanos(number) -> duration
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "3ns"

*/
RETURN duration::from_nanos(3);

-- 3ns
```

<br />

## `duration::from_secs`

The `duration::from_secs` function converts a numeric amount of seconds into a duration that represents seconds.

```surql title="API DEFINITION"
duration::from_secs(number) -> duration
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "3s"

*/
RETURN duration::from_secs(3);

-- 3s
```

<br />

## `duration::from_weeks`

The `duration::from_weeks` function converts a numeric amount of weeks into a duration that represents weeks.

```surql title="API DEFINITION"
duration::from_weeks(number) -> duration
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "3w"

*/
RETURN duration::from_weeks(3);

-- 3w
```

<br /><br />


## Method chaining

<Since v="v2.0.0" />

Method chaining allows functions to be called using the `.` dot operator on a value of a certain type instead of the full path of the function followed by the value.

```surql

/**[test]

[[test.results]]
value = "3240"

[[test.results]]
value = "3240"

*/

-- Traditional syntax
duration::mins(2d6h);

-- Method chaining syntax
2d6h.mins();
```

```surql title="Response"
3240
```

This is particularly useful for readability when a function is called multiple times.

```surql
/**[test]

[[test.results]]
value = "1645"

[[test.results]]
value = "1645"

*/

-- Traditional syntax
duration::mins(duration::from_millis(98734234));

-- Method chaining syntax
duration::from_millis(98734234).mins();
```

```surql title="Response"
1645
```



================================================
FILE: src/content/doc-surrealql/functions/database/encoding.mdx
================================================
---
sidebar_position: 8
sidebar_label: Encoding functions
title: Encoding functions | SurrealQL
description: These functions can be used to encode and decode data in base64. It is particularly used when that data needs to be stored and transferred over media that are designed to deal with text. This encoding and decoding helps to ensure that the data remains intact without modification during transport.
---
import Since from '@components/shared/Since.astro'

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Encoding functions

These functions can be used to encode and decode data into other formats, such as `base64` and [`CBOR`](/docs/surrealdb/integration/cbor) (Concise Binary Object Representation). It is particularly used when that data needs to be stored and transferred over media that are designed to deal with text. This encoding and decoding helps to ensure that the data remains intact without modification during transport.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#encodingbase64decode"><code>encoding::base64::decode()</code></a></td>
      <td scope="row" data-label="Description">This function is used to decode data.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#encodingbase64encode"><code>encoding::base64::encode()</code></a></td>
      <td scope="row" data-label="Description"> This function is used to encode data with optionally padded output.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#encodingcbordecode"><code>encoding::cbor::decode()</code></a></td>
      <td scope="row" data-label="Description">This function is used to decode data.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#encodingcborencode"><code>encoding::cbor::encode()</code></a></td>
      <td scope="row" data-label="Description">This function is used to encode data.</td>
    </tr>
  </tbody>
</table>

<br></br>

## `encoding::base64::encode()`

The `encoding::base64::encode()` function encodes a bytes to base64 with optionally padded output.

<Tabs>

<TabItem label="API DEFINITION (before 2.3.0)">
```surql
encoding::base64::encode(bytes) -> string
```

</TabItem>

<TabItem label="API DEFINITION (after 2.3.0)">
```surql
encoding::base64::encode(bytes, option<bool>) -> string
```

</TabItem>

</Tabs>

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "''"

*/
RETURN encoding::base64::encode(<bytes>"");

-- ''
```

```surql
/**[test]

[[test.results]]
value = "'MjMyMw'"

*/
RETURN encoding::base64::encode(<bytes>"2323");

-- 'MjMyMw'
```

```surql
/**[test]

[[test.results]]
value = "'aGVsbG8'"

*/
RETURN encoding::base64::encode(<bytes>"hello");

-- 'aGVsbG8'
```

As of version 2.3.0, you can pass `true` as the second argument to enable padded base64 outputs:

```surql
/**[test]

[[test.results]]
value = "''"

*/
RETURN encoding::base64::encode(<bytes>"", true);

-- ""
```

```surql
/**[test]

[[test.results]]
value = "'MjMyMw=='"

*/
RETURN encoding::base64::encode(<bytes>"2323", true);

"MjMyMw=="
```

```surql
/**[test]

[[test.results]]
value = "'aGVsbG8='"

*/
RETURN encoding::base64::encode(<bytes>"hello", true);

"aGVsbG8="
```

<br />

## `encoding::base64::decode()`

The `encoding::base64::decode()` function decodes a string into bytes.

```surql title="API DEFINITION"
encoding::base64::decode(string) -> bytes
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "b"32333233""

*/
RETURN encoding::base64::decode("MjMyMw");

-- b"32333233"
```

You can also verify that the output of the encoded value matches the original value. 

```surql
/**[test]

[[test.results]]
value = "true"

*/
RETURN encoding::base64::decode("aGVsbG8") = <bytes>"hello";

-- true
```

<br /><br />

## `encoding::cbor::decode()`

<Since v="v3.0.0-alpha.1" />

The `encoding::cbor::decode()` function decodes bytes in valid CBOR format into a SurrealQL value.

```surql title="API DEFINITION"
encoding::cbor::decode(string) -> any
```

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ cbor: 'encoding', is: 'pretty neat' }"

*/
LET $some_bytes = encoding::base64::decode("omRjYm9yaGVuY29kaW5nYmlza3ByZXR0eSBuZWF0");
encoding::cbor::decode($some_bytes);
```

```surql title="Output"
{
	cbor: 'encoding',
	is: 'pretty neat'
}
```

<br /><br />

## `encoding::cbor::encode()`

<Since v="v3.0.0-alpha.1" />

The `encoding::cbor::encode()` function encodes any SurrealQL value into bytes in CBOR format.

```surql title="API DEFINITION"
encoding::cbor::encode(any) -> bytes
```

```surql
/**[test]

[[test.results]]
value = "b"A26463626F7268656E636F64696E676269736B707265747479206E656174""

*/
encoding::cbor::encode({
    cbor: "encoding",
    is: "pretty neat"
});
```

```surql title="Output"
b"A26463626F7268656E636F64696E676269736B707265747479206E656174"
```



================================================
FILE: src/content/doc-surrealql/functions/database/file.mdx
================================================
---
sidebar_position: 9
sidebar_label: File functions
title: File functions | SurrealQL
description: These functions can be used to work with files.
---

import Since from '@components/shared/Since.astro';

# File functions

These functions can be used to work with files.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#filebucket"><code>file::bucket()</code></a></td>
      <td scope="row" data-label="Description">Returns the bucket path from a file pointer</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#filecopy"><code>file::copy()</code></a></td>
      <td scope="row" data-label="Description">Copies the contents of a file</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#filecopy_if_not_exists"><code>file::copy_if_not_exists()</code></a></td>
      <td scope="row" data-label="Description">Copies the contents of a file to a new file if the name is available</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#filedelete"><code>file::delete()</code></a></td>
      <td scope="row" data-label="Description">Deletes a file</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#fileexists"><code>file::exists()</code></a></td>
      <td scope="row" data-label="Description">Checks if a file already exists</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#fileget"><code>file::get()</code></a></td>
      <td scope="row" data-label="Description">Loads a file</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#filehead"><code>file::head()</code></a></td>
      <td scope="row" data-label="Description">Returns the metadata of a file</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#filekey"><code>file::key()</code></a></td>
      <td scope="row" data-label="Description">Returns the key (the portion following the bucket) from a file pointer</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#filelist"><code>file::list()</code></a></td>
      <td scope="row" data-label="Description">Returns a list of files inside a bucket</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#fileput"><code>file::put()</code></a></td>
      <td scope="row" data-label="Description">Writes bytes to a file</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#fileput_if_not_exists"><code>file::put_if_not_exists()</code></a></td>
      <td scope="row" data-label="Description">Attempts to write bytes to a file</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#filerename"><code>file::rename()</code></a></td>
      <td scope="row" data-label="Description">Renames a file</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#filerename_if_available"><code>file::rename_if_not_exists()</code></a></td>
      <td scope="row" data-label="Description">Renames a file if the new name is not already in use</td>
    </tr>
  </tbody>
</table>

<Since v="v3.0.0-alpha.1" />

## `file::bucket`

```surql title="API DEFINITION"
file::bucket(file) -> string
```

The `file::bucket` function returns the name of the bucket in which a file is located.

```surql
/**[test]

[[test.results]]
value = "'my_bucket'"

[[test.results]]
value = "NONE"

[[test.results]]
value = "'my_bucket'"

*/
file::bucket(f"my_bucket:/file_name");

DEFINE PARAM $SOME_DATABASE_FILE VALUE f"my_bucket:/file_name";
file::bucket($SOME_DATABASE_FILE);
```

```surql title="Output"
'my_bucket'
```

The counterpart to this function is `file::key`, which returns the latter part of a file pointer.

## `file::copy`

The `file::copy` function copies the contents of a file to a new file, overwriting any existing file that has the same name as the new file.

```surql title="API DEFINITION"
file::copy(string)
```

Example of a file `my_book.txt` being copied to a new location `lion_witch_wardrobe.txt`:

```surql
/**[test]

[[test.results]]
error = ""The bucket 'my_bucket' does not exist""

*/

f"my_bucket:/my_book.txt".copy("lion_witch_wardrobe.txt");
```

<br></br>

## `file::copy_if_not_exists`

The `file::copy_if_not_exists` function copies the contents of a file to a new file, returning an error if a file already exists that has the same name as that of the intended copy.

```surql title="API DEFINITION"
file::copy_if_not_exists(string)
```

Example of a file `my_book.txt` attempting to copy to a new location `lion_witch_wardrobe.txt`:

```surql
DEFINE BUCKET my_bucket BACKEND "memory";

f"my_bucket:/lion_witch_wardrobe.txt".put("Once there were four children whose names were Peter, Susan...");
f"my_bucket:/other_book.txt".put("Um meine Geschichte zu erzählen, muß ich weit vorn anfangen.");
f"my_bucket:/other_book.txt".copy_if_not_exists("lion_witch_wardrobe.txt");
```

```surql title="Output"
'Operation for bucket `my_bucket` failed: Object at location lion_witch_wardrobe.txt already exists:
Object already exists at that location: lion_witch_wardrobe.txt'
```

<br></br>

## `file::delete`

The `file::delete` function deletes a file.

```surql title="API DEFINITION"
file::delete(string)
```

Example of a file `my_book.txt` being deleted:

```surql
f"my_bucket:/my_book.txt".delete();
```

<br></br>

## `file::exists`

The `file::exists` function checks to see if a file exists at the path and file name indicated.

```surql title="API DEFINITION"
file::exists(string) -> bool
```

Example of an `IF` else `STATEMENT` used to check if a file exists before writing content to the location:

```surql
IF f"my_bucket:/my_book.txt".exists() {
    THROW "Whoops, already there!"
} ELSE {
    f"my_bucket:/my_book.txt".put("Some content")
};
```

<br></br>

## `file::get`

The `file::get` function retrieves a file for use.

```surql title="API DEFINITION"
file::get(string) -> bytes
```

A retrieved file will display as bytes. If valid text, these can be cast into a `string`.

```surql
f"my_bucket:/my_book.txt".get();
<string>f"my_bucket:/my_book.txt".get();
```

```surql title="Output"
-------- Query --------

b"536F6D6520636F6E74656E74"

-------- Query --------

'Once there were four children whose names were Peter, Susan...'
```

<br></br>

## `file::head`

The `file::head` function returns the metadata for a file.

```surql title="API DEFINITION"
file::head() -> object
```

If a file is found, the metadata will be returned as an object with the following fields:

* `e_data` (`option<string>`): the unique identifier for the file.
* `last_modified` (`datetime`)
* `location` (`string`)
* `size` (`int`)
* `version` (`option<string>`)

An example of this function and its output:

```surql
f"my_bucket:/my_book.txt".head();
```

```surql title="Output"
{
	e_tag: '1',
	key: 'my_book.txt',
	last_modified: d'2025-03-26T06:29:18.988Z',
	size: 78,
	version: NONE
}
```

<br></br>

## `file::key`

```surql title="API DEFINITION"
file::key(file) -> string
```

The `file::key` function returns the key of a file: the part of a file pointer following the bucket name.

```surql
/**[test]

[[test.results]]
value = "'/file_name'"

[[test.results]]
value = "NONE"

[[test.results]]
value = "'/file_name'"

*/
file::key(f"my_bucket:/file_name");

DEFINE PARAM $SOME_DATABASE_FILE VALUE f"my_bucket:/file_name";
file::key($SOME_DATABASE_FILE);
```

```surql title="Output"
'/file_name'
```

The counterpart to this function is `file::bucket`, which returns the bucket name of a file pointer.

## `file::list`

```surql title="API DEFINITION"
file::list(string, list_options: option<object>) -> array<object>
```

The `file::list` returns the metadata for the files inside a certain bucket. The output is an array of objects, each containing the following fields:

* `file`: the pointer to the file.
* `size` (`int`): the file size in bytes.
* `updated` (`datetime`): the last time a change was made to the file.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ file: f"my_bucket:/awesome_book", size: 19, updated: d'2025-10-07T01:13:20.226926Z' }, { file: f"my_bucket:/some_book", size: 39, updated: d'2025-10-07T01:13:20.227320Z' }]
"
skip-datetime = true

*/

DEFINE BUCKET my_bucket BACKEND "memory";

f"my_bucket:/some_book".put("Once upon a time...");
f"my_bucket:/some_book".rename("awesome_book");
f"my_bucket:/some_book".put("In a hole in the ground lived a Hobbit.");
file::list("my_bucket");
```

```surql title="Output"
[
	{
		file: f"my_bucket:/awesome_book",
		size: 19,
		updated: d'2025-04-08T03:28:20.530511Z'
	},
	{
		file: f"my_bucket:/some_book",
		size: 39,
		updated: d'2025-04-08T03:28:20.530704Z'
	}
]
```

To modify the output, a second argument can be passed in that contains a single object with up to three fields:

* `limit` (`int`): the maximum number of files to display.
* `start` (`string`): displays files ordered after `start`.
* `prefix` (`string`): displays files whose names begin with `prefix`.

Some examples of the function containing the second object and their responses:

```surql
file::list("my_bucket", { limit: 1 });
file::list("my_bucket", { limit: 0 });
```

```surql title="Output"
-------- Query --------
[
	{
		file: f"my_bucket:/awesome_book",
		size: 19,
		updated: d'2025-04-15T05:35:40.913221Z'
	}
]

-------- Query --------
[]
```

```surql
file::list("my_bucket", { prefix: "some" });
file::list("my_bucket", { prefix: "someBOOOEOEOK" });
```

```surql title="Output"
-------- Query --------
[
	{
		file: f"my_bucket:/some_book",
		size: 39,
		updated: d'2025-04-15T05:35:40.913554Z'
	}
]

-------- Query --------
[]
```

```surql
file::list("my_bucket", { start: "a" });
file::list("my_bucket", { start: "m" });
```

```surql title="Output"
-------- Query --------
[
	{
		file: f"my_bucket:/awesome_book",
		size: 19,
		updated: d'2025-04-15T05:55:41.973869Z'
	},
	{
		file: f"my_bucket:/some_book",
		size: 39,
		updated: d'2025-04-15T05:55:41.974370Z'
	}
]

-------- Query --------
[
	{
		file: f"my_bucket:/some_book",
		size: 39,
		updated: d'2025-04-15T05:55:41.974370Z'
	}
]
```

```surql
file::list("my_bucket", { prefix: "some", start: "a", limit: 1 });
```

```surql title="Output"
[
	{
		file: f"my_bucket:/some_book",
		size: 39,
		updated: d'2025-04-15T05:35:40.913554Z'
	}
]
```

## `file::put`

The `file::put` function adds data into a file, overwriting any existing data.

```surql title="API DEFINITION"
file::put()
```

An example of this function followed by `file::get()` to display the contents:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = ""Or were there? I don't quite remember.""

*/

DEFINE BUCKET my_bucket BACKEND "memory";

f"my_bucket:/my_book.txt".put("Once there were four children whose names were Peter, Susan...");
f"my_bucket:/my_book.txt".put("Or were there? I don't quite remember.");
<string>f"my_bucket:/my_book.txt".get();
```

```surql title="Output"
"Or were there? I don't quite remember."
```

<br></br>

## `file::put_if_not_exists`

The `file::put` function adds data into a file, unless a file of the same name already exists.

```surql title="API DEFINITION"
file::put_if_not_exists()
```

An example of this function followed by `file::get()` to display the contents:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "'Once there were four children whose names were Peter, Susan...'"

*/

DEFINE BUCKET my_bucket BACKEND "memory";

-- Creates file and adds data
f"my_bucket:/my_book.txt".put_if_not_exists("Once there were four children whose names were Peter, Susan...");
-- Does nothing
f"my_bucket:/my_book.txt".put_if_not_exists("Or were there? I don't quite remember.");
<string>f"my_bucket:/my_book.txt".get();
```

```surql title="Output"
'Once there were four children whose names were Peter, Susan...'
```

<br></br>

## `file::rename`

The `file::rename` function renames a file, overwriting any existing file that has the same name as the target name.

```surql title="API DEFINITION"
file::rename()
```

An example of a file being renamed over an existing file:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = ""Or were there? I don't quite remember.""

*/


DEFINE BUCKET my_bucket BACKEND "memory";

f"my_bucket:/my_book.txt".put("Once there were four children whose names were Peter, Susan...");
f"my_bucket:/other_book.txt".put("Or were there? I don't quite remember.");
-- Rename to my_book.txt, overwriting existing file of the same name
f"my_bucket:/other_book.txt".rename("my_book.txt");
<string>f"my_bucket:/my_book.txt".get();
```

```surql title="Output"
"Or were there? I don't quite remember."
```

<br></br>

## `file::rename_if_not_exists`

The `file::rename_if_not_exists` function renames a file, returning an error if a file already exists that has the same name as the target name.

```surql title="API DEFINITION"
file::rename_if_not_exists()
```

```surql title="Output"
-------- Query --------

'Operation for bucket `my_bucket` failed: Object at location my_book.txt already exists:
Object already exists at that location: my_book.txt'

-------- Query --------

'Once there were four children whose names were Peter, Susan...
```


================================================
FILE: src/content/doc-surrealql/functions/database/geo.mdx
================================================
---
sidebar_position: 10
sidebar_label: Geo functions
title: Geo functions | SurrealQL
description: These functions can be used when working with and analysing geospatial data.
---
import Image from "@components/Image.astro";

import LightBearing from "@img/image/light/geo-bearing.png";
import LightCentroid from "@img/image/light/geo-centroid.png";
import LightLondon from "@img/image/light/geo-london.png";
import LightParis from "@img/image/light/geo-paris.png";
import LightWyoming from "@img/image/light/geo-wyoming.png";

import DarkBearing from "@img/image/dark/geo-bearing.png";
import DarkCentroid from "@img/image/dark/geo-centroid.png";
import DarkLondon from "@img/image/dark/geo-london.png";
import DarkParis from "@img/image/dark/geo-paris.png";
import DarkWyoming from "@img/image/dark/geo-wyoming.png";

# Geo functions

These functions can be used when working with and analysing geospatial data.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#geoarea"><code>geo::area()</code></a></td>
      <td scope="row" data-label="Description">Calculates the area of a geometry</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#geobearing"><code>geo::bearing()</code></a></td>
      <td scope="row" data-label="Description">Calculates the bearing between two geolocation points</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#geocentroid"><code>geo::centroid()</code></a></td>
      <td scope="row" data-label="Description">Calculates the centroid of a geometry</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#geodistance"><code>geo::distance()</code></a></td>
      <td scope="row" data-label="Description">Calculates the distance between two geolocation points</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#geohashdecode"><code>geo::&#8203;hash::decode()</code></a></td>
      <td scope="row" data-label="Description">Decodes a geohash into a geometry point</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#geohashencode"><code>geo::&#8203;hash::encode()</code></a></td>
      <td scope="row" data-label="Description">Encodes a geometry point into a geohash</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#geoisvalid"><code>geo::is_valid()</code></a></td>
      <td scope="row" data-label="Description">Determines if a geometry type is a geography type</td>
    </tr>
  </tbody>
</table>

## Point and geometry

* A `point` is composed of two floats that represent the longitude (east/west) and latitude (north/south) of a location.
* A `geometry` is a type of object defined in the [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) spec, of which Polygon is the most common. They can be passed in to the geo functions as objects that contain a "type" (such as "Polygon") and "coordinates" (an array of points).

## `geo::area`

The `geo::area` function calculates the area of a geometry in square metres.

```surql title="API DEFINITION"
geo::area(geometry) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement for four approximate points found on a map for the US state of Wyoming which has an area of 253,340 km<sup>2</sup> and a mostly rectangular shape. Note: the doubled square brackets are because the function takes an array of an array to allow for more complex types such as MultiPolygon.


<Image
  alt="A map of Wyoming in the United States with four approximate points on each corner used to approximate its total surface area in SurrealDB's geo area function."
  src={{
    light: LightWyoming,
    dark: DarkWyoming,
  }}
/>

```surql
/**[test]

[[test.results]]
value = "253317731850.3478f"

*/
RETURN geo::area({
  type: "Polygon",
  coordinates: [[
    [-111.0690, 45.0032],
    [-104.0838, 44.9893],
    [-104.0910, 40.9974],
    [-111.0672, 40.9862]
  ]]
});
```

```surql title="Response"
253317731850.3478f
```

If the argument is not a geometry type, then an error will be returned.

```surql
/**[test]

[[test.results]]
error = "'Incorrect arguments for function geo::area(). Argument 1 was the wrong type. Expected `geometry` but found `12345`'"

*/
RETURN geo::area(12345);

-- 'Incorrect arguments for function geo::area(). Argument 1 was the wrong type. Expected `geometry` but found `12345`'
```

<br />

## `geo::bearing`

The `geo::bearing` function calculates the bearing between two geolocation points. Bearing begins at 0 degrees to indicate north, increasing clockwise into positive values and decreasing counterclockwise into negative values that converge at 180 degrees.

<Image
  alt="A circle showing how bearing is defined from 0 degrees to 360 degrees."
  src={{
    light: LightBearing,
    dark: DarkBearing,
  }}
/>

```surql title="API DEFINITION"
geo::bearing(point, point) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "164.18154786094604f"

*/

-- LET used here for readability
LET $paris = (2.358058597411099, 48.861109346459536);
LET $le_puy_en_velay = (3.883428431947686, 45.04383588468415);
RETURN geo::bearing($paris, $le_puy_en_velay);
RETURN geo::bearing($le_puy_en_velay, $paris);
```

```surql title="Response"
-- Slightly east of directly south
164.18154786094604f
-- Slightly west of directly north
-14.70308114652183f
```

<Image
  alt="A map showing the path from Paris, the capital of France, to a French town called Le Puy En Velay. The bearing is south southeast."
  src={{
    light: LightParis,
    dark: DarkParis,
  }}
/>

<br />

## `geo::centroid`

The `geo::centroid` function calculates the centroid between multiple geolocation points.

```surql title="API DEFINITION"
geo::centroid(geometry) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement. Note: the doubled square brackets are because the function takes an array of an array to allow for more complex types such as MultiPolygon.

```surql
/**[test]

[[test.results]]
value = "(13.483896437936192, 47.07117241195589)"

*/
RETURN geo::centroid({
  type: "Polygon",
  coordinates: [[
    [-0.03921743611083, 51.88106875736589], -- London
    [30.48112752349519, 50.68377089794912], -- Kyiv
    [23.66174524001544, 42.94500782833793], -- Sofia
    [ 1.92481534361859, 41.69698118125476] -- Barcelona
  ]]
});
```

The return value is a mountainous region somewhere in Austria:

```surql title="Response"
(13.483896437936192, 47.07117241195589)
```

<Image
  alt="A map showing the centroid between four points in Europe: London, Kyiv, Sofia, and Barcelona. The centroid itself is located in Austria."
  src={{
    light: LightCentroid,
    dark: DarkCentroid,
  }}
/>

<br />

## `geo::distance`

The `geo::distance` function calculates the haversine distance, in metres, between two geolocation points.

```surql title="API DEFINITION"
geo::distance(point, point) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "8268604.251890703f"

*/
let $london = (-0.04592553673505285, 51.555282574465764);
let $harare = (30.463880214538577, -17.865161568822085);
RETURN geo::distance($london, $harare);
```

```surql title="Response"
8268604.251890703f
```

<Image
  alt="A map showing the distance in a straight line from London, the capital of the United Kingdom, to Harare, the capital of Zimbabwe"
  src={{
    light: LightLondon,
    dark: DarkLondon,
  }}
/>

<br />

## `geo::hash::decode`

The `geo::hash::decode` function converts a geohash into a geolocation point.

```surql title="API DEFINITION"
geo::hash::decode(point) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "(51.50986494496465, -0.11809204705059528)"

*/
RETURN geo::hash::decode("mpuxk4s24f51");
```

```surql title="Response"
(51.50986494496465, -0.11809204705059528)
```

<br />

## `geo::hash::encode`

The `geo::hash::encode` function converts a geolocation point into a geohash.

```surql title="API DEFINITION"
geo::hash::encode(point) -> string
```

The function accepts a second argument, which determines the accuracy and granularity of the geohash.

```surql title="API DEFINITION"
geo::hash::encode(point, number) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'mpuxk4s24f51'"

*/
RETURN geo::hash::encode( (51.509865, -0.118092) );

-- 'mpuxk4s24f51'
```

The following example shows this function with two arguments, and its output, when used in a select statement:

```surql
/**[test]

[[test.results]]
value = "'mpuxk'"

*/

RETURN geo::hash::encode( (51.509865, -0.118092), 5 );

-- 'mpuxk'
```

<br />

## `geo::is_valid`

The `geo::is_valid` function determines if a geometry type is a geography type.
Geography types are used to store geolocation data in a [Geographic Coordinate System (GCS)](https://en.wikipedia.org/wiki/Geographic_coordinate_system), 
whereas geometry types can store geolocation data in any coordinate system, including GCS, mathematical planes, board game layouts, etc...

A geography type add the following constraint: 
each `Point` coordinates are in the range of -180° to 180° for longitude and -90° to 90° for latitude.

```surql title="API DEFINITION"
geo::is_valid(geometry) -> bool
```

The following examples show this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql title="A valid geography point"
/**[test]

[[test.results]]
value = "true"

*/ 
RETURN geo::is_valid( (51.509865, -0.118092) );

-- true
```

```surql title="Out of range geometry point"
/**[test]

[[test.results]]
value = "false"

*/ 
RETURN geo::is_valid( (-181.0, -0.118092) );

-- false
```

<br /><br />



================================================
FILE: src/content/doc-surrealql/functions/database/http.mdx
================================================
---
sidebar_position: 11
sidebar_label: HTTP functions
title: HTTP functions | SurrealQL
description: These functions can be used when opening and submitting remote web requests, and webhooks.
---
import Since from '@components/shared/Since.astro';

# HTTP functions

These functions can be used when opening and submitting remote web requests, and webhooks.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#httphead"><code>http::head()</code></a></td>
      <td scope="row" data-label="Description">Perform a remote HTTP HEAD request</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#httpget"><code>http::get()</code></a></td>
      <td scope="row" data-label="Description">Perform a remote HTTP GET request</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#httpput"><code>http::put()</code></a></td>
      <td scope="row" data-label="Description">Perform a remote HTTP PUT request</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#httppost"><code>http::post()</code></a></td>
      <td scope="row" data-label="Description">Perform a remote HTTP POST request</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#httppatch"><code>http::patch()</code></a></td>
      <td scope="row" data-label="Description">Perform a remote HTTP PATCH request</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#httpdelete"><code>http::delete()</code></a></td>
      <td scope="row" data-label="Description">Perform a remote HTTP DELETE request</td>
    </tr>
  </tbody>
</table>


## Before you begin

<Since v="v2.2.0" />

From version `2.2` of SurrealDB, the HTTP functions have been improved to provide a more consistent and user-friendly experience. These improvements include:

- **Enhanced HTTP error messages**: The server provides more descriptive error responses, including relevant HTTP status codes and detailed error information when available.

- **Raw SurrealQL data encoding**: Data types are preserved more faithfully in responses through improved encoding.
  - SurrealQL **byte values** are now sent as raw bytes (not base64-encoded or JSON-encoded).  
  - SurrealQL **string values** are sent as raw strings.  
  - All other SurrealQL values (numbers, arrays, objects, booleans, etc.) are automatically JSON-encoded.

- **Manual Header Configuration**: SurrealDB no longer automatically adds `Content-Type: application/octet-stream` to responses when the body contains SurrealQL byte values. If you need this header, you can set it manually.

## `http::head`

The `http::head` function performs a remote HTTP `HEAD` request. The first parameter is the URL of the remote endpoint. If the response does not return a `2XX` status code, then the function will fail and return the error.

```surql title="API DEFINITION"
http::head(string) -> null
```

If an object is given as the second argument, then this can be used to set the request headers.

```surql title="API DEFINITION"
http::head(string, object) -> null
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN http::head('https://surrealdb.com');

null
```

To specify custom headers with the HTTP request, pass an object as the second argument:

```surql
RETURN http::head('https://surrealdb.com', {
	'x-my-header': 'some unique string'
});

null
```

<br />

## `http::get`

The `http::get` function performs a remote HTTP `GET` request. The first parameter is the URL of the remote endpoint. If the response does not return a 2XX status code, then the function will fail and return the error. 

If the remote endpoint returns an `application/json content-type`, then the response is parsed and returned as a value, otherwise the response is treated as text.

```surql title="API DEFINITION"
http::get(string) -> value
```
If an object is given as the second argument, then this can be used to set the request headers.

```surql title="API DEFINITION"
http::get(string, object) -> value
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN http::get('https://surrealdb.com');

-- The HTML code is returned
```

To specify custom headers with the HTTP request, pass an object as the second argument:

```surql
RETURN http::get('https://surrealdb.com', {
	'x-my-header': 'some unique string'
});

-- The HTML code is returned
```

<br />

## `http::put`

The `http::put` function performs a remote HTTP `PUT` request. The first parameter is the URL of the remote endpoint, and the second parameter is the value to use as the request body, which will be converted to JSON. If the response does not return a `2XX` status code, then the function will fail and return the error. If the remote endpoint returns an `application/json` content-type, then the response is parsed and returned as a value, otherwise the response is treated as text.

```surql title="API DEFINITION"
http::put(string, object) -> value
```

If an object is given as the third argument, then this can be used to set the request headers.

```surql title="API DEFINITION"
http::put(string, object, object) -> value
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql title="Request without headers"
RETURN http::put('https://dummyjson.com/comments', {
  "id": 1,
  "body": "This is some awesome thinking!",
  "postId": 100,
  "user": {
    "id": 63,
    "username": "eburras1q"
  }
});
```

```surql title="Request with headers"
RETURN http::put('https://dummyjson.com/comments', {
  "id": 1,
  "body": "This is some awesome thinking!",
  "postId": 100,
  "user": {
    "id": 63,
    "username": "eburras1q"
  }
}, {
  'Authorization': 'Bearer your-token-here',
  'Content-Type': 'application/json',
  'x-custom-header': 'custom-value'
});
```

```surql title="Response"
{
  "id": 1,
  "body": "This is some awesome thinking!",
  "postId": 100,
  "user": {
    "id": 63,
    "username": "eburras1q"
  }
}
```

<br />

## `http::post`

The `http::post` function performs a remote HTTP `POST` request. The first parameter is the URL of the remote endpoint, and the second parameter is the value to use as the request body, which will be converted to JSON. If the response does not return a `2XX` status code, then the function will fail and return the error. If the remote endpoint returns an `application/json` content-type, then the response is parsed and returned as a value, otherwise the response is treated as text.

```surql title="API DEFINITION"
http::post(string, object) -> value
```
If an object is given as the third argument, then this can be used to set the request headers.

```surql title="API DEFINITION"
http::post(string, object, object) -> value
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql title="Request without headers"
RETURN http::post('https://dummyjson.com/comments/1', {
  "id": 1,
  "body": "This is some awesome thinking!",
  "postId": 100,
  "user": {
    "id": 63,
    "username": "eburras1q"
  }
});
```

```surql title="Request with headers"
RETURN http::post('https://dummyjson.com/comments/1', {
  "id": 1,
  "body": "This is some awesome thinking!",
  "postId": 100,
  "user": {
    "id": 63,
    "username": "eburras1q"
  }
}, {
  'Authorization': 'Bearer your-token-here',
  'Content-Type': 'application/json',
  'x-custom-header': 'custom-value'
});
```

```surql title="Response"
{
  "id": 1,
  "body": "This is some awesome thinking!",
  "postId": 100,
  "user": {
    "id": 63,
    "username": "eburras1q"
  }
}
```

<br />

## `http::patch`

The `http::patch` function performs a remote HTTP `PATCH` request. The first parameter is the URL of the remote endpoint, and the second parameter is the value to use as the request body, which will be converted to JSON. If the response does not return a `2XX` status code, then the function will fail and return the error. If the remote endpoint returns an `application/json` content-type, then the response is parsed and returned as a value, otherwise the response is treated as text.

```surql title="API DEFINITION"
http::patch(string, object) -> value
```
If an object is given as the third argument, then this can be used to set the request headers.

```surql title="API DEFINITION"
http::patch(string, object, object) -> value
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql title="Request without headers"
RETURN http::patch('https://dummyjson.com/comments/1', {
  "id": 1,
  "body": "This is some awesome thinking!",
  "postId": 100,
  "user": {
    "id": 63,
    "username": "eburras1q"
  }
});
```

```surql title="Setting the request headers"
RETURN http::patch('https://dummyjson.com/comments/1', {
  "id": 1,
  "body": "This is some awesome thinking!",
  "postId": 100,
  "user": {
    "id": 63,
    "username": "eburras1q"
  }
}, {
  'Authorization': 'Bearer your-token-here',
  'Content-Type': 'application/json',
  'x-custom-header': 'custom-value'
});
```

```surql title="RESPONSE"
{
  "id": 1,
  "body": "This is some awesome thinking!",
  "postId": 100,
  "user": {
    "id": 63,
    "username": "eburras1q"
  }
}
```

<br />

## `http::delete`

The `http::delete` function performs a remote HTTP `DELETE` request. The first parameter is the URL of the remote endpoint, and the second parameter is the value to use as the request body, which will be converted to JSON. If the response does not return a `2XX` status code, then the function will fail and return the error. If the remote endpoint returns an `application/json` content-type, then the response is parsed and returned as a value, otherwise the response is treated as text.

```surql title="API DEFINITION"
http::delete(string) -> value
```
If an object is given as the second argument, then this can be used to set the request headers.

```surql title="API DEFINITION"
http::delete(string, object) -> value
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN http::delete('https://dummyjson.com/comments/1');

null
```
To specify custom headers with the HTTP request, pass an object as the second argument:

```surql
RETURN http::delete('https://dummyjson.com/comments/1', {
	'x-my-header': 'some unique string'
});

null
```

<br /><br />


================================================
FILE: src/content/doc-surrealql/functions/database/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Database Functions
title: Database Functions | SurrealQL
description: SurrealDB comes with a large number of in-built functions for checking, manipulating, and working with many different types of data.
---

import Since from '@components/shared/Since.astro'
import Table from '@components/shared/Table.astro'

# Database Functions

SurrealDB has many built-in functions designed to handle many common database tasks and work with SurrealDB's various data types, grouped into modules based on their purpose and the data types they are designed to work with. The table below lists all of SurrealDB's function modules, with descriptions and links to their own detailed documentation.

<Table>
	<thead>
		<tr>
			<th scope="col" class="w-40">
				Function
			</th>
			<th scope="col">Description and Example</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/array">
					<code>Array</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used when working with, and
				manipulating arrays of data.
				
				Example: <code>array::len([1,2,3])</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/bytes">
					<code>Bytes</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used when working with bytes in
				SurrealQL.
				
				Example: <code>bytes::len("SurrealDB".to_bytes());</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/count">
					<code>Count</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				This function can be used when counting field values and
				expressions.
				
				Example: <code>count([1,2,3])</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/crypto">
					<code>Crypto</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used when hashing data, encrypting
				data, and for securely authenticating users into the
				database.
				
				Example: <code>crypto::argon2::generate("MyPaSSw0RD")</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/duration">
					<code>Duration</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used when converting between numeric
				and duration data.
				
				Example: <code>duration::days(90h30m)</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/encoding">
					<code>Encoding</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used to encode and decode data in{' '}
				<code>base64</code>.
				Example: <code>encoding::base64::decode("aGVsbG8")</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/geo">
					<code>Geo</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used when working with and analysing
				geospatial data.
				
				Example:{' '}
				<code>geo::distance((-0.04, 51.55), (30.46, -17.86))</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/http">
					<code>HTTP</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used when opening and submitting
				remote web requests, and webhooks.
				
				Example: `http::get('https://surrealdb.com')`
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/math">
					<code>Math</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used when analysing numeric data and
				numeric collections.
				
				Example:{' '}
				<code>
					math::max([ 26.164, 13.746189, 23, 16.4, 41.42 ])
				</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/meta">
					<code>Meta</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used to retrieve specific metadata
				from a SurrealDB Record ID. As of version 2.0, these
				functions are deprecated and replaced with SurrealDB's{' '}
				<code>record</code> functions.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/not">
					<code>Not</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				This function reverses the truthiness of a value.
				
				Example: <code>not(true)</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/object">
					<code>Object</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used when working with, and
				manipulating data objects.
				
				Example:{' '}
				<code>
					object::from_entries([[ "a", 1 ],[ "b", true ]])
				</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/parse">
					<code>Parse</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used when parsing email addresses and
				URL web addresses.
				
				Example:{' '}
				<code>
					parse::url::domain("http://127.0.0.1/index.html")
				</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/rand">
					<code>Rand</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used when generating random data
				values.
				
				Example:{' '}
				<code>
					rand::enum('one', 'two', 3, 4.15385, 'five', true)
				</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/record">
					<code>Record</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used to retrieve specific metadata
				from a SurrealDB Record ID.
				
				Example: <code>record::id(person:tobie)</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/search">
					<code>Search</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions are used in conjunction with the{' '}
				<code>@@</code> operator (the 'matches' operator) to either
				collect the relevance score or highlight the searched
				keywords within the content.
				
				Example:{' '}
				<code>
					SELECT search::score(1) AS score FROM book WHERE title
					@1@ 'rust web'
				</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/session">
					<code>Session</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions return information about the current
				SurrealDB session.
				
				Example: <code>session::db()</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/sleep">
					<code>Sleep</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				This function can be used to introduce a delay or pause in
				the execution of a query or a batch of queries for a
				specific amount of time.
				
				Example: <code>sleep(900ms)</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/string">
					<code>String</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used when working with and
				manipulating text and string values.
				
				Example:{' '}
				<code>string::reverse('emosewa si 0.2 BDlaerruS')</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/time">
					<code>Time</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used when working with and
				manipulating datetime values.
				
				Example: <code>time::timezone()</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/type">
					<code>Type</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				These functions can be used for generating and coercing data
				to specific data types.
				
				Example: <code>type::is_number(500)</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/value">
					<code>Value</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				This module contains several miscellaneous functions that
				can be used with values of any type.
				
				Example:{' '}
				<code>value::diff([true, false], [true, true])</code>
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Function">
				<a href="/docs/surrealql/functions/database/vector">
					<code>Vector</code>
				</a>
			</td>
			<td scope="row" data-label="Description and Example">
				A collection of essential vector operations that provide
				foundational functionality for numerical computation,
				machine learning, and data analysis.
				
				Example: <code>vector::add([1, 2, 3], [1, 2, 3])</code>
			</td>
		</tr>
	</tbody>
</Table>

## How to use database functions

### Classic syntax

Functions in SurrealDB can always be called using their full path names beginning with the package names indicated above, followed by the function arguments.

```surql
string::split("SurrealDB 2.0 is on its way!", " ");
array::len([1,2,3]);
type::is_number(10);
type::record("cat", "mr_meow");
```

```surql title="Response"
-------- Query --------

[
	'SurrealDB',
	'2.0',
	'is',
	'on',
	'its',
	'way!'
]

-------- Query --------

3

-------- Query --------

true

-------- Query --------

cat:mr_meow
```

### Method syntax

<Since v="v2.0.0" />

Functions that are called on an existing value can be called using method syntax, using the `.` (dot) operator.

The following functions will produce the same output as the classic syntax above. `type::record()` cannot be called with method syntax because it is used to outright create a record ID from nothing, rather than being called on an existing value.

```surql
"SurrealDB 2.0 is on its way!".split(" ");
[1,2,3].len();
10.is_number();
```

The method syntax is particular useful when calling a number of functions inside a single query.

```surql
array::len(array::windows(array::distinct(array::flatten([[1,2,3],[1,4,6],[4,2,4]])), 2));
```

Readability before `2.0` could be improved to a certain extent by moving a query of this type over multiple lines.

```surql
array::len(
    array::clump(
        array::distinct(
            array::flatten([[1,2,3],[1,4,6],[4,2,4]])
        )
    , 2)
);
```

However, method chaining syntax allows queries of this type to be read from left to right in a functional manner. This is known as method chaining. As each of the methods below except the last return an array, further array methods can thus be called by using the `.` operator. The final method then returns an integer.

```surql
[[1,2,3],[1,4,6],[4,2,4],2].flatten().distinct().windows(2).len();
```

This can be made even more readable by splitting over multiple lines.

```surql
[[1,2,3],[1,4,6],[4,2,4]]
    .flatten()
    .distinct()
    .windows(2)
    .len();
```

### Conversion from `::` (double colon) to `_` (underscore) syntax

<Since v="v3.0.0-alpha.8" />

Full function paths in SurrealDB were converted to match the method syntax detailed above.

```surql
-- Old syntax
type::is::record(person:one);
-- Method syntax
person:one.is_record();
-- New syntax now matches method syntax
type::is_record(person:one);
```

### Mathematical constants

The page on mathematical functions also contains a number of mathematical constants. They are used in a similar way to functions except that their paths point to hard-coded values instead of a function pointer and thus do not need parentheses.

```surql
RETURN [math::pi, math::tau, math::e];
```

```surql title="Response"
[
	3.141592653589793f,
	6.283185307179586f,
	2.718281828459045f
]
```

## Anonymous functions

<Since v="v2.0.0" />

SurrealDB also allows for the creation of anonymous functions (also known as closures) that do not need to be defined on the database. See [the page on closures](/docs/surrealql/datamodel/closures) for more details.



================================================
FILE: src/content/doc-surrealql/functions/database/math.mdx
================================================
---
sidebar_position: 12
sidebar_label: Math functions
title: Math functions | SurrealQL
description: These functions can be used when analysing numeric data and numeric collections.
---
import Since from '@components/shared/Since.astro'

# Math functions

These functions can be used when analysing numeric data and numeric collections.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathabs"><code>math::abs()</code></a></td>
      <td scope="row" data-label="Description">Returns the absolute value of a number</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathacos"><code>math::acos()</code></a></td>
      <td scope="row" data-label="Description">Computes the arccosine (inverse cosine) of a value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathacot"><code>math::acot()</code></a></td>
      <td scope="row" data-label="Description">Computes the arccotangent (inverse cotangent) of an angle given in radians</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathasin"><code>math::asin()</code></a></td>
      <td scope="row" data-label="Description">Computes the arcsine (inverse sine) of a value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathatan"><code>math::atan()</code></a></td>
      <td scope="row" data-label="Description">Computes the arctangent (inverse tangent) of a value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathbottom"><code>math::bottom()</code></a></td>
      <td scope="row" data-label="Description">Returns the bottom X set of numbers in a set of numbers</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathceil"><code>math::ceil()</code></a></td>
      <td scope="row" data-label="Description">Rounds a number up to the next largest integer</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathclamp"><code>math::clamp()</code></a></td>
      <td scope="row" data-label="Description">Clamps a value between a specified minimum and maximum</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathcos"><code>math::cos()</code></a></td>
      <td scope="row" data-label="Description">Computes the cosine of an angle given in radians</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathcot"><code>math::cot()</code></a></td>
      <td scope="row" data-label="Description">Computes the cotangent of an angle given in radians</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathdeg2rad"><code>math::deg2rad()</code></a></td>
      <td scope="row" data-label="Description">Converts an angle from degrees to radians</td>
    </tr>
    <tr>
      <td scope="row" data-label="Constant"><a href="#mathe"><code>math::e</code></a></td>
      <td scope="row" data-label="Description">Constant representing the base of the natural logarithm (Euler's number)</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathfixed"><code>math::fixed()</code></a></td>
      <td scope="row" data-label="Description">Returns a number with the specified number of decimal places</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathfloor"><code>math::floor()</code></a></td>
      <td scope="row" data-label="Description">Rounds a number down to the nearest integer</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathfrac_1_pi"><code>math::frac_1_pi</code></a></td>
      <td scope="row" data-label="Description">Constant representing the fraction 1/π</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathfrac_1_sqrt_2"><code>math::frac_1_sqrt_2</code></a></td>
      <td scope="row" data-label="Description">Constant representing the fraction 1/sqrt(2)</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathfrac_2_pi"><code>math::frac_2_pi</code></a></td>
      <td scope="row" data-label="Description">Constant representing the fraction 2/π</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathfrac_2_sqrt_pi"><code>math::frac_2_sqrt_pi</code></a></td>
      <td scope="row" data-label="Description">Constant representing the fraction 2/sqrt(π)</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathfrac_pi_2"><code>math::frac_pi_2</code></a></td>
      <td scope="row" data-label="Description">Constant representing the fraction π/2</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathfrac_pi_3"><code>math::frac_pi_3</code></a></td>
      <td scope="row" data-label="Description">Constant representing the fraction π/3</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathfrac_pi_4"><code>math::frac_pi_4</code></a></td>
      <td scope="row" data-label="Description">Constant representing the fraction π/4</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathfrac_pi_6"><code>math::frac_pi_6</code></a></td>
      <td scope="row" data-label="Description">Constant representing the fraction π/6</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathfrac_pi_8"><code>math::frac_pi_8</code></a></td>
      <td scope="row" data-label="Description">Constant representing the fraction π/8</td>
    </tr>
    <tr>
      <td scope="row" data-label="Constant"><a href="#mathinf"><code>math::inf</code></a></td>
      <td scope="row" data-label="Description">Constant representing positive infinity</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathinterquartile"><code>math::interquartile()</code></a></td>
      <td scope="row" data-label="Description">Returns the interquartile of an array of numbers</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathlerp"><code>math::lerp()</code></a></td>
      <td scope="row" data-label="Description">Linearly interpolates between two values based on a factor</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathlerpangle"><code>math::lerpangle()</code></a></td>
      <td scope="row" data-label="Description">Linearly interpolates between two angles in degrees</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathln"><code>math::ln()</code></a></td>
      <td scope="row" data-label="Description">Computes the natural logarithm (base e) of a value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathln_10"><code>math::ln_10</code></a></td>
      <td scope="row" data-label="Description">Constant representing the natural logarithm (base e) of 10</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathln_2"><code>math::ln_2</code></a></td>
      <td scope="row" data-label="Description">Constant representing the natural logarithm (base e) of 2</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathlog"><code>math::log()</code></a></td>
      <td scope="row" data-label="Description">Computes the logarithm of a value with the specified base</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathlog10"><code>math::log10()</code></a></td>
      <td scope="row" data-label="Description">Computes the base-10 logarithm of a value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathlog10_2"><code>math::log10_2</code></a></td>
      <td scope="row" data-label="Description">Constant representing the base-10 logarithm of 2</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathlog10_e"><code>math::log10_e</code></a></td>
      <td scope="row" data-label="Description">Constant representing the base-10 logarithm of e, the base of the natural logarithm (Euler’s number)</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathlog2"><code>math::log2()</code></a></td>
      <td scope="row" data-label="Description">Computes the base-2 logarithm of a value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathlog2_10"><code>math::log2_10</code></a></td>
      <td scope="row" data-label="Description">Constant representing the base-2 logarithm of 10</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathlog2_e"><code>math::log2_e</code></a></td>
      <td scope="row" data-label="Description">Constant representing the base-2 logarithm of e, the base of the natural logarithm (Euler’s number)</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathmax"><code>math::max()</code></a></td>
      <td scope="row" data-label="Description">Returns the greatest number from an array of numbers</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathmean"><code>math::mean()</code></a></td>
      <td scope="row" data-label="Description">Returns the mean of a set of numbers</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathmedian"><code>math::median()</code></a></td>
      <td scope="row" data-label="Description">Returns the median of a set of numbers</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathmidhinge"><code>math::midhinge()</code></a></td>
      <td scope="row" data-label="Description">Returns the midhinge of a set of numbers</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathmin"><code>math::min()</code></a></td>
      <td scope="row" data-label="Description">Returns the least number from an array of numbers</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathmode"><code>math::mode()</code></a></td>
      <td scope="row" data-label="Description">Returns the value that occurs most often in a set of numbers</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathnearestrank"><code>math::nearestrank()</code></a></td>
      <td scope="row" data-label="Description">Returns the nearest rank of an array of numbers</td>
    </tr>
    <tr>
      <td scope="row" data-label="Constant"><a href="#mathneg_inf"><code>math::neg_inf</code></a></td>
      <td scope="row" data-label="Description">Constant representing negative infinity</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathpercentile"><code>math::percentile()</code></a></td>
      <td scope="row" data-label="Description">Returns the value below which a percentage of data falls</td>
    </tr>
    <tr>
      <td scope="row" data-label="Constant"><a href="#mathpi"><code>math::pi</code></a></td>
      <td scope="row" data-label="Description">Constant representing the mathematical constant π.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Constant"><a href="#mathpow"><code>math::pow()</code></a></td>
      <td scope="row" data-label="Description">Returns a number raised to a power</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathproduct"><code>math::product()</code></a></td>
      <td scope="row" data-label="Description">Returns the product of a set of numbers</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathrad2deg"><code>math::rad2deg()</code></a></td>
      <td scope="row" data-label="Description">Converts an angle from radians to degrees</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathround"><code>math::round()</code></a></td>
      <td scope="row" data-label="Description">Rounds a number up or down to the nearest integer</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathsign"><code>math::sign()</code></a></td>
      <td scope="row" data-label="Description">Returns the sign of a value (-1, 0, or 1)</td>
    </tr>
     <tr>
      <td scope="row" data-label="Function"><a href="#mathsin"><code>math::sin()</code></a></td>
      <td scope="row" data-label="Description">Computes the sine of an angle given in radians</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathspread"><code>math::spread()</code></a></td>
      <td scope="row" data-label="Description">Returns the spread of an array of numbers</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathsqrt"><code>math::sqrt()</code></a></td>
      <td scope="row" data-label="Description">Returns the square root of a number</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathsqrt_2"><code>math::sqrt_2</code></a></td>
      <td scope="row" data-label="Description">Constant representing the square root of 2</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathstddev"><code>math::stddev()</code></a></td>
      <td scope="row" data-label="Description">Calculates how far a set of numbers are away from the mean</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathsum"><code>math::sum()</code></a></td>
      <td scope="row" data-label="Description">Returns the total sum of a set of numbers</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathtan"><code>math::tan()</code></a></td>
      <td scope="row" data-label="Description">Computes the tangent of an angle given in radians.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Constant"><a href="#mathtau"><code>math::tau()</code></a></td>
      <td scope="row" data-label="Description">Represents the mathematical constant τ, which is equal to 2π</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathtop"><code>math::top()</code></a></td>
      <td scope="row" data-label="Description">Returns the top X set of numbers in a set of numbers</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathtrimean"><code>math::trimean()</code></a></td>
      <td scope="row" data-label="Description">The weighted average of the median and the two quartiles</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#mathvariance"><code>math::variance()</code></a></td>
      <td scope="row" data-label="Description">Calculates how far a set of numbers are spread out from the mean</td>
    </tr>
  </tbody>
</table>

## `math::abs`

The `math::abs` function returns the absolute value of a number.

```surql title="API DEFINITION"
math::abs(number) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "13.746189f"

*/

RETURN math::abs(-13.746189);

13.746189f
```

<br />

## `math::acos`

<Since v="v2.0.0" />

The `math::acos` function returns the arccosine (inverse cosine) of a number, which must be in the range -1 to 1. The result is expressed in radians.

```surql title="API DEFINITION"
math::acos(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1.0471975511965976f"

*/

RETURN math::acos(0.5);

-- 1.0471975511965976f
```

<br />

## `math::acot`

<Since v="v2.0.0" />

The `math::acot` function returns the arccotangent (inverse cotangent) of a number. The result is expressed in radians.

```surql title="API DEFINITION"
math::acot(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.7853981633974483f"

*/

RETURN math::acot(1);

-- 0.7853981633974483f
```

## `math::asin`

<Since v="v2.0.0" />

The `math::asin` function returns the arcsine (inverse sine) of a number, which must be in the range -1 to 1. The result is expressed in radians.

```surql title="API DEFINITION"
math::asin(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.5235987755982988f"

*/

RETURN math::asin(0.5);

-- 0.5235987755982988f
```

<br />

## `math::atan`

<Since v="v2.0.0" />

The `math::atan` function returns the arctangent (inverse tangent) of a number. The result is expressed in radians.

```surql title="API DEFINITION"
math::atan(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.7853981633974483f"

*/

RETURN math::atan(1);

-- 0.7853981633974483f
```

<br />

## `math::bottom`

The `math::bottom` function returns the bottom X set of numbers in a set of numbers.

```surql title="API DEFINITION"
math::bottom(array<number>, number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[2, 1]"

*/

RETURN math::bottom([1, 2, 3], 2);

-- [2, 1]
```

<br />

## `math::ceil`

The `math::ceil` function rounds a number up to the next largest whole number.

```surql title="API DEFINITION"
math::ceil(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "14f"

*/

RETURN math::ceil(13.146572);
-- 14f
```

<br />

## `math::clamp`

<Since v="v2.0.0" />

The `math::clamp` function constrains a number within the specified range, defined by a minimum and a maximum value. If the number is less than the minimum, it returns the minimum. If it is greater than the maximum, it returns the maximum.

```surql title="API DEFINITION"
math::clamp(number, min, max) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "5"

*/

RETURN math::clamp(1, 5, 10);
-- 5
```

<br />

## `math::cos`

<Since v="v2.0.0" />

The `math::cos` function returns the cosine of a number, which is assumed to be in radians. The result is a value between -1 and 1.

```surql title="API DEFINITION"
math::cos(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.5403023058681398f"

*/

RETURN math::cos(1);
-- 0.5403023058681398f
```

<br />

## `math::cot`

<Since v="v2.0.0" />

The `math::cot` function returns the cotangent of a number, which is assumed to be in radians. The cotangent is the reciprocal of the tangent function.

```surql title="API DEFINITION"
math::cot(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.6420926159343308f"

*/

RETURN math::cot(1);
-- 0.6420926159343308f
```

<br />

## `math::deg2rad`

<Since v="v2.0.0" />

The `math::deg2rad` function converts an angle from degrees to radians.

```surql title="API DEFINITION"
math::deg2rad(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "3.141592653589793f"

*/

RETURN math::deg2rad(180);
-- 3.141592653589793f
```

<br />

## `math::e`

The `math::e` constant represents the base of the natural logarithm (Euler’s number).

```surql title="API DEFINITION"
math::e -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "2.718281828459045f"

*/

RETURN math::e;
-- 2.718281828459045f
```

<br />

## `math::fixed`

The `math::fixed` function returns a number with the specified number of decimal places.

```surql title="API DEFINITION"
math::fixed(number, number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "13.15f"

*/

RETURN math::fixed(13.146572, 2);

-- 13.15f
```

<br />

## `math::floor`

The `math::floor` function rounds a number down to the nearest integer.

```surql title="API DEFINITION"
math::floor(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "13f"

*/

RETURN math::floor(13.746189);
-- 13f 
```

<br />

## `math::frac_1_pi`

The `math::frac_1_pi` constant represents the fraction 1/π.

```surql title="API DEFINITION"
math::frac_1_pi -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.3183098861837907f"

*/

RETURN math::frac_1_pi;

-- 0.3183098861837907f
```

<br />

## `math::frac_1_sqrt_2`

The `math::frac_1_sqrt_2` constant represents the fraction 1/sqrt(2).

```surql title="API DEFINITION"
math::frac_1_sqrt_2 -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.7071067811865476f"

*/

RETURN math::frac_1_sqrt_2;
-- 0.7071067811865476f
```

<br />

## `math::frac_2_pi`

The `math::frac_2_pi` constant represents the fraction 2/π.

```surql title="API DEFINITION"
math::frac_2_pi -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.6366197723675814f"

*/

RETURN math::frac_2_pi;
-- 0.6366197723675814f
```

<br />

## `math::frac_2_sqrt_pi`

The `math::frac_2_sqrt_pi` constant represents the fraction 2/sqrt(π).

```surql title="API DEFINITION"
math::frac_2_sqrt_pi -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1.1283791670955126f"

*/

RETURN math::frac_2_sqrt_pi;
-- 1.1283791670955126f
```

<br />

## `math::frac_pi_2`

The `math::frac_pi_2` constant represents the fraction π/2.

```surql title="API DEFINITION"
math::frac_pi_2 -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1.5707963267948966f"

*/

RETURN math::frac_pi_2;
-- 1.5707963267948966f
```

<br />

## `math::frac_pi_3`

The `math::frac_pi_3` constant represents the fraction π/3.

```surql title="API DEFINITION"
math::frac_pi_3 -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1.0471975511965979f"

*/

RETURN math::frac_pi_3;
-- 1.0471975511965979f
```

<br />

## `math::frac_pi_4`

The `math::frac_pi_4` constant represents the fraction π/4.

```surql title="API DEFINITION"
math::frac_pi_4 -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.7853981633974483f"

*/

RETURN math::frac_pi_4;
-- 0.7853981633974483f
```

<br />

## `math::frac_pi_6`

The `math::frac_pi_6` constant represents the fraction π/6.

```surql title="API DEFINITION"
math::frac_pi_6 -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.5235987755982989f"

*/

RETURN math::frac_pi_6;
-- 0.5235987755982989f
```

<br />

## `math::frac_pi_8`

The `math::frac_pi_8` constant represents the fraction π/8.

```surql title="API DEFINITION"
math::frac_pi_8 -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.39269908169872414f"

*/

RETURN math::frac_pi_8;
-- 0.39269908169872414f
```

<br />


## `math::inf`

The `math::inf` constant represents positive infinity.

```surql title="API DEFINITION"
math::inf -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "Infinity"

*/

RETURN math::inf;

-- Infinity
```

<br />

## `math::interquartile`

The `math::interquartile` function returns the interquartile of an array of numbers.

```surql title="API DEFINITION"
math::interquartile(array<number>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "51f"

*/

RETURN math::interquartile([ 1, 40, 60, 10, 2, 901 ]);
-- 51f
```

<br />

## `math::lerp`

<Since v="v2.0.0" />

The `math::lerp` function performs a linear interpolation between two numbers (a and b) based on a given fraction (t). The fraction t should be between 0 and 1, where 0 returns a and 1 returns b.

```surql title="API DEFINITION"
math::lerp(a, b, t) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "5f"

*/

RETURN math::lerp(0, 10, 0.5);
-- 5f
```

<br />

## `math::lerpangle`

<Since v="v2.0.0" />

The `math::lerpangle` function interpolates between two angles (a and b) by the given fraction (t). This is useful for smoothly transitioning between angles.

```surql title="API DEFINITION"
math::lerpangle(a, b, t) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "90f"

*/

RETURN math::lerpangle(0, 180, 0.5);
-- 90f
```

<br />

## `math::ln`

<Since v="v2.0.0" />

The `math::ln` function returns the natural logarithm (base e) of a number.

```surql title="API DEFINITION"
math::ln(number) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "2.302585092994046f"

*/

RETURN math::ln(10);
-- 2.302585092994046f
```

<br />

## `math::ln_10`

The `math::ln_10` constant represents the natural logarithm (base e) of 10.

```surql title="API DEFINITION"
math::ln_10 -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "2.302585092994046f"

*/

RETURN math::ln_10;
-- 2.302585092994046f
```

<br />

## `math::ln_2`

The `math::ln_2` constant represents the natural logarithm (base e) of 2.

```surql title="API DEFINITION"
math::ln_2 -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.6931471805599453f"

*/

RETURN math::ln_2;
-- 0.6931471805599453f
```

<br />

## `math::log`

<Since v="v2.0.0" />

The `math::log` function returns the logarithm of a number with a specified base.

```surql title="API DEFINITION"
math::log(number, base) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "2f"

*/

RETURN math::log(100, 10);
-- 2f
```

<br />

## `math::log10`
<Since v="v2.0.0" />

The `math::log10` function returns the base-10 logarithm of a number.

```surql title="API DEFINITION"
math::log10(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "3f"

*/

RETURN math::log10(1000);
-- 3f
```

<br />

## `math::log10_2`

The `math::log10_2` constant represents the base-10 logarithm of 2.

```surql title="API DEFINITION"
math::log10_2 -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.3010299956639812f"

*/

RETURN math::log10_2;
-- 0.3010299956639812f
```

<br />

## `math::log10_e`

The `math::log10_e` constant represents the base-10 logarithm of e, the base of the natural logarithm (Euler’s number).

```surql title="API DEFINITION"
math::log10_e -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.4342944819032518f"

*/

RETURN math::log10_e;

-- 0.4342944819032518f
```

<br />

## `math::log2`
<Since v="v2.0.0" />

The `math::log2` function returns the base-2 logarithm of a number.

```surql title="API DEFINITION"
math::log2(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "3f"

*/

RETURN math::log2(8);
-- 3f
```

<br />

## `math::log2_10`

The `math::log2_10` constant represents the base-2 logarithm of 10.

```surql title="API DEFINITION"
math::log2_10 -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "3.321928094887362f"

*/

RETURN math::log2_10;
-- 3.321928094887362f
```

<br />

## `math::log2_e`

The `math::log2_e` constant represents the base-2 logarithm of e, the base of the natural logarithm (Euler’s number).

```surql title="API DEFINITION"
math::log2_e -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1.4426950408889634f"

*/

RETURN math::log2_e;
-- 1.4426950408889634f
```

<br />

## `math::max`

The `math::max` function returns the greatest number from an array of numbers.

```surql title="API DEFINITION"
math::max(array<number>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "41.42f"

*/

RETURN math::max([ 26.164, 13.746189, 23, 16.4, 41.42 ]);
-- 41.42f
```

See also:

* [`array::max`](/docs/surrealql/functions/database/array#arraymax), which extracts the greatest value from an array of values
* [`time::max`](/docs/surrealql/functions/database/time#timemax), which extracts the greatest datetime from an array of datetimes

## `math::mean`

The `math::mean` function returns the mean of a set of numbers.

```surql title="API DEFINITION"
math::mean(array<number>) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "24.146037800000002f"

*/

RETURN math::mean([ 26.164, 13.746189, 23, 16.4, 41.42 ]);

-- 24.146037800000002f
```

<br />

## `math::median`

The `math::median` function returns the median of a set of numbers.

```surql title="API DEFINITION"
math::median(array<number>) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "23f"

*/

RETURN math::median([ 26.164, 13.746189, 23, 16.4, 41.42 ]);
-- 23f
```

<br />

## `math::midhinge`

The `math::midhinge` function returns the midhinge of an array of numbers.

```surql title="API DEFINITION"
math::midhinge(array<number>) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "29.5f"

*/

RETURN math::midhinge([ 1, 40, 60, 10, 2, 901 ]);
-- 29.5f
```

<br />

## `math::min`

The `math::min` function returns the least number from an array of numbers.

```surql title="API DEFINITION"
math::min(array<number>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "13.746189f"

*/

RETURN math::min([ 26.164, 13.746189, 23, 16.4, 41.42 ]);
-- 13.746189f
```

See also:

* [`array::min`](/docs/surrealql/functions/database/array#arraymin), which extracts the least value from an array of values
* [`time::min`](/docs/surrealql/functions/database/time#timemin), which extracts the least datetime from an array of datetimes

## `math::mode`

The `math::mode` function returns the value that occurs most often in a set of numbers. In case of a tie, the highest one is returned.

```surql title="API DEFINITION"
math::mode(array<number>) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "901"

[[test.results]]
value = "2"

*/

RETURN math::mode([ 1, 40, 60, 10, 2, 901 ]);
-- 901

RETURN math::mode([ 1, 40, 60, 10, 2, 901, 2 ]);
-- 2
```

<br />

## `math::nearestrank`

The `math::nearestrank` function returns the nearestrank of an array of numbers.

```surql title="API DEFINITION"
math::nearestrank(array<number>, number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "40"

*/

RETURN math::nearestrank([1, 40, 60, 10, 2, 901], 50);
-- 40
```

<br />

## `math::neg_inf`

The `math::neg_inf` constant represents negative infinity.

```surql title="API DEFINITION"
math::neg_inf -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "-Infinity"

*/

RETURN math::neg_inf;

-Infinity
```

<br />

## `math::percentile`

The `math::percentile` function returns the value below which a percentage of data falls.

```surql title="API DEFINITION"
math::percentile(array<number>, number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "25f"

*/

RETURN math::percentile([1, 40, 60, 10, 2, 901], 50);
-- 25f
```

<br />

## `math::pi`

The `math::pi` constant represents the mathematical constant π.

```surql title="API DEFINITION"
math::pi -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "3.141592653589793f"

*/

RETURN math::pi;
-- 3.141592653589793f
```

<br />

## `math::pow`

The `math::pow` function returns a number raised to the power of a second number.

```surql title="API DEFINITION"
math::pow(number, number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1.9671513572895665f"

*/

RETURN math::pow(1.07, 10);
-- 1.9671513572895665f
```

<br />

## `math::product`

The `math::product` function returns the product of a set of numbers.

```surql title="API DEFINITION"
math::product(array<number>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "5619119.004884841f"

*/

RETURN math::product([ 26.164, 13.746189, 23, 16.4, 41.42 ]);
-- 5619119.004884841f
```

<br />

## `math::rad2deg`

<Since v="v2.0.0" />

The `math::rad2deg` function converts an angle from radians to degrees.

```surql title="API DEFINITION"
math::rad2deg(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "180f"

*/

RETURN math::rad2deg(3.141592653589793);
-- 180f
```

<br />

## `math::round`

The `math::round` function rounds a number up or down to the nearest integer.

```surql title="API DEFINITION"
math::round(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "14f"

*/

RETURN math::round(13.53124);
-- 14f
```

<br />

## `math::sign`

<Since v="v2.0.0" />

The `math::sign` function returns the sign of a number, indicating whether the number is positive, negative, or zero.
It returns 1 for positive numbers, -1 for negative numbers, and 0 for zero.

```surql title="API DEFINITION"
math::sign(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "-1"

*/

RETURN math::sign(-42);
-- -1
```

<br />

## `math::sin`

<Since v="v2.0.0" />

The `math::sin` function returns the sine of a number, which is assumed to be in radians.

```surql title="API DEFINITION"
math::sin(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.8414709848078965f"

*/

RETURN math::sin(1);
-- 0.8414709848078965f
```

<br />

## `math::spread`

The `math::spread` function returns the spread of an array of numbers.

```surql title="API DEFINITION"
math::spread(array<number>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "900"

*/

RETURN math::spread([ 1, 40, 60, 10, 2, 901 ]);
-- 900
```

<br />

## `math::sqrt`

The `math::sqrt` function returns the square root of a number.

```surql title="API DEFINITION"
math::sqrt(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "3.872983346207417f"

*/

RETURN math::sqrt(15);
-- 3.872983346207417f
```

<br />

## `math::sqrt_2`

The `math::sqrt_2` constant represents the square root of 2.

```surql title="API DEFINITION"
math::sqrt_2 -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1.4142135623730951f"

*/

RETURN math::sqrt_2;
-- 1.4142135623730951f
```

<br />

## `math::stddev`

The `math::stddev` function calculates how far a set of numbers are away from the mean.

```surql title="API DEFINITION"
math::stddev(array<number>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "359.37167389765153f"

*/

RETURN math::stddev([ 1, 40, 60, 10, 2, 901 ]);
-- 359.37167389765153f
```

As of SurrealDB 3.0.0-alpha.11, this function can be used [inside a table view](/docs/surrealql/statements/select#mathstddev-and-mathvariance-in-table-views).

```surql
DEFINE TABLE person SCHEMALESS;
DEFINE TABLE person_stats AS
	SELECT
		count(),
		age,
		math::stddev(score) AS score_stddev
	FROM person
	GROUP BY age;
```

<br />

## `math::sum`

The `math::sum`  function returns the total sum of a set of numbers.

```surql title="API DEFINITION"
math::sum(array<number>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "120.73018900000001f"

*/

RETURN math::sum([ 26.164, 13.746189, 23, 16.4, 41.42 ]);

-- 120.730189
```

This function on its own expects a numeric value at each point in an array, meaning that on its own it will not be able to be used on an array that contains `NONE` or `NULL` values.

```surql
/**[test]

[[test.results]]
error = "Incorrect arguments for function math::sum(). Argument 1 was the wrong type. Expected `number` but found `NONE` when coercing an element of `array<number>`"

*/

math::sum([0, NONE, 10dec, 10.7, NULL]);

-- Error: Incorrect arguments for function math::sum().
-- Argument 1 was the wrong type.
-- Expected `number` but found `NONE` when coercing an element of `array<number>`
```

However, `NONE` and `NULL` can be coalesced into a default value by using the `??` operator (the "null coalescing operator").

```surql
/**[test]

[[test.results]]
value = "0"

[[test.results]]
value = "1000"

*/

NONE ?? 0; -- Finds NONE so returns latter value: 0
1000 ?? 0; -- Finds 1000 so returns 1000 instead of 0
```

Inside an array the [`array::map()`](/docs/surrealql/functions/database/array#arraymap) function can be used to ensure that each value is the number 0 if a `NONE` or `NULL` is encountered.

Classic [array filtering](/docs/surrealql/datamodel/arrays#mapping-and-filtering-on-arrays) can also be used to simply remove any `NONE` or `NULL` values before `math::sum()` is called.

```surql
/**[test]

[[test.results]]
value = "[10dec, 10.7f]"

[[test.results]]
value = "[0, 0, 10dec, 10.7f, 0]"

*/

// Classic array filtering, removes NONE / NULL
[0,NONE,10dec,10.7,NULL][? $this];
// array::map() function, turns NONE / NULL to 0
[0, NONE, 10dec, 10.7, NULL].map(|$num| $num ?? 0);
```

With this mapping in place, `math::sum()` will be guaranteed to work.

```surql
/**[test]

[[test.results]]
value = "20.7dec"

[[test.results]]
value = "20.7dec"

*/

// Classic array filtering
math::sum([0,NONE,10dec,10.7,NULL][? $this]);
// array::map() function
math::sum([0, NONE, 10dec, 10.7, NULL].map(|$num| $num ?? 0));

-- 20.7dec
```

<br />

## `math::tan`

<Since v="v2.0.0" />

The `math::tan` function returns the tangent of a number, which is assumed to be in radians.

```surql title="API DEFINITION"
math::tan(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1.557407724654902f"

*/

RETURN math::tan(1);
-- 1.557407724654902f
```

<br />

## `math::tau`

The `math::tau` constant represents the mathematical constant τ, which is equal to 2π.

```surql title="API DEFINITION"
math::tau -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "6.283185307179586f"

*/

RETURN math::tau;
-- 6.283185307179586f
```

<br />

## `math::top`

The `math::top` function returns the top of an array of numbers.

```surql title="API DEFINITION"
math::top(array<number>, number) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[40, 901, 60]"

*/

RETURN math::top([1, 40, 60, 10, 2, 901], 3);
-- [40, 901, 60]
```

<br />

## `math::trimean`

The `math::trimean` function returns the trimean of an array of numbers.

```surql title="API DEFINITION"
math::trimean(array<number>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "27.25f"

*/

RETURN math::trimean([ 1, 40, 60, 10, 2, 901 ]);
-- 27.25f
```

<br />

## `math::variance`

The `math::variance` function returns the variance of an array of numbers.

```surql title="API DEFINITION"
math::variance(array<number>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "129148f"

*/

RETURN math::variance([ 1, 40, 60, 10, 2, 901 ]);
-- 129148
```

As of SurrealDB 3.0.0-alpha.11, this function can be used [inside a table view](/docs/surrealql/statements/select#mathstddev-and-mathvariance-in-table-views).

```surql
DEFINE TABLE person SCHEMALESS;
DEFINE TABLE person_stats AS
	SELECT
		count(),
		age,
		math::variance(score) AS score_variance
	FROM person
	GROUP BY age;
```

<br /><br />



================================================
FILE: src/content/doc-surrealql/functions/database/meta.mdx
================================================
---
sidebar_position: 13
sidebar_label: Meta functions
title: Meta functions | SurrealQL
description: These functions can be used to retrieve specific metadata from a SurrealDB Record ID.
---

import Since from '@components/shared/Since.astro'

# Meta functions

> [!NOTE]
> As of version 2.0, these functions are now part of SurrealDB's [record](/docs/surrealql/functions/database/record) functions.


These functions can be used to retrieve specific metadata from a SurrealDB Record ID.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#metaid"><code>meta::id()</code></a></td>
      <td scope="row" data-label="Description">Extracts and returns the identifier from a SurrealDB Record ID</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#metatb"><code>meta::tb()</code></a></td>
      <td scope="row" data-label="Description">Extracts and returns the table name from a SurrealDB Record ID</td>
    </tr>
  </tbody>
</table>

## `meta::id`

The `meta::id` function extracts and returns the identifier from a SurrealDB Record ID.

```surql title="API DEFINITION"
meta::id(record) -> value
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN meta::id(person:tobie);

"tobie"
```

<br />

## `meta::tb`

The `meta::tb` function extracts and returns the table name from a SurrealDB Record ID.

```surql title="API DEFINITION"
meta::tb(record) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN meta::tb(person:tobie);

"person"
```

This function can also be called using the path `meta::table`.

```surql
RETURN meta::table(person:tobie);

"person"
```

<br /><br />



================================================
FILE: src/content/doc-surrealql/functions/database/not.mdx
================================================
---
sidebar_position: 14
sidebar_label: Not function
title: Not function | SurrealQL
description: This function can be used to reverse the truthiness of a value.
---

# Not function

This function can be used to reverse the truthiness of a value.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#not"><code>not()</code></a></td>
      <td scope="row" data-label="Description">Reverses the truthiness of a value.</td>
    </tr>
  </tbody>
</table>

## `not`

The `not` function reverses the truthiness of a value. It is functionally identical to `!`, the [NOT](/docs/surrealql/operators#not) operator.

```surql title="API DEFINITION"
not(any) -> bool
```

```surql
/**[test]

[[test.results]]
value = "false"

*/

RETURN not("I speak the truth");
-- false
```

A value is not [truthy](/docs/surrealql/datamodel/values#values-and-truthiness) if it is NONE, NULL, false, empty, or has a value of 0. As such, all the following return `true`.

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

*/

RETURN [
    not(""),
    not(false),
    not([]),
    not({}),
    not(0)
];
```

Similarly, the function can be used twice to determine whether a value is truthy or not. As each item in the example below is truthy, calling `not()` twice will return the value `true` for each.

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

*/

RETURN [
    not(not("I have value")),
    not(not(true)),
    not(not(["value!"])),
    not(not({i_have: "value"})),
    not(not(100))
];
```

Doubling the `!` operator is functionally identical to the above and is a more commonly seen pattern.

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

*/

RETURN [
    !!"I have value",
    !!true,
    !!["value!"],
    !!{i_have: "value"},
    !!100
];
```

<br /><br />



================================================
FILE: src/content/doc-surrealql/functions/database/object.mdx
================================================
---
sidebar_position: 15
sidebar_label: Object functions
title: Object functions | SurrealQL
description: These functions can be used when working with, and manipulating data objects.
---
import Since from '@components/shared/Since.astro'

# Object functions

These functions can be used when working with, and manipulating data objects.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#objectentries"><code>object::entries()</code></a></td>
      <td scope="row" data-label="Description">Transforms an object into an array with arrays of key-value combinations.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#objectextend"><code>object::extend()</code></a></td>
      <td scope="row" data-label="Description">Extends an object with the content of another one.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#objectfrom_entries"><code>object::from_entries()</code></a></td>
      <td scope="row" data-label="Description">Transforms an array with arrays of key-value combinations into an object.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#objectis_empty"><code>object::is_empty()</code></a></td>
      <td scope="row" data-label="Description">Checks if an object is empty</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#objectkeys"><code>object::keys()</code></a></td>
      <td scope="row" data-label="Description">Returns an array with all the keys of an object.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#objectlen"><code>object::len()</code></a></td>
      <td scope="row" data-label="Description">Returns the amount of key-value pairs an object holds.</td>
    </tr>
<tr>
      <td scope="row" data-label="Function"><a href="#objectremove"><code>object::remove()</code></a></td>
      <td scope="row" data-label="Description">Removes one or more fields from an object.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#objectvalues"><code>object::values()</code></a></td>
      <td scope="row" data-label="Description">Returns an array with all the values of an object.</td>
    </tr>
  </tbody>
</table>

## `object::entries`

<Since v="v1.1.0" />

The `object::entries` function transforms an object into an array with arrays of key-value combinations.

```surql title="API DEFINITION"
object::entries(object) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[['a', 1], ['b', true]]"

*/

RETURN object::entries({
  a: 1,
  b: true
});
```

```surql title="Response"
[
  [ 'a', 1 ],
  [ 'b', true ],
]
```

<br />

## `object::extend`

<Since v="v3.0.0-alpha.3" />

The `object::extend` function extends an object with the fields and values of another one, essentially adding the two together.

```surql title="API DEFINITION"
object::extend(object, object) -> object
```

An example of the function, resulting in one new field (`gold`) and one updated field (`last_updated`) in the final output.

```surql
/**[test]

[[test.results]]
value = "{ gold: 100, last_updated: d'2025-10-07T02:36:30.164629Z', name: 'Mat Cauthon' }"
skip-datetime = true

*/

{ name: "Mat Cauthon", last_updated: d'2013-01-08'}.extend( 
{ gold: 100, last_updated: time::now() });
```

```surql title="Output"
{
	gold: 100,
	last_updated: d'2025-05-07T06:15:00.768Z',
	name: 'Mat Cauthon'
}
```

Note: the same behaviour can also be achieved using the `+` operator.

```surql
/**[test]

[[test.results]]
value = "{ gold: 100, last_updated: d'2025-10-07T02:36:44.494879Z', name: 'Mat Cauthon' }"
skip-datetime = true

*/

{ name: "Mat Cauthon", last_updated: d'2013-01-08'} + 
{ gold: 100, last_updated: time::now() };
```

<br />

## `object::from_entries`

<Since v="v1.1.0" />

The `object::from_entries` function transforms an array with arrays of key-value combinations into an object.

```surql title="API DEFINITION"
object::from_entries(array) -> object
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "{ a: 1, b: true }"

*/

RETURN object::from_entries([
  [ "a", 1 ],
  [ "b", true ],
]);
```

```surql title="Response"
{
  a: 1,
  b: true
}
```

## `object::is_empty`

<Since v="v2.2.0" />

The `object::is_empty` function checks whether the object contains values.

```surql title="API DEFINITION"
object::is_empty(object) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql title="An object that contain values"
/**[test]

[[test.results]]
value = "false"

*/

RETURN {
  name: "Aeon",
  age: 20
}.is_empty();

-- false
```

```surql title="An empty object"
/**[test]

[[test.results]]
value = "true"

*/

RETURN object::is_empty({});

-- true
```

Example of `.is_empty()` being used in a [`DEFINE FIELD`](/docs/surrealql/statements/define/field#asserting-rules-on-fields) statement to disallow empty objects:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
match = "$error = Found {  } for field `metadata`, with record `house:.*`, but field must conform to: !$value.is_empty()'"
error = true

[[test.results]]
value = "[{ id: house:ur51z2flendqdp3i130o, metadata: { floors: 5 } }]"
skip-record-id-key = true

*/

DEFINE FIELD metadata
  ON house
  TYPE object
  ASSERT !$value.is_empty();
CREATE house SET metadata = {};
CREATE house SET metadata = { floors: 5 };
```

```surql title="Output"
-------- Query --------

'Found {  } for field `metadata`, with record `house:aei2fms2jccm46ceib8l`, but field must conform to: !$value.is_empty()'

-------- Query --------

[
	{
		id: house:g126ct3m0scbkockq32u,
		metadata: {
			floors: 5
		}
	}
]
```

## `object::keys`

<Since v="v1.1.0" />

The `object::keys` function returns an array with all the keys of an object.

```surql title="API DEFINITION"
object::keys(object) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "['a', 'b']"

*/

RETURN object::keys({
  a: 1,
  b: true
});

-- [ 'a', 'b' ]
```

<br />

## `object::len`

<Since v="v1.1.0" />

The `object::len` function returns the amount of key-value pairs an object holds.

```surql title="API DEFINITION"
object::len(object) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "2"

*/

RETURN object::len({
  a: 1,
  b: true
});

-- 2
```

## `object::remove`

<Since v="v3.0.0-alpha.3" />

The `object::remove` function removes one or more fields from an object.

```surql title="API DEFINITION"
object::remove(object, string|array<string>) -> object
```

A single string can be used to remove a single field from an object, while an array of strings can be used to remove one or more fields at a time.

```surql
/**[test]

[[test.results]]
value = "{ last_updated: d'2013-01-08T00:00:00Z', name: 'Mat Cauthon' }"

[[test.results]]
value = "{ name: 'Mat Cauthon' }"

*/

{ name: "Mat Cauthon", last_updated: d'2013-01-08', gold: 100 }.remove("gold");
{ name: "Mat Cauthon", last_updated: d'2013-01-08', gold: 100 }.remove(["gold", "last_updated"]);
```

```surql title="Output"
-------- Query 1 --------

{
	last_updated: d'2013-01-08T00:00:00Z',
	name: 'Mat Cauthon'
}

-------- Query 2 --------

{
	name: 'Mat Cauthon'
}
```

## `object::values`

<Since v="v1.1.0" />

The `object::values` function returns an array with all the values of an object.

```surql title="API DEFINITION"
object::values(object) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, true]"

*/

RETURN object::values({
  a: 1,
  b: true
});

-- [1, true]
```

<br /><br />

## Method chaining

<Since v="v2.0.0" />

Method chaining allows functions to be called using the `.` dot operator on a value of a certain type instead of the full path of the function followed by the value.

```surql
/**[test]

[[test.results]]
value = "[1, true]"

[[test.results]]
value = "[1, true]"

*/

-- Traditional syntax
object::values({
  a: 1,
  b: true
});

-- Method chaining syntax
{
  a: 1,
  b: true
}.values();
```

```surql title="Response"
[
  1,
  true
]
```

This is particularly useful for readability when a function is called multiple times.

```surql
/**[test]

[[test.results]]
value = "2"

[[test.results]]
value = "2"

*/

-- Traditional syntax
array::max(object::values(object::from_entries([["a", 1], ["b", 2]])));

-- Method chaining syntax
object::from_entries([["a", 1], ["b", 2]]).values().max();
```

```surql title="Response"
2
```



================================================
FILE: src/content/doc-surrealql/functions/database/parse.mdx
================================================
---
sidebar_position: 16
sidebar_label: Parse functions
title: Parse functions | SurrealQL
description: These functions can be used when parsing email addresses and URL web addresses.
---

# Parse functions

These functions can be used when parsing email addresses and URL web addresses.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#parseemailhost"><code>parse::&#8203;email::host()</code></a></td>
      <td scope="row" data-label="Description">Parses and returns an email host from an email address</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#parseemailuser"><code>parse::&#8203;email::user()</code></a></td>
      <td scope="row" data-label="Description">Parses and returns an email username from an email address</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#parseurldomain"><code>parse::url::domain()</code></a></td>
      <td scope="row" data-label="Description">Parses and returns the domain from a URL</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#parseurlfragment"><code>parse::url::fragment()</code></a></td>
      <td scope="row" data-label="Description">Parses and returns the fragment from a URL</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#parseurlhost"><code>parse::url::host()</code></a></td>
      <td scope="row" data-label="Description">Parses and returns the hostname from a URL</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#parseurlpath"><code>parse::url::path()</code></a></td>
      <td scope="row" data-label="Description">Parses and returns the path from a URL</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#parseurlport"><code>parse::url::port()</code></a></td>
      <td scope="row" data-label="Description">Parses and returns the port number from a URL</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#parseurlscheme"><code>parse::url::scheme()</code></a></td>
      <td scope="row" data-label="Description">Parses and returns the scheme from a URL</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#parseurlquery"><code>parse::url::query()</code></a></td>
      <td scope="row" data-label="Description">Parses and returns the query string from a URL</td>
    </tr>
  </tbody>
</table>

## `parse::email::host`

The `parse::email::host` function parses and returns an email host from a valid email address.

```surql title="API DEFINITION"
parse::email::host(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'surrealdb.com'"

*/

RETURN parse::email::host("info@surrealdb.com");

-- 'surrealdb.com'
```

<br />

## `parse::email::user`

The `parse::email::user` function parses and returns an email username from a valid email address.

```surql title="API DEFINITION"
parse::email::user(string) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'info'"

*/

RETURN parse::email::user("info@surrealdb.com");

-- "info"
```

<br />

## `parse::url::domain`

The `parse::url::domain` function parses and returns domain from a valid URL.
This function is similar to `parse::url::host` only that it will return `null` if the URL is an IP address.

```surql title="API DEFINITION"
parse::url::domain(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'surrealdb.com"

[[test.results]]
value = 'NONE'

*/

RETURN parse::url::domain("https://surrealdb.com:80/features?some=option#fragment");
RETURN parse::url::domain("http://127.0.0.1/index.html");
```

```surql title="Response"
"surrealdb.com"

NONE
```

<br />

## `parse::url::fragment`

The `parse::url::fragment` function parses and returns the fragment from a valid URL.

```surql title="API DEFINITION"
parse::url::fragment(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'fragment'"

*/

RETURN parse::url::fragment("https://surrealdb.com:80/features?some=option#fragment");

-- 'fragment'
```

<br />

## `parse::url::host`

The `parse::url::host` function parses and returns the hostname from a valid URL.

```surql title="API DEFINITION"
parse::url::host(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'surrealdb.com'"

[[test.results]]
value = "'127.0.0.1'"

*/

RETURN parse::url::host("https://surrealdb.com:80/features?some=option#fragment");
RETURN parse::url::host("http://127.0.0.1/index.html");
```

```surql title="Response"
'surrealdb.com'

'127.0.0.1'
```

<br />

## `parse::url::path`

The `parse::url::path`  function parses and returns the path from a valid URL.

```surql title="API DEFINITION"
parse::url::path(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'/features'"

*/

RETURN parse::url::path("https://surrealdb.com:80/features?some=option#fragment");

-- '/features'
```

<br />

## `parse::url::port`

The `parse::url::port` function parses and returns the port from a valid URL.

```surql title="API DEFINITION"
parse::url::port(string) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "80"

*/

RETURN parse::url::port("https://surrealdb.com:80/features?some=option#fragment");

-- 80
```

<br />

## `parse::url::scheme`

The `parse::url::scheme` function parses and returns the scheme from a valid URL, in lowercase, as an ASCII string without the ':' delimiter.

```surql title="API DEFINITION"
parse::url::scheme(string) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'https'"

*/

RETURN parse::url::scheme("https://surrealdb.com:80/features?some=option#fragment");

-- 'https'
```

<br />

## `parse::url::query`

The `parse::url::query` function parses and returns the query from a valid URL.

```surql title="API DEFINITION"
parse::url::query(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'some=option'"

*/

RETURN parse::url::query("https://surrealdb.com:80/features?some=option#fragment");

-- 'some=option'
```

<br /><br />



================================================
FILE: src/content/doc-surrealql/functions/database/rand.mdx
================================================
---
sidebar_position: 17
sidebar_label: Rand functions
title: Rand functions | SurrealQL
description: These functions can be used when generating random data values.
---
import Since from '@components/shared/Since.astro'

# Rand functions

These functions can be used when generating random data values.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#rand"><code>rand()</code></a></td>
      <td scope="row" data-label="Description">Generates and returns a random floating point number</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#randbool"><code>rand::bool()</code></a></td>
      <td scope="row" data-label="Description">Generates and returns a random boolean</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#randduration"><code>rand::duration()</code></a></td>
      <td scope="row" data-label="Description">Generates and returns a random duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#randenum"><code>rand::enum()</code></a></td>
      <td scope="row" data-label="Description">Randomly picks a value from the specified values</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#randfloat"><code>rand::float()</code></a></td>
      <td scope="row" data-label="Description">Generates and returns a random floating point number</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#randid"><code>rand::id()</code></a></td>
      <td scope="row" data-label="Description">Generates and returns a random id</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#randint"><code>rand::int()</code></a></td>
      <td scope="row" data-label="Description">Generates and returns a random integer</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#randstring"><code>rand::string()</code></a></td>
      <td scope="row" data-label="Description">Generates and returns a random string</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#randtime"><code>rand::time()</code></a></td>
      <td scope="row" data-label="Description">Generates and returns a random datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#randuuid"><code>rand::uuid()</code></a></td>
      <td scope="row" data-label="Description">Generates and returns a random UUID</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#randuuidv4"><code>rand::uuid::v4()</code></a></td>
      <td scope="row" data-label="Description">Generates and returns a random Version 4 UUID</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#randuuidv7"><code>rand::uuid::v7()</code></a></td>
      <td scope="row" data-label="Description">Generates and returns a random Version 7 UUID</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#randulid"><code>rand::ulid()</code></a></td>
      <td scope="row" data-label="Description">Generates and returns a random ULID</td>
    </tr>
  </tbody>
</table>

## `rand`

The rand function generates a random [`float`](/docs/surrealql/datamodel/numbers#floating-point-numbers), between 0 and 1.

```surql title="API DEFINITION"
rand() -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN rand();

0.7062321084863658
```
The following example shows this function being used in a [`SELECT`](/docs/surrealql/statements/select) statement with an `ORDER BY` clause:

```surql
SELECT * FROM [{ age: 33 }, { age: 45 }, { age: 39 }] ORDER BY rand();


[
	{
		age: 45
	},
	{
		age: 39
	},
	{
		age: 33
	}
]
```

<br />

## `rand::bool`

The rand::bool function generates a random [`boolean`](/docs/surrealql/datamodel/booleans) value.

```surql title="API DEFINITION"
rand::bool() -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN rand::bool();

true
```

<br />

## `rand::duration`

<Since v="v2.3.0" />

The rand::duration function generates a random [`duration`](/docs/surrealql/datamodel/datetimes#durations-and-datetimes) value between two `duration` arguments.

```surql title="API DEFINITION"
rand::bool(duration, duration) -> duration
```

Some examples of the function in use:

```surql
rand::duration(1ns, 1ms);

rand::duration(0ns, duration::max);
```

```surql title="Output"
-------- Query 1 --------
435µs884ns

-------- Query 2 --------
405337457164y36w2d5h54m8s16ms76µs191ns
```

<br />

## `rand::enum`

The `rand::enum` function generates a random value, from a multitude of values.



```surql title="API DEFINITION"
rand::enum(value...) -> any
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN rand::enum('one', 'two', 3, 4.15385, 'five', true);

"five"
```

<br />

## `rand::float`

The `rand::float` function generates a random [`float`](/docs/surrealql/datamodel/numbers#floating-point-numbers), between `0` and `1`.



```surql title="API DEFINITION"
rand::float() -> float
```
If two numbers are provided, then the function generates a random [`float`](/docs/surrealql/datamodel/numbers#floating-point-numbers), between two numbers.

```surql title="API DEFINITION"
rand::float(number, number) -> float
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN rand::float();

0.7812733136200293
```
```surql
RETURN rand::float(10, 15);

11.305355983514927
```

<br />

## `rand::id`

> [!NOTE]
> This function was known as `rand::guid` in versions of SurrrealDB before 3.0.0-alpha.11. The behaviour has not changed.

The `rand::id` function generates a random alphanumeric ID, defaulting to a length of 20 characters.

```surql title="API DEFINITION"
rand::id() -> string
```

If a number is provided, then the function generates a random ID with a specific length.

```surql title="API DEFINITION"
rand::id(number) -> string
```

If a second number is provided, then the function will generate a random id, with a length between the two numbers.

```surql title="API DEFINITION"
rand::id(min, max) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql title="Default 20-char random id"
RETURN rand::id();

'4uqmrmtjhtjeg77et0dl'
```

```surql title="A 10-char random id"
RETURN rand::id(10);

'f3b6cjh0nt'
```

```surql title="A random id with a length between 1 and 9 chars"
RETURN rand::id(1, 9);

'894bqt4lp'
```

This function is used for default record ID keys in SurrealDB, and can be overridden to use a ULID or UUID instead by affixing `:ulid()` and `:uuid()` after the table name, respectively.

```surql
CREATE 
  person,
  person:ulid(),
  person:uuid()
-- Return only id values for nicer output
RETURN VALUE id;
```

Output:

```surql
[
	person:o9s1sl3ivckuxo0kglix,
	person:01K7JRP6KVAQGN2THR2T13X9WP,
	person:u'0199e58b-1a7b-7880-ad5b-01671678c11f'
]
```

<br />

## `rand::int`

The `rand::int`  function generates a random int.



```surql title="API DEFINITION"
rand::int() -> int
```
If two numbers are provided, then the function generates a random int, between two numbers.

```surql title="API DEFINITION"
rand::int(number, number) -> int
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN rand::int();

6841551695902514727
```
```surql
RETURN rand::int(10, 15);

13
```

<br />

## `rand::string`

The `rand::string` function generates a random string, with 32 characters.

```surql title="API DEFINITION"
rand::string() -> string
```
The `rand::string` function generates a random string, with a specific length.

```surql title="API DEFINITION"
rand::string(number) -> string
```

If two numbers are provided, then the function generates a random string, with a length between two numbers.

```surql title="API DEFINITION"
rand::string(number, number) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN rand::string();

"N8Q86mklN6U7kv0A2XCRh5UlpQMSvdoT"
```
```surql
RETURN rand::string(15);

"aSCtrfJj4pSJ7Xq"
```
```surql
RETURN rand::string(10, 15);

"rEUWFUMcx0YH"
```

<br />

## `rand::time`

The `rand::time` function generates a random [`datetime`](/docs/surrealql/datamodel/datetimes).

```surql title="API DEFINITION"
rand::time() -> datetime
rand::time(datetime|number, datetime|number) -> datetime
```

The rand::time function generates a random [`datetime`](/docs/surrealql/datamodel/datetimes), either a completely random datetime when no arguments are passed in, or between two unix timestamps.

```surql
RETURN rand::time();

-- d'1327-07-12T01:00:32Z'

RETURN rand::time(198371, 1223138713);

-- d'1991-01-13T23:27:17Z'
```

<Since v="v2.2.0" />

This function can take two datetimes, returning a random datetime in between the least and greatest of the two.

```surql
RETURN rand::time(d'1970-01-01', d'2000-01-01');

-- d'1999-05-29T17:02:16Z"
```

<Since v="v2.3.0" />

Either of the arguments of this function can now be either a number or a datetime.

```surql
RETURN rand::time(0, d'1990-01-01');

-- d'1986-11-17T15:06:01Z'
```

As of this version, this function returns a datetime between 0000-01-01T00:00:00Z and 9999-12-31T23:59:59Z. Before this, the function returned a random datetime between 1970-01-01T00:00:00Z (0 seconds after the UNIX epoch) and +262142-12-31T23:59:59Z (the maximum possible value for a `datetime`).

## `rand::uuid`

The `rand::uuid` function generates a random UUID. You can also generate uuids from datetime values.

```surql title="API DEFINITION"
rand::uuid() -> uuid
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN rand::uuid();

[u"e20b2836-e689-4643-998d-b17a16800323"]
```

### `rand::uuid` from timestamp

<Since v="v2.0.0" />

The `rand::uuid` function generates a random UUID from a datetime type.

```surql title="API DEFINITION"
rand::uuid(datetime) -> uuid
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN rand::uuid(d"2021-09-07T04:27:53Z");
```

```surql
CREATE ONLY test:[rand::uuid()] SET created = time::now(), num = 1;
SLEEP 100ms;

LET $rec = CREATE ONLY test:[rand::uuid()] SET created = time::now(), num = 2;
SLEEP 100ms;
CREATE ONLY test:[rand::uuid()] SET created = time::now(), num = 3;
-- Select the value of the record created before the current record in the table
SELECT VALUE num FROM test:[rand::uuid($rec.created - 100ms)]..;
  ```

<br />

## `rand::uuid::v4`

The `rand::uuid::v4` function generates a random version 4 UUID.

```surql title="API DEFINITION"
rand::uuid::v4() -> uuid
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN rand::uuid::v4();

[u"4def23a5-a847-4934-8dad-c64ccc48921b"]
```

### `rand::uuid::v4` from timestamp

<Since v="v2.0.0" />

The `rand::uuid::v4` function generates a random version 4 UUID from a datetime type.

```surql title="API DEFINITION"
rand::uuid::v4(datetime) -> uuid
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN rand::uuid::v4(d"2021-09-07T04:27:53Z");
```

```surql
CREATE ONLY test:[rand::uuid::v4()] SET created = time::now(), num = 1;
SLEEP 100ms;

LET $rec = CREATE ONLY test:[rand::uuid::v4()] SET created = time::now(), num = 2;
SLEEP 100ms;
CREATE ONLY test:[rand::uuid::v4()] SET created = time::now(), num = 3;
-- Select the value of the record created before the current record in the table
SELECT VALUE num FROM test:[rand::uuid::v4($rec.created - 100ms)]..;
  ```

<br />

## `rand::uuid::v7`

The `rand::uuid::v7` function generates a random Version 7 UUID.

```surql title="API DEFINITION"
rand::uuid::v7() -> uuid
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN rand::uuid::v7();

[u'0190d9df-c6cd-7e8a-aae2-aa3a162507ed']
```

### `rand::uuid::v7` from timestamp

<Since v="v2.0.0" />

The `rand::uuid::v7` function generates a random  Version 7  UUID from a datetime type.

```surql title="API DEFINITION"
rand::uuid::v7(datetime) -> uuid
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN rand::uuid::v7(d"2021-09-07T04:27:53Z");
```

```surql
CREATE ONLY test:[rand::uuid::v7()] SET created = time::now(), num = 1;
SLEEP 100ms;

LET $rec = CREATE ONLY test:[rand::uuid::v7()] SET created = time::now(), num = 2;
SLEEP 100ms;
CREATE ONLY test:[rand::uuid::v7()] SET created = time::now(), num = 3;
-- Select the value of the record created before the current record in the table
SELECT VALUE num FROM test:[rand::uuid::v7($rec.created - 100ms)]..;
  ```

To enable `rand::uuid::v7` in [embedded mode](/docs/surrealdb/embedding/rust) you need to add the following to your `.cargo/config.toml` file in your project

```toml
[build]
rustflags = ["--cfg", "uuid_unstable"]
```

<br />

## `rand::ulid`

The `rand::ulid` function generates a random ULID.

```surql title="API DEFINITION"
rand::ulid() -> ulid
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN rand::ulid();

[u"01H9QDG81Q7SB33RXB7BEZBK7G"]
```

### `rand::ulid` from timestamp

<Since v="v2.0.0" />

The `rand::ulid` function generates a random ULID from a datetime type.

```surql title="API DEFINITION"
rand::ulid(datetime) -> ulid
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN rand::ulid(d"2021-09-07T04:27:53Z");
```

```surql
CREATE ONLY test:[rand::ulid()] SET created = time::now(), num = 1;
SLEEP 100ms;

LET $rec = CREATE ONLY test:[rand::ulid()] SET created = time::now(), num = 2;
SLEEP 100ms;
CREATE ONLY test:[rand::ulid()] SET created = time::now(), num = 3;
-- Select the value of the record created before the current record in the table
SELECT VALUE num FROM test:[rand::ulid($rec.created - 100ms)]..;
  ```


<br /><br />



================================================
FILE: src/content/doc-surrealql/functions/database/record.mdx
================================================
---
sidebar_position: 18
sidebar_label: Record functions
title: Record functions | SurrealQL
description: These functions can be used to retrieve specific metadata from a SurrealDB Record ID.
---

import Since from '@components/shared/Since.astro'

# Record functions

> [!NOTE]
> Record functions before SurrealDB 2.0 were located inside the module [meta](/docs/surrealql/functions/database/meta). Their behaviour has not changed.

These functions can be used to retrieve specific metadata from a SurrealDB Record ID.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#recordexists"><code>record::exists()</code></a></td>
      <td scope="row" data-label="Description">Checks to see if a SurrealDB Record ID exists</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#recordid"><code>record::id()</code></a></td>
      <td scope="row" data-label="Description">Extracts and returns the identifier from a SurrealDB Record ID</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#recordtb"><code>record::tb()</code></a></td>
      <td scope="row" data-label="Description">Extracts and returns the table name from a SurrealDB Record ID</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#recordrefs"><code>record::refs()</code></a></td>
      <td scope="row" data-label="Description">Extracts and returns the record IDs of any records that have a record link along with a `REFERENCES` clause</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#recordis_edge"><code>record::is_edge()</code></a></td>
      <td scope="row" data-label="Description">Identifies whether the value passed in is a graph edge</td>
    </tr>
  </tbody>
</table>

## `record::exists`

The `record::exists` function checks to see if a given record exists.

```surql title="API DEFINITION"
record::exists(record) -> bool
```

A simple example showing the output of this function when a record does not exist and when it does:

```surql
/**[test]

[[test.results]]
value = "false"

[[test.results]]
value = "[{ id: person:tobie }]"

[[test.results]]
value = "true"

*/

RETURN record::exists(r"person:tobie");
-- false

CREATE person:tobie;
RETURN record::exists(r"person:tobie");
-- true
```

A longer example of `record::exists` using method syntax:

```surql
/**[test]

[[test.results]]
value = "false"

*/

FOR $person IN ["Haakon_VII", "Ferdinand_I", "Manuel_II", "Wilhelm_II", "George_I", "Albert_I", "Alfonso_XIII", "George_V", "Frederick_VIII"] {
    LET $record_name = type::record("person", $person.lowercase());
    IF !$record_name.exists() {
        CREATE $record_name;
    }
}
```

## `record::id`

The `record::id` function extracts and returns the identifier from a SurrealDB Record ID.

```surql title="API DEFINITION"
record::id(record) -> value
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'tobie'"

*/

RETURN record::id(person:tobie);

'tobie'
```

## `record::tb`

The `record::tb` function extracts and returns the table name from a SurrealDB Record ID.

```surql title="API DEFINITION"
record::tb(record) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'person'"

*/

RETURN record::tb(person:tobie);

-- 'person'
```

<br /><br />

## `record::is_edge`

<Since v="v3.0.0-alpha.8" />

The `record::is_edge` function checks to see if the value passed in is a graph edge.

```surql title="API DEFINITION"
record::is::edge(record | string) -> bool
```

```surql
/**[test]

[[test.results]]
value = "[{ id: likes:first_like, in: person:one, out: person:two }]"

[[test.results]]
value = "true"

[[test.results]]
value = "true"

*/

RELATE person:one->likes:first_like->person:two;

-- Both return true
record::is_edge(likes:first_like);
record::is_edge("likes:first_like");
```

## Method chaining

<Since v="v2.0.0" />

Method chaining allows functions to be called using the `.` dot operator on a value of a certain type instead of the full path of the function followed by the value.

```surql
/**[test]

[[test.results]]
value = "'aeon'"

[[test.results]]
value = "'aeon'"

*/

-- Traditional syntax
record::id(r"person:aeon");

-- Method chaining syntax
r"person:aeon".id();
```

```surql title="Response"
'aeon'
```

This is particularly useful for readability when a function is called multiple times.

```surql
/**[test]

[[test.results]]
value = "'person'"

[[test.results]]
value = "'person'"

*/

-- Traditional syntax
record::table(array::max([r"person:aeon", r"person:landevin"]));

-- Method chaining syntax
[r"person:aeon", r"person:landevin"].max().table();
```

```surql title="Response"
'person'
```



================================================
FILE: src/content/doc-surrealql/functions/database/search.mdx
================================================
---
sidebar_position: 19
sidebar_label: Search functions
title: Search functions | SurrealQL
description: These functions are used in conjunction with the 'matches' operator to either collect the relevance score or highlight the searched keywords within the content.
---

import Since from '@components/shared/Since.astro'

# Search functions

These functions are used in conjunction with the [`@@` operator (the 'matches' operator)](/docs/surrealql/operators#matches) to either collect the relevance score or highlight the searched keywords within the content.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#searchanalyze"><code>search::analyze()</code></a></td>
      <td scope="row" data-label="Description">Returns the output of a defined search analyzer</td>
    </tr>
      <td scope="row" data-label="Function"><a href="#searchhighlight"><code>search::highlight()</code></a></td>
      <td scope="row" data-label="Description">Highlights the matching keywords</td>
    <tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#searchlinear"><code>search::linear()</code></a></td>
      <td scope="row" data-label="Description"><Since v="v3.0.0-alpha.8" /> Performs weighted linear search</td>
    </tr>
      <td scope="row" data-label="Function"><a href="#searchoffsets"><code>search::offsets()</code></a></td>
      <td scope="row" data-label="Description">Returns the position of the matching keywords</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#searchrrf"><code>search::rrf()</code></a></td>
      <td scope="row" data-label="Description"><Since v="v3.0.0-alpha.8" /> Performs RRF (reciprocal rank fusion) search</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#searchscore"><code>search::score()</code></a></td>
      <td scope="row" data-label="Description">Returns the relevance score</td>
    </tr>
  </tbody>
</table>

<br/>

> [!NOTE]
> Before SurrealDB version 3.0.0-alpha.8, the `FULLTEXT ANALYZER` clause used the syntax `SEARCH ANALYZER`.

The examples below assume the following queries:

```surql
CREATE book:1 SET title = "Rust Web Programming";
DEFINE ANALYZER book_analyzer TOKENIZERS blank, class, camel, punct FILTERS snowball(english);
DEFINE INDEX book_title ON book FIELDS title FULLTEXT ANALYZER book_analyzer BM25;
```

## `search::analyze`

The `search_analyze` function returns the outut of a defined search analyzer on an input string.

```surql title="API DEFINITION"
search::analyze(analyzer, string) -> array<string>
```

First define the analyzer using the [`DEFINE ANALYZER`](/docs/surrealql/statements/define/analyzer) statement 

```surql title="Define book analyzer"
DEFINE ANALYZER book_analyzer TOKENIZERS blank, class, camel, punct FILTERS snowball(english); 
```

Next you can pass the analyzer to the `search::analyze`function. The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN search::analyze("book_analyzer", "A hands-on guide to developing, packaging, and deploying fully functional Rust web applications");
```

```surql title="Output"
[
	'a',
	'hand',
	'-',
	'on',
	'guid',
	'to',
	'develop',
	',',
	'packag',
	',',
	'and',
	'deploy',
	'fulli',
	'function',
	'rust',
	'web',
	'applic'
]
```

## `search::highlight`

The `search::highlight` function highlights the matching keywords for the predicate reference number.

```surql title="API DEFINITION"
search::highlight(string, string, number, [boolean]) -> string | string[]
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
SELECT id, search::highlight('<b>', '</b>', 1) AS title
	FROM book WHERE title @1@ 'rust web';
```

```surql title="Output"
[
	{
		id: book:1,
		title: [ '<b>Rust</b> <b>Web</b> Programming' ]
	}
]
```

The optional Boolean parameter can be set to `true` to explicitly request that the whole found term be highlighted,
or set to `false` to highlight only the sequence of characters we are looking for. This must be used with an `edgengram` or `ngram` filter.
The default value is true.

<br />

## `search::linear`

```surql title="API DEFINITION"
search::linear(lists: array, weights: array, limit: int, norm: 'minmax' | 'zscore') -> array<object>
```

Notes on the arguments and output of this function:

- **Input**:
  - `lists` - array of result arrays. Each inner array must be pre‑sorted most‑relevant‑first (BM25 score descending, distance ascending already inverted, etc.).
  - `weights` - An array of numeric weights corresponding to each result(must have same length as results)
  - `limit` - Maximum number of documents to return (must be ≥ 1)
  - `norm` - Normalization method: "minmax" for MinMax normalization or "zscore" for Z-score normalization
- **Processing:**
  - Computes the union of all candidate ids.
  - The function automatically extracts scores from documents using the following priority:
    1. `distance` field - converted using `1.0 / (1.0 + distance)` (lower distance = higher score)
    2. `ft_score` field - used directly (full-text search scores)
    3. `score` field - used directly (generic scores)
    4. Rank-based fallback - `1.0 / (1.0 + rank)` if no score field is found
  - Normalization Methods:
    - **MinMax**: Scales scores to [0,1] range using `(score - min) / (max - min)`
    - **Z-score**: Standardizes scores using `(score - mean) / std_dev`
  - When merging field data from the per‑list rows, keeps the first non‑null value encountered in the order the lists were supplied, or the last one if there are several fields with the same key.
  - Sorts by `linear_score` descending and truncates to limit.
- **Output:**
  - Array of merged result objects, each containing original fields and an added fuse_score.


```surql
/**[test]

[[test.results]]
value = "[{ embedding: [0.1f, 0.2f, 0.3f], id: test:1, text: 'Graph databases are great.' }]"

[[test.results]]
value = "[{ embedding: [0.05f, 0.1f, 0f], id: test:2, text: 'Relational databases store tables.' }]"

[[test.results]]
value = "[{ embedding: [0.2f, 0.1f, 0.25f], id: test:3, text: 'This document mentions graphs and networks.' }]"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: test:1, linear_score: 2f, score: 0.5366538763046265f }, { id: test:3, linear_score: 0f }]"

[[test.results]]
value = "[{ id: test:1, linear_score: 2f, score: 0.5366538763046265f }, { id: test:3, linear_score: -2f }]"

*/

-- Sample data --
CREATE test:1 SET text = "Graph databases are great.", embedding = [0.10, 0.20, 0.30];
CREATE test:2 SET text = "Relational databases store tables.", embedding = [0.05, 0.10, 0.00];
CREATE test:3 SET text = "This document mentions graphs and networks.", embedding = [0.20, 0.10, 0.25];

-- Analyzer used by the full‑text index
DEFINE ANALYZER simple TOKENIZERS class, punct FILTERS lowercase, ascii;

-- Full‑text index
DEFINE INDEX idx_text ON TABLE test FIELDS text FULLTEXT ANALYZER simple BM25;

-- Vector index (HNSW) on a 3‑dimensional embedding, using cosine distance
DEFINE INDEX idx_embedding ON TABLE test FIELDS embedding HNSW DIMENSION 3 DIST COSINE;

-- Query vector (whatever your embedding model produced for "graph databases")
LET $qvec = [0.12, 0.18, 0.27];

-- Vector search: top 2 nearest neighbours
LET $vs = SELECT id FROM test  WHERE embedding <|2,100|> $qvec;

-- Full‑text search: top 2 lexical matches
LET $ft = SELECT id, search::score(1) as score FROM test
          WHERE text @1@ 'graph' ORDER BY score DESC LIMIT 2;

-- Fuse with Linear / minmax
search::linear([$vs, $ft], [2, 1], 2, 'minmax');

-- Fuse with Linear / zscore
search::linear([$vs, $ft], [2, 1], 2, 'zscore');
```

Output of the final search::linear() queries:

```surql
-------- Query 1 --------

[
	{
		ft_score: 0.5366538763046265f,
		id: test:1,
		linear_score: 2
	},
	{
		id: test:3,
		linear_score: 0
	}
]

-------- Query 2 --------

[
	{
		score: 0.5366538763046265f,
		id: test:1,
		linear_score: 1.9999999999999956f
	},
	{
		id: test:3,
		linear_score: -2.0000000000000044f
	}
]
```

## `search::offsets`

The `search::offsets` function returns the position of the matching keywords for the predicate reference number.

```surql title="API DEFINITION"
search::offsets(number, [boolean]) -> object
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
SELECT id, title, search::offsets(1) AS title_offsets
	FROM book WHERE title @1@ 'rust web';
```

```surql title="Output"
[
	{
		id: book:1,
		title: [ 'Rust Web Programming' ],
		title_offsets: {
			0: [
				{ e: 4, s: 0 },
				{ e: 8, s: 5 }
			]
		}
	}
]
```

The output returns the start `s` and end `e` positions of each matched term found within the original field.

The full-text index is capable of indexing both single strings and arrays of strings. In this example, the key `0` indicates that we're highlighting the first string within the `title` field, which contains an array of strings.

The optional Boolean parameter can be set to `true` to explicitly request that the whole found term be highlighted,
or set to `false` to highlight only the sequence of characters we are looking for. This must be used with an `edgengram` or `ngram` filter.

The default value is true.

<br />

## `search::rrf`

```surql title="API DEFINITION"
search::rrf(lists: array, limit: int, k: option<int>) -> array<object>
```

Notes on the arguments and output of this function:

- **Input**:
  - lists: array of result arrays. Each inner array must be pre‑sorted most‑relevant‑first (BM25 score descending, distance ascending already inverted, etc.).
  - limit: maximum number of fused results to return.
  - k (optional): RRF constant; defaults to 60.

See [this paper](https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf) for why 60 tends to be the default `k` value:

> Our intuition in choosing this formula derived from fact that while highly-ranked documents are more important, the importance of lower-ranked documents does not vanish as it would were, say, an exponential function used. The constant `k` mitigates the impact of high rankings by outlier systems.

- **Processing:**
  - Computes the union of all candidate ids.
  -  For each candidate, derives its rank in each list and computes `rff_score = Σ 1/(k + rank)`.
  - When merging field data from the per‑list rows, keeps the first non‑null value encountered in the order the lists were supplied, or the last one if there are several fields with the same key.
  - Sorts by `rff_score` descending and truncates to limit.
- **Output:**
  - Array of merged result objects, each containing original fields and an added fuse_score.

```surql
/**[test]

[[test.results]]
value = "[{ embedding: [0.1f, 0.2f, 0.3f], id: test:1, text: 'Graph databases are great.' }]"

[[test.results]]
value = "[{ embedding: [0.05f, 0.1f, 0f], id: test:2, text: 'Relational databases store tables.' }]"

[[test.results]]
value = "[{ embedding: [0.2f, 0.1f, 0.25f], id: test:3, text: 'This document mentions graphs.' }]"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: test:1, rrf_score: 0.03278688524590164f, score: 0.5108256340026855f }, { id: test:3, rrf_score: 0.016129032258064516f }]"

*/

-- Sample data --
CREATE test:1 SET text = "Graph databases are great.", embedding = [0.10, 0.20, 0.30];
CREATE test:2 SET text = "Relational databases store tables.", embedding = [0.05, 0.10, 0.00];
CREATE test:3 SET text = "This document mentions graphs.", embedding = [0.20, 0.10, 0.25];

-- Analyzer used by the full‑text index
DEFINE ANALYZER simple TOKENIZERS class, punct FILTERS lowercase, ascii;

-- Full‑text index
DEFINE INDEX idx_text ON TABLE test FIELDS text FULLTEXT ANALYZER simple BM25;

-- Vector index (HNSW) on a 3‑dimensional embedding, using cosine distance
DEFINE INDEX idx_embedding ON TABLE test FIELDS embedding HNSW DIMENSION 3 DIST COSINE;

-- Query vector (whatever your embedding model produced for "graph databases")
LET $qvec = [0.12, 0.18, 0.27];

-- Vector search: top 2 nearest neighbours
LET $vs = SELECT id FROM test  WHERE embedding <|2,100|> $qvec;

-- Full‑text search: top 2 lexical matches
LET $ft = SELECT id, search::score(1) as score FROM test
          WHERE text @1@ 'graph' ORDER BY score DESC LIMIT 2;

-- Fuse with Reciprocal Rank Fusion (k defaults to 60 if omitted)
search::rrf([$vs, $ft], 2, 60);
```

Output of the final search::rrf() query:

```surql
[
	{
		score: 0.5366538763046265f,
		id: test:1,
		rrf_score: 0.03278688524590164f
	},
	{
		id: test:3,
		rrf_score: 0.016129032258064516f
	}
];
```

## `search::score`

The `search::score` function returns the relevance score corresponding to the given 'matches' predicate reference numbers.

```surql title="API DEFINITION"
search::score(number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
SELECT id, title, search::score(1) AS score FROM book
	WHERE title @1@ 'rust web'
	ORDER BY score DESC;
```

```surql title="Output"
[
	{
		id: book:1,
		score: 0.9227996468544006,
		title: [ 'Rust Web Programming' ],
	}
]
```

<br />



<br /><br />


================================================
FILE: src/content/doc-surrealql/functions/database/sequence.mdx
================================================
---
sidebar_position: 20
sidebar_label: Sequence functions
title: Sequence functions | SurrealQL
description: Functions to work with sequences.
---

import Since from '@components/shared/Since.astro'

# Sequence functions

<Since v="v3.0.0-alpha.2" />

These functions can be used to work with [sequences](/docs/surrealql/statements/define/sequence).

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#sequencenext"><code>sequence::next()</code></a></td>
      <td scope="row" data-label="Description">Returns the next value in a sequence.</td>
    </tr>
  </tbody>
</table>

## `sequence::next`

The `sequence::next` function returns the next value in a sequence.

```surql title="API DEFINITION"
sequence::next(sequence_name) -> int
```

```surql 
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "100"

*/

DEFINE SEQUENCE mySeq2 BATCH 1000 START 100 TIMEOUT 5s;
sequence::nextval('mySeq2');

-- 100
```



================================================
FILE: src/content/doc-surrealql/functions/database/session.mdx
================================================
---
sidebar_position: 21
sidebar_label: Session functions
title: Session functions | SurrealQL
description: These functions return information about the current SurrealDB session.
---
import Since from '@components/shared/Since.astro'

# Session functions

These functions return information about the current SurrealDB session.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#sessionac"><code>session::ac()</code></a></td>
      <td scope="row" data-label="Description">Returns the current user's access method</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#sessiondb"><code>session::db()</code></a></td>
      <td scope="row" data-label="Description">Returns the currently selected database</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#sessionid"><code>session::id()</code></a></td>
      <td scope="row" data-label="Description">Returns the current user's session ID</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#sessionip"><code>session::ip()</code></a></td>
      <td scope="row" data-label="Description">Returns the current user's session IP address</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#sessionns"><code>session::ns()</code></a></td>
      <td scope="row" data-label="Description">Returns the currently selected namespace</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#sessionorigin"><code>session::origin()</code></a></td>
      <td scope="row" data-label="Description">Returns the current user's HTTP origin</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#sessionrd"><code>session::rd()</code></a></td>
      <td scope="row" data-label="Description">Returns the current user's record authentication data</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#sessiontoken"><code>session::token()</code></a></td>
      <td scope="row" data-label="Description">Returns the current user's authentication token</td>
    </tr>
  </tbody>
</table>

## `session::ac`

<Since v="v2.0.0" />

> [!NOTE]
> This function was known as `session::sc` in versions of SurrrealDB before 2.0. The behaviour has not changed.

The `session::ac` function returns the current user's access method.

```surql title="API DEFINITION"
session::ac() -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN session::ac();

"user"
```

<br /><br />

## `session::db`

The `session::db` function returns the currently selected database.

```surql title="API DEFINITION"
session::db() -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN session::db();

"my_db"
```

<br />

## `session::id`

The `session::id` function returns the current user's session ID.

```surql title="API DEFINITION"
session::id() -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN session::id();

"I895rKuixHwCNIduyBIYH2M0Pga7oUmWnng5exEE4a7EB942GVElGrnRhE5scF5d"
```

<br />

## `session::ip`

The `session::ip` function returns the current user's session IP address.

```surql title="API DEFINITION"
session::ip() -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN session::ip();

"2001:db8:3333:4444:CCCC:DDDD:EEEE:FFFF"
```

<br />

## `session::ns`

The `session::ns` function returns the currently selected namespace.

```surql title="API DEFINITION"
session::ns() -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN session::ns();

"my_ns"
```

<br />

## `session::origin`

The `session::origin` function returns the current user's HTTP origin.

```surql title="API DEFINITION"
session::origin() -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN session::origin();

"http://localhost:3000"
```

<br />

## `session::rd`

<Since v="v2.0.0" />

The `session::rd` function returns the current user's record authentication.

```surql title="API DEFINITION"
session::rd() -> string
```

## `session::token`

The `session::token` function returns the current authentication token.

```surql title="API DEFINITION"
session::token() -> string
```

<br />



================================================
FILE: src/content/doc-surrealql/functions/database/sleep.mdx
================================================
---
sidebar_position: 22
sidebar_label: Sleep function
title: Sleep function | SurrealQL
description: This function can be used to introduce a delay or pause in the execution of a query or a batch of queries for a specific amount of time.
---

# Sleep function

This function can be used to introduce a delay or pause in the execution of a query or a batch of queries for a specific amount of time.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#sleep"><code>sleep()</code></a></td>
      <td scope="row" data-label="Description">Delays or pauses in the execution of a query or a batch of queries.</td>
    </tr>
  </tbody>
</table>

## `sleep`

The `sleep` function delays or pauses the execution of a query or a set of statements.

```surql title="API DEFINITION"
sleep(duration) -> none
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN sleep(1s);
RETURN sleep(500ms);
```

SurrealDB also has a [SLEEP statement](/docs/surrealql/statements/sleep) statement that accepts a datetime; however, the `sleep` function can be used in more dynamic ways such as the following example that simulates a 100ms delay between each record in a query.

```surql
-- Create 3 `person` records
CREATE |person:3|;

LET $now = time::now();

SELECT *, 
  sleep(100ms) AS _, 
  time::now() - $now AS elapsed
FROM person;
```

```surql title="Response"
[
	{
		_: NONE,
		elapsed: 101ms457µs,
		id: person:fkgvriz1kl2tcgv6yqfq
	},
	{
		_: NONE,
		elapsed: 203ms599µs,
		id: person:lgibwdgtvx4v8ck60guk
	},
	{
		_: NONE,
		elapsed: 305ms728µs,
		id: person:pr0uby896y1az2p44wtw
	}
]
```

## SLEEP during parallel operations

The `sleep()` function does not interfere with operations that are underway in the background, such as a [`DEFINE INDEX`](/docs/surrealql/statements/define/indexes) statement using the `CONCURRENTLY` clause.

```surql
CREATE |user:50000| SET name = id.id() RETURN NONE;
DEFINE INDEX unique_name ON TABLE user FIELDS name UNIQUE CONCURRENTLY;
INFO FOR INDEX unique_name ON TABLE user;√
RETURN sleep(50ms);
INFO FOR INDEX unique_name ON TABLE user;
RETURN sleep(50ms);
INFO FOR INDEX unique_name ON TABLE user;
RETURN sleep(50ms);
INFO FOR INDEX unique_name ON TABLE user;
```

```surql title="Possible output"
-------- Query 1 --------
{ 
    building: {
        initial: 0,
        pending: 0,
        status: 'indexing', 
        updated: 0
    }
}

-------- Query 2 --------
{ 
    building: {
        initial: 100,
        pending: 20,
        status: 'indexing', 
        updated: 0
    }
}

-------- Query 3 --------
{ 
    building: {
        initial: 100,
        pending: 4,
        status: 'indexing', 
        updated: 16
    }
}

-------- Query 4 --------
{
    building: {
        status: 'ready'
    }
}
```

## Use cases

Putting a database to sleep can be useful in a small number of situations, such as:

* Testing and debugging: can be used to understand how concurrent transactions interact, test how systems handle timeouts and delays, simulate behaviour in more distant regions with longer latency
* Throttling: can be used to throttle the execution of operations to prevent the database from being overwhelmed by too many requests at once
* Security measures: can be used to slow down the response rate of login attempts to mitigate the risk of brute force attacks



================================================
FILE: src/content/doc-surrealql/functions/database/string.mdx
================================================
---
sidebar_position: 23
sidebar_label: String functions
title: String functions | SurrealQL
description: These functions can be used when working with and manipulating text and string values.
---

import Since from '@components/shared/Since.astro'
import Table from '@components/shared/Table.astro'
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# String Functions

> [!NOTE]
> Since version 3.0.0-alpha.8, the `::is::` functions (e.g. `string::is::domain()`) now use underscores (e.g. `string::is_domain()`) to better match the intent of the function and method syntax.

These functions can be used when working with and manipulating text and string values.

<Table>
  <thead>
    <tr>
      <th >Function</th>
      <th >Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="#stringcapitalize"><code>string::capitalize()</code></a></td>
      <td>Capitalizes each word of a string</td>
    </tr>
    <tr>
      <td><a href="#stringconcat"><code>string::concat()</code></a></td>
      <td>Concatenates strings together</td>
    </tr>
    <tr>
      <td><a href="#stringcontains"><code>string::contains()</code></a></td>
      <td>Checks whether a string contains another string</td>
    </tr>
    <tr>
      <td><a href="#stringends_with"><code>string::ends_with()</code></a></td>
      <td>Checks whether a string ends with another string</td>
    </tr>
    <tr>
      <td><a href="#stringjoin"><code>string::join()</code></a></td>
      <td>Joins strings together with a delimiter</td>
    </tr>
    <tr>
      <td><a href="#stringlen"><code>string::len()</code></a></td>
      <td>Returns the length of a string</td>
    </tr>
    <tr>
      <td><a href="#stringlowercase"><code>string::lowercase()</code></a></td>
      <td>Converts a string to lowercase</td>
    </tr>
    <tr>
      <td><a href="#stringmatches"><code>string::matches()</code></a></td>
      <td>Performs a regex match on a string</td>
    </tr>
    <tr>
      <td><a href="#stringrepeat"><code>string::repeat()</code></a></td>
      <td>Repeats a string a number of times</td>
    </tr>
    <tr>
      <td><a href="#stringreplace"><code>string::replace()</code></a></td>
      <td>Replaces an occurrence of a string with another string</td>
    </tr>
    <tr>
      <td><a href="#stringreverse"><code>string::reverse()</code></a></td>
      <td>Reverses a string</td>
    </tr>
    <tr>
      <td><a href="#stringslice"><code>string::slice()</code></a></td>
      <td>Extracts and returns a section of a string</td>
    </tr>
    <tr>
      <td><a href="#stringslug"><code>string::slug()</code></a></td>
      <td>Converts a string into human and URL-friendly string</td>
    </tr>
    <tr>
      <td><a href="#stringsplit"><code>string::split()</code></a></td>
      <td>Divides a string into an ordered list of substrings</td>
    </tr>
    <tr>
      <td><a href="#stringstarts_with"><code>string::starts_with()</code></a></td>
      <td>Checks whether a string starts with another string</td>
    </tr>
    <tr>
      <td><a href="#stringtrim"><code>string::trim()</code></a></td>
      <td>Removes whitespace from the start and end of a string</td>
    </tr>
    <tr>
      <td><a href="#stringuppercase"><code>string::uppercase()</code></a></td>
      <td>Converts a string to uppercase</td>
    </tr>
    <tr>
      <td><a href="#stringwords"><code>string::words()</code></a></td>
      <td>Splits a string into an array of separate words</td>
    </tr>
    <tr>
      <td><a href="#stringdistancedamerau_levenshtein"><code>string::distance::damerau_levenshtein()</code></a></td>
      <td>Returns the Damerau–Levenshtein distance between two strings</td>
    </tr>
    <tr>
      <td><a href="#stringdistancenormalizeddamerau_levenshtein"><code>string::distance::normalized_damerau_levenshtein()</code></a></td>
      <td>Returns the normalized Damerau–Levenshtein distance between two strings</td>
    </tr>    
    <tr>
      <td><a href="#stringdistancehamming"><code>string::distance::hamming()</code></a></td>
      <td>Returns the Hamming distance between two strings</td>
    </tr>
    <tr>
      <td><a href="#stringdistancelevenshtein"><code>string::distance::levenshtein()</code></a></td>
      <td>Returns the Levenshtein distance between two strings</td>
    </tr>
    <tr>
      <td><a href="#stringdistancenormalized_levenshtein"><code>string::distance::normalized_levenshtein()</code></a></td>
      <td>Returns the normalized Levenshtein distance between two strings</td>
    </tr>
    <tr>
      <td><a href="#stringdistanceosa_distance"><code>string::distance::osa()</code></a></td>
      <td>Returns the OSA (Optimal String Alignment) distance between two strings</td>
    </tr>
    <tr>
      <td><a href="#stringhtmlencode"><code>string::html::encode()</code></a></td>
      <td>Encodes special characters into HTML entities to prevent HTML injection</td>
    </tr>
    <tr>
      <td><a href="#stringhtmlsanitize"><code>string::html::sanitize()</code></a></td>
      <td>Sanitizes HTML code to prevent the most dangerous subset of HTML injection</td>
    </tr>
    <tr>
      <td><a href="#stringis_alphanum"><code>string::is_alphanum()</code></a></td>
      <td>Checks whether a value has only alphanumeric characters</td>
    </tr>
    <tr>
      <td><a href="#stringis_alpha"><code>string::is_alpha()</code></a></td>
      <td>Checks whether a value has only alpha characters</td>
    </tr>
    <tr>
      <td><a href="#stringis_ascii"><code>string::is_ascii()</code></a></td>
      <td>Checks whether a value has only ascii characters</td>
    </tr>
    <tr>
      <td><a href="#stringis_datetime"><code>string::is_datetime()</code></a></td>
      <td>Checks whether a string representation of a date and time matches a specified format</td>
    </tr>
    <tr>
      <td><a href="#stringis_domain"><code>string::is_domain()</code></a></td>
      <td>Checks whether a value is a domain</td>
    </tr>
    <tr>
      <td><a href="#stringis_email"><code>string::is_email()</code></a></td>
      <td>Checks whether a value is an email</td>
    </tr>
    <tr>
      <td><a href="#stringis_hexadecimal"><code>string::is_hexadecimal()</code></a></td>
      <td>Checks whether a value is hexadecimal</td>
    </tr>
    <tr>
      <td><a href="#stringis_ip"><code>string::is_ip()</code></a></td>
      <td>Checks whether a value is an IP address</td>
    </tr>
    <tr>
      <td><a href="#stringis_ipv4"><code>string::is_ipv4()</code></a></td>
      <td>Checks whether a value is an IP v4 address</td>
    </tr>
    <tr>
      <td><a href="#stringis_ipv6"><code>string::is_ipv6()</code></a></td>
      <td>Checks whether a value is an IP v6 address</td>
    </tr>
    <tr>
      <td><a href="#stringis_latitude"><code>string::is_latitude()</code></a></td>
      <td>Checks whether a value is a latitude value</td>
    </tr>
    <tr>
      <td><a href="#stringis_longitude"><code>string::is_longitude()</code></a></td>
      <td>Checks whether a value is a longitude value</td>
    </tr>
    <tr>
      <td><a href="#stringis_numeric"><code>string::is_numeric()</code></a></td>
      <td>Checks whether a value has only numeric characters</td>
    </tr>
    <tr>
      <td><a href="#stringis_record"><code>string::is_record()</code></a></td>
      <td>Checks whether a string is a Record ID, optionally of a certain table</td>
    </tr>
    <tr>
      <td><a href="#stringis_semver"><code>string::is_semver()</code></a></td>
      <td>Checks whether a value matches a semver version</td>
    </tr>
    <tr>
      <td><a href="#stringis_ulid"><code>string::is_ulid()</code></a></td>
      <td>Checks whether a string is a ULID</td>
    </tr>
    <tr>
      <td><a href="#stringis_url"><code>string::is_url()</code></a></td>
      <td>Checks whether a value is a valid URL</td>
    </tr>
    <tr>
      <td><a href="#stringis_uuid"><code>string::is_uuid()</code></a></td>
      <td>Checks whether a string is a UUID</td>
    </tr>
    <tr>
      <td><a href="#stringsemvercompare"><code>string::semver::compare()</code></a></td>
      <td>Performs a comparison between two semver strings</td>
    </tr>
    <tr>
      <td><a href="#stringsemvermajor"><code>string::semver::major()</code></a></td>
      <td>Extract the major version from a semver string</td>
    </tr>
    <tr>
      <td><a href="#stringsemverminor"><code>string::semver::minor()</code></a></td>
      <td>Extract the minor version from a semver string</td>
    </tr>
    <tr>
      <td><a href="#stringsemverpatch"><code>string::semver::patch()</code></a></td>
      <td>Extract the patch version from a semver string</td>
    </tr>
    <tr>
      <td><a href="#stringsemverincmajor"><code>string::semver::inc::major()</code></a></td>
      <td>Increment the major version of a semver string</td>
    </tr>
    <tr>
      <td><a href="#stringsemverincminor"><code>string::semver::inc::minor()</code></a></td>
      <td>Increment the minor version of a semver string</td>
    </tr>
    <tr>
      <td><a href="#stringsemverincpatch"><code>string::semver::inc::patch()</code></a></td>
      <td>Increment the patch version of a semver string</td>
    </tr>
    <tr>
      <td><a href="#stringsemversetmajor"><code>string::semver::set::major()</code></a></td>
      <td>Set the major version of a semver string</td>
    </tr>
    <tr>
      <td><a href="#stringsemversetminor"><code>string::semver::set::minor()</code></a></td>
      <td>Set the minor version of a semver string</td>
    </tr>
    <tr>
      <td><a href="#stringsemversetpatch"><code>string::semver::set::patch()</code></a></td>
      <td>Set the patch version of a semver string</td>
    </tr>
    <tr>
      <td><a href="#stringsimilarityfuzzy"><code>string::similarity::fuzzy()</code></a></td>
      <td>Return the similarity score of fuzzy matching strings</td>
    </tr>
    <tr>
      <td><a href="#stringsimilarityjaro"><code>string::similarity::jaro()</code></a></td>
      <td>Returns the Jaro similarity between two strings</td>
    </tr>
    <tr>
      <td><a href="#stringsimilarityjarowinkler"><code>string::similarity::jaro_winkler()</code></a></td>
      <td>Return the Jaro-Winkler similarity between two strings</td>
    </tr>
  </tbody>
</Table>

## `string::capitalize`

<Since v="v3.0.0-alpha.11" />

The `string::capitalize` function capitalizes the first letter of each word in a string.

```surql title="API DEFINITION"
string::capitalize(string, ...) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
string::capitalize("how to cook for forty humans");

-- 'How To Cook For Forty Humans'
```

<br />

## `string::concat`

The `string::concat` function concatenates strings together.

```surql title="API DEFINITION"
string::concat(string, ...) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'this is a test'"

*/

RETURN string::concat('this', ' ', 'is', ' ', 'a', ' ', 'test');

-- 'this is a test'
```

<br />

## `string::contains`

The `string::contains`  function checks whether a string contains another string.

```surql title="API DEFINITION"
string::contains(string, string) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::contains('abcdefg', 'cde');

-- true
```

<br />

## `string::ends_with`

<Since v="v2.0.0" />

> [!NOTE]
> This function was known as `string::endsWith` in versions of SurrrealDB before 2.0. The behaviour has not changed.

The `string::ends_with` function checks whether a string ends with another string.

```surql title="API DEFINITION"
string::ends_with(string, string) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::ends_with('some test', 'test');

-- true
```

<br />

## `string::join`

The `string::join` function joins strings together with a delimiter.

If you want to join an array of strings use [`array::join`](/docs/surrealql/functions/database/array#arrayjoin).

```surql title="API DEFINITION"
string::join(string, string...) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'a, list, of, items'"

*/

RETURN string::join(', ', 'a', 'list', 'of', 'items');

-- "a, list, of, items"
```

<br />

## `string::len`

The `string::len` function returns the length of a given string in characters.

```surql title="API DEFINITION"
string::len(string) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "14"

*/

RETURN string::len('this is a test');

-- 14
```

<br />

## `string::lowercase`

The `string::lowercase` function converts a string to lowercase.

```surql title="API DEFINITION"
string::lowercase(string) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'this is a test'"

*/

RETURN string::lowercase('THIS IS A TEST');

-- 'this is a test'
```

<br />

## `string::matches`

The `string::matches` function performs a regex match on a string.

```surql title="API DEFINITION"
string::matches(string, string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

*/

RETURN [
  string::matches("grey", "gr(a|e)y"),
  string::matches("gray", "gr(a|e)y")
];

-- [true, true]
```

<br />

## `string::repeat`

The `string::repeat` function repeats a string a number of times.

```surql title="API DEFINITION"
string::repeat(string, number) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'testtesttest'"

*/

RETURN string::repeat('test', 3);

-- 'testtesttest'
```

<br />

## `string::replace`

The `string::replace`  function replaces an occurrence of a string with another string.

<Tabs>
  <TabItem label="Before 2.3" default>

```surql title="API DEFINITION"
string::replace(string, string, string) -> string
```

  </TabItem>

  <TabItem label="After 2.3" default>
```surql title="API DEFINITION"
string::replace(string, string|regex, string) -> string
```
  </TabItem>
</Tabs>

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'this is awesome'"

*/

RETURN string::replace('this is a test', 'a test', 'awesome');

-- 'this is awesome'
```

With [`regexes`](/docs/surrealql/datamodel/regex) added as a data type in version 2.3, the second argument can also be a regex instead of a string.

```surql
/**[test]

[[test.results]]
value = "'Mny lnggs nly s cnsnnts n thr wrtng'"

*/

RETURN string::replace('Many languages only use consonants in their writing', <regex>'a|e|i|o|u', '');
```

```surql title="Output"
'Mny lnggs nly s cnsnnts n thr wrtng'
```

<br />

## `string::reverse`

The `string::reverse`  function reverses a string.

```surql title="API DEFINITION"
string::reverse(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'tset a si siht'"

*/

RETURN string::reverse('this is a test');

-- 'tset a si siht'
```

<br />

## `string::slice`

The `string::slice` function extracts and returns a section of a string.

```surql title="API DEFINITION"
string::slice(string, number, number) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
RETURN string::slice('this is a test', 10, 4);

"test"
```

<br />

## `string::slug`

The `string::slug`  function converts a string into a human and URL-friendly string.

```surql title="API DEFINITION"
string::slug(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'surrealdb-cloud-has-launched-database-awesome'"

*/

RETURN string::slug('SurrealDB Cloud has launched!!! #ai_native_database #awesome');

-- 'surrealdb-cloud-has-launched-ai_native_database-awesome'
```

<br />

## `string::split`

The `string::split` function splits a string by a given delimiter.

```surql title="API DEFINITION"
string::split(string, string) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "['this', 'is', 'a', 'list']"

*/

RETURN string::split('this, is, a, list', ', ');

-- ['this', 'is', 'a', 'list']
```

<br />

## `string::starts_with`

<Since v="v2.0.0" />

> [!NOTE]
> This function was known as `string::startsWith` in versions of SurrrealDB before 2.0. The behaviour has not changed.

The `string::starts_with` function checks whether a string starts with another string.

```surql title="API DEFINITION"
string::starts_with(string, string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::starts_with('some test', 'some');

-- true
```

<br />

## `string::trim`

The `string::trim` function removes whitespace from the start and end of a string.

```surql title="API DEFINITION"
string::trim(string) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'this is a test'"

*/

RETURN string::trim('    this is a test    ');

-- 'this is a test'
```

<br />

## `string::uppercase`

The `string::uppercase` function converts a string to uppercase.

```surql title="API DEFINITION"
string::uppercase(string) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'THIS IS A TEST'"

*/

RETURN string::uppercase('this is a test');

-- 'THIS IS A TEST'
```

## `string::words`

The `string::words` function splits a string into an array of separate words.

```surql title="API DEFINITION"
string::words(string) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "['this', 'is', 'a', 'test']"

*/

RETURN string::words('this is a test');

-- ['this', 'is', 'a', 'test']
```

## `string::distance::damerau_levenshtein`

<Since v="v2.1.0" />

The `string::distance::damerau_levenshtein` function returns the Damerau-Levenshtein distance between two strings.

```surql title="API DEFINITION"
string::distance::damerau_levenshtein(string, string) -> int
```

The following examples shows this function, and its output in comparison with a number of strings.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "0"

[[test.results]]
value = "7"

[[test.results]]
value = "34"

[[test.results]]
value = "38"

*/

LET $first     = "In a hole in the ground there lived a hobbit";
LET $same      = "In a hole in the ground there lived a hobbit";
LET $close     = "In a hole in the GROUND there lived a Hobbit";
LET $different = "A narrow passage holds four hidden treasures";
LET $short     = "Hi I'm Brian";

-- Returns 0
string::distance::damerau_levenshtein($first, $same);
-- Returns 7
string::distance::damerau_levenshtein($first, $close);
-- Returns 34
string::distance::damerau_levenshtein($first, $different);
-- Returns 38
string::distance::damerau_levenshtein($first, $short);
```

## `string::distance::normalized_damerau_levenshtein`

<Since v="v2.1.0" />

The `string::distance::normalized_damerau_levenshtein` function returns the normalized Damerau-Levenshtein distance between two strings. Normalized means that identical strings will return a score of 1, with less similar strings returning lower numbers as the distance grows.

```surql title="API DEFINITION"
string::distance::normalized_damerau_levenshtein(string, string) -> float
```

The following examples shows this function, and its output in comparison with a number of strings.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "1f"

[[test.results]]
value = "0.8409090909090909f"

[[test.results]]
value = "0.2272727272727273f"

[[test.results]]
value = "0.13636363636363635f"

*/

LET $first     = "In a hole in the ground there lived a hobbit";
LET $same      = "In a hole in the ground there lived a hobbit";
LET $close     = "In a hole in the GROUND there lived a Hobbit";
LET $different = "A narrow passage holds four hidden treasures";
LET $short     = "Hi I'm Brian";

-- Returns 1f
string::distance::normalized_damerau_levenshtein($first, $same);
-- Returns 0.8409090909090909f
string::distance::normalized_damerau_levenshtein($first, $close);
-- Returns 0.2272727272727273f
string::distance::normalized_damerau_levenshtein($first, $different);
-- Returns 0.13636363636363635f
string::distance::normalized_damerau_levenshtein($first, $short);
```

## `string::distance::hamming`

<Since v="v2.1.0" />

The `string::distance::hamming` function returns the Hamming distance between two strings of equal length.

```surql title="API DEFINITION"
string::distance::hamming(string, string) -> int
```

The following examples shows this function, and its output in comparison with a number of strings.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "0"

[[test.results]]
value = "7"

[[test.results]]
value = "40"

[[test.results]]
value = "'Incorrect arguments for function string::distance::hamming(). Strings must be of equal length.'"

*/

LET $first     = "In a hole in the ground there lived a hobbit";
LET $same      = "In a hole in the ground there lived a hobbit";
LET $close     = "In a hole in the GROUND there lived a Hobbit";
LET $different = "A narrow passage holds four hidden treasures";
LET $short     = "Hi I'm Brian";

-- Returns 0
string::distance::hamming($first, $same);
-- Returns 7
string::distance::hamming($first, $close);
-- Returns 40
string::distance::hamming($first, $different);
-- Error: strings must be of equal length
string::distance::hamming($first, $short);
```

## `string::distance::levenshtein`

<Since v="v2.1.0" />

The `string::distance::levenshtein` function returns the Levenshtein distance between two strings.

```surql title="API DEFINITION"
string::distance::levenshtein(string, string) -> int
```

The following examples shows this function, and its output in comparison with a number of strings.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "0"

[[test.results]]
value = "7"

[[test.results]]
value = "35"

[[test.results]]
value = "38"

*/

LET $first     = "In a hole in the ground there lived a hobbit";
LET $same      = "In a hole in the ground there lived a hobbit";
LET $close     = "In a hole in the GROUND there lived a Hobbit";
LET $different = "A narrow passage holds four hidden treasures";
LET $short     = "Hi I'm Brian";

-- Returns 0
string::distance::levenshtein($first, $same);
-- Returns 7
string::distance::levenshtein($first, $close);
-- Returns 35
string::distance::levenshtein($first, $different);
-- Returns 38
string::distance::levenshtein($first, $short);
```

## `string::distance::normalized_levenshtein`

<Since v="v2.1.0" />

The `string::distance::normalized_levenshtein` function returns the normalized Levenshtein distance between two strings. Normalized means that identical strings will return a score of 1, with less similar strings returning lower numbers as the distance grows.

```surql title="API DEFINITION"
string::distance::normalized_levenshtein(string, string) -> float
```

The following examples shows this function, and its output in comparison with a number of strings.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "1f"

[[test.results]]
value = "0.8409090909090909f"

[[test.results]]
value = "0.20454545454545459f"

[[test.results]]
value = "0.13636363636363635f"

*/

LET $first     = "In a hole in the ground there lived a hobbit";
LET $same      = "In a hole in the ground there lived a hobbit";
LET $close     = "In a hole in the GROUND there lived a Hobbit";
LET $different = "A narrow passage holds four hidden treasures";
LET $short     = "Hi I'm Brian";

-- Returns 1
string::distance::normalized_levenshtein($first, $same);
-- Returns 0.8409090909090909f
string::distance::normalized_levenshtein($first, $close);
-- Returns 0.20454545454545459f
string::distance::normalized_levenshtein($first, $different);
-- Returns 0.13636363636363635f
string::distance::normalized_levenshtein($first, $short);
```

## `string::distance::osa`

> [!NOTE]
> This function was known as `string::distance::osa_distance` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

<Since v="v2.1.0" />

The `string::distance::osa_distance` function returns the OSA (Optimal String Alignment) distance between two strings.

```surql title="API DEFINITION"
string::distance::normalized_levenshtein(string, string) -> int
```

The following examples shows this function, and its output in comparison with a number of strings.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "0"

[[test.results]]
value = "7"

[[test.results]]
value = "34"

[[test.results]]
value = "38"

*/

LET $first     = "In a hole in the ground there lived a hobbit";
LET $same      = "In a hole in the ground there lived a hobbit";
LET $close     = "In a hole in the GROUND there lived a Hobbit";
LET $different = "A narrow passage holds four hidden treasures";
LET $short     = "Hi I'm Brian";

-- Returns 0
string::distance::osa($first, $same);
-- Returns 7
string::distance::osa($first, $close);
-- Returns 34
string::distance::osa($first, $different);
-- Returns 38
string::distance::osa($first, $short);
```

## `string::html::encode`

<Since v="v2.0.0" />

The `string::html::encode` function encodes special characters into HTML entities to prevent HTML injection. It is recommended to use this function in most cases when retrieving any untrusted content that may be rendered inside of an HTML document. You can learn more about its behavior from the [original implementation](https://docs.rs/ammonia/latest/ammonia/fn.clean_text.html).

```surql title="API DEFINITION"
string::html::encode(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'&lt;h1&gt;Safe&#32;Title&lt;&#47;h1&gt;&lt;script&gt;alert(&apos;XSS&apos;)&lt;&#47;script&gt;&lt;p&gt;Safe&#32;paragraph.&#32;Not&#32;safe&#32;&lt;span&#32;onload&#61;&apos;logout()&apos;&gt;event&lt;&#47;span&gt;.&lt;&#47;p&gt;'"

*/

RETURN string::html::encode("<h1>Safe Title</h1><script>alert('XSS')</script><p>Safe paragraph. Not safe <span onload='logout()'>event</span>.</p>");

-- '&lt;h1&gt;Safe&#32;Title&lt;&#47;h1&gt;&lt;script&gt;alert(&apos;XSS&apos;)&lt;&#47;script&gt;&lt;p&gt;Safe&#32;paragraph.&#32;Not&#32;safe&#32;&lt;span&#32;onload&#61;&apos;logout()&apos;&gt;event&lt;&#47;span&gt;.&lt;&#47;p&gt;'
```

<br />

## `string::html::sanitize`

<Since v="v2.0.0" />

The `string::html::sanitize` function sanitizes HTML code to prevent the most dangerous subset of HTML injection that can lead to attacks like cross-site scripting, layout breaking or clickjacking. This function will keep any other HTML syntax intact in order to support user-generated content that needs to contain HTML styling. It is only recommended to rely on this function if you want to allow the creators of the content to have some control over its HTML styling. You can learn more about its behavior from the [original implementation](https://docs.rs/ammonia/latest/ammonia/fn.clean.html).

```surql title="API DEFINITION"
string::html::sanitize(string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'<h1>Safe Title</h1><p>Safe paragraph. Not safe <span>event</span>.</p>'"

*/

RETURN string::html::sanitize("<h1>Safe Title</h1><script>alert('XSS')</script><p>Safe paragraph. Not safe <span onload='logout()'>event</span>.</p>");

-- '<h1>Safe Title</h1><p>Safe paragraph. Not safe <span>event</span>.</p>'
```
<br />

## `string::is_alphanum`

> [!NOTE]
> This function was known as `string::is::alphanum` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `string::is_alphanum` function checks whether a value has only alphanumeric characters.

```surql title="API DEFINITION"
string::is_alphanum(string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_alphanum("ABC123");

-- true
```

<br />

## `string::is_alpha`

> [!NOTE]
> This function was known as `string::is::alpha` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `string::is_alpha` function checks whether a value has only alpha characters.

```surql title="API DEFINITION"
string::is_alpha(string) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_alpha("ABCDEF");

-- true
```

<br />

## `string::is_ascii`

> [!NOTE]
> This function was known as `string::is::ascii` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `string::is_ascii` function checks whether a value has only ascii characters.

```surql title="API DEFINITION"
string::is_ascii(string) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "false"

*/

RETURN string::is_ascii("ABC123"); -- true
'𓀀'.is_ascii(); -- false
```

<br />

## `string::is_datetime`

> [!NOTE]
> This function was known as `string::is::datetime` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `string::is_datetime` function checks whether a string representation of a date and time matches a specified format.

```surql title="API DEFINITION"
string::is_datetime(string, string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_datetime("2015-09-05 23:56:04", "%Y-%m-%d %H:%M:%S");
```

```surql title="Response"
true
```

This can be useful when validating datetimes obtained from other sources that do not use the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format.

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_datetime("5sep2024pm012345.6789", "%d%b%Y%p%I%M%S%.f");
```

```surql title="Response"
true
```

```surql
/**[test]

[[test.results]]
value = "false"

*/

RETURN string::is_datetime("23:56:00 2015-09-05", "%Y-%m-%d %H:%M");
```

```surql title="Response"
false
```

[View all format options](/docs/surrealql/datamodel/formatters)

<br />

## `string::is_domain`

> [!NOTE]
> This function was known as `string::is::domain` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `string::is_domain` function checks whether a value is a domain.

```surql title="API DEFINITION"
string::is_domain(string) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_domain("surrealdb.com");

-- true
```

<br />

## `string::is_email`

> [!NOTE]
> This function was known as `string::is::email` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `string::is_email` function checks whether a value is an email.

```surql title="API DEFINITION"
string::is_email(string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_email("info@surrealdb.com");

true
```

<br />

## `string::is_hexadecimal`

> [!NOTE]
> This function was known as `string::is::hexadecimal` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `string::is_hexadecimal` function checks whether a value is hexadecimal.

```surql title="API DEFINITION"
string::is_hexadecimal(string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_hexadecimal("ff009e");

-- true
```

<br />

## `string::is_ip`

> [!NOTE]
> This function was known as `string::is::ip` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

<Since v="v2.0.0" />

The `string::is_ip` function checks whether a value is an IP address.

```surql title="API DEFINITION"
string::is_ip(string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_ip("192.168.0.1");

-- true
```

<br />

## `string::is_ipv4`

> [!NOTE]
> This function was known as `string::is::ipv4` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

<Since v="v2.0.0" />

The `string::is_ipv4` function checks whether a value is an IP v4 address.

```surql title="API DEFINITION"
string::is_ipv4(string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_ipv4("192.168.0.1");

-- true
```

<br />

## `string::is_ipv6`

> [!NOTE]
> This function was known as `string::is::ipv6` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

<Since v="v2.0.0" />

The `string::is_ipv6` function checks whether a value is an IP v6 address.

```surql title="API DEFINITION"
string::is_ipv6(string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_ipv6("2001:0db8:85a3:0000:0000:8a2e:0370:7334");

-- true
```

<br />

## `string::is_latitude`

> [!NOTE]
> This function was known as `string::is::latitude` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `string::is_latitude` function checks whether a value is a latitude value.

```surql title="API DEFINITION"
string::is_latitude(string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_latitude("-0.118092");

-- true
```

<br />

## `string::is_longitude`

> [!NOTE]
> This function was known as `string::is::longitude` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `string::is_longitude` function checks whether a value is a longitude value.

```surql title="API DEFINITION"
string::is_longitude(string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_longitude("51.509865");

-- true
```

<br />

## `string::is_numeric`

> [!NOTE]
> This function was known as `string::is::numeric` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `string::is_numeric`function checks whether a value has only numeric characters.

```surql title="API DEFINITION"
string::is_numeric(string) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_numeric("1484091748");

-- true
```

<br />

## `string::is_semver`

> [!NOTE]
> This function was known as `string::is::semver` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `string::is_semver` function checks whether a value matches a semver version.

```surql title="API DEFINITION"
string::is_semver(string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_semver("1.0.0");

-- true
```

<br />

## `string::is_ulid`

> [!NOTE]
> This function was known as `string::is::ulid` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `string::is_ulid` function checks whether a string is a ULID.

```surql title="API DEFINITION"
string::is_ulid(string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_ulid("01JCJB3TPQ50XTG32WM088NKJD");

-- true
```

<br />

## `string::is_url`

> [!NOTE]
> This function was known as `string::is::url` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `string::is_url` function checks whether a value is a valid URL.

```surql title="API DEFINITION"
string::is_url(string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_url("https://surrealdb.com");

-- true
```

<br />

## `string::is_record`

> [!NOTE]
> This function was known as `string::is::record` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `string::is_record` function checks whether a string is a Record ID.

```surql title="API DEFINITION"
string::is_record(string, option<string | table>) -> bool
```
> [!NOTE]
> The second argument is optional and can be used to specify the table name that the record ID should belong to. If the table name is provided, the function will check if the record ID belongs to that table only.

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

[[test.results]]
value = "false"

[[test.results]]
value = "false"

*/

RETURN string::is_record("person:test");           -- true
RETURN string::is_record("person:test", "person"); -- true
RETURN string::is_record("person:test", "other");  -- false
RETURN string::is_record("not a record id");       -- false
```

<br />

## `string::is_uuid`

> [!NOTE]
> This function was known as `string::is::uuid` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `string::is_uuid` function checks whether a string is a UUID.

```surql title="API DEFINITION"
string::is_uuid(string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN string::is_uuid("018a6680-bef9-701b-9025-e1754f296a0f");

-- true
```

<br />

## `string::semver::compare`

<Since v="v1.2.0" />

The `string::semver::compare` function performs a comparison on two semver strings and returns a number.

A value of `-1` indicates the first version is lower than the second, `0` indicates both versions are equal, and `1` indicates the first version is higher than the second.

```surql title="API DEFINITION"
string::semver::compare(string, string) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "-1"

*/

RETURN string::semver::compare("1.0.0", "1.3.5");

-- -1
```

<br />

## `string::semver::major`

<Since v="v1.2.0" />

The `string::semver::major` function extracts the major number out of a semver string.

```surql title="API DEFINITION"
string::semver::major(string) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "3"

*/

RETURN string::semver::major("3.2.6");

-- 3
```

<br />

## `string::semver::minor`

<Since v="v1.2.0" />

The `string::semver::minor` function extracts the minor number out of a semver string.

```surql title="API DEFINITION"
string::semver::minor(string) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "2"

*/

RETURN string::semver::minor("3.2.6");

-- 2
```

<br />

## `string::semver::patch`

<Since v="v1.2.0" />

The `string::semver::patch` function extracts the patch number out of a semver string.

```surql title="API DEFINITION"
string::semver::patch(string) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "6"

*/

RETURN string::semver::patch("3.2.6");

-- 6
```

<br />

## `string::semver::inc::major`

<Since v="v1.2.0" />

The `string::semver::inc::major` function increments the major number of a semver string. As a result, the minor and patch numbers are reset to zero.

```surql title="API DEFINITION"
string::semver::inc::major(string) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'2.0.0'"

*/

RETURN string::semver::inc::major("1.2.3");

-- '2.0.0'
```

<br />

## `string::semver::inc::minor`

<Since v="v1.2.0" />

The `string::semver::inc::minor` function increments the minor number of a semver string. As a result, the patch number is reset to zero.

```surql title="API DEFINITION"
string::semver::inc::minor(string) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'1.3.0'"

*/

RETURN string::semver::inc::minor("1.2.3");

-- '1.3.0'
```

<br />

## `string::semver::inc::patch`

<Since v="v1.2.0" />

The `string::semver::inc::patch` function increments the patch number of a semver string.

```surql title="API DEFINITION"
string::semver::inc::patch(string) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'1.2.4'"

*/

RETURN string::semver::inc::patch("1.2.3");

-- '1.2.4'
```

<br />

## `string::semver::set::major`

<Since v="v1.2.0" />

The `string::semver::set::major` function sets the major number of a semver string without changing the minor and patch numbers.

```surql title="API DEFINITION"
string::semver::set::major(string, number) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'9.2.3'"

*/

RETURN string::semver::set::major("1.2.3", 9);

-- '9.2.3'
```

<br />

## `string::semver::set::minor`

<Since v="v1.2.0" />

The `string::semver::set::minor` function sets the minor number of a semver string without changing the major and patch numbers.

```surql title="API DEFINITION"
string::semver::set::minor(string, number) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'1.9.3'"

*/

RETURN string::semver::set::minor("1.2.3", 9);

-- '1.9.3'
```

<br />

## `string::semver::set::patch`

<Since v="v1.2.0" />

The `string::semver::set::patch` function sets the patch number of a semver string without changing the major and minor numbers.

```surql title="API DEFINITION"
string::semver::set::patch(string, number) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'1.2.9'"

*/

RETURN string::semver::set::patch("1.2.3", 9);

-- '1.2.9'
```

<br />

## `string::similarity::fuzzy`

```surql title="API DEFINITION"
string::similarity::fuzzy(string, string) -> int
```

The `string::similarity::fuzzy` function allows a comparison of similarity to be made. Any value that is greater than 0 is considered a fuzzy match.

```surql
/**[test]

[[test.results]]
value = "51"

[[test.results]]
value = "47"

*/

-- returns 51
RETURN string::similarity::fuzzy("DB", "DB");
-- returns 47
RETURN string::similarity::fuzzy("DB", "db");
```

The similarity score is not based on a single score such as 1 to 100, but is built up over the course of the algorithm used to compare one string to another and will be higher for longer strings. As a result, similarity can only be compared from a single string to a number of possible matches, but not multiple strings to a number of possible matches.

While the first two uses of the function in the following example compare identical strings, the longer string returns a much higher fuzzy score.

```surql
/**[test]

[[test.results]]
value = "51"

[[test.results]]
value = "2997"

[[test.results]]
value = "151"

*/

-- returns 51
RETURN string::similarity::fuzzy("DB", "DB");
-- returns 2997
RETURN string::similarity::fuzzy(
  "SurrealDB Cloud Beta is now live! We are excited to announce that we are inviting users from the waitlist to join. Stay tuned for your invitation!", "SurrealDB Cloud Beta is now live! We are excited to announce that we are inviting users from the waitlist to join. Stay tuned for your invitation!"
);
-- returns 151 despite nowhere close to exact match
RETURN string::similarity::fuzzy(
  "SurrealDB Cloud Beta is now live! We are excited to announce that we are inviting users from the waitlist to join. Stay tuned for your invitation!", "Surreal"
);
```

A longer example showing a comparison of similarity scores to one another:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ of: 'SurrealDB	surrealdb', score: 187 }, { of: 'SurrealDB	SurralDB', score: 165 }, { of: 'SurrealDB	Surreal', score: 151 }, { of: 'SurrealDB	real', score: 75 }, { of: 'SurrealDB	eal', score: 55 }, { of: 'SurrealDB	DB', score: 41 }]"

*/

LET $original = "SurrealDB";
LET $strings = ["SurralDB", "surrealdb", "DB", "Surreal", "real", "basebase", "eel", "eal"];

FOR $string IN $strings {
    LET $score = string::similarity::fuzzy($original, $string);
    IF $score > 0 {
        CREATE comparison SET of = $original + '\t' + $string,
        score = $score
    };
};

SELECT of, score FROM comparison ORDER BY score DESC;
```

```surql title="Response"
[
	{
		of: 'SurrealDB	surrealdb',
		score: 187
	},
	{
		of: 'SurrealDB	SurralDB',
		score: 165
	},
	{
		of: 'SurrealDB	Surreal',
		score: 151
	},
	{
		of: 'SurrealDB	real',
		score: 75
	},
	{
		of: 'SurrealDB	eal',
		score: 55
	},
	{
		of: 'SurrealDB	DB',
		score: 41
	}
]
```

## `string::similarity::jaro`

<Since v="v2.1.0" />

The `string::similarity::jaro` function returns the Jaro similarity between two strings. Two strings that are identical have a score of 1, while less similar strings will have lower scores as the distance between them increases.

```surql title="API DEFINITION"
string::similarity::jaro(string, string) -> float
```

The following examples shows this function, and its output in comparison with a number of strings.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "1f"

[[test.results]]
value = "0.8218673218673219f"

[[test.results]]
value = "0.6266233766233765f"

[[test.results]]
value = "0.4379509379509379f"

*/

LET $first     = "In a hole in the ground there lived a hobbit";
LET $same      = "In a hole in the ground there lived a hobbit";
LET $close     = "In a hole in the GROUND there lived a Hobbit";
LET $different = "A narrow passage holds four hidden treasures";
LET $short     = "Hi I'm Brian";

-- Returns 1
string::similarity::jaro($first, $same);
-- Returns 0.8218673218673219f
string::similarity::jaro($first, $close);
-- Returns 0.6266233766233765f
string::similarity::jaro($first, $different);
-- Returns 0.4379509379509379f
string::similarity::jaro($first, $short);
```

## `string::similarity::jaro_winkler`

<Since v="v2.1.0" />

The `string::similarity::jaro_winkler` function returns the Jaro-Winkler similarity between two strings. Two strings that are identical have a score of 1, while less similar strings will have lower scores as the distance between them increases.

```surql title="API DEFINITION"
string::similarity::jaro_winkler(string, string) -> float
```

The following examples shows this function, and its output in comparison with a number of strings.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "1f"

[[test.results]]
value = "0.8931203931203932f"

[[test.results]]
value = "0.6266233766233765f"

[[test.results]]
value = "0.4379509379509379f"

*/

LET $first     = "In a hole in the ground there lived a hobbit";
LET $same      = "In a hole in the ground there lived a hobbit";
LET $close     = "In a hole in the GROUND there lived a Hobbit";
LET $different = "A narrow passage holds four hidden treasures";
LET $short     = "Hi I'm Brian";

-- Returns 0
string::similarity::jaro_winkler($first, $same);
-- Returns 0.8931203931203932f
string::similarity::jaro_winkler($first, $close);
-- Returns 0.6266233766233765f
string::similarity::jaro_winkler($first, $different);
-- Returns 0.4379509379509379f
string::similarity::jaro_winkler($first, $short);
```

## Method chaining

<Since v="v2.0.0" />

Method chaining allows functions to be called using the `.` dot operator on a value of a certain type instead of the full path of the function followed by the value.

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

*/


-- Traditional syntax
string::is_alphanum("MyStrongPassword123");

-- Method chaining syntax
"MyStrongPassword123".is_alphanum();
```

```surql title="Response"
true
```

This is particularly useful for readability when a function is called multiple times.

```surql
/**[test]

[[test.results]]
value = ""I'LL SEND YOU A CHEQUE FOR THE CATALOGUE!!!!""

*/

-- Traditional syntax
string::concat(
  string::uppercase(
    string::replace(
      string::replace("I'll send you a check for the catalog", "ck", "que")
    , "og", "ogue")
  )
, "!!!!");

-- Method chaining syntax
"I'll send you a check for the catalog"
  .replace("ck", "que")
  .replace("og", "ogue")
  .uppercase()
  .concat("!!!!");
```

```surql title="Response"
"I'LL SEND YOU A CHEQUE FOR THE CATALOGUE!!!!"
```



================================================
FILE: src/content/doc-surrealql/functions/database/time.mdx
================================================
---
sidebar_position: 24
sidebar_label: Time functions
title: Time functions | SurrealQL
description: These functions can be used when working with and manipulating datetime values.
---
import Since from '@components/shared/Since.astro'

# Time Functions

> [!NOTE]
> Since version 3.0.0-alpha.8, the `::from::` functions (e.g. `time::from::millis()`) now use underscores (e.g. `time::from_millis()`) to better match the intent of the function and method syntax.

These functions can be used when working with and manipulating [datetime](/docs/surrealql/datamodel/datetimes) values.

Many time functions take an `option<datetime>` in order to return certain values from a datetime such as its hours, minutes, day of the year, and so in. If no argument is present, the current datetime will be extracted and used. As such, all of the following function calls are valid and will not return an error.

```surql
time::hour(d'2024-09-04T00:32:44.107Z');
time::hour();

time::minute(d'2024-09-04T00:32:44.107Z');
time::minute();

time::yday(d'2024-09-04T00:32:44.107Z');
time::yday();
```

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#timeceil"><code>time::ceil()</code></a></td>
      <td scope="row" data-label="Description">Rounds a datetime up to the next largest duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timeday"><code>time::day()</code></a></td>
      <td scope="row" data-label="Description">Extracts the day as a number from a datetime or current datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timeepoch"><code>time::epoch</code></a></td>
      <td scope="row" data-label="Description">Constant datetime representing the UNIX epoch</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timefloor"><code>time::floor()</code></a></td>
      <td scope="row" data-label="Description">Rounds a datetime down by a specific duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timeformat"><code>time::format()</code></a></td>
      <td scope="row" data-label="Description">Outputs a datetime according to a specific format</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timegroup"><code>time::group()</code></a></td>
      <td scope="row" data-label="Description">Groups a datetime by a particular time interval</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timehour"><code>time::hour()</code></a></td>
      <td scope="row" data-label="Description">Extracts the hour as a number from a datetime or current datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timemax"><code>time::max()</code></a></td>
      <td scope="row" data-label="Description">Returns the greatest datetime from an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timemaximum"><code>time::maximum</code></a></td>
      <td scope="row" data-label="Description">Constant representing the greatest possible datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timemicros"><code>time::micros()</code></a></td>
      <td scope="row" data-label="Description">Extracts the microseconds as a number from a datetime or current datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timemillis"><code>time::millis()</code></a></td>
      <td scope="row" data-label="Description">Extracts the milliseconds as a number from a datetime or current datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timemin"><code>time::min()</code></a></td>
      <td scope="row" data-label="Description">Returns the least datetime from an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timeminimum"><code>time::minimum</code></a></td>
      <td scope="row" data-label="Description">Constant representing the least possible datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timeminute"><code>time::minute()</code></a></td>
      <td scope="row" data-label="Description">Extracts the minutes as a number from a datetime or current datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timemonth"><code>time::month()</code></a></td>
      <td scope="row" data-label="Description">Extracts the month as a number from a datetime or current datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timenano"><code>time::nano()</code></a></td>
      <td scope="row" data-label="Description">Returns the number of nanoseconds since the UNIX epoch until a datetime or current datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timenow"><code>time::now()</code></a></td>
      <td scope="row" data-label="Description">Returns the current datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timeround"><code>time::round()</code></a></td>
      <td scope="row" data-label="Description">Rounds a datetime to the nearest multiple of a specific duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timesecond"><code>time::second()</code></a></td>
      <td scope="row" data-label="Description">Extracts the second as a number from a datetime or current datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timetimezone"><code>time::timezone()</code></a></td>
      <td scope="row" data-label="Description">Returns the current local timezone offset in hours</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timeunix"><code>time::unix()</code></a></td>
      <td scope="row" data-label="Description">Returns the number of seconds since the UNIX epoch</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timewday"><code>time::wday()</code></a></td>
      <td scope="row" data-label="Description">Extracts the week day as a number from a datetime or current datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timeweek"><code>time::week()</code></a></td>
      <td scope="row" data-label="Description">Extracts the week as a number from a datetime or current datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timeyday"><code>time::yday()</code></a></td>
      <td scope="row" data-label="Description">Extracts the yday as a number from a datetime or current datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timeyear"><code>time::year()</code></a></td>
      <td scope="row" data-label="Description">Extracts the year as a number from a datetime or current datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timeisleap_year"><code>time::is_leap_year()</code></a></td>
      <td scope="row" data-label="Description">Checks if given datetime is a leap year</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timefrom_micros"><code>time::from_micros()</code></a></td>
      <td scope="row" data-label="Description">Calculates a datetime based on the microseconds since January 1, 1970 0:00:00 UTC.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timefrom_millis"><code>time::from_millis()</code></a></td>
      <td scope="row" data-label="Description">Calculates a datetime based on the milliseconds since January 1, 1970 0:00:00 UTC.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timefrom_nanos"><code>time::from_nanos()</code></a></td>
      <td scope="row" data-label="Description">Calculates a datetime based on the nanoseconds since January 1, 1970 0:00:00 UTC.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timefrom_secs"><code>time::from_secs()</code></a></td>
      <td scope="row" data-label="Description">Calculates a datetime based on the seconds since January 1, 1970 0:00:00 UTC.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timefrom_unix"><code>time::from_unix()</code></a></td>
      <td scope="row" data-label="Description">Calculates a datetime based on the seconds since January 1, 1970 0:00:00 UTC.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timefrom_ulid"><code>time::from_ulid()</code></a></td>
      <td scope="row" data-label="Description">Calculates a datetime based on the ULID.</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#timefrom_uuid"><code>time::from_uuid()</code></a></td>
      <td scope="row" data-label="Description">Calculates a datetime based on the UUID.</td>
    </tr>
  </tbody>
</table>

## `time::ceil`

The `time::ceil` function rounds a datetime up to the next largest duration.

```surql title="API DEFINITION"
time::ceil(datetime, duration) -> datetime
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[d'2024-08-30T03:00:00Z', d'2024-09-05T00:00:00Z']"

*/
LET $now = d'2024-08-30T02:22:50.231631Z';

RETURN [
  time::ceil($now, 1h),
  time::ceil($now, 1w)
];
```

```surql title="Output"
[
	d'2024-08-30T03:00:00Z',
	d'2024-09-05T00:00:00Z'
]
```

## `time::day`

The `time::day` function extracts the day as a number from a datetime, or from the current date if no datetime argument is present.

```surql title="API DEFINITION"
time::day(option<datetime>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1"

*/

RETURN time::day(d"2021-11-01T08:30:17+00:00");

-- 1
```

<br />

## `time::epoch`

The `time::epoch` constant returns the `datetime` for the UNIX epoch (January 1, 1970).

```surql
// Return the const
RETURN time::epoch;
-- d'1970-01-01T00:00:00Z'

// Define field using the const
DEFINE FIELD since_epoch ON event COMPUTED time::now().floor(1d) - time::epoch;
CREATE ONLY event:one SET information = "Something happened";
-- { id: event:one, information: 'Something happened', since_epoch: 55y42w6d }
```

<br />

## `time::floor`

The `time::floor` function rounds a datetime down by a specific duration.

```surql title="API DEFINITION"
time::floor(datetime, duration) -> datetime
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "d'2021-10-28T00:00:00Z'"

*/

RETURN time::floor(d"2021-11-01T08:30:17+00:00", 1w);

-- d'2021-10-28T00:00:00Z'
```

<br />

## `time::format`

The `time::format` function outputs a datetime as a string according to a specific format.

```surql title="API DEFINITION"
time::format(datetime, string) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'2021-11-01'"

*/

RETURN time::format(d"2021-11-01T08:30:17+00:00", "%Y-%m-%d");
```

```surql output="Response"
'2021-11-01'
```

[View all format options](/docs/surrealql/datamodel/formatters)

<br />

## `time::group`

The `time::group` function reduces and rounds a datetime down to a particular time interval. The second argument must be a string, and can be one of the following values: `year`, `month`, `day`, `hour`, `minute`, `second`.

```surql title="API DEFINITION"
time::group(datetime, string) -> datetime
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "d'2021-01-01T00:00:00Z'"

*/

RETURN time::group(d"2021-11-01T08:30:17+00:00", "year");

d'2021-01-01T00:00:00Z'
```

<br />

## `time::hour`

The `time::hour` function extracts the hour as a number from a datetime, or from the current date if no datetime argument is present.

```surql title="API DEFINITION"
time::hour(option<datetime>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "8"

*/

RETURN time::hour(d"2021-11-01T08:30:17+00:00");

-- 8
```

<br />

## `time::max`

The `time::max` function returns the greatest datetime from an array of datetimes.

```surql title="API DEFINITION"
time::max(array<datetime>) -> datetime
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "d'1988-06-22T08:30:45Z'"

*/

RETURN time::max([ d"1987-06-22T08:30:45Z", d"1988-06-22T08:30:45Z" ])

-- d'1988-06-22T08:30:45Z'
```

See also:

* [`array::max`](/docs/surrealql/functions/database/array#arraymax), which extracts the greatest value from an array of values
* [`math::max`](/docs/surrealql/functions/database/math#mathmax), which extracts the greatest number from an array of numbers

<br />

## `time::maximum`

<Since v="v2.3.0" />

The `time::maximum` constant returns the greatest possible datetime that can be used.

```surql title="API DEFINITION"
time::maximum -> datetime
```

Some examples of the constant in use:

```surql
/**[test]

[[test.results]]
value = "d'+262142-12-31T23:59:59.999999999Z'"

[[test.results]]
error = ""Failed to compute: \"1ns + d'+262142-12-31T23:59:59.999999999Z'\", as the operation results in an arithmetic overflow.""

[[test.results]]
value = "true"

*/

time::maximum;

time::maximum + 1ns;

time::now() IN time::minimum..time::maximum;
```

```surql title="Output"
-------- Query 1 --------

d'+262142-12-31T23:59:59.999Z'

-------- Query 2 --------

"Failed to compute: \"1ns + d'+262142-12-31T23:59:59.999999999Z'\", as the operation results in an arithmetic overflow."

-------- Query 3 --------

true
```

<br />

## `time::micros`

<Since v="v1.1.0" />

The `time::micros` function extracts the microseconds as a number from a datetime, or from the current date if no datetime argument is present.

```surql title="API DEFINITION"
time::micros(option<datetime>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "551349045000000"

*/

RETURN time::micros(d"1987-06-22T08:30:45Z");

-- 551349045000000
```

<br />

## `time::millis`

<Since v="v1.1.0" />

The `time::millis` function extracts the milliseconds as a number from a datetime, or from the current date if no datetime argument is present.

```surql title="API DEFINITION"
time::millis(option<datetime>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "551349045000"

*/

RETURN time::millis(d"1987-06-22T08:30:45Z");

-- 551349045000
```

<br />

## `time::min`

The `time::min` function returns the least datetime from an array of datetimes.

```surql title="API DEFINITION"
time::min(array<datetime>) -> datetime
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "d'1987-06-22T08:30:45Z'"

*/

RETURN time::min([ d"1987-06-22T08:30:45Z", d"1988-06-22T08:30:45Z" ]);

-- d'1987-06-22T08:30:45Z'
```

See also:

* [`array::min`](/docs/surrealql/functions/database/array#arraymin), which extracts the least value from an array of values
* [`math::min`](/docs/surrealql/functions/database/math#mathmin), which extracts the least number from an array of numbers

<br />

## `time::minimum`

<Since v="v2.3.0" />

The `time::minimum` constant returns the least possible datetime that can be used.

```surql title="API DEFINITION"
time::minimum -> datetime
```

Some examples of the constant in use:

```surql
/**[test]

[[test.results]]
value = "d'-262143-01-01T00:00:00Z'"

[[test.results]]
value = "true"

*/

time::minimum;

time::now() IN time::minimum..time::maximum;
```

```surql title="Output"
-------- Query 1 --------

d'-262143-01-01T00:00:00Z'

-------- Query 2 --------

true
```

<br />

## `time::minute`

The `time::minute` function extracts the minutes as a number from a datetime, or from the current date if no datetime argument is present.

```surql title="API DEFINITION"
time::minute(option<datetime>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "30"

*/

RETURN time::minute(d"2021-11-01T08:30:17+00:00");

-- 30
```

<br />

## `time::month`

The `time::month` function extracts the month as a number from a datetime, or from the current date if no datetime argument is present.

```surql title="API DEFINITION"
time::month(option<datetime>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "11"

*/

RETURN time::month(d"2021-11-01T08:30:17+00:00");

-- 11
```

<br />

## `time::nano`

The `time::nano`function returns a datetime as an integer representing the number of nanoseconds since the UNIX epoch until a datetime, or the current date if no datetime argument is present.

```surql title="API DEFINITION"
time::nano(option<datetime>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1635755417000000000"

*/

RETURN time::nano(d"2021-11-01T08:30:17+00:00");

-- 1635755417000000000
```

<br />

## `time::now`

The `time::now` function returns the current datetime as an ISO8601 timestamp.

```surql title="API DEFINITION"
time::now() -> datetime
```

<br />

## `time::round`

The `time::round` function rounds a datetime up by a specific duration.

```surql title="API DEFINITION"
time::round(datetime, duration) -> datetime
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "d'2021-11-04T00:00:00Z'"

*/

RETURN time::round(d"2021-11-01T08:30:17+00:00", 1w);

-- d'2021-11-04T00:00:00Z'
```

<br />

## `time::second`

The `time::second` function extracts the second as a number from a datetime, or from the current date if no datetime argument is present.

```surql title="API DEFINITION"
time::second(option<datetime>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "17"

*/

RETURN time::second(d"2021-11-01T08:30:17+00:00");

-- 17
```

<br />

## `time::timezone`

The `time::timezone` function returns the current local timezone offset in hours.

```surql title="API DEFINITION"
time::timezone() -> string
```

<br />

## `time::unix`

The `time::unix` function returns a datetime as an integer representing the number of seconds since the UNIX epoch until a certain datetime, or from the current date if no datetime argument is present.

```surql title="API DEFINITION"
time::unix(option<datetime>) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1635755417"

*/

RETURN time::unix(d"2021-11-01T08:30:17+00:00");

-- 1635755417
```

<br />

## `time::wday`

The `time::wday` function extracts the week day as a number from a datetime, or from the current date if no datetime argument is present.

```surql title="API DEFINITION"
time::wday(option<datetime>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1"

*/

RETURN time::wday(d"2021-11-01T08:30:17+00:00");

-- 1
```

<br />

## `time::week`

The `time::week` function extracts the week as a number from a datetime, or from the current date if no datetime argument is present.

```surql title="API DEFINITION"
time::week(option<datetime>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "44"

*/

RETURN time::week(d"2021-11-01T08:30:17+00:00");

-- 44
```

<br />

## `time::yday`

The `time::yday` function extracts the day of the year as a number from a datetime, or from the current date if no datetime argument is present.

```surql title="API DEFINITION"
time::yday(option<datetime>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "305"

*/

RETURN time::yday(d"2021-11-01T08:30:17+00:00");

-- 305
```

<br />

## `time::year`

The `time::year` function extracts the year as a number from a datetime, or from the current date if no datetime argument is present.

```surql title="API DEFINITION"
time::year(option<datetime>) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "2021"

*/

RETURN time::year(d"2021-11-01T08:30:17+00:00");

-- 2021
```

<br />

## `time::is_leap_year()`

The `time::is_leap_year()` function Checks if given datetime is a leap year.

```surql title="API DEFINITION"
time::is_leap_year(datetime) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
-- Checks with current datetime if none is passed
RETURN time::is_leap_year();

RETURN time::is_leap_year(d"1987-06-22T08:30:45Z");
-- false

RETURN time::is_leap_year(d"1988-06-22T08:30:45Z");
-- true

-- Using function via method chaining
RETURN d'2024-09-03T02:33:15.349397Z'.is_leap_year();
-- true
```

## `time::from_micros`

<Since v="v1.1.0" />

The `time::from_micros` function calculates a datetime based on the microseconds since January 1, 1970 0:00:00 UTC.

```surql title="API DEFINITION"
time::from_micros(number) -> datetime
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "d'1970-01-01T00:00:01Z'"

*/

RETURN time::from_micros(1000000);

-- d'1970-01-01T00:00:01Z'
```

<br />

## `time::from_millis`

The `time::from_millis` function calculates a datetime based on the milliseconds since January 1, 1970 0:00:00 UTC.

```surql title="API DEFINITION"
time::from_millis(number) -> datetime
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "d'1970-01-01T00:00:01Z'"

*/

RETURN time::from_millis(1000);

-- d'1970-01-01T00:00:01Z'
```

<br />

## `time::from_nanos`

<Since v="v1.1.0" />

The `time::from_nanos` function calculates a datetime based on the nanoseconds since January 1, 1970 0:00:00 UTC.

```surql title="API DEFINITION"
time::from_nanos(number) -> datetime
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "d'1970-01-01T00:00:00.001Z'"

*/

RETURN time::from_nanos(1000000);

-- d'1970-01-01T00:00:00.001Z'
```

<br />

## `time::from_secs`

The `time::from_secs` function calculates a datetime based on the seconds since January 1, 1970 0:00:00 UTC.

```surql title="API DEFINITION"
time::from_secs(number) -> datetime
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "d'1970-01-01T00:16:40Z'"

*/

RETURN time::from_secs(1000);

-- d'1970-01-01T00:16:40Z'
```

<br />

## `time::from_unix`

The `time::from_unix` function calculates a datetime based on the seconds since January 1, 1970 0:00:00 UTC.

```surql title="API DEFINITION"
time::from_unix(number) -> datetime
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "d'1970-01-01T00:16:40Z'"

*/

RETURN time::from_unix(1000);

-- d'1970-01-01T00:16:40Z'
```

<br />

## `time::from_ulid`

The `time::from_ulid` function calculates a datetime based on the ULID.

```surql title="API DEFINITION"
time::from_ulid(ulid) -> datetime
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "d'2025-01-09T10:57:03.593Z'"

*/

RETURN time::from_ulid("01JH5BBTK9FKTGSDXHWP5YP9TQ");

-- d'2025-01-09T10:57:03.593Z'
```

<br />

## `time::from_uuid`

The `time::from_uuid` function calculates a datetime based on the UUID.

```surql title="API DEFINITION"
time::from_uuid(uuid) -> datetime
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "d'2025-01-09T10:57:58.757Z'"

*/

RETURN time::from_uuid(u'01944ab6-c1e5-7760-ab6a-127d37eb1b94');

-- d'2025-01-09T10:57:58.757Z'
```

<br />



================================================
FILE: src/content/doc-surrealql/functions/database/type.mdx
================================================
---
sidebar_position: 25
sidebar_label: Type functions
title: Type functions | SurrealQL
description: These functions can be used for generating and coercing data to specific data types.
---

import Since from '@components/shared/Since.astro'
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Type Functions

> [!NOTE]
> Since version 3.0.0-alpha.8, the `::is::` functions (e.g. `type::is::record()`) now use underscores (e.g. `type::is_record()`) to better match the intent of the function and method syntax.

These functions can be used for generating and coercing data to specific data types. These functions are useful when accepting input values in client libraries, and ensuring that they are the desired type within SQL statements.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#typearray"><code>type::array()</code></a></td>
      <td scope="row" data-label="Description">Converts a value into an array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typebool"><code>type::bool()</code></a></td>
      <td scope="row" data-label="Description">Converts a value into a boolean</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typebytes"><code>type::bytes()</code></a></td>
      <td scope="row" data-label="Description">Converts a value into bytes</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typedatetime"><code>type::datetime()</code></a></td>
      <td scope="row" data-label="Description">Converts a value into a datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typedecimal"><code>type::decimal()</code></a></td>
      <td scope="row" data-label="Description">Converts a value into a decimal</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeduration"><code>type::duration()</code></a></td>
      <td scope="row" data-label="Description">Converts a value into a duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typefield"><code>type::field()</code></a></td>
      <td scope="row" data-label="Description">Projects a single field within a SELECT statement</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typefields"><code>type::fields()</code></a></td>
      <td scope="row" data-label="Description">Projects a multiple fields within a SELECT statement</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typefile"><code>type::file()</code></a></td>
      <td scope="row" data-label="Description">Converts two strings into a file pointer</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typefloat"><code>type::float()</code></a></td>
      <td scope="row" data-label="Description">Converts a value into a floating point number</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeint"><code>type::int()</code></a></td>
      <td scope="row" data-label="Description">Converts a value into an integer</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typenumber"><code>type::number()</code></a></td>
      <td scope="row" data-label="Description">Converts a value into a number</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeof"><code>type::of()</code></a></td>
      <td scope="row" data-label="Description">Returns the type of a value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typepoint"><code>type::point()</code></a></td>
      <td scope="row" data-label="Description">Converts a value into a geometry point</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typerecord"><code>type::record()</code></a></td>
      <td scope="row" data-label="Description">Converts a value into a record pointer</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typestring"><code>type::string()</code></a></td>
      <td scope="row" data-label="Description">Converts a value into a string</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typetable"><code>type::table()</code></a></td>
      <td scope="row" data-label="Description">Converts a value into a table</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typerange"><code>type::range()</code></a></td>
      <td scope="row" data-label="Description">Converts a value into a range</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeuuid"><code>type::uuid()</code></a></td>
      <td scope="row" data-label="Description">Converts a value into a UUID</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_array"><code>type::is_array()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type array</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_bool"><code>type::is_bool()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type bool</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_bytes"><code>type::is_bytes()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type bytes</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_collection"><code>type::is_collection()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type collection</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_datetime"><code>type::is_datetime()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type datetime</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_decimal"><code>type::is_decimal()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type decimal</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_duration"><code>type::is_duration()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type duration</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_float"><code>type::is_float()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type float</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_geometry"><code>type::is_geometry()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type geometry</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_int"><code>type::is_int()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type int</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_line"><code>type::is_line()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type line</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_none"><code>type::is_none()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type none</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_null"><code>type::is_null()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type null</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_multiline"><code>type::is_multiline()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type multiline</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_multipoint"><code>type::is_multipoint()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type multipoint</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_multipolygon"><code>type::is_multipolygon()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type multipolygon</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_number"><code>type::is_number()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type number</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_object"><code>type::is_object()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type object</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_point"><code>type::is_point()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type point</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_polygon"><code>type::is_polygon()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type polygon</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_polygon"><code>type::is_range()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type range</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_record"><code>type::is_record()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type record</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_string"><code>type::is_string()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type string</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#typeis_uuid"><code>type::is_uuid()</code></a></td>
      <td scope="row" data-label="Description">Checks if given value is of type uuid</td>
    </tr>
  </tbody>
</table>

## `type::array`

The `type::array` function converts a value into an array.

```surql title="API DEFINITION"
type::array(array | range) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 2, 3]"

*/

RETURN type::array(1..=3);

-- [1, 2, 3]
```

This is the equivalent of using [`<array>`](/docs/surrealql/datamodel/casting#array) to cast a value to an array.

## `type::bool`

The `type::bool` function converts a value into a boolean.

```surql title="API DEFINITION"
type::bool(bool | string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::bool("true");

-- true
```

This is the equivalent of using [`<bool>`](/docs/surrealql/datamodel/casting#bool) to cast a value to a boolean.

<br />

## `type::bytes`

The `type::bytes` function converts a value into bytes.

```surql title="API DEFINITION"
type::bytes(bytes | string) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "b"4120666577206279746573""

*/

RETURN type::bytes("A few bytes");

-- b"4120666577206279746573"
```

This is the equivalent of using [`<bytes>`](/docs/surrealql/datamodel/casting) to cast a value to bytes.

<br />

## `type::datetime`

The `type::datetime` function converts a value into a datetime.

```surql title="API DEFINITION"
type::datetime(datetime | string) -> datetime
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "d'2022-04-27T18:12:27Z'"

*/

RETURN type::datetime("2022-04-27T18:12:27+00:00");

-- d'2022-04-27T18:12:27Z'
```

This is the equivalent of using [`<datetime>`](/docs/surrealql/datamodel/casting#datetime) to cast a value to a datetime.

<br />

## `type::decimal`

The `type::decimal` function converts a value into a decimal.

```surql title="API DEFINITION"
type::decimal(decimal | float | int | number | string) -> decimal
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "12345dec"

*/

RETURN type::decimal("12345");

-- 12345dec
```

This is the equivalent of using [`<decimal>`](/docs/surrealql/datamodel/casting#decimal) to cast a value to a decimal.

<br />

## `type::duration`

The `type::duration` function converts a value into a duration.

```surql title="API DEFINITION"
type::duration(duration | string) -> duration
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "4h"

*/

RETURN type::duration("4h");

-- 4h
```

This is the equivalent of using [`<duration>`](/docs/surrealql/datamodel/casting#duration) to cast a value to a duration.

<br />

## `type::field`

The `type::field` function projects a single field within a SELECT statement.

```surql title="API DEFINITION"
type::field($field)
```
The following example shows this function, and its output:

```surql
/**[test]

[[test.results]]
value = "[{ id: person:test, name: { first: 'Tobie', last: 'Morgan Hitchcock' }, title: 'Mr' }]"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ name: { first: 'Tobie', last: 'Morgan Hitchcock' } }]"

[[test.results]]
value = "[{ firstname: 'Tobie', lastname: 'Morgan Hitchcock' }]"

[[test.results]]
value = "[['Tobie', 'Morgan Hitchcock']]"

*/

CREATE person:test SET title = 'Mr', name.first = 'Tobie', name.last = 'Morgan Hitchcock';

LET $param = 'name.first';

SELECT type::field($param), type::field('name.last') FROM person;

SELECT VALUE { 'firstname': type::field($param), lastname: type::field('name.last') } FROM person;

SELECT VALUE [type::field($param), type::field('name.last')] FROM person;
```

```surql title="Output"
[
	{
		id: person:test,
		title: 'Mr',
		name: {
			first: 'Tobie',
			last: 'Morgan Hitchcock',
	    }
	}
]
```

<br/>

<Since v="v3.0.0-alpha.8" />

This function can be used after the `OMIT` clause of a `SELECT` statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ age: 19, id: person:7iucxhs7x6ausbdlhj8a, name: 'Galen', surname: 'Pathwarden' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ age: 19, name: 'Galen', surname: 'Pathwarden' }]"

*/

LET $omit = "id";
CREATE person SET name = "Galen", surname = "Pathwarden", age = 19;
SELECT * OMIT type::field($omit) FROM person;
```

```surql title="Output"
[
	{
		age: 19,
		name: 'Galen',
		surname: 'Pathwarden'
	}
]
```

<br />

## `type::fields`

The `type::fields` function projects one or more fields within a SELECT statement.

```surql title="API DEFINITION"
type::fields($fields)
```
The following example shows this function, and its output:

```surql
/**[test]

[[test.results]]
value = "[{ id: person:test, name: { first: 'Tobie', last: 'Morgan Hitchcock' }, title: 'Mr' }]"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ name: { first: 'Tobie', last: 'Morgan Hitchcock' }, title: 'Mr' }]"

[[test.results]]
value = "[{ names: ['Tobie', 'Morgan Hitchcock'] }]"

[[test.results]]
value = "[['Tobie', 'Morgan Hitchcock']]"

*/

CREATE person:test SET title = 'Mr', name.first = 'Tobie', name.last = 'Morgan Hitchcock';

LET $param = ['name.first', 'name.last'];

SELECT type::fields($param), type::fields(['title']) FROM person;

SELECT VALUE { 'names': type::fields($param) } FROM person;

SELECT VALUE type::fields($param) FROM person;
```

```surql title="Output"
[
	{
		id: person:test,
		title: 'Mr',
		name: {
			first: 'Tobie',
			last: 'Morgan Hitchcock',
		}
	}
]
```

<br/>

<Since v="v3.0.0-alpha.8" />

This function can be used after the `OMIT` clause of a `SELECT` statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ age: 19, id: person:826qwse66s6igdeh977j, name: 'Galen', surname: 'Pathwarden' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ name: 'Galen', surname: 'Pathwarden' }]"

*/

LET $omit = ["id", "age"];
CREATE person SET name = "Galen", surname = "Pathwarden", age = 19;
SELECT * OMIT type::fields($omit) FROM person;
```

```surql title="Output"
[
	{
		name: 'Galen',
		surname: 'Pathwarden'
	}
]
```

<br />

## `type::file`

<Since v="v3.0.0-alpha.1" />

The `type::file` function converts two strings representing a bucket name and a key into a [file pointer](/docs/surrealql/datamodel/files).

```surql title="API DEFINITION"
type::file(bucket: string, key: string) -> file
```

An example of a file pointer created using this function:

```surql
/**[test]

[[test.results]]
value = "f"my_bucket:/file_name""

*/

type::file("my_bucket", "file_name")
```

```surql title="Output"
f"my_bucket:/file_name"
```

The following query shows the equivalent file pointer when created using the `f` prefix:

```surql
/**[test]

[[test.results]]
value = "true"

*/

type::file("my_bucket", "file_name") == f"my_bucket:/file_name";

-- true
```

Once a [bucket has been defined](/docs/surrealql/statements/define/indexes), operations using one of the [file functions](/docs/surrealql/functions/database/file) can be performed on the file pointer.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "b"536F6D65206461746120696E73696465""

*/

DEFINE BUCKET my_bucket BACKEND "memory";

type::file("my_bucket", "file_name").put("Some data inside");
type::file("my_bucket", "file_name").get();
```

```surql title="Output"
b"536F6D65206461746120696E73696465"
```

<br />

## `type::float`

The `type::float` function converts a value into a float.

```surql title="API DEFINITION"
type::float(decimal | float | int | number | string) -> float
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "12345f"

*/

RETURN type::float("12345");

-- 12345f
```
This is the equivalent of using [`<float>`](/docs/surrealql/datamodel/casting#float) to cast a value to a float.

<br />

## `type::int`

The `type::int` function converts a value into an integer.

```surql title="API DEFINITION"
type::int(decimal | float | int | number | string) -> int
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "12345"

*/

RETURN type::int("12345");

-- 12345
```
This is the equivalent of using [`<int>`](/docs/surrealql/datamodel/casting#int) to cast a value to a int.

<br />

## `type::number`

The `type::number` function converts a value into a number.

```surql title="API DEFINITION"
type::number(decimal | float | int | number | string) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "12345"

*/

RETURN type::number("12345");

-- 12345
```

This is the equivalent of using [`<number>`](/docs/surrealql/datamodel/casting#number) to cast a value to a number.

<br />

## `type:of`

<Since v="v3.0.0-alpha.12" />

The `type::of` function returns a string denoting the type of a value.

```surql title="API DEFINITION"
type::of(value) -> string
```

```surql
type::of(2022dec);        -- 'decimal';
type::of(["some", 9]);    -- 'array';
type::of((50.0, 9.9));    -- 'geometry<point>'
```

## `type::point`

The `type::point` function converts a value into a geometry point.

```surql title="API DEFINITION"
type::point(array | point) -> point
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "(51.509865, -0.118092)"

*/

RETURN type::point([ 51.509865, -0.118092 ]);

-- (51.509865, -0.118092)
```

<br />

## `type::range`

<Since v="v2.0.0" />

The `type::range` function converts a value into a [range](docs/surrealql/datamodel/ranges). It accepts a single argument, either a range or an array with two values. If the argument is an array, it will be converted into a range, similar to [casting](/docs/surrealql/datamodel/casting).

```surql title="API DEFINITION"
type::range(range | array) -> range<record>
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1..2"

[[test.results]]
value = "1..10"

[[test.results]]
value = "'Expected a range but cannot convert [1, 9, 4] into a range'"

*/

RETURN type::range([1, 2]);
-- 1..2

RETURN type::range(1..10);
-- 1..10

RETURN type::range([1,9,4]);
-- 'Expected a range but cannot convert [1, 9, 4] into a range'
```

<br />

## `type::record`

> [!NOTE]
> This function was known as `type::thing` in versions of SurrrealDB before 3.0.0-alpha.11. The behaviour has not changed.

The `type::record` function converts a value into a record pointer definition.

```surql title="API DEFINITION"
type::record(any, any) -> record
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
LET $tb = "person";
LET $id = "tobie";
RETURN type::record($tb, $id);
```

An example of this function being used to turn an array of objects into records to be created or upserted:

```surql
FOR $data IN [
	{
		id: 9,
		name: 'Billy'
	},
	{
		id: 10,
		name: 'Bobby'
	}
] {
	UPSERT type::record('person', $data.id) CONTENT $data;
};
```

An example of the same except in which the `num` field is to be used as the record's ID. In this case, it can be mapped with the [`array::map()`](/docs/surrealql/functions/database/array#arraymap) function to rename `num` as `id` so that the following `CONTENT` clause does not create both a `num` and an `id` with the same value.

```surql
FOR $data IN [
	{
		name: 'Billy',
		num: 9
	},
    {
		name: 'Bobby',
		num: 10
	},
].map(|$o| {
    id: $o.num,
    name: $o.name
}) {
    UPSERT type::record('person', $data.id) CONTENT $data;
};
```

If the second argument passed into `type::record` is a record ID, the latter part of the ID (the record identifier) will be extracted and used.

```surql
type::record("person", person:mat);

-- person:mat
```

The output of the above function call will thus be `person:mat`, not `person:person:mat`.

<br/>

## `type::string`

The `type::string` function converts any value except `NONE`, `NULL`, and `bytes` into a string.

```surql title="API DEFINITION"
type::string(any) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'12345'"

*/

RETURN type::string(12345);

-- '12345'
```

This is the equivalent of using [`<string>`](/docs/surrealql/datamodel/casting#string) to cast a value to a string.

<br />

## `type::string_lossy`

<Since v="v3.0.0-alpha.1" />

The `type::string_lossy` function converts any value except `NONE`, `NULL`, and `bytes` into a string. In the case of bytes, it will not return an error if the bytes are not valid UTF-8. Instead, invalid bytes will be replaced with the character `�` (`U+FFFD REPLACEMENT CHARACTER`, used in Unicode to represent a decoding error).

```surql title="API DEFINITION"
type::string(any) -> string
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "'Sur�rea�lDB'"

[[test.results]]
value = "'SurrealDB'"

*/

-- Contains some invalid bytes
type::string_lossy(<bytes>[83, 117, 114, 255, 114, 101, 97, 254, 108, 68, 66]);
-- valid bytes
type::string_lossy(<bytes>[ 83, 117, 114, 114, 101, 97, 108, 68, 66 ]);
```

```surql title="Output"
-------- Query --------

'Sur�rea�lDB'

-------- Query --------

'SurrealDB'
```

This is similar to using [`<string>`](/docs/surrealql/datamodel/casting#string) to cast a value to a string, except that an input of bytes will not fail.

<br />

## `type::table`

The `type::table` function converts a value into a table name.

```surql title="API DEFINITION"
type::table(record | string) -> string
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[person, cat]"

*/

RETURN [
  type::table("person"),
  type::table(cat:one)
];

-- [person, cat]
```

As of version 2.0, SurrealDB no longer eagerly parses strings into record IDs. As such, the output of the last item ("dog:two") in the following example will differ. In version 1.x, it will be eagerly parsed into a record ID after which the `dog` table name will be returned, while in version 2.x it will be treated as a string and converted into the table name `dog:two`.

```surql
/**[test]

[[test.results]]
value = "`55`"

[[test.results]]
value = "cat"

[[test.results]]
value = "dog"

[[test.results]]
value = "`dog:two`"

*/

RETURN [
  type::table(55),
  type::table(cat:one),
  type::table("dog"),
  type::table("dog:two"),
];
```

<Tabs groupId="function-output">

<TabItem value="V1" label="V1.x" >

```surql title="Output (V1.x)"
[
	`55`,
	cat,
	dog,
	dog
]
```

</TabItem>

<TabItem value="V2" label="V2.x" >

```surql title="Output (V2.x)"
[
	`55`,
	cat,
	dog,
	`dog:two`
]
```

</TabItem>
</Tabs>

<br />

## `type::uuid`

The `type::uuid` function converts a value into a UUID.

```surql title="API DEFINITION"
type::uuid(string | uuid) -> uuid
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "u'0191f946-936f-7223-bef5-aebbc527ad80'"

*/

RETURN type::uuid("0191f946-936f-7223-bef5-aebbc527ad80");

-- u'0191f946-936f-7223-bef5-aebbc527ad80'
```
<br />

## `type::is_array`

> [!NOTE]
> This function was known as `type::is::array` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_array` function checks if the passed value is of type `array`.

```surql title="API DEFINITION"
type::is_array(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::is_array([ 'a', 'b', 'c' ]);

-- true
```

<br />

## `type::is_bool`

> [!NOTE]
> This function was known as `type::is::bool` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_bool` function checks if the passed value is of type `bool`.

```surql title="API DEFINITION"
type::is_bool(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::is_bool(true);

-- true
```

<br />

## `type::is_bytes`

> [!NOTE]
> This function was known as `type::is::bytes` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_bytes` function checks if the passed value is of type `bytes`.

```surql title="API DEFINITION"
type::is_bytes(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "false"

*/

RETURN type::is_bytes("I am not bytes");

-- false
```

<br />

## `type::is_collection`

> [!NOTE]
> This function was known as `type::is::collection` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_collection` function checks if the passed value is of type `collection`.

```surql title="API DEFINITION"
type::is_collection(any) -> bool
```


The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "false"

*/

RETURN type::is_collection("I am not a collection");

-- false
```

<br />

## `type::is_datetime`

> [!NOTE]
> This function was known as `type::is::datetime` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_datetime` function checks if the passed value is of type `datetime`.

```surql title="API DEFINITION"
type::is_datetime(any) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::is_datetime(time::now());

-- true
```

<br />

## `type::is_decimal`

> [!NOTE]
> This function was known as `type::is::decimal` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_decimal` function checks if the passed value is of type `decimal`.

```surql title="API DEFINITION"
type::is_decimal(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::is_decimal(<decimal> 13.5719384719384719385639856394139476937756394756);

-- true
```

<br />

## `type::is_duration`

> [!NOTE]
> This function was known as `type::is::duration` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_duration` function checks if the passed value is of type `duration`.

```surql title="API DEFINITION"
type::is_duration(any) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "false"

*/

RETURN type::is_duration('1970-01-01T00:00:00');

-- false
```

<br />

## `type::is_float`

> [!NOTE]
> This function was known as `type::is::float` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_float` function checks if the passed value is of type ` float`.

```surql title="API DEFINITION"
type::is_float(any) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::is_float(<float> 41.5);

-- true
```

<br />

## `type::is_geometry`

> [!NOTE]
> This function was known as `type::is::geometry` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_geometry` function checks if the passed value is of type `geometry`.

```surql title="API DEFINITION"
type::is_geometry(any) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::is_geometry((-0.118092, 51.509865));

-- true
```

<br />

## `type::is_int`

> [!NOTE]
> This function was known as `type::is::int` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_int` function checks if the passed value is of type `int`.

```surql title="API DEFINITION"
type::is_int(any) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::is_int(<int> 123);

-- true
```

<br />

## `type::is_line`

> [!NOTE]
> This function was known as `type::is::line` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_line` function checks if the passed value is of type `line`.

```surql title="API DEFINITION"
type::is_line(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "false"

*/

RETURN type::is_line("I am not a line");

-- false
```

<br />

## `type::is_none`

> [!NOTE]
> This function was known as `type::is::none` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

<Since v="v1.1.0" />

The `type::is_none` function checks if the passed value is of type `none`.

```surql title="API DEFINITION"
type::is_none(any) -> bool
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::is_none(NONE);

-- true
```

<br />

## `type::is_null`

> [!NOTE]
> This function was known as `type::is::null` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_null` function checks if the passed value is of type `null`.

```surql title="API DEFINITION"
type::is_null(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::is_null(NULL);

-- true
```

<br />

## `type::is_multiline`

> [!NOTE]
> This function was known as `type::is::multiline` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_multiline` function checks if the passed value is of type `multiline`.

```surql title="API DEFINITION"
type::is_multiline(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "false"

*/

RETURN type::is_multiline("I am not a multiline");

-- false
```

<br />

## `type::is_multipoint`

> [!NOTE]
> This function was known as `type::is::multipoint` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_multipoint` function checks if the passed value is of type `multipoint`.

```surql title="API DEFINITION"
type::is_multipoint(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "false"

*/

RETURN type::is_multipoint("I am not a multipoint");

-- false
```

<br />

## `type::is_multipolygon`

> [!NOTE]
> This function was known as `type::is::multipolygon` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_multipolygon` function checks if the passed value is of type `multipolygon`.

```surql title="API DEFINITION"
type::is_multipolygon(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "false"

*/

RETURN type::is_multipolygon("I am not a multipolygon");

-- false
```

<br />

## `type::is_number`

> [!NOTE]
> This function was known as `type::is::number` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_number` function checks if the passed value is of type `number`.

```surql title="API DEFINITION"
type::is_number(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::is_number(123);

-- true
```

<br />

## `type::is_object`

> [!NOTE]
> This function was known as `type::is::object` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_object` function checks if the passed value is of type `object`.

```surql title="API DEFINITION"
type::is_object(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::is_object({ hello: 'world' });

-- true
```

<br />

## `type::is_point`

> [!NOTE]
> This function was known as `type::is::point` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_point` function checks if the passed value is of type `point`.

```surql title="API DEFINITION"
type::is_point(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::is_point((-0.118092, 51.509865));

-- true
```

<br />

## `type::is_polygon`

> [!NOTE]
> This function was known as `type::is::polygon` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_polygon` function checks if the passed value is of type `polygon`.

```surql title="API DEFINITION"
type::is_polygon(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "false"

*/

RETURN type::is_polygon("I am not a polygon");

-- false
```

## `type::is_range`

> [!NOTE]
> This function was known as `type::is::range` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_range` function checks if the passed value is of type `range`.

```surql title="API DEFINITION"
type::is_range(any) -> bool
```

```surql
/**[test]

[[test.results]]
value = "true"

[[test.results]]
value = "true"

*/

type::is_range(0..1);
-- true

// method syntax
(0..1).is_range();
-- true
```

## `type::is_record`

> [!NOTE]
> This function was known as `type::is::record` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_record` function checks if the passed value is of type `record`.

```surql title="API DEFINITION"
type::is_record(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::is_record(user:tobie);

-- true
```


### Validate a table

<Since v="v1.1.0" />

```surql title="Check if user:tobie is a record on the test table"
/**[test]

[[test.results]]
value = "false"

*/

RETURN type::is_record(user:tobie, 'test');

-- false
```

<br />

## `type::is_string`

> [!NOTE]
> This function was known as `type::is::string` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_string` function checks if the passed value is of type `string`.

```surql title="API DEFINITION"
type::is_string(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::is_string("abc");

-- true
```

<br />

## `type::is_uuid`

> [!NOTE]
> This function was known as `type::is::uuid` in versions of SurrrealDB before 3.0.0-alpha.8. The behaviour has not changed.

The `type::is_uuid` function checks if the passed value is of type `uuid`.

```surql title="API DEFINITION"
type::is_uuid(any) -> bool
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "true"

*/

RETURN type::is_uuid(u"018a6680-bef9-701b-9025-e1754f296a0f");

-- true
```

<br /><br />

## Method chaining

<Since v="v2.0.0" />

Method chaining allows functions to be called using the `.` dot operator on a value of a certain type instead of the full path of the function followed by the value.

```surql
/**[test]

[[test.results]]
value = "false"

[[test.results]]
value = "false"

*/

-- Traditional syntax
type::is_record(r"person:aeon", "cat");

-- Method chaining syntax
r"person:aeon".is_record("cat");
```

```surql title="Response"
false
```



================================================
FILE: src/content/doc-surrealql/functions/database/value.mdx
================================================
---
sidebar_position: 26
sidebar_label: Value functions
title: Value functions | SurrealQL
description: This module contains several miscellaneous functions that can be used with values of any type.
---

import Since from '@components/shared/Since.astro'

# Value functions

This module contains several miscellaneous functions that can be used with values of any type.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#chain"><code>.chain()</code></a></td>
      <td scope="row" data-label="Description">Allows an anonymous function to be called on a value</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#valuediff"><code>value::diff()</code></a></td>
      <td scope="row" data-label="Description">Returns the operation required for one value to equal another</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#valuepatch"><code>value::patch()</code></a></td>
      <td scope="row" data-label="Description">Applies JSON Patch operations to a value</td>
    </tr>
  </tbody>
</table>

## `.chain()`

<Since v="v2.0.0" />

The `.chain()` method takes the output of an expression upon which the user can call an [anonymous function](/docs/surrealql/datamodel/closures) (closure).

```surql title="API DEFINITION"
value.chain(|$val_name| @closure_body) -> value;
```

Any value can be followed with the `.chain()` syntax, after which an anonymous function (closure) can be written to perform an operation on it.

```surql
/**[test]

[[test.results]]
value = "'SurrealDB 2.0'"

*/

'SurrealDB'.chain(|$n| $n + ' 2.0');
-- 'SurrealDB 2.0'
```

The function is only called using the `.` operator (method syntax) and, as the name implies, works well within a chain of methods.

```surql
/**[test]

[[test.results]]
value = ""{ company: 'SURREALDB!!!!!', latest_version: '2.0' }""

*/

{ company: 'SurrealDB', latest_version: '2.0' }
    .chain(|$name| <string>$name)
    .replace('SurrealDB', 'SURREALDB!!!!!');
```

```surql title="Response"
"{ company: 'SURREALDB!!!!!', latest_version: '2.0' }"
```

For a similar function that allows using a closure on each item in an array instead of a value as a whole, see [array::map](/docs/surrealql/functions/database/array#arraymap).

## `value::diff`

<Since v="v2.0.0" />

The `value::diff` function returns an object that shows the [JSON Patch](https://jsonpatch.com/) operation(s) required for the first value to equal the second one.

```surql title="API DEFINITION"
value::diff(value, value) -> array<object>
```

The following is an example of the `value::diff` function used to display the changes required to change one string into another. Note that the JSON Patch spec requires an array of objects, and thus an array will be returned even if only one patch is needed between two values.

```surql
/**[test]

[[test.results]]
value = "[{ op: 'change', path: '', value: '@@ -1,5 +1,6 @@
 tobi
-e
+as
' }]"

*/

RETURN 'tobie'.diff('tobias');
```

```surql title="Output"
[
	{
		op: 'change',
		path: '/',
		value: '@@ -1,5 +1,6 @@
 tobi
-e
+as
'
	}
]
```

An example of the output when the diff output includes more than one operation:

```surql
/**[test]

[[test.results]]
value = "[{ op: 'change', path: '/company', value: '@@ -2,8 +2,10 @@
 urrealDB
+!!
' }, { op: 'add', path: '/latest_version', value: '2.0' }, { op: 'add', path: '/location', value: city:london }]"

*/

{ company: 'SurrealDB' }.diff({ company: 'SurrealDB!!', latest_version: '2.0', location: city:london });
```

```surql title="Response"
[
	{
		op: 'change',
		path: '/company',
		value: '@@ -2,8 +2,10 @@
 urrealDB
+!!
'
	},
	{
		op: 'add',
		path: '/latest_version',
		value: '2.0'
	},
	{
		op: 'add',
		path: '/location',
		value: city:london
	}
]
```

## `value::patch`

<Since v="v2.0.0" />

The `value::patch` function applies an array of JSON Patch operations to a value.

```surql title="API DEFINITION"
value::patch(value, patch: array<object>) -> value
```

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ company: 'SurrealDB', latest_version: '3.0' }"

*/


LET $company = {
    company: 'SurrealDB',
    latest_version: '1.5.4'
};

$company.patch([{
		'op': 'replace',
		'path': 'latest_version',
		'value': '3.0'
}]);
```

```surql title="Response"
{
	company: 'SurrealDB',
	version: '3.0'
}
```



================================================
FILE: src/content/doc-surrealql/functions/database/vector.mdx
================================================
---
sidebar_position: 27
sidebar_label: Vector functions
title: Vector functions | SurrealQL
description: A collection of essential vector operations that provide foundational functionality for numerical computation, machine learning, and data analysis.
---
import Since from '@components/shared/Since.astro'

# Vector functions

A collection of essential vector operations that provide foundational functionality for numerical computation, machine learning, and data analysis. These operations include distance measurements, similarity coefficients, and other basic and complex operations related to vectors. Through understanding and implementing these functions, we can perform a wide variety of tasks ranging from data processing to advanced statistical analyses.

<table>
  <thead>
    <tr>
      <th scope="col">Function</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectoradd"><code>vector::add()</code></a></td>
      <td scope="row" data-label="Description">Performs element-wise addition of two vectors</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectorangle"><code>vector::angle()</code></a></td>
      <td scope="row" data-label="Description">Computes the angle between two vectors</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectorcross"><code>vector::cross()</code></a></td>
      <td scope="row" data-label="Description">Computes the cross product of two vectors</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectordivide"><code>vector::divide()</code></a></td>
      <td scope="row" data-label="Description">Performs element-wise division between two vectors</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectordot"><code>vector::dot()</code></a></td>
      <td scope="row" data-label="Description">Computes the dot product of two vectors</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectormagnitude"><code>vector::magnitude()</code></a></td>
      <td scope="row" data-label="Description">Computes the magnitude (or length) of a vector</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectormultiply"><code>vector::multiply()</code></a></td>
      <td scope="row" data-label="Description">Performs element-wise multiplication of two vectors</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectornormalize"><code>vector::normalize()</code></a></td>
      <td scope="row" data-label="Description">Computes the normalization of a vector</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectorproject"><code>vector::project()</code></a></td>
      <td scope="row" data-label="Description">Computes the projection of one vector onto another</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectorscale"><code>vector::scale()</code></a></td>
      <td scope="row" data-label="Description">Multiplies each item in a vector</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectorsubtract"><code>vector::subtract()</code></a></td>
      <td scope="row" data-label="Description">Performs element-wise subtraction between two vectors</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectordistancechebyshev"><code>vector::distance::chebyshev()</code></a></td>
      <td scope="row" data-label="Description">Computes the Chebyshev distance</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectordistanceeuclidean"><code>vector::distance::euclidean()</code></a></td>
      <td scope="row" data-label="Description">Computes the Euclidean distance between two vectors</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectordistancehamming"><code>vector::distance::hamming()</code></a></td>
      <td scope="row" data-label="Description">Computes the Hamming distance between two vectors</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectordistanceknn"><code>vector::distance::knn()</code></a></td>
      <td scope="row" data-label="Description">Returns the distance computed during the query</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectordistancemanhattan"><code>vector::distance::manhattan()</code></a></td>
      <td scope="row" data-label="Description">Computes the Manhattan distance between two vectors</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectordistanceminkowski"><code>vector::distance::minkowski()</code></a></td>
      <td scope="row" data-label="Description">Computes the Minkowski distance between two vectors</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectorsimilaritycosine"><code>vector::similarity::cosine()</code></a></td>
      <td scope="row" data-label="Description">Computes the Cosine similarity between two vectors</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectorsimilarityjaccard"><code>vector::similarity::jaccard()</code></a></td>
      <td scope="row" data-label="Description">Computes the Jaccard similarity between two vectors</td>
    </tr>
    <tr>
      <td scope="row" data-label="Function"><a href="#vectorsimilaritypearson"><code>vector::similarity::pearson()</code></a></td>
      <td scope="row" data-label="Description">Computes the Pearson correlation coefficient between two vectors</td>
    </tr>
  </tbody>
</table>

## `vector::add`

The `vector::add` function performs element-wise addition of two vectors, where each element in the first vector is added to the corresponding element in the second vector.

```surql title="API DEFINITION"
vector::add(array, array) -> array
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[2, 4, 6]"

*/

RETURN vector::add([1, 2, 3], [1, 2, 3]);

-- [2, 4, 6]
```

<br />

## `vector::angle`

The `vector::angle` function computes the angle between two vectors, providing a measure of the orientation difference between them.

```surql title="API DEFINITION"
vector::angle(array, array) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.36774908225917935f"

*/

RETURN vector::angle([5, 10, 15], [10, 5, 20]);

-- 0.36774908225917935f
```

<br />

## `vector::cross`

The `vector::cross` function computes the cross product of two vectors, which results in a vector that is orthogonal (perpendicular) to the plane containing the original vectors.

```surql title="API DEFINITION"
vector::cross(array, array) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[-3, 6, -3]"

*/

RETURN vector::cross([1, 2, 3], [4, 5, 6]);

[-3, 6, -3]
```

<br />

## `vector::divide`

The `vector::divide` function performs element-wise division between two vectors, where each element in the first vector is divided by the corresponding element in the second vector.

```surql title="API DEFINITION"
vector::divide(array, array) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[NaN, 20, 15, 0]"

*/

RETURN vector::divide([10, -20, 30, 0], [0, -1, 2, -3]);

[NaN, 20, 15, 0]
```

<br />

## `vector::dot`

The `vector::dot` function computes the dot product of two vectors, which is the sum of the products of the corresponding entries of the two sequences of numbers.

```surql title="API DEFINITION"
vector::dot(array, array) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "14"

*/

RETURN vector::dot([1, 2, 3], [1, 2, 3]);

-- 14
```

<br />

## `vector::magnitude`

The `vector::magnitude` function computes the magnitude (or length) of a vector, providing a measure of the size of the vector in multi-dimensional space.

```surql title="API DEFINITION"
vector::magnitude(array) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "8.54400374531753f"

*/

RETURN vector::magnitude([ 1, 2, 3, 3, 3, 4, 5 ]);

-- 8.54400374531753f
```

<br />

## `vector::multiply`

The `vector::multiply` function performs element-wise multiplication of two vectors, where each element in the first vector is multiplied by the corresponding element in the second vector.

```surql title="API DEFINITION"
vector::multiply(array, array) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 4, 9]"

*/

RETURN vector::multiply([1, 2, 3], [1, 2, 3]);

-- [1, 4, 9]
```

<br />

## `vector::normalize`

The `vector::normalize` function computes the normalization of a vector, transforming it to a unit vector (a vector of length 1) that maintains the original direction.

```surql title="API DEFINITION"
vector::normalize(array) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[0.8f, 0.6f]"

*/

RETURN vector::normalize([ 4, 3 ]);

-- [0.8f, 0.6f]
```

<br />

## `vector::project`

The `vector::project` function computes the projection of one vector onto another, providing a measure of the shadow of one vector on the other. The projection is obtained by multiplying the magnitude of the given vectors with the cosecant of the angle between the two vectors.


```surql title="API DEFINITION"
vector::project(array, array) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1.6623376623376624f, 2.077922077922078f, 2.4935064935064934f]"

*/

RETURN vector::project([1, 2, 3], [4, 5, 6]);

-- [1.6623376623376624f, 2.077922077922078f, 2.4935064935064934f]
```

<br />

## `vector::scale`

<Since v="v2.0.0" />

The `vector::scale` function multiplies each item in a vector by a number.

```surql title="API DEFINITION"
vector::scale(array, number) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[15, 5, 25, -15, 35, 10]"

*/

RETURN vector::scale([3, 1, 5, -3, 7, 2], 5);

-- [15,	5, 25, -15, 35, 10]
```

<br />

## `vector::subtract`

The `vector::subtract` function performs element-wise subtraction between two vectors, where each element in the second vector is subtracted from the corresponding element in the first vector.

```surql title="API DEFINITION"
vector::subtract(array, array) -> array
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "[1, 3, 5]"

*/

RETURN vector::subtract([4, 5, 6], [3, 2, 1]);

-- [1, 3, 5]
```

<br />

## `vector::distance::chebyshev`

The `vector::distance::chebyshev` function computes the Chebyshev distance (also known as maximum value distance) between two vectors, which is the greatest of their differences along any coordinate dimension.

```surql title="API DEFINITION"
vector::distance::chebyshev(array, array) -> number
```
The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "6f"

*/

RETURN vector::distance::chebyshev([2, 4, 5, 3, 8, 2], [3, 1, 5, -3, 7, 2]);

-- 6f
```

<br />

## `vector::distance::euclidean`

The `vector::distance::euclidean` function computes the Euclidean distance between two vectors, providing a measure of the straight-line distance between two points in a multi-dimensional space.

```surql title="API DEFINITION"
vector::distance::euclidean(array, array) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "432.43496620879307f"

*/

RETURN vector::distance::euclidean([10, 50, 200], [400, 100, 20]);

-- 432.43496620879307f
```

<br />

## `vector::distance::hamming`

The `vector::distance::hamming` function computes the Hamming distance between two vectors, measuring the minimum number of substitutions required to change one vector into the other, useful for comparing strings or codes.

```surql title="API DEFINITION"
vector::distance::hamming(array, array) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "1"

*/

RETURN vector::distance::hamming([1, 2, 2], [1, 2, 3]);

-- 1
```

<br />

## `vector::distance::knn`

The `vector::distance::knn` function returns the distance computed during the query by the Knn operator (avoiding recomputation).

```surql title="API DEFINITION"
vector::distance::knn() -> number
```

The following example shows this function, and its output, when used in a [`SELECT`](/docs/surrealql/statements/select) statement:

```surql
/**[test]

[[test.results]]
value = "[{ id: pts:1, point: [1, 2, 3, 4] }]"

[[test.results]]
value = "[{ id: pts:2, point: [4, 5, 6, 7] }]"

[[test.results]]
value = "[{ id: pts:3, point: [8, 9, 10, 11] }]"

[[test.results]]
value = "[{ dist: 2f, id: pts:1 }, { dist: 4f, id: pts:2 }]"

*/
CREATE pts:1 SET point = [1,2,3,4];
CREATE pts:2 SET point = [4,5,6,7];
CREATE pts:3 SET point = [8,9,10,11];
SELECT id, vector::distance::knn() AS dist FROM pts WHERE point <|2,EUCLIDEAN|> [2,3,4,5];
```

```surql title="Output"
[
			{
				id: pts:1,
				dist: 2f
			},
			{
				id: pts:2,
				dist: 4f
			}
]
```

<br />

## `vector::distance::manhattan`

The `vector::distance::manhattan`  function computes the Manhattan distance (also known as the L1 norm or Taxicab geometry) between two vectors, which is the sum of the absolute differences of their corresponding elements.

```surql title="API DEFINITION"
vector::distance::manhattan(array, array) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "13"

*/

RETURN vector::distance::manhattan([10, 20, 15, 10, 5], [12, 24, 18, 8, 7]);

-- 13
```

<br />

## `vector::distance::minkowski`

The `vector::distance::minkowski` function computes the Minkowski distance between two vectors, a generalization of other distance metrics such as Euclidean and Manhattan when parameterized with different values of p.


```surql title="API DEFINITION"
vector::distance::minkowski(array, array, number) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "4.862944131094279f"

*/

RETURN vector::distance::minkowski([10, 20, 15, 10, 5], [12, 24, 18, 8, 7], 3);

-- 4.862944131094279f
```

<br />

## `vector::similarity::cosine`

The `vector::similarity::cosine` function computes the Cosine similarity between two vectors, indicating the cosine of the angle between them, which is a measure of how closely two vectors are oriented to each other.


```surql title="API DEFINITION"
vector::similarity::cosine(array, array) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.15258215962441316f"

*/

RETURN vector::similarity::cosine([10, 50, 200], [400, 100, 20]);

-- 0.15258215962441316f
```

<br />

## `vector::similarity::jaccard`

The `vector::similarity::jaccard` function computes the Jaccard similarity between two vectors, measuring the intersection divided by the union of the datasets represented by the vectors.


```surql title="API DEFINITION"
vector::similarity::jaccard(array, array) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.3333333333333333f"

*/

RETURN vector::similarity::jaccard([0,1,2,5,6], [0,2,3,4,5,7,9]);

-- 0.3333333333333333f
```

<br />

## `vector::similarity::pearson`

The `vector::similarity::pearson` function Computes the Pearson correlation coefficient between two vectors, reflecting the degree of linear relationship between them.


```surql title="API DEFINITION"
vector::similarity::pearson(array, array) -> number
```

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql
/**[test]

[[test.results]]
value = "0.9819805060619659f"

*/

RETURN vector::similarity::pearson([1,2,3], [1,5,7]);

-- 0.9819805060619659f
```

<br />

<br /><br />



================================================
FILE: src/content/doc-surrealql/functions/ml/functions.mdx
================================================
---
sidebar_position: 2
sidebar_label: Machine learning functions
title: Machine learning functions | SurrealQL
description: These functions can be used when calculating outputs from a trained machine learning model that has been uploaded to the database.
---

# Machine Learning functions

These functions can be used when calculating outputs from a trained machine learning model that has been uploaded to the database.

<table>
	<thead>
		<tr>
			<th scope="col">Function</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Function">
				<a href="#mlname-of-modelversion">
					<code>
						ml::name-of-model&lt;version&gt;()
					</code>
				</a>
			</td>
			<td scope="row" data-label="Description">Computes a value from a trained machine learning model</td>
		</tr>
	</tbody>
</table>

## `ml::name-of-model<version>()`

Once a model has been uploaded to the database, the model can be called with inputs resulting in a calculation
from the trained ml model. We can do a basic raw computation with the following call:

```surql title="API DEFINITION"
ml::house-price-prediction<0.0.1>(500.0, 1.0);
```
In the above example, the model we are calling is called `house-price-prediction` with the version `0.0.1`. We
then pass in a raw vector of `[ [500.0, 1.0] ]` Depending on the model, the name and version of the model will vary as well
as the inputs. The name and version of the model will be defined in the `.surml` file which will defined when uploading the
model to the database. We can also perform a "buffered compute" with the code below:

```surql title="API DEFINITION"
ml::house-price-prediction<0.0.1>({squarefoot: 500.0, num_floors: 1.0});
```
Here, we are using the key mappings in the header of the `.surml` file uploaded to the database to map the fields defined
in the object passed into the `ml::` function in the correct order. If there are any normalisation parameters in the header
of the `.surml` file, these will also be applied.

The following example shows this function, and its output, when used in a [`RETURN`](/docs/surrealql/statements/return) statement:

```surql 
RETURN ml::house-price-prediction<0.0.1>({squarefoot: 500.0, num_floors: 1.0});

250000
```

Seeing as the ML is integrated into our surql, we can infer entire columns using the ml function. We can demonstrate this with a simple
example of house prices. We can define some basic table with the following surql:

```surql
CREATE house_listing SET squarefoot_col = 500.0, num_floors_col = 1.0;
CREATE house_listing SET squarefoot_col = 1000.0, num_floors_col = 2.0;
CREATE house_listing SET squarefoot_col = 1500.0, num_floors_col = 3.0;
```

We can then get all the rows with the imputed price prediction with the surql below:

```surql
SELECT 
	*, 
	ml::house-price-prediction<0.0.1>({ squarefoot: squarefoot_col, num_floors: num_floors_col }) AS price_prediction 
FROM house_listing;
```

This would statement gives us the following result:

```json
[
	{
		"id": "house_listing:7bo0f35tl4hpx5bymq5d",
		"num_floors_col": 3,
		"price_prediction": 406534.75,
		"squarefoot_col": 1500
	},
	{
		"id": "house_listing:8k2ttvhp2vh8v7skwyie",
		"num_floors_col": 2,
		"price_prediction": 291870.5,
		"squarefoot_col": 1000
	},
	{
		"id": "house_listing:vnlv3nzr21oi5o23kydw",
		"num_floors_col": 1,
		"price_prediction": 177206.21875,
		"squarefoot_col": 500
	}
]
```

We can see that our price prediction is calculated in the query. We can build on the previous surql to filter based on the computed
price prediction with the surql below:

```surql
SELECT * FROM (
		SELECT 
			*, 
			ml::house-price-prediction<0.0.1>({ squarefoot: squarefoot_col, num_floors: num_floors_col }) AS price_prediction 
		FROM house_listing
	) 
	WHERE price_prediction > 177206.21875;
```

This gives us the following result:

```json
[
	{
		"id": "house_listing:7bo0f35tl4hpx5bymq5d",
		"num_floors_col": 3,
		"price_prediction": 406534.75,
		"squarefoot_col": 1500
	},
	{
		"id": "house_listing:8k2ttvhp2vh8v7skwyie",
		"num_floors_col": 2,
		"price_prediction": 291870.5,
		"squarefoot_col": 1000
	}
]
```


<br /><br />


================================================
FILE: src/content/doc-surrealql/functions/ml/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: ML functions
title: Machine Learning functions | SurrealQL
description: SurrealDB offers machine learning functions to help you build and deploy machine learning models.
---

# Machine Learning functions

SurrealDB offers machine learning functions to help you build and deploy machine learning models.

Currently, SurrealDB supports the following machine learning functions:

- [Trained models](/docs/surrealql/functions/ml/functions)


================================================
FILE: src/content/doc-surrealql/functions/script/arguments.mdx
================================================
---
sidebar_position: 2
sidebar_label: Arguments
title: Arguments | Embedded scripting functions | SurrealQL
description: Additional arguments can be passed in to the function from SurrealDB, and these are accessible as an array using the arguments object within the JavaScript function.
---

# Arguments

Additional arguments can be passed in to the function from SurrealDB, and these are accessible as an array using the `arguments` object within the JavaScript function.

```surql 
-- Create a new parameter
LET $val = "SurrealDB";
-- Create a new parameter
LET $words = ["awesome", "advanced", "cool"];
-- Pass the parameter values into the function
CREATE article SET summary = function($val, $words) {
	const [val, words] = arguments;
	return `${val} is ${words.join(', ')}`;
};
```


================================================
FILE: src/content/doc-surrealql/functions/script/built-in-functions.mdx
================================================
---
sidebar_position: 3
sidebar_label: Built-in functions
title: Built-in functions | Embedded scripting functions | SurrealQL
description: Besides basic JavaScript utilities and classes for SurrealQL types, there are a handful of utilities built into the embedded scripting functions.
---

import Label from "@components/shared/Label.astro";

# Built-in functions

Besides basic JavaScript utilities and [classes for SurrealQL types](/docs/surrealql/functions/script/type-conversion), there are a handful of utilities built into the embedded scripting functions.

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="#fetch"><code>async fetch(resource, options)</code></a></td>
      <td>Full fledged fetch implementation closely matching the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">official specification</a>.</td>
    </tr>
    <tr>
      <td><a href="#query"><code>async query(surql)</code></a></td>
      <td>Run SurrealQL subqueries from within the embedded scripting functions.</td>
    </tr>
    <tr>
      <td><a href="#value"><code>async value(variable)</code></a></td>
      <td>Retrieve values for SurrealQL variables from within the embedded scripting functions.</td>
    </tr>
  </tbody>
</table>

## `async fetch(resource, options)` {#fetch}

Full fledged fetch implementation closely matching the [official specification](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).

> [!NOTE]
> For complete documentation, please refer to the MDN documentation.

<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2">
                <code>resource</code>
                <Label label="required" />
            </td>
            <td colspan="2">
                Accepts either a url in a string, or a URL or Request object.
            </td>
        </tr>
         <tr>
            <td colspan="2">
                <code>options</code>
            </td>
            <td colspan="2">
                Accepts various options related to the request. Refer to MDN docs for a full reference.
            </td>
        </tr>
    </tbody>
</table>

```surql
RETURN function() {
	// List all posts
	const posts = fetch('https://jsonplaceholder.typicode.com/posts');

	// Update post with ID 1
	const updated = fetch('https://jsonplaceholder.typicode.com/posts/1', {
		method: 'PUT',
		body: JSON.stringify({
			id: 1,
			title: 'foo',
			body: 'bar',
			userId: 1,
		}),
		headers: {
			'Content-type': 'application/json; charset=UTF-8',
		},
	});

	return { posts, updated };
}
```

<br />

## `async query(surql)` {#query}

Run SurrealQL subqueries from within the embedded scripting functions.

> [!NOTE]
> Only subqueries can be executed with the query() function. This means that only a single query can currently be executed, and that only CRUD operations are allowed.

<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2">
                <code>surql</code>
                <Label label="required" />
            </td>
            <td colspan="2">
                Accepts a single SurrealQL query, which is limited to a CRUD operation.
            </td>
        </tr>
    </tbody>
</table>

```surql
CREATE user:john, user:mary;

RETURN function() {
	// Select all users
	const users = await surrealdb.query("SELECT * FROM user");

	// Prepared query
	const query = new surrealdb.Query("SELECT * FROM $id", {
		id: new Record('user', 'mary')
	});

	// Execute prepared query
	const mary = (await surrealdb.query(query))[0];

	// Assign variables later to prepared query
	query.bind('id', new Record('user', 'john'));

	// Execute prepared query
	const john = (await surrealdb.query(query))[0];

	return { john, mary };
}
```

<br />

## `async value(variable)` {#value}

Retrieve values for SurrealQL variables from within the embedded scripting functions.

<table>
    <thead>
        <tr>
            <th colspan="2">Arguments</th>
            <th colspan="2">Description</th>
        </tr>
    </thead>  
    <tbody>
        <tr>
            <td colspan="2">
                <code>variable</code>
                <Label label="required" />
            </td>
            <td colspan="2">
                Accepts the path to a variable
            </td>
        </tr>
    </tbody>
</table>

```surql
LET $something = 123;
LET $obj = {
	nested: 456
};

LET $arr = [
	{ value: 1 },
	{ value: 2 },
	{ value: 3 },
	{ value: 4 },
	{ value: 5 },
	{ value: 6 },
];

RETURN function() {
	// Get the value for a variable
	const something = await surrealdb.value("$something");

	// Get the value for a nested property
	const nested = await surrealdb.value("$obj.nested");

	// Filter properties from an array
	const fromArray = await surrealdb.value("$arr[WHERE value > 3].value");

	return { something, nested, fromArray };
}
```

<br /><br />


================================================
FILE: src/content/doc-surrealql/functions/script/context.mdx
================================================
---
sidebar_position: 4
sidebar_label: Function context
title: Function context | Embedded scripting functions | SurrealQL
description: Embedded scripting functions inherit the context in which they are ran in. The this context of every embedded function is automatically set to the current document on every invocation.
---

# Function context

Embedded scripting functions inherit the context in which they are ran in. The this context of every embedded function is automatically set to the current document on every invocation. This allows the function to access the properties and fields of the current record being accessed / modified.

```surql
CREATE film SET
	ratings = [
		{ rating: 6, user: user:bt8e39uh1ouhfm8ko8s0 },
		{ rating: 8, user: user:bsilfhu88j04rgs0ga70 },
	],
	featured = function() {
		return this.ratings.filter(
			({ rating }) => rating >= 7
		).map(({ rating, ...data }) => {
			return {
				...data,
				rating: rating * 10
			};
		});
	}
;
```


================================================
FILE: src/content/doc-surrealql/functions/script/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Scripting functions
title: Embedded scripting functions | SurrealQL
description: SurrealDB allows for advanced functions with complicated logic, by allowing embedded functions to be written in JavaScript.
---

# Embedded scripting functions

SurrealDB allows for advanced functions with complicated logic, by allowing embedded functions to be written in JavaScript. These functions support the ES2020 JavaScript specification.

## Simple function

Embedded JavaScript functions within SurrealDB support all functionality in the ES2020 specification including async / await functions, and generator functions. Any value from SurrealDB is converted into a JavaScript type automatically, and the return value from the JavaScript function is converted to a SurrealDB value.

```surql
CREATE person SET scores = function() {
	return [1,2,3].map(v => v * 10);
};
```




================================================
FILE: src/content/doc-surrealql/functions/script/surrealql-functions.mdx
================================================
---
sidebar_position: 6
sidebar_label: SurrealQL functions
title: SurrealQL functions | Embedded scripting functions | SurrealQL
description: Embedded scripting functions have access to native SurrealQL functions, allowing for complex and performant operations otherwise not possible.
---

# SurrealQL functions

Embedded scripting functions have access to native SurrealQL functions, allowing for complex and performant operations otherwise not possible. SurrealQL functions are published under the `surrealdb.functions` variable. Custom functions are not available within the embedded JavaScript function at the moment.

```surql
RETURN function() {
	// Using the rand::uuid::v4() function
	const uuid = surrealdb.functions.rand.uuid.v4();
};
```


================================================
FILE: src/content/doc-surrealql/functions/script/type-conversion.mdx
================================================
---
sidebar_position: 5
sidebar_label: Type conversion
title: Type conversion | Embedded scripting functions | SurrealQL
description: Any value from SurrealDB is converted into a JavaScript type automatically, and the return value from the JavaScript function is converted to a SurrealQL value.
---

# Type conversion

Any value from SurrealDB is converted into a JavaScript type automatically, and the return value from the JavaScript function is converted to a SurrealQL value. Boolean values, Integers, Floats, Strings, Arrays, Objects, and Date objects are all converted automatically to and from SurrealQL values.

```surql
CREATE user:test SET created_at = function() {
	return new Date();
};
```

In addition, a number of special classes are included within the JavaScript functions for the additional types which are not built into JavaScript. These enable the creation of [`duration`](/docs/surrealql/datamodel/datetimes#durations-and-datetimes) values, [`record`](/docs/surrealql/datamodel/ids) ids, and [`UUID`](/docs/surrealql/datamodel/strings#uuid) values from within JavaScript.

Any values of these types passed into embedded scripting functions are also represented with these special classes.

```surql
CREATE user:test SET
	session_timeout = function() {
		return new Duration('1w');
	},
	best_friend = function() {
		return new Record('user', 'joanna');
	},
	identifier = function() {
		return new Uuid('03412258-988f-47cd-82db-549902cdaffe');
	}
;
```


================================================
FILE: src/content/doc-surrealql/statements/access.mdx
================================================
---
sidebar_position: 0
sidebar_label: ACCESS 
title: ACCESS statement | SurrealQL
description: The ACCESS statement can be used to manage access grants.
---

import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `ACCESS` statement

<Since v="v2.2.0" />

> [!CAUTION]
> Currently, the `ACCESS` statement is an experimental feature intended to be used for validating its suitability and security. As such, it may be subject to breaking changes and may present unidentified security issues. Do not rely on this feature in production applications.

The `ACCESS` statement can be used to manage access grants. It provides the ability to generate access grants using certain access methods, such as bearer keys defined with the [`DEFINE ACCESS ... TYPE BEARER`](/docs/surrealql/statements/define/access/bearer) statement, as well as the ability to show, revoke and purge such grants.

By default, the `ACCESS` statement will default to referencing access methods defined at the current level specified with the [`USE`](/docs/surrealql/statements/use) statement. As with other statements, access methods defined at any level can be referenced by using the `ON` clause.

Operations that either create, revoke or purge access grants using the `ACCESS` statement will be logged in the server as long as it is running with the `INFO` level (the default) or any higher verbosity level. These logs are identified by the `surrealdb_core::sql::statements::access` prefix.

### Statement syntax

<Tabs syncKey="access-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
ACCESS @name [ ON [ ROOT | NAMESPACE | DATABASE ] ]
	GRANT [ FOR USER @name | FOR RECORD @record ]
	| SHOW [ GRANT @id | ALL | WHERE @expression ] 
	| REVOKE [ GRANT @id | ALL | WHERE @expression ] 
	| PURGE [ EXPIRED | REVOKED [ , EXPIRED | REVOKED ] ] [ FOR @duration ]
```

  </TabItem>
  <TabItem label="Railroad Diagram">


export const accessAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    {
      type: "Sequence",
      children: [
        { type: "Terminal", text: "ACCESS" },
        { type: "NonTerminal", text: "@name" },
        {
          type: "Optional",
          child: {
            type: "Sequence",
            children: [
              { type: "Terminal", text: "ON" },
              { type: "Choice", index: 1, children: [
                { type: "Terminal", text: "ROOT" },
                { type: "Terminal", text: "NAMESPACE" },
                { type: "Terminal", text: "DATABASE" }
              ]}
            ]
          }
        },
        {
          type: "Choice",
          index: 1,
          children: [
              {
                type: "Sequence",
                children: [
                  { type: "Terminal", text: "GRANT" },
                  {
                    type: "Choice",
                    index: 1,
                    children: [
                      {
                        type: "Sequence",
                        children: [
                          { type: "Terminal", text: "FOR" },
                          { type: "Terminal", text: "USER" },
                          { type: "NonTerminal", text: "@name" }
                        ]
                      },
                      {
                        type: "Sequence",
                        children: [
                          { type: "Terminal", text: "FOR" },
                          { type: "Terminal", text: "RECORD" },
                          { type: "NonTerminal", text: "@record" }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                type: "Sequence",
                children: [
                  { type: "Terminal", text: "SHOW" },
                  {
                    type: "Choice",
                    index: 1,
                    children: [
                      {
                        type: "Sequence",
                        children: [
                          { type: "Terminal", text: "GRANT" },
                          { type: "NonTerminal", text: "@id" }
                        ]
                      },
                      { type: "Terminal", text: "ALL" },
                      {
                        type: "Sequence",
                        children: [
                          { type: "Terminal", text: "WHERE" },
                          { type: "NonTerminal", text: "@expression" }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                type: "Sequence",
                children: [
                  { type: "Terminal", text: "REVOKE" },
                  {
                    type: "Choice",
                    index: 1,
                    children: [
                      {
                        type: "Sequence",
                        children: [
                          { type: "Terminal", text: "GRANT" },
                          { type: "NonTerminal", text: "@id" }
                        ]
                      },
                      { type: "Terminal", text: "ALL" },
                      {
                        type: "Sequence",
                        children: [
                          { type: "Terminal", text: "WHERE" },
                          { type: "NonTerminal", text: "@expression" }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                type: "Sequence",
                children: [
                  { type: "Terminal", text: "PURGE" },
                  {
                    type: "Choice",
                    index: 1,
                    children: [
                      { type: "Terminal", text: "EXPIRED" },
                      {
                        type: "Sequence",
                        children: [
                          { type: "Terminal", text: "REVOKED" },
                          {
                            type: "Optional",
                            child: {
                              type: "Sequence",
                              children: [
                                { type: "Terminal", text: "," },
                                {
                                  type: "Choice",
                                  index: 0,
                                  children: [
                                    { type: "Terminal", text: "EXPIRED" },
                                    { type: "Terminal", text: "REVOKED" }
                                  ]
                                }
                              ]
                            }
                          }
                        ]
                      }
                    ]
                  },
                  {
                    type: "Optional",
                    child: {
                      type: "Sequence",
                      children: [
                        { type: "Terminal", text: "FOR" },
                        { type: "NonTerminal", text: "@duration" }
                      ]
                    }
                  }
                ]
              }
            ]
        }
      ]
    }
  ]
};

<RailroadDiagram ast={accessAst} className="my-6" />

  </TabItem>
</Tabs>

## `GRANT`

The `GRANT` clause creates and returns a grant for a certain subject using the specified access method. This subject can be a [system user](/docs/surrealdb/security/authentication#system-users) or [record user](/docs/surrealdb/security/authentication#record-users). Access grants can be used to access SurrealDB as that subject until they become expired or revoked.

When creating a grant, a secret (e.g. a key) corresponding with the grant will be returned. This secret should be stored securely, as it will no longer be displayed by SurrealDB, instead being printed as `[REDACTED]` whenever the grant details are shown.

```syntax title="SurrealQL Syntax"
ACCESS @name [ ON [ ROOT | NAMESPACE | DATABASE ] ] 
	GRANT [ FOR USER @name | FOR RECORD @record ]
```

#### Example: Grant for Automation using System User

```surql
-- Define system user for automation
DEFINE USER automation ON DATABASE PASSWORD 'secret' ROLES VIEWER;
-- Define bearer access method to generate API keys
DEFINE ACCESS api ON DATABASE TYPE BEARER FOR USER DURATION FOR GRANT 10d;
-- Generate bearer grant to be used by the automation
ACCESS api GRANT FOR USER automation;
```

```surql title="Response"
-- Query 1
NONE
-- Query 2
NONE
-- Query 3
{
        ac: 'api',
        creation: d'2024-12-16T16:15:51.517384293Z',
        expiration: d'2024-12-26T16:15:51.517386053Z',
        grant: {
                id: 'BNb2pS0GmaJz',
                key: 'surreal-bearer-BNb2pS0GmaJz-5eTfQ5uEu8jbRb3oblqVMAt8'
        },
        id: 'BNb2pS0GmaJz',
        revocation: NONE,
        subject: {
                user: 'automation'
        },
        type: 'bearer'
}
```

#### Example: Grant for End-User using Record User

```surql
-- Create record representing a user
CREATE user:1 CONTENT { name: "tobie" };
-- Define bearer access method to generate API keys
DEFINE ACCESS api ON DATABASE TYPE BEARER FOR RECORD DURATION FOR GRANT 10d;
-- Generate bearer grant to be used by the user
ACCESS api GRANT FOR RECORD user:1;
```

```surql title="Response"
-- Query 1
[
        {
                id: user:1,
                name: 'tobie'
        }
]
-- Query 2
NONE
-- Query 3
{
        ac: 'api',
        creation: d'2024-12-16T16:16:41.996932810Z',
        expiration: d'2024-12-26T16:16:41.996934501Z',
        grant: {
                id: 'sRLEKGxObJuM',
                key: 'surreal-bearer-sRLEKGxObJuM-iUUFe1vijFDaFDW7jceZJDkX'
        },
        id: 'sRLEKGxObJuM',
        revocation: NONE,
        subject: {
                record: user:1
        },
        type: 'bearer'
}
```

## `SHOW`

The `SHOW` clause displays the details of grants created with a specific access method. The statement allows showing the details of individual grants, all grants or only grants matching a particular SurrealQL expression. Beware that, in situations where grants are automatically created, showing all grants at once may be impractical and filtering is advised.

Note that any secrets (e.g. keys) associated with the grant will not be displayed and instead will be shown as `[REDACTED]`.

```syntax title="SurrealQL Syntax"
ACCESS @name [ ON [ ROOT | NAMESPACE | DATABASE ] ]
	SHOW [ GRANT @id | ALL | WHERE @expression ] 
```

#### Example: Showing the details of a specific grant 

```surql
-- Create record representing a user
CREATE user:1 CONTENT { name: "tobie" };
-- Define bearer access method to generate API keys
DEFINE ACCESS api ON DATABASE TYPE BEARER FOR RECORD DURATION FOR GRANT 10d;
-- Generate bearer grant to be used by the user
ACCESS api GRANT FOR RECORD user:1;
```

```surql title="Response"
-- Query 1
[
        {
                id: user:1,
                name: 'tobie'
        }
]
-- Query 2
NONE
-- Query 3
{
        ac: 'api',
        creation: d'2024-12-16T16:17:24.903832476Z',
        expiration: d'2024-12-26T16:17:24.903834523Z',
        grant: {
                id: 'JdvDFKMCVYoM',
                key: 'surreal-bearer-JdvDFKMCVYoM-0ahEAVY6egVdg33Vs5gc6J4h'
        },
        id: 'JdvDFKMCVYoM',
        revocation: NONE,
        subject: {
                record: user:1
        },
        type: 'bearer'
}
```


```surql
ACCESS api SHOW GRANT JdvDFKMCVYoM;
```

```surql title="Response"
{
        ac: 'api',
        creation: d'2024-12-16T16:17:24.903832476Z',
        expiration: d'2024-12-26T16:17:24.903834523Z',
        grant: {
                id: 'JdvDFKMCVYoM',
                key: '[REDACTED]'
        },
        id: 'JdvDFKMCVYoM',
        revocation: NONE,
        subject: {
                record: user:1
        },
        type: 'bearer'
}
```

#### Example: Showing the details of all grants for users of a certain name

Since the `subject` attribute of grants associated with a record is a record identifier, it can be used as a [record link](/docs/surrealql/datamodel/records) in order to access any record fields. This can be used to filter grants associated with record users matching certain conditions based on arbitrary data.

```surql
-- Create records representing users
CREATE user:1 CONTENT { name: "tobie" };
CREATE user:2 CONTENT { name: "jaime" };
-- Define bearer access method to generate API keys
DEFINE ACCESS api ON DATABASE TYPE BEARER FOR RECORD DURATION FOR GRANT 10d;
-- Generate bearer grants to be used by the users
ACCESS api GRANT FOR RECORD user:1;
ACCESS api GRANT FOR RECORD user:2;
```

```surql title="Response"
-- Query 1
[
        {
                id: user:1,
                name: 'tobie'
        }
]
-- Query 2
[
        {
                id: user:2,
                name: 'jaime'
        }
]
-- Query 3
NONE
-- Query 4
{
        ac: 'api',
        creation: d'2024-12-16T16:18:57.061692071Z',
        expiration: d'2024-12-26T16:18:57.061694228Z',
        grant: {
                id: 'HaJ19zCnP6RI',
                key: 'surreal-bearer-HaJ19zCnP6RI-R545vHcTbSCYdHnxIsVnjSFu'
        },
        id: 'HaJ19zCnP6RI',
        revocation: NONE,
        subject: {
                record: user:1
        },
        type: 'bearer'
}
-- Query 5
{
        ac: 'api',
        creation: d'2024-12-16T16:18:57.063673293Z',
        expiration: d'2024-12-26T16:18:57.063674755Z',
        grant: {
                id: 'ND2ZegEHfUGl',
                key: 'surreal-bearer-ND2ZegEHfUGl-JGPSr162qJ2bN8kURV8mYaLv'
        },
        id: 'ND2ZegEHfUGl',
        revocation: NONE,
        subject: {
                record: user:2
        },
        type: 'bearer'
}
```


```surql
ACCESS api SHOW WHERE subject.record.name = "tobie";
```

```surql title="Response"
[
        {
                ac: 'api',
                creation: d'2024-12-16T16:18:57.061692071Z',
                expiration: d'2024-12-26T16:18:57.061694228Z',
                grant: {
                        id: 'HaJ19zCnP6RI',
                        key: '[REDACTED]'
                },
                id: 'HaJ19zCnP6RI',
                revocation: NONE,
                subject: {
                        record: user:1
                },
                type: 'bearer'
        }
]
```

## `REVOKE`

The `REVOKE` clause revokes grants created with a specific access method. Revoking a grant ensures that the grant can no longer be used to authenticate. The grant will continue existing in revoked form and the time of the revocation is recorded in the details of the grant. Grants that have already been revoked cannot be revoked again. The statement allows revoking individual grants, all grants or only grants matching a particular SurrealQL expression.

```syntax title="SurrealQL Syntax"
ACCESS @name [ ON [ ROOT | NAMESPACE | DATABASE ] ]
	REVOKE [ GRANT @id | ALL | WHERE @expression ] 
]
```

#### Example: Revoking a specific grant

```surql
-- Create record representing a user
CREATE user:1 CONTENT { name: "tobie" };
-- Define bearer access method to generate API keys
DEFINE ACCESS api ON DATABASE TYPE BEARER FOR RECORD DURATION FOR GRANT 10d;
-- Generate bearer grant to be used by the user
ACCESS api GRANT FOR RECORD user:1;
```

```surql title="Response"
-- Query 1
[
        {
                id: user:1,
                name: 'tobie'
        }
]
-- Query 2
NONE
-- Query 3
{
        ac: 'api',
        creation: d'2024-12-17T10:36:09.215762475Z',
        expiration: d'2024-12-27T10:36:09.216227523Z',
        grant: {
                id: 'NJ2I2d7OXxN9',
                key: 'surreal-bearer-NJ2I2d7OXxN9-Oa5LqF36IzfURpo6Bhxy9WMF'
        },
        id: 'NJ2I2d7OXxN9',
        revocation: NONE,
        subject: {
                record: user:1
        },
        type: 'bearer'
}
```


```surql
ACCESS api REVOKE GRANT NJ2I2d7OXxN9;
```

```surql title="Response"
[
        [
                {
                        ac: 'api',
                        creation: d'2024-12-17T10:36:09.215762475Z',
                        expiration: d'2024-12-27T10:36:09.216227523Z',
                        grant: {
                                id: 'NJ2I2d7OXxN9',
                                key: '[REDACTED]'
                        },
                        id: 'NJ2I2d7OXxN9',
                        revocation: d'2024-12-17T10:36:52.740438379Z',
                        subject: {
                                record: user:1
                        },
                        type: 'bearer'
                }
        ]
]
```

#### Example: Revoking all grants for users of a certain name

Since the `subject` attribute of grants associated with a record is a record identifier, it can be used as a [record link](/docs/surrealql/datamodel/records) in order to access any record fields. This can be used to filter grants associated with record users matching certain conditions based on arbitrary data.

```surql
-- Create records representing users
CREATE user:1 CONTENT { name: "tobie" };
CREATE user:2 CONTENT { name: "jaime" };
-- Define bearer access method to generate API keys
DEFINE ACCESS api ON DATABASE TYPE BEARER FOR RECORD DURATION FOR GRANT 10d;
-- Generate bearer grants to be used by the users
ACCESS api GRANT FOR RECORD user:1;
ACCESS api GRANT FOR RECORD user:2;
```

```surql title="Response"
-- Query 1
[
        {
                id: user:1,
                name: 'tobie'
        }
]
-- Query 2
[
        {
                id: user:2,
                name: 'jaime'
        }
]
-- Query 3
NONE
-- Query 4
{
        ac: 'api',
        creation: d'2024-12-17T10:42:35.040901759Z',
        expiration: d'2024-12-27T10:42:35.040903414Z',
        grant: {
                id: 'mjSACes6sej4',
                key: 'surreal-bearer-mjSACes6sej4-WbEPMgmLTO3Jfg3po4we9m0V'
        },
        id: 'mjSACes6sej4',
        revocation: NONE,
        subject: {
                record: user:1
        },
        type: 'bearer'
}
-- Query 5
{
        ac: 'api',
        creation: d'2024-12-17T10:42:35.043162877Z',
        expiration: d'2024-12-27T10:42:35.043164533Z',
        grant: {
                id: 'RFilJMRp9lZi',
                key: 'surreal-bearer-RFilJMRp9lZi-OmflYxXwikDAvm8CNpsWYxd6'
        },
        id: 'RFilJMRp9lZi',
        revocation: NONE,
        subject: {
                record: user:2
        },
        type: 'bearer'
}
```


```surql
ACCESS api REVOKE WHERE subject.record.name = "tobie";
```

```surql title="Response"
[
        [
                {
                        ac: 'api',
                        creation: d'2024-12-17T10:42:35.040901759Z',
                        expiration: d'2024-12-27T10:42:35.040903414Z',
                        grant: {
                                id: 'mjSACes6sej4',
                                key: '[REDACTED]'
                        },
                        id: 'mjSACes6sej4',
                        revocation: d'2024-12-17T10:43:23.944198560Z',
                        subject: {
                                record: user:1
                        },
                        type: 'bearer'
                }
        ]
]
```

## `PURGE`

The `PURGE` clause completely removes grants created with a specific access method that have already been expired or revoked. In scenarios with very large amount of grants associated with an access method (e.g. when grants are automatically generated), purging inactive grants can improve the performance and experience of auditing grants with the `SHOW` clause. In some very high volume scenarios where grants are created by the hundreds of millions, purging may be necessary to limit the probability of collisions resulting in failure to create new grants. Note that the performance cost of validating a grant is independent from the number of existing grants, regardless of whether they are active or inactive.

Beware that any details associated with purged grants will be permanently lost and will no longer be available for auditing purposes. The `FOR` clause can be used to establish a minimum grace period after which expired or revoked grants should be purged. As with other security-sensitive operations related with the `ACCESS` statement, the purging of grants is logged in the SurrealDB server.

The clause will return the details of all grants that have successfully been purged and its performance will depend on the number of purged grants.

```syntax title="SurrealQL Syntax"
ACCESS @name [ ON [ ROOT | NAMESPACE | DATABASE ] ]
	PURGE [ EXPIRED | REVOKED [ , EXPIRED | REVOKED ] ] [ FOR @duration ]
]
```

#### Example: Purging grants that have been expired

```surql
/**[test]

[[test.results]]
value = "[]"

*/

ACCESS api PURGE EXPIRED;
```

#### Example: Purging grants that have been revoked for more than 90 days

```surql
/**[test]

[[test.results]]
value = "[]"

*/

ACCESS api PURGE REVOKED FOR 90d;
```

#### Example: Purging all grants that have been invalid for more than a year

```surql
/**[test]

[[test.results]]
value = "[]"

*/

ACCESS api PURGE EXPIRED, REVOKED FOR 1y;
```

## Improving error output

To improve the output of an error message inside an `ACCESS` statement, a [`THROW`](/docs/surrealql/statements/throw) statement can be used.

Follow these steps to see the output in practice.

First, start the SurrealDB server with a root user:

```bash
surreal start --user root --pass secret
```

Log in as the root user, choose the namespace `test` and database `test`, and run the following `DEFINE ACCESS` command.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE ACCESS account ON DATABASE TYPE RECORD
    SIGNUP ({
    IF $email = "me@me.com" {
        THROW "That's my email!!!"
    } ELSE {
        CREATE user SET email = $email, pass = crypto::argon2::generate($pass)}   
    })
    SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
    DURATION FOR TOKEN 15m, FOR SESSION 12h
;
```

As the `THROW` statement checks for the email address `me@me.com`, this can be tested using CURL at the [`signup`](/docs/surrealdb/integration/http#signup) endpoint via the following command.

```bash
curl -X POST -H "Accept: application/json" -d '{"ns":"test","db":"test","ac":"account", "email": "me@me.com", "pass": "strongpassword"}' http://localhost:8000/signup
```

The error output shows the user-defined error message `That's my email!!!`.

```bash title="Output"
{"code":400,"details":"Request problems detected","description":"There is a problem with your request. Refer to the documentation for further information.","information":"There was a problem with the database: An error occurred: That's my email!!!"
```

In all other cases, the signup process will work, returning a token.

```bash
curl -X POST -H "Accept: application/json" -d '{"ns":"test","db":"test","ac":"account", "email": "someotheremail@me.com", "pass": "strongpassword"}' http://localhost:8000/signup
```

```bash title="Output"
{"code":200,"details":"Authentication succeeded","token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3NDYwNzIxOTAsIm5iZiI6MTc0NjA3MjE5MCwiZXhwIjoxNzQ2MDczMDkwLCJpc3MiOiJTdXJyZWFsREIiLCJqdGkiOiI3YTc0ZjQ5ZS02OWMxLTRiMjMtYmRhNy05YThkNTNjNWFiZmIiLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJBQyI6ImFjY291bnQiLCJJRCI6InVzZXI6b2tlZjN5bmI4eXJkd2l3b3h1YjEifQ.4t1xwVkl36PeTFuBj0d41D6A-bwCx7LoNoLlj6yokA8wOKwEa1ldjBzTldZEmylLgP5-q8D4wp6f9Y6ntBZyPA","refresh":null}
```


================================================
FILE: src/content/doc-surrealql/statements/alter.mdx
================================================
---
sidebar_position: 1
sidebar_label: ALTER
title: ALTER statement | SurrealQL
description: The ALTER statement can be used to change authentication access and behaviour, global parameters, table configurations, table events, schema definitions, and indexes.
---
import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `ALTER` statement

<Since v="v2.0.0" />

The `ALTER` statement can be used to change definitions for defined resources.


> [!NOTE]
> Currently, the `ALTER` statement only supports modifying tables and their properties - `ALTER TABLE`, but will be expanded to include other resources. In the meantime, the `OVERWRITE` clause can be used in other `DEFINE` statements to redefine resources that have already been defined.

<Tabs syncKey="alter-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
ALTER [
	| TABLE [ IF EXISTS ] @name
		[ DROP ]
		[ SCHEMAFULL | SCHEMALESS ]
		[ PERMISSIONS [ NONE | FULL
			| FOR select @expression
			| FOR create @expression
			| FOR update @expression
			| FOR delete @expression
		] ]
    [ COMMENT @string | CHANGEFEED ]
]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const alterAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "ALTER" },
      { type: "Sequence", children: [
        { type: "Terminal", text: "TABLE" },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "EXISTS" } ] } },
        { type: "NonTerminal", text: "@name" },
        { type: "Optional", child: { type: "Terminal", text: "DROP" } },
        { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "SCHEMAFULL" }, { type: "Terminal", text: "SCHEMALESS" } ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "PERMISSIONS" }, { type: "Choice", index: 1, children: [
          { type: "Terminal", text: "NONE" },
          { type: "Terminal", text: "FULL" },
          { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "select" }, { type: "NonTerminal", text: "@expression" } ] },
          { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "create" }, { type: "NonTerminal", text: "@expression" } ] },
          { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "update" }, { type: "NonTerminal", text: "@expression" } ] },
          { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "delete" }, { type: "NonTerminal", text: "@expression" } ] }
        ] } ] } },
        { type: "Optional", child: { type: "Choice", index: 1, children: [
          { type: "Sequence", children: [ { type: "Terminal", text: "COMMENT" }, { type: "NonTerminal", text: "@string" } ] },
          { type: "Terminal", text: "CHANGEFEED" }
        ] } }
      ] },
    ]}
  ]
};

<RailroadDiagram ast={alterAst} className="my-6" />

  </TabItem>
</Tabs>

## Modify a table schema

When starting a new project, you may require a table to be schemaless to allow for flexibility in the data structure. However, as the project progresses, you may want to lock down the schema to prevent new fields from being added. This can be done using the `ALTER` statement.

> [!NOTE]
> To see the already defined items that can be modified with `ALTER`, use the [INFO](/docs/surrealql/statements/info) statement (`INFO FOR ROOT`, `INFO FOR NAMESPACE`, or `INFO FOR DATABASE`).

An example of `ALTER` to modify an existing table:
```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: user:317esn5r3spd4em0lfze, name: 'LordofSalty' }]"
skip-record-id-key = true

[[test.results]]
value = "NONE"

*/

DEFINE TABLE user SCHEMALESS;
DEFINE FIELD name ON TABLE user TYPE string;
CREATE user SET name = "LordofSalty";

-- Now make it schemafull to ensure that no other fields can be used
ALTER TABLE user SCHEMAFULL;
```

## Modify table permissions

You can also use the `ALTER` statement to change a table's permissions. An `ALTER` statement only needs to include the items to be altered, not the entire definition.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Will show up as DEFINE TABLE user TYPE ANY SCHEMAFULL PERMISSIONS NONE
DEFINE TABLE user SCHEMAFULL;

-- Now defined as DEFINE TABLE user TYPE ANY SCHEMAFULL PERMISSIONS FULL
ALTER TABLE user PERMISSIONS FOR create FULL;
```

## Using `IF EXISTS` clause

You can use the' IF EXISTS' clause to prevent an error from occurring when trying to alter a table that does not exist.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

ALTER TABLE IF EXISTS user SCHEMAFULL;
```



================================================
FILE: src/content/doc-surrealql/statements/begin.mdx
================================================
---
sidebar_position: 2
sidebar_label: BEGIN
title: BEGIN statement | SurrealQL
description: The BEGIN statement starts a single transaction in which run multiple statements can be run, either succeeding as a whole, or failing.
---

# `BEGIN` statement

Each statement within SurrealDB is run within its own transaction by default. The `BEGIN` statement can be used to modify this behaviour by running a group of statements inside a single transaction, either succeeding as a whole, or failing. Once all of the statements within a transaction succeed, then all of the data modifications can be made permanent by finalizing the transaction with a [COMMIT](/docs/surrealql/statements/commit) statement at the end. If any statement within a transaction encounters an error or the transaction is manually cancelled ([CANCEL](/docs/surrealql/statements/cancel)), then any data modification made within the transaction is rolled back, and will not become a permanent part of the database.

### Statement syntax

import RailroadDiagram from "@components/RailroadDiagram.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

<Tabs syncKey="begin-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
BEGIN [ TRANSACTION ];
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const beginAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    {
      type: "Sequence",
      children: [
        { type: "Terminal", text: "BEGIN" },
        { type: "Optional", child: { type: "Terminal", text: "TRANSACTION" } },
        { type: "Terminal", text: ";" },
      ],
    },
  ],
};

<RailroadDiagram ast={beginAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

The following query shows example usage of this statement.

```surql
/**[test]

[[test.results]]
value = "[{ balance: 135605.16f, id: account:one }]"

[[test.results]]
value = "[{ balance: 91031.31f, id: account:two }]"

[[test.results]]
value = "[{ balance: 135905.16f, id: account:one }]"

[[test.results]]
value = "[{ balance: 90731.31f, id: account:two }]"

*/

-- Start a new database transaction. Transactions are a way to ensure multiple operations
-- either all succeed or all fail, maintaining data integrity.
BEGIN TRANSACTION;

-- Create a new account with the ID 'one' and set its initial balance to 135605.16
CREATE account:one SET balance = 135605.16;

-- Create another new account with the ID 'two' and set its initial balance to 91031.31
CREATE account:two SET balance = 91031.31;

-- Update the balance of account 'one' by adding 300.00 to the current balance.
-- This could represent a deposit or other form of credit on the balance property.
UPDATE account:one SET balance += 300.00;

-- Update the balance of account 'two' by subtracting 300.00 from the current balance.
-- This could represent a withdrawal or other form of debit on the balance property.
UPDATE account:two SET balance -= 300.00;

-- Finalize the transaction. This will apply the changes to the database. If there was an error
-- during any of the previous steps within the transaction, all changes would be rolled back and
-- the database would remain in its initial state.
COMMIT TRANSACTION;
```

## Returning early from a transaction

While all transactions require a final `COMMIT` or `CANCEL` statement in order to run, an early return can take place via the following:

* An error inside one of the statements inside the transaction,
* A `THROW` statement to return early with an error,
* A `RETURN` statement to return early. This is often used to customize the output of a transaction.

An example of the above:

```surql
/**[test]

[[test.results]]
value = "'Money sent! Status:
{ balance: 135905.16f, id: account:one }
{ balance: 90731.31f, id: account:two, wants_to_send_money: true }'"

[[test.results]]
value = "{ balance: 135905.16f, id: account:one }, { balance: 90731.31f, id: account:two, wants_to_send_money: true }"

*/

BEGIN;

CREATE account:one SET balance = 135605.16;
CREATE account:two SET balance = 91031.31, wants_to_send_money = true;

IF !account:two.wants_to_send_money {
    THROW "Customer doesn't want to send any money!";
};

LET $first = UPDATE ONLY account:one SET balance += 300.00;
LET $second = UPDATE ONLY account:two SET balance -= 300.00;

RETURN "Money sent! Status:\n" + <string>$first + '\n' + <string>$second;

COMMIT;
```

```surql title="Output"
'Money sent! Status:
{ balance: 135905.16f, id: account:one }
{ balance: 90731.31f, id: account:two, wants_to_send_money: true }'
```


================================================
FILE: src/content/doc-surrealql/statements/break.mdx
================================================
---
sidebar_position: 3
sidebar_label: BREAK
title: BREAK statement | SurrealQL
description: The BREAK statement can be used to break out of a loop.
---

# `BREAK` statement

The BREAK statement can be used to break out of a loop, such as inside one created by the [FOR statement](/docs/surrealql/statements/for).

import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

### Statement syntax

<Tabs syncKey="break-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
BREAK
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const breakAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "BREAK" }
    ]}
  ]
};

<RailroadDiagram ast={breakAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

The following queries shows example usage of this statement.

Creating a person for everyone in the array where the number is less than or equal to 5:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

LET $numbers = [1,2,3,4,5,6,7,8,9];

FOR $num IN $numbers {
    IF $num > 5 {
        BREAK;

    } ELSE IF $num < 5 {
        CREATE type::record(
            'person', $num
        ) CONTENT {
            name: "Person number " + <string>$num
        };
    };
};
```

Breaking out of a loop once unwanted data is encountered:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Data retrieved from somewhere which contains many NONE values
LET $weather = [
	{
		city: 'London',
		temperature: 22.2,
		timestamp: 1722565566389
	},
	NONE,
	{
		city: 'London',
		temperature: 20.1,
		timestamp: 1722652002699
	},
    {
        city: 'Phoenix',
        temperature: 45.1,
        timestamp: 1722565642160
    },
    NONE,
    NONE,
    {
        city: 'Phoenix',
        temperature: 45.1,
        timestamp: 1722652070372
    },
];

-- Sort the data to move the NONE values to the end
-- and break once the first NONE is reached
FOR $data IN array::sort::desc($weather) {
    IF $data IS NONE {
        BREAK;
    } ELSE {
        CREATE weather CONTENT $data;
    };
};
```



================================================
FILE: src/content/doc-surrealql/statements/cancel.mdx
================================================
---
sidebar_position: 4
sidebar_label: CANCEL
title: CANCEL statement | SurrealQL
description: The CANCEL statement can be used to cancel the statements within a transaction, reverting or rolling back any data modification made within the transaction as a whole.
---

# `CANCEL` statement

Each statement within SurrealDB is run within its own transaction. If a set of changes need to be made together, then groups of statements can be run together as a single transaction, either succeeding as a whole, or failing without leaving any residual data modifications. While a transaction will fail if any of its statements encounters an error, the `CANCEL` statement can also be used to cancel a transaction manually.

import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

### Statement syntax

<Tabs syncKey="cancel-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
CANCEL [ TRANSACTION ];
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const cancelAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "CANCEL" },
      { type: "Optional", child: { type: "Terminal", text: "TRANSACTION" } },
      { type: "Terminal", text: ";" }
    ]}
  ]
};

<RailroadDiagram ast={cancelAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

The following query shows example usage of this statement.

```surql
/**[test]

[[test.results]]
error = "'The query was not executed due to a cancelled transaction'"

[[test.results]]
error = "'The query was not executed due to a cancelled transaction'"

[[test.results]]
error = "'The query was not executed due to a cancelled transaction'"

[[test.results]]
error = "'The query was not executed due to a cancelled transaction'"

*/

BEGIN TRANSACTION;

-- Setup accounts
CREATE account:one SET balance = 135605.16;
CREATE account:two SET balance = 91031.31;

-- Move money
UPDATE account:one SET balance += 300.00;
UPDATE account:two SET balance -= 300.00;

-- Rollback all changes
CANCEL TRANSACTION;
```

`CANCEL` is not used to automatically cancel a transaction based on a condition such as inside an [IF..ELSE](/docs/surrealql/statements/ifelse) block. Instead, a [THROW](/docs/surrealql/statements/throw) statement is used. THROW can be followed by any value, usually a string containing context behind the error.

```surql
/**[test]

[[test.results]]
error = "'The query was not executed due to a cancelled transaction'"

[[test.results]]
error = "'The query was not executed due to a cancelled transaction'"

[[test.results]]
error = "'The query was not executed due to a cancelled transaction'"

[[test.results]]
error = "'The query was not executed due to a cancelled transaction'"

[[test.results]]
error = "'An error occurred: Not enough funds'"

*/

BEGIN TRANSACTION;

-- Setup accounts
CREATE account:one SET balance = 135605.16;
CREATE account:two SET balance = 200.31;

-- Move money
UPDATE account:one SET balance += 300.00;
UPDATE account:two SET balance -= 300.00;

IF account:two.balance < 0 {
    THROW "Not enough funds";
};

COMMIT TRANSACTION;
```



================================================
FILE: src/content/doc-surrealql/statements/commit.mdx
================================================
---
sidebar_position: 4
sidebar_label: COMMIT
title: COMMIT statement | SurrealQL
description: The COMMIT statement is used to commit a set of statements within a transaction, ensuring that all data modifications become a permanent part of the database.
---

# `COMMIT` statement

Each statement within SurrealDB is run within its own transaction by default. If a set of changes need to be made together, then groups of statements can be run together as a single transaction, either succeeding as a whole, or failing without leaving any residual data modifications. A `COMMIT` statement is used at the end of such a transaction to make the data modifications a permanent part of the database.

### Statement syntax

import RailroadDiagram from "@components/RailroadDiagram.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

<Tabs syncKey="commit-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
COMMIT [ TRANSACTION ];
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const commitAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    {
      type: "Sequence",
      children: [
        { type: "Terminal", text: "COMMIT" },
        { type: "Optional", child: { type: "Terminal", text: "TRANSACTION" } },
        { type: "Terminal", text: ";" },
      ],
    },
  ],
};

<RailroadDiagram ast={commitAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

The following query shows example usage of this statement.

```surql
/**[test]

[[test.results]]
value = "[{ balance: 135605.16f, id: account:one }]"

[[test.results]]
value = "[{ balance: 91031.31f, id: account:two }]"

[[test.results]]
value = "[{ balance: 135905.16f, id: account:one }]"

[[test.results]]
value = "[{ balance: 90731.31f, id: account:two }]"

*/

BEGIN TRANSACTION;

-- Setup accounts
CREATE account:one SET balance = 135605.16;
CREATE account:two SET balance = 91031.31;

-- Move money
UPDATE account:one SET balance += 300.00;
UPDATE account:two SET balance -= 300.00;

-- Finalise all changes
COMMIT TRANSACTION;
```

The following two options can be used at any point if a transaction must be cancelled without commiting the changes:

* [CANCEL](/docs/surrealql/statements/cancel) to manually cancel the transaction.
* [THROW](/docs/surrealql/statements/throw) to cancel a transaction with an optional error message. THROW is the only way to cancel a transaction based on a condition, such as inside an [IF..ELSE](/docs/surrealql/statements/ifelse) block.

In addition, a `RETURN` statement can be used to return early from a successful transaction. This is often used in order to return a customized output.

```surql
/**[test]

[[test.results]]
value = "'Money sent! Status:
{ balance: 135905.16f, id: account:one }
{ balance: 90731.31f, id: account:two, wants_to_send_money: true }'"

[[test.results]]
value = "{ balance: 135905.16f, id: account:one }"

[[test.results]]
value = "{ balance: 90731.31f, id: account:two, wants_to_send_money: true }"

*/

BEGIN;

CREATE account:one SET balance = 135605.16;
CREATE account:two SET balance = 91031.31, wants_to_send_money = true;

IF !account:two.wants_to_send_money {
    THROW "Customer doesn't want to send any money!";
};

LET $first = UPDATE ONLY account:one SET balance += 300.00;
LET $second = UPDATE ONLY account:two SET balance -= 300.00;

RETURN "Money sent! Status:\n" + <string>$first + '\n' + <string>$second;

COMMIT;
```

```surql title="Output"
'Money sent! Status:
{ balance: 135905.16f, id: account:one }
{ balance: 90731.31f, id: account:two, wants_to_send_money: true }'
```


================================================
FILE: src/content/doc-surrealql/statements/continue.mdx
================================================
---
sidebar_position: 6
sidebar_label: CONTINUE
title: CONTINUE statement | SurrealQL
description: The CONTINUE statement can be used to skip an iteration of a loop, like within the FOR statement
---

# `CONTINUE` statement

The CONTINUE statement can be used to skip an iteration of a loop, like within the [FOR statement](/docs/surrealql/statements/for).

import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

### Statement syntax

<Tabs syncKey="continue-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
CONTINUE
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const continueAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "CONTINUE" }
    ]}
  ]
};

<RailroadDiagram ast={continueAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

The following queries shows example usage of this statement.

Skipping an iteration of a loop unless a certain condition is met:

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Set can_vote to true for every person over 18 years old.
FOR $person IN (SELECT id, age FROM person) {
	IF ($person.age < 18) {
		CONTINUE;
	};

	UPDATE $person.id SET can_vote = true;
};
```

Skipping an iteration of a loop when bad data is encountered:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Data retrieved from somewhere which contains many NONE values
LET $weather = [
	{
		city: 'London',
		temperature: 22.2,
		timestamp: 1722565566389
	},
	NONE,
	{
		city: 'London',
		temperature: 20.1,
		timestamp: 1722652002699
	},
    {
        city: 'Phoenix',
        temperature: 45.1,
        timestamp: 1722565642160
    },
    NONE,
    NONE,
    {
        city: 'Phoenix',
        temperature: 45.1,
        timestamp: 1722652070372
    },
];

FOR $data IN $weather {
    IF $data IS NONE {
        CONTINUE;
    };

	CREATE weather CONTENT $data;
};
```



================================================
FILE: src/content/doc-surrealql/statements/create.mdx
================================================
---
sidebar_position: 7
sidebar_label: CREATE
title: CREATE statement | SurrealQL
description: The CREATE statement can be used to add a record to the database if it does not already exist.
---

import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `CREATE` statement

The `CREATE` statement can be used to add a record to the database. If the record already exists, the statement will give an error.

> [!NOTE]
> This statement can not be used to create graph relationships. For that, use the [`RELATE`](/docs/surrealql/statements/relate) statement.

### Statement syntax

<Tabs syncKey="create-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
CREATE [ ONLY ] @targets
	[ CONTENT @value
	  | SET @field = @value ...
	]
	[ RETURN NONE | RETURN BEFORE | RETURN AFTER | RETURN DIFF | RETURN @statement_param, ... | RETURN VALUE @statement_param ]
	[ TIMEOUT @duration ]
;
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const createAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    {
      type: "Sequence",
      children: [
        { type: "Terminal", text: "CREATE" },
        { type: "Optional", child: { type: "Terminal", text: "ONLY" } },
        { type: "NonTerminal", text: "@targets" },
        { type: "Optional", child: { type: "Choice", index: 1, children: [
          { type: "Sequence", children: [ { type: "Terminal", text: "CONTENT" }, { type: "NonTerminal", text: "@value" } ] },
          { type: "Sequence", children: [ { type: "Terminal", text: "SET" }, { type: "NonTerminal", text: "@field = @value ..." } ] }
        ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "RETURN" }, { type: "Choice", index: 1, children: [
          { type: "Terminal", text: "NONE" },
          { type: "Terminal", text: "BEFORE" },
          { type: "Terminal", text: "AFTER" },
          { type: "Terminal", text: "DIFF" },
          { type: "NonTerminal", text: "@statement_param, ..." },
          { type: "Sequence", children: [ { type: "Terminal", text: "VALUE" }, { type: "NonTerminal", text: "@statement_param" } ] }
        ] } ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "TIMEOUT" }, { type: "NonTerminal", text: "@duration" } ] } },
        { type: "Terminal", text: ";" },
      ],
    },
  ],
};

<RailroadDiagram ast={createAst} className="my-6" />

  </TabItem>
</Tabs>

## Creating a Table Record

`CREATE` can be used with just a table name, in which case its ID will be generated randomly.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:ht9tbw226vijmg2uf72c }]"
skip-record-id-key = true

*/

-- Create a new record
CREATE person;
```

```surql title="Response"
[
    {
        "id": "person:2vvgzt6m24s952yiy7x8"
    }
]
```

To specify a specific ID for a table instead, use `:` followed by a value.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:one }]"

*/

CREATE person:one;
```

```surql title="Response"
[
	{
		id: person:one
	}
]
```

The table name and ID together form the full [record ID](/docs/surrealql/datamodel/ids) which can be used to query the created data or by using the [`SELECT`](/docs/surrealql/statements/select) statement. See the [record ID](/docs/surrealql/datamodel/ids) page to learn more about what counts as a valid record identifier.

The default random ID can be generated in different ways (such as a ULID) using the [built-in ID generation functions](/docs/surrealql/datamodel/ids#generating-record-ids).

It is also possible to specify the ID of the record you want to create using a string or any of the supported formats for [record IDs](/docs/surrealql/datamodel/ids).

```surql
-- Use the type::record() function to provide a record's table and id separately
CREATE type::record("person", "one");
```

## Adding Record Data

When creating a record, you can specify the record data using the `SET` clause, or the `CONTENT` clause. The `SET` clause is used to specify record data one field at a time, while the `CONTENT` clause is used to specify record data using a SurrealQL object. The `CONTENT` clause is useful when the record data is already in the form of a SurrealQL or JSON object.

```surql
/**[test]

[[test.results]]
value = "[{ company: 'SurrealDB', id: person:tobie, name: 'Tobie', skills: ['Rust', 'Go', 'JavaScript'] }]"

*/

-- Create a new record with a text id
CREATE person:tobie SET
    name = 'Tobie',
    company = 'SurrealDB',
    skills = ['Rust', 'Go', 'JavaScript'];
```

The above will create a new record with the ID `person:tobie` and the specified data.

```surql title="Response"
[
	{
		"id": "person:tobie",
		"name": "Tobie",
		"company": "SurrealDB",
		"skills": ["Rust", "Go", "JavaScript"]
	}
]
```

Specifing record data using the `CONTENT` keyword:

```surql
/**[test]

[[test.results]]
value = "[{ company: 'SurrealDB', id: person:100, name: 'Tobie', skills: ['Rust', 'Go', 'JavaScript'] }]"

*/

-- Create a new record with a numeric id
CREATE person:100 CONTENT {
	name: 'Tobie',
	company: 'SurrealDB',
	skills: ['Rust', 'Go', 'JavaScript'],
};
```

## Options and clauses

### Creating multiple records

Multiple records or even multiple record types can be created by separating table names by commas.

```surql
/**[test]

[[test.results]]
value = "[{ created_at: d'2025-10-08T02:18:52.928229Z', id: townsperson:0jkw66fganx0eqdkimgd, name: 'Just a townsperson' }, { created_at: d'2025-10-08T02:18:52.932072Z', id: cat:yw43e5ycrdq8mpzx7zq3, name: 'Just a cat' }, { created_at: d'2025-10-08T02:18:52.934887Z', id: dog:z4yq39x2hj79jl43v57x, name: 'Just a dog' }]"
skip-datetime = true 
skip-record-id-key = true

*/

-- Note: meta::tb(id) returns just the table name portion of a record ID
CREATE townsperson, cat, dog SET
    created_at = time::now(),
    name = "Just a " + record::tb(id);
```

```surql title="Response"
[
    {
        "created_at": "2024-03-19T03:12:05.079Z",
        "id": "townsperson:p37ha2lngckp3v8tvf2j",
        "name": "Just a townsperson"
    },
    {
        "created_at": "2024-03-19T03:12:05.080Z",
        "id": "cat:p1pwbjaq96nhhnuohjtc",
        "name": "Just a cat"
    },
    {
        "created_at": "2024-03-19T03:12:05.080Z",
        "id": "dog:01vcxgdpuctdk354hzkp",
        "name": "Just a dog"
    }
]
```

The `| |` syntax is another way to create multiple records in a single execution. This syntax can be used in two ways.

One is by including a table name, a `:` (a colon), and then a number. This will create a quantity of records equal to the number after the table name. The records created will have random IDs.

```surql
/**[test]

[[test.results]]
value = "[{ id: townsperson:ddt3gkla0ve6yt0vwunr }, { id: townsperson:cj902h7hbsn8evg7fq5d }, { id: townsperson:01n15yxzw0vl42u008a4 }]"
skip-record-id-key = true

*/

-- Creates three townperson records with a random ID
CREATE |townsperson:3|;
```

```surql title="Response"
[
	{
		id: townsperson:hzkt0piy3f72xo5dl2jf
	},
	{
		id: townsperson:k0mujrohm8qe2txz5pnz
	},
	{
		id: townsperson:pwumqelrsi1qt0jmihwh
	}
]
```

The other method is by using the `..` range syntax after the `:` instead of a single number. This will create records with specific IDs that span across the range indicated.

```surql
-- Note: 1..4 used to be inclusive until SurrealDB 3.0.0
-- Now creates 1 up to but not including 4
CREATE |townsperson:1..4|;
```

```surql title="Response"
[
	{
		id: townsperson:1
	},
	{
		id: townsperson:2
	},
	{
		id: townsperson:3
	}
]
```

All of these methods can be combined to create multiple records at the same time.

```surql
CREATE dog, |cat:2|, |townsperson:1..3| SET
    created_at = time::now(),
    name = "Just a " + meta::tb(id);
```

```surql title="Response"
[
	{
		created_at: '2024-08-13T04:14:44.135Z',
		id: dog:u3fzmqvg3yq9mo3o6z2s,
		name: 'Just a dog'
	},
	{
		created_at: '2024-08-13T04:14:44.137Z',
		id: cat:n6x3caiiazucslfs7rpm,
		name: 'Just a cat'
	},
	{
		created_at: '2024-08-13T04:14:44.137Z',
		id: cat:rnvhxgjhsbea5u58s0wu,
		name: 'Just a cat'
	},
	{
		created_at: '2024-08-13T04:14:44.137Z',
		id: townsperson:1,
		name: 'Just a townsperson'
	},
	{
		created_at: '2024-08-13T04:14:44.137Z',
		id: townsperson:2,
		name: 'Just a townsperson'
	},
	{
		created_at: '2024-08-13T04:14:44.137Z',
		id: townsperson:3,
		name: 'Just a townsperson'
	}
]
```

### ONLY

When creating a single record, the `ONLY` clause can be used to return the record object on its own instead of inside an array.

```surql
-- Returns an array with a single record inside
CREATE person:tobie SET
    name = 'Tobie',
    company = 'SurrealDB',
    skills = ['Rust', 'Go', 'JavaScript'];

-- Returns just a single record
CREATE ONLY person:tobie SET
    name = 'Tobie',
    company = 'SurrealDB',
    skills = ['Rust', 'Go', 'JavaScript'];
```

```surql title="Response"
-------- Query --------

[
	{
		company: 'SurrealDB',
		id: person:tobie,
		name: 'Tobie',
		skills: [
			'Rust',
			'Go',
			'JavaScript'
		]
	}
]

-------- Query --------

{
	company: 'SurrealDB',
	id: person:tobieagain,
	name: 'Tobie',
	skills: [
		'Rust',
		'Go',
		'JavaScript'
	]
}
```

### Return Values

By default, the create statement returns the record once it has been created. To change what is returned, we can use the `RETURN` clause, specifying either `NONE`, `BEFORE`, `AFTER`, `DIFF`, or a comma-separated list of specific fields to return.

`RETURN NONE` can be useful to avoid excess output:

```surql
-- Create 10000 records but don't show any of them
CREATE |person:10000| SET age = 46, username = "john-smith" RETURN NONE;
```

`RETURN DIFF` returns the changeset diff:

```surql
/**[test]

[[test.results]]
value = "[[{ op: 'replace', path: '', value: { age: 46, id: person:2wm77z4dn1wjh7az4r5f, username: 'john-smith' } }]]"

*/

CREATE person SET age = 46, username = "john-smith" RETURN DIFF;
```

```surql title="Response"
[
	[
		{
			op: 'replace',
			path: '/',
			value: {
				age: 46,
				id: person:h84x4k5kh2m6cjf1vvza,
				username: 'john-smith'
			}
		}
	]
]
```

`RETURN BEFORE` inside a `CREATE` statement is essentially a synonym for `RETURN NONE`, while `RETURN AFTER` is the default behaviour for create.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Will always return NONE
CREATE person SET age = 46, username = "john-smith" RETURN BEFORE;
```

```surql
/**[test]

[[test.results]]
value = "[{ age: 46, id: person:ncnnp25vhiqddlfvz5ve, username: 'john-smith' }]"
skip-record-id-key = true

*/

-- Return the record after creation
CREATE person SET age = 46, username = "john-smith" RETURN AFTER;
```

You can also return specific fields from a created record, the value of a single field using `VALUE`, as well as ad-hoc fields to modify the output as needed.

```surql
/**[test]

[[test.results]]
value = "[{ age: 46, age_next_year: 47, interests: ['skiing', 'music'] }]"

[[test.results]]
value = "[20, 20, 20, 20, 20]"

*/

CREATE person
    SET age = 46,
    username = "john-smith",
    interests = ['skiing', 'music']
RETURN
    age,
    interests,
    age + 1 AS age_next_year;

CREATE |person:5|
    SET age = 20
RETURN VALUE age;
```

```surql title="Response"
-------- Query --------

[
	{
		age: 46,
		age_next_year: 47,
		interests: [
			'skiing',
			'music'
		]
	}
]

-------- Query --------

[
	20,
	20,
	20,
	20,
	20
]
```

### Timeout

The `TIMEOUT` clause can be used to specify the maximum time the statement should take to execute. This is useful when you want more control such as controlling compute costs or making sure queries succeed or fail within tight latency boundaries to not have a big query queue forming.

The value for `TIMEOUT` is specified in seconds or milliseconds.

```surql
-- Query attempting to create half a million `person` records
CREATE |person:500000| SET age = 46, username = "john-smith" TIMEOUT 500ms;
```

### `VERSION`

<Since v="v2.0.0" />

If you are using [SurrealKV as the storage engine](/docs/surrealkv) with versioning enabled, when creating a record you can specify a version for each record. This is useful for time-travel queries. You can query a specific version of a record by using the `VERSION` clause.

The `VERSION` clause is always followed by a [datetime](/docs/surrealql/datamodel/datetimes) and when the specified timestamp does not exist, an empty array is returned.

> [!NOTE]
> The `VERSION` clause is currently in alpha and is subject to change. We do not recommend this for production.

```surql
-- Create a record for user:john at 8:00AM
CREATE user:john SET name = 'John' VERSION d'2024-08-19T08:00:00Z';
[[{ id: user:john, name: 'John' }]]

-- Return the record for user:john at 8:00AM
SELECT * FROM user:john VERSION d'2024-08-19T08:00:00Z';
[[{ id: user:john, name: 'John' }]]

-- Create a record for user:john at 8:01AM
CREATE user:john SET name = 'John-1' VERSION d'2024-08-19T08:01:00Z';
[[{ id: user:john, name: 'John-1' }]]

-- Return the record for user:john at 8:01AM
SELECT * FROM user:john VERSION d'2024-08-19T08:01:00Z';
[[{ id: user:john, name: 'John-1' }]]

-- Return an empty array because the record at the datetime does not exist
SELECT * FROM user:john VERSION d'2024-08-19T07:00:00Z';
[[]]
```

Another example of how `VERSION` works with `CREATE` is by creating records at different times and then querying for them at a specific point in time.

```surql
CREATE |user:10| VERSION d"2020-09-09";

[[{ id: user:rtbjoqv1xe9wnxjx5aro }, { id: user:tkik878q8uoddvuucu0a }, { id: user:rcnywgogvlipv3tb8qut }, { id: user:30ynx82x52ff77dxzv1i }, { id: user:59mxi0xosi3im5ccbx8l }, { id: user:nolu7yreqs4e5m7255oa }, { id: user:u384ycj1d2esi3yrasli }, { id: user:n4xnrq98ookevhmdd7d2 }, { id: user:5j5ujfu4dokcpdk51qa8 }, { id: user:jiqmlvrgafeorr50nvn9 }]]

CREATE |user:10| VERSION d"2020-09-10";
[[{ id: user:ze98ow4bzdcndzc5nlqj }, { id: user:gjqu2uh3wnp1cpjg1unt }, { id: user:17bxpjl4ptbxv9k2ghmt }, { id: user:fmqqeajf52neg4c7oaoq }, { id: user:bfn45ewsg86auvekeuz0 }, { id: user:834yq1tyatwopb4726mj }, { id: user:veehoua4cu65ff4wc8pf }, { id: user:y3az4pizc0ddpruixw6g }, { id: user:xrn6eqrtyqgg8cgpm9zp }, { id: user:s06acf74rsnvhvim3ys5 }]]

RETURN count(SELECT * FROM user VERSION d"2020-09-09"); -- returns 10
[10]

RETURN count(SELECT * FROM user); -- returns 21
[21]
```

<Since v="v2.1.0" />

The `VERSION` clause can also take a dynamic value or parameter that resolves to a datetime.

```surql
CREATE user:john SET name = 'John' VERSION time::now();

LET $now = time::now();
CREATE user:john_the_second SET name = 'John' VERSION $now;

DEFINE FUNCTION fn::yesterday() { time::now() - 1d };
CREATE user:john_the_third SET name = 'John' VERSION fn::yesterday();
```

## Implicit statement behaviour

While a number of definitions need to be in place for a `CREATE` statement to happen, SurrealDB will handle them automatically by default. This behaviour is best seen by starting a new database.

While a connection to SurrealDB via Surrealist or the [surreal sql](/docs/surrealdb/cli/sql) command can include a defined namespace and database, the namespace and database names do not exist upon creation. At this point, they are only held inside the pre-defined [$session](/docs/surrealql/parameters#session) parameter. This can be seen through the [INFO](/docs/surrealql/statements/info) statements, which will show no definitions at all inside a new database.

```surql
INFO FOR ROOT;
INFO FOR NS;
INFO FOR DB;
RETURN $session;
```

```surql title="Response"
-------- Query --------

{
	accesses: {},
	namespaces: {},
	nodes: {},
	system: {
		available_parallelism: 0,
		cpu_usage: 0,
		load_average: [
			0,
			0,
			0
		],
		memory_allocated: 0,
		memory_usage: 0,
		physical_cores: 0,
		threads: 0
	},
	users: {}
}

-------- Query --------

{
	accesses: {},
	analyzers: {},
	apis: {},
	configs: {},
	functions: {},
	models: {},
	params: {},
	tables: {},
	users: {}
}

-------- Query --------

{
	analyzers: {},
	functions: {},
	models: {},
	params: {},
	scopes: {},
	tables: {},
	tokens: {},
	users: {}
}

-------- Query --------

{
	ac: NONE,
	db: 'sandbox',
	exp: NONE,
	id: NONE,
	ip: NONE,
	ns: 'sandbox',
	or: NONE,
	rd: NONE,
	tk: NONE
}
```

This is to allow the chance to [define](/docs/surrealql/statements/define/database) them manually, such as by including a comment.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE DATABASE my_database COMMENT "Some important info that I prefer to add manually";
```

However, once the first record is created or inserted, SurrealDB will access the session data to execute a number of definition statements for the namespace, database, and then add a definition for the desired table name in order to allow the operation to proceed.

```surql
-- Three DEFINE statements will happen to allow this operation
CREATE person;

INFO FOR ROOT;
INFO FOR NS;
INFO FOR DB;
```

```surql title="Response"
-------- Query --------

{
	accesses: {},
	namespaces: {
		sandbox: 'DEFINE NAMESPACE sandbox'
	},
	nodes: {},
	system: {
		available_parallelism: 0,
		cpu_usage: 0,
		load_average: [
			0,
			0,
			0
		],
		memory_allocated: 0,
		memory_usage: 0,
		physical_cores: 0,
		threads: 0
	},
	users: {}
}

-------- Query --------

{
	accesses: {},
	databases: {
		sandbox: 'DEFINE DATABASE sandbox'
	},
	users: {}
}

-------- Query 7 --------

{
	accesses: {},
	analyzers: {},
	apis: {},
	configs: {},
	functions: {},
	models: {},
	params: {},
	tables: {
		person: 'DEFINE TABLE person TYPE ANY SCHEMALESS PERMISSIONS NONE'
	},
	users: {}
}
```

To disallow this behaviour, you can pass the `--strict` flag when [starting the database](/docs/surrealdb/cli/start). In strict mode, everything must first be explicitly defined before it can be used.

```surql
ns/db> CREATE person;
["The namespace 'ns' does not exist"]

ns/db> DEFINE NAMESPACE ns;
[NONE]

ns/db> CREATE person;
["The database 'db' does not exist"]

ns/db> DEFINE DATABASE db;
[NONE]

ns/db> CREATE person;
["The table 'person' does not exist"]

ns/db> DEFINE TABLE person;
[NONE]

ns/db> CREATE person;
[[{ id: person:c76lfw6n4yb1z2dj9xaj }]]
```

## Learn more

To learn more about SurrealDB, check out the following resources:
- [Getting started guide](/docs/surrealdb/introduction/start)
- [Select statement](/docs/surrealql/statements/select)
- [Update statement](/docs/surrealql/statements/update)
- [Insert statement](/docs/surrealql/statements/insert)
- [Delete statement](/docs/surrealql/statements/delete)
- [Relate statement](/docs/surrealql/statements/relate)



================================================
FILE: src/content/doc-surrealql/statements/delete.mdx
================================================
---
sidebar_position: 8
sidebar_label: DELETE
title: DELETE statement | SurrealQL
description: The DELETE statement can be used to delete records from the database.
---

# `DELETE` statement

The `DELETE` statement can be used to delete records from the database.

import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

### Statement syntax

<Tabs syncKey="delete-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
DELETE [ FROM | ONLY ] @targets
	[ WHERE @condition ]
	[ RETURN NONE | RETURN BEFORE | RETURN AFTER | RETURN DIFF | RETURN @statement_param, ... ]
	[ TIMEOUT @duration ]
	[ EXPLAIN [ FULL ]]
;
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const deleteAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DELETE" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "FROM" }, { type: "Terminal", text: "ONLY" } ] } },
      { type: "NonTerminal", text: "@targets" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "WHERE" }, { type: "NonTerminal", text: "@condition" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "RETURN" }, { type: "Choice", index: 1, children: [ { type: "Terminal", text: "NONE" }, { type: "Terminal", text: "BEFORE" }, { type: "Terminal", text: "AFTER" }, { type: "Terminal", text: "DIFF" }, { type: "NonTerminal", text: "@statement_param, ..." } ] } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "TIMEOUT" }, { type: "NonTerminal", text: "@duration" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "EXPLAIN" }, { type: "Optional", child: { type: "Terminal", text: "FULL" } } ] } },
      { type: "Terminal", text: ";" }
    ]}
  ]
};

<RailroadDiagram ast={deleteAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

### Basic usage

The following queries shows basic usage of the DELETE statement, which is used to delete records from a table or a graph edge.

Deleting records can be done in multiple ways.

Specifying only the table name will delete all the records from a table. Note that a `DELETE` statement returns nothing (i.e. an empty array) by default.

```surql
/**[test]

[[test.results]]
value = "[]"

*/

-- Delete all records from a table
DELETE person;
```

```surql title="Output"
[]
```

A `DELETE` statement on a specific ID will delete a single record.

```surql
/**[test]

[[test.results]]
value = "[]"

[[test.results]]
value = "[]"

*/

-- Delete a record with a specific numeric id
DELETE person:100;

-- Delete a record with a specific string id
DELETE person:tobie;
```

The `ONLY` keyword can be followed by a `RETURN BEFORE` clause to return just the object for the record in question before it was deleted.

```surql
/**[test]

[[test.results]]
value = "{ id: person:tobie }"

[[test.results]]
value = "{ id: person:tobie }"

*/

CREATE ONLY person:tobie;
DELETE ONLY person:tobie RETURN BEFORE;
-- { id: person:tobie }
```

Note that as a `DELETE` statement returns an empty array by default, and the `ONLY` keyword assumes that a single object will be returned, it will return an error if `RETURN BEFORE` is not included.

```surql
/**[test]

[[test.results]]
error = "'Expected a single result output when using the ONLY keyword'"

*/

DELETE ONLY person:tobie;
```

```surql title="Output"
'Expected a single result output when using the ONLY keyword'
```

### Deleting records based on conditions

The delete statement supports conditional matching of records using a `WHERE` clause. If the expression in the `WHERE` clause evaluates to true, then the respective record will be deleted.

```surql
/**[test]

[[test.results]]
value = "[]"

*/

-- Update all records which match the condition
DELETE city WHERE name = 'London';
```

By default, the delete statement does not return any data, returning only an empty array if the statement succeeds completely. Specify a `RETURN` clause to change the value which is returned for each document that is deleted.

```surql
/**[test]

[[test.results]]
value = "[]"

[[test.results]]
value = "[]"

[[test.results]]
value = "[]"

[[test.results]]
value = "[]"

*/

-- Don't return any result (the default)
DELETE user WHERE age < 18 RETURN NONE;

-- Return the changeset diff
DELETE user WHERE interests CONTAINS 'reading' RETURN DIFF;

-- Return the record before changes were applied
DELETE user WHERE interests CONTAINS 'reading' RETURN BEFORE;

-- Return the record after changes were applied
DELETE user WHERE interests CONTAINS 'reading' RETURN AFTER;
```

An important point to know when using a `WHERE` clause is that it performs a check on the [truthiness](/docs/surrealql/datamodel/values#values-and-truthiness) of a value, namely whether a value exists and is not a default value like 0, an empty string, empty array, and so on.

As such, the `DELETE` query below that only specifies `WHERE age` essentially evaluates to "WHERE age exists" and will delete every cat in the database with an `age`.

```surql
/**[test]

[[test.results]]
value = "[{ age: 4, id: cat:one }]"

[[test.results]]
value = "[{ id: cat:two }]"

[[test.results]]
value = "[]"

[[test.results]]
value = "[{ id: cat:two }]"

*/

CREATE cat:one SET age = 4;
CREATE cat:two;
DELETE cat WHERE age;
SELECT * FROM cat;
```

```surql title="Output"
[
	{
		id: cat:two
	}
]
```

This pattern is particularly useful when using SurrealDB's [literal types](/docs/surrealql/datamodel/literals) which were added in version 2.0. A literal type containing objects that contain a single top-level field can easily be matched on through the field name.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ error_info: { continue: { message: 'Continue' } }, id: information:y0wty8grwins5yxyswea }]"
skip-record-id-key = true

[[test.results]]
value = "[{ error_info: { continue: { message: 'Continue' } }, id: information:wbg4q0k3z97jdy7x5sns }]"
skip-record-id-key = true

[[test.results]]
value = "[{ error_info: { deprecated: { message: "We don't use this anymore" } }, id: information:r4pa3c49one2ofd2bcbw }]"
skip-record-id-key = true

[[test.results]]
value = "[]"

[[test.results]]
value = "[{ error_info: { deprecated: { message: "We don't use this anymore" } }, id: information:r4pa3c49one2ofd2bcbw }]"
skip-record-id-key = true

*/

DEFINE FIELD error_info ON TABLE information TYPE
      { continue: { message: "Continue" } }
    | { retry_with_id: { error: string  } }
    | { deprecated: { message: string   } };

CREATE information SET error_info = { continue: { message: "Continue" }};
CREATE information SET error_info = { continue: { message: "Continue" }};
CREATE information SET error_info = { deprecated: { message: "We don't use this anymore" }};

DELETE information WHERE error_info.continue;
SELECT * FROM information;
```

```surql title="Output"
[
	{
		error_info: {
			deprecated: {
				message: "We don't use this anymore"
			}
		},
		id: info:o0pmm7zos98iv03xliav
	}
]
```

### Using TIMEOUT duration records based on conditions
When processing a large result set with many interconnected records, it is possible to use the `TIMEOUT` keywords to specify a timeout duration for the statement. If the statement continues beyond this duration, then the transaction will fail, no records will be deleted from the database, and the statement will return an error.

```surql
/**[test]

[[test.results]]
value = "[]"

*/

DELETE person WHERE ->knows->person->(knows WHERE influencer = false) TIMEOUT 5s;
```

## Deleting graph edges

You can also delete graph edges between two records in the database by using the DELETE statement.

For example the graph edge below:

```surql
/**[test]

[[test.results]]
value = "[{ id: bought:ruo8s16ib6j6hoker96z, in: person:tobie, out: product:iphone }]"
skip-record-id-key = true

*/

RELATE person:tobie->bought->product:iphone;

[
	{
		"id": bought:ctwsll49k37a7rmqz9rr,
		"in": person:tobie,
		"out": product:iphone
	}
]
```

Can be deleted by:

```surql
/**[test]

[[test.results]]
value = "[]"

*/

DELETE person:tobie->bought WHERE out=product:iphone;
```

## Soft deletions

While soft deletions do not exist natively in SurrealDB, they can be simulated by [defining an event](/docs/surrealql/statements/define/event) that reacts whenever a deletion occurs.

The following example archives the data of a deleted record in another table. This can be combined with  [fewer permissions for the new table](/docs/surrealql/statements/define/table#defining-permissions) so that it can be accessed only by [system users](/docs/surrealql/statements/define/user) and not [record users](/docs/surrealql/statements/define/access/record).

```surql
DEFINE EVENT archive_person ON TABLE person WHEN $event = "DELETE" THEN {
    CREATE deleted_person SET
        data = $before,
        deleted_at = time::now()
};

CREATE |person:1..5|;
DELETE person:1;

-- Only two `person` records left
SELECT * FROM person;
-- But the data of `person:1` is still here
SELECT * FROM deleted_person;
```

```surql title="Output"

-------- Query --------

[
	{
		id: person:2
	},
	{
		id: person:3
	}
]

-------- Query --------

[
	{
		data: {
			id: person:1
		},
		deleted_at: d'2024-09-12T00:46:59.176Z',
		id: deleted_person:p3fpzhpxuu9jvjn8juyf
	}
]
```

## The `EXPLAIN` clause

When `EXPLAIN` is used:

1. The `DELETE` statement returns an explanation, essentially revealing the execution plan to provide transparency and understanding of the query performance.
2. The records are not deleted.

`EXPLAIN` can be followed by `FULL` to see the number of executed rows.


================================================
FILE: src/content/doc-surrealql/statements/for.mdx
================================================
---
sidebar_position: 9
sidebar_label: FOR
title: FOR statement | SurrealQL
description: The FOR statement creates a loop that iterates over the values of an array.
---

import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `FOR` statement

The `FOR` statement can be used to iterate over the values of an array, and to perform certain actions with those values.

> [!NOTE]
> A `FOR` loop currently cannot modify items outside its own scope, such as variables declared before the loop.


<Tabs syncKey="for-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
FOR @item IN @iterable {
@block
};
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const forAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "FOR" },
      { type: "NonTerminal", text: "@item" },
      { type: "Terminal", text: "IN" },
      { type: "NonTerminal", text: "@iterable" },
      { type: "Terminal", text: "{" },
      { type: "NonTerminal", text: "@block" },
      { type: "Terminal", text: "}" },
      { type: "Terminal", text: ";" }
    ]}
  ]
};

<RailroadDiagram ast={forAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage
The following query shows example usage of this statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a person for everyone in the array
FOR $name IN ['Tobie', 'Jaime'] {
	CREATE type::record('person', $name) CONTENT {
		name: $name
	};
};
```

The following query shows the `FOR` statement being used update a property on every user matching certain criteria.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Set can_vote to true for every person over 18 years old.
FOR $person IN (SELECT VALUE id FROM person WHERE age >= 18) {
	UPDATE $person SET can_vote = true;
};
```

## Ranges in FOR loops

<Since v="v2.0.0" />

A `FOR` loop can also be made out of a [range UUID](/docs/surrealql/datamodel/ranges) of integers.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

FOR $year IN 0..=2024 {
    CREATE historical_events SET
        for_year = $year,
        events = "To be added";
};
```

## Limitations of FOR loops

Parameters declared outside of a `FOR` loop can be used inside the loop.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

LET $table1 = "person";
LET $table2 = "cat";

FOR $key in 0..4 {
    CREATE type::record($table1, $key);
	  CREATE type::record($table2, $key);
};
```

However, they currently cannot be modified inside a loop, making an operation like the following impossible.

```surql
LET $init = [];

FOR $num IN 1..=3 {
	$init += $num;
};
-- Error: 'assignment operators are only allowed in SET and DUPLICATE KEY UPDATE clauses'

RETURN $init;
```

In this case, the [`array::fold`](/docs/surrealql/functions/database/array#arrayfold) and [`array::reduce`](/docs/surrealql/functions/database/array#arrayreduce) functions can often be used to accomplish the intended behaviour.

```surql
/**[test]

[[test.results]]
value = "6"

*/

(<array>1..=3).reduce(|$one, $two| $one + $two);
```

```surql title="Output"
6
```


================================================
FILE: src/content/doc-surrealql/statements/ifelse.mdx
================================================
---
sidebar_position: 10
sidebar_label: IF ELSE
title: IF ELSE statement | SurrealQL
description: The IF ELSE statement can be used as a main statement, or within a parent statement, to return a value depending on whether a condition, or a series of conditions match.
---

# `IF ELSE` statement

The `IF ELSE` statement can be used as a main statement, or within a parent statement, to return a value depending on whether a condition, or a series of conditions match. The statement allows for multiple `ELSE IF` expressions, and a final `ELSE` expression, with no limit to the number of `ELSE IF` conditional expressions.

> [!NOTE]
> As [THROW](/docs/surrealql/statements/throw), [CONTINUE](/docs/surrealql/statements/continue), and [BREAK](/docs/surrealql/statements/break) do not return an expression, they must be inside a separate code block inside an `IF ELSE` statement.

An `IF ELSE` syntax uses `{}` to open up a code block on each condition check which will be run when it evaluates as [truthy](/docs/surrealql/datamodel/values#values-and-truthiness).

import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

<Tabs syncKey="ifelse-statement">

  <TabItem label="Syntax">

```surql title="Modern syntax"
IF @condition { @expression; .. }
   [ ELSE IF @condition { @expression; .. } ] ...
   [ ELSE { @expression; .. } ]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const ifElseAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "IF" },
      { type: "NonTerminal", text: "@condition" },
      { type: "Terminal", text: "{" },
      { type: "NonTerminal", text: "@expression; .." },
      { type: "Terminal", text: "}" },
      { type: "ZeroOrMore", child: { type: "Sequence", children: [
        { type: "Terminal", text: "ELSE" },
        { type: "Terminal", text: "IF" },
        { type: "NonTerminal", text: "@condition" },
        { type: "Terminal", text: "{" },
        { type: "NonTerminal", text: "@expression; .." },
        { type: "Terminal", text: "}" }
      ] } },
      { type: "Optional", child: { type: "Sequence", children: [
        { type: "Terminal", text: "ELSE" },
        { type: "Terminal", text: "{" },
        { type: "NonTerminal", text: "@expression; .." },
        { type: "Terminal", text: "}" }
      ] } }
    ]}
  ]
};

<RailroadDiagram ast={ifElseAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

### Basic usage

The following queries show example usage of this statement.

The smallest possible `IF THEN` statement simply does something when a condition is true, and nothing otherwise.

```surql
IF 9 = 9 { 'Nine is indeed nine' };
```

As the last line of a scope is its return value, the `RETURN` keyword can also be placed before the entire `IF THEN` statement. This is particularly convenient in long `IF ELSE` chains to avoid using the `RETURN` keyword at the end of every check for a condition.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "'Positive uninteresting number'"

*/

LET $num = 100;

RETURN IF $num < 0 {
    "Negative"
} ELSE IF $num = 0 {
    "Zero"
} ELSE IF $num = 13 {
    "Thirteen"
} ELSE {
    "Positive uninteresting number"
};
```

The `RETURN` keyword can even be omitted, as the output at each point is the output of the entire expression if evaluated as truthy.

```surql
LET $num = 100;

IF $num < 0 {
    "Negative"
} ELSE IF $num = 0 {
    "Zero"
} ELSE IF $num = 13 {
    "Thirteen"
} ELSE {
    "Positive uninteresting number"
};
```

The `THROW` keyword inside `{}` braces can be used to break out of an `IF LET` statement early.

```surql
LET $badly_formatted_datetime = "2024-04TT08:08:08Z";

IF !type::is_datetime($badly_formatted_datetime) {
    THROW "Whoops, that isn't a real datetime"
};
```

```surql title="Response"
"An error occurred: Whoops, that isn't a real datetime"
```

`ELSE IF` branches and a final `ELSE` can be added into an `IF ELSE` statement:

```surql
RETURN
    IF $access = "admin" { (SELECT * FROM account) }
    ELSE IF $access = "user"  { (SELECT * FROM $auth.account) }
    ELSE { THROW "Access method hasn't been defined!" };
```

### Advanced usage

The output of an `IF ELSE` statement can be assigned to a parameter:

```surql
LET $num = 9;

LET $odd_even = 
    IF $num % 2 = 0 { "even" } 
    ELSE { "odd" };
```

If-else statements can also be used as subqueries within other statements.

```surql
UPSERT person SET railcard =
    IF age <= 10 { 'junior' }
    ELSE IF age <= 21 { 'student' }
    ELSE IF age >= 65 { 'senior' }
    ELSE { NULL };
```

You can also have nested conditions:

```surql
IF $access = 'admin'
	{
        CREATE admin_user_event SET 
            time = time::now(),
            info = "Admin user activity registered";
		SELECT * FROM admin_data WHERE access_level = 'full';
	}
ELSE IF $access = 'user'
	{
		IF $auth.role = 'premium'
			{
                CREATE premium_user_event SET 
                    time = time::now(),
                    info = "Premium user activity registered";

				IF $auth.subscription_status = 'active'
					{ SELECT * FROM premium_user_data WHERE active = 1 }
				ELSE IF $auth.subscription_status = 'trial'
					{ SELECT * FROM trial_user_data }
				ELSE
					{ SELECT * FROM basic_user_data }
			}
		ELSE IF $auth.role = 'standard'
			{ SELECT * FROM standard_user_data WHERE region = 'US' }
		ELSE IF $auth.role = 'standard' AND $auth.subscription_status = 'active'
			{ SELECT * FROM standard_user_data WHERE region = 'EU' }
		ELSE
			{ SELECT * FROM unauthorized_user_data }
	}
ELSE
	{ SELECT * FROM unknown_access_data };
```



================================================
FILE: src/content/doc-surrealql/statements/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Overview
title: Statements | SurrealQL
description: Statements are used to configure and query a database.
---

# Statements

SurrealDB has a variety of statements that let you configure and query a database. In this section, we'll look at the different types of statements that are available.

## Statement parameters

A number of parameters prefixed with `$` are automatically available within a statement that provide access to relevant context inside the statement. These are known as reserved variable names. For example:

* [$before](/docs/surrealql/parameters#before-after) and [$after](/docs/surrealql/parameters#before-after) can be accessed in statements that mutate values to see the values before and after an update,
* [$session](/docs/surrealql/parameters#session) provides context on the current session,
* [$parent](/docs/surrealql/parameters#parent-this) provides access to the value in a primary query while inside a subquery.

For a full list of these automatically generated parameters, see the [parameters](/docs/surrealql/parameters#reserved-variable-names) page.


================================================
FILE: src/content/doc-surrealql/statements/info.mdx
================================================
---
sidebar_position: 11
sidebar_label: INFO
title: INFO statement | SurrealQL
description: The INFO command outputs information about the setup of the SurrealDB system.
---

import Since from "@components/shared/Since.astro";
import RailroadDiagram from "@components/RailroadDiagram.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# `INFO` statement

The `INFO` command outputs information about the setup of the SurrealDB system. There are a number of different `INFO` commands for retrieving the configuration at the different levels of the database.

<Tabs syncKey="info-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
INFO FOR [
	ROOT
	| NS | NAMESPACE
	| DB | DATABASE
	| TABLE @table
	| USER @user [ON @level]
    | INDEX @index ON @table
];
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const infoAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "INFO" },
      { type: "Terminal", text: "FOR" },
      { type: "Choice", index: 1, children: [
        { type: "Terminal", text: "ROOT" },
        { type: "Choice", index: 1, children: [ { type: "Terminal", text: "NS" }, { type: "Terminal", text: "NAMESPACE" } ] },
        { type: "Choice", index: 1, children: [ { type: "Terminal", text: "DB" }, { type: "Terminal", text: "DATABASE" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "TABLE" }, { type: "NonTerminal", text: "@table" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "USER" }, { type: "NonTerminal", text: "@user" }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "ON" }, { type: "NonTerminal", text: "@level" } ] } } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "INDEX" }, { type: "NonTerminal", text: "@index" }, { type: "Terminal", text: "ON" }, { type: "NonTerminal", text: "@table" } ] }
      ] },
      { type: "Terminal", text: ";" }
    ]}
  ]
};

<RailroadDiagram ast={infoAst} className="my-6" />

  </TabItem>
</Tabs>

The information returned from an `INFO` command is an object containing items that almost always correspond to a matching [DEFINE](/docs/surrealql/statements/define) statement. For example, the `INFO FOR NS` command returns the information on the access methods, databases and users of a namespace, which are defined with `DEFINE ACCESS`, `DEFINE DATABASE` and `DEFINE USER` statements.

> [!NOTE]
> Before SurrealDB v3.0.0-alpha.2, the output of an `INFO FOR` was only able to be used as a standalone statement and not in a dynamic context, such as inside other queries or as the value of a parameter.

## Example usage

There are a number of different `INFO` commands for retrieving the configuration at the different levels of the database.

## System  information

### Root information
The top-level ROOT command returns information regarding:
- The users and namespaces which exists within the SurrealDB system.
- The memory allocated by SurrealDB itself. Note that this may not match what the operating system reports, as it also includes memory consumed by third-party libraries or pre-allocated memory.
- The level of parallelism: This number indicates the number of available hardware threads.

> [!NOTE]
> You must be authenticated as a top-level root user to execute this command.

#### Examples

```surql
INFO FOR ROOT;
```

```surql title="Sample output"
{
	accesses: {},
	namespaces: {
		ns: 'DEFINE NAMESPACE ns'
	},
	nodes: {
		"2d3b720d-f152-4c0d-8a16-26d1474ed3cd": 'NODE 2d3b720d-f152-4c0d-8a16-26d1474ed3cd SEEN 1745463977888 ACTIVE'
	},
	system: {
		available_parallelism: 14,
		cpu_usage: 0.3816290497779846f,
		load_average: [
			1.2734375f,
			1.68310546875f,
			1.9189453125f
		],
		memory_allocated: 13900485,
		memory_usage: 136314880,
		physical_cores: 14,
		threads: 32
	},
	users: {
		root: "DEFINE USER root ON ROOT PASSHASH '$argon2id$v=19$m=19456,t=2,p=1$0RoO7PtdHuGLOz9Pomoucg$T6FYVogdEF8sFse/Su11nKaZb8FjEp3Bb3rD35mI1b8' ROLES OWNER DURATION FOR TOKEN 1h, FOR SESSION NONE"
	}
}
```

### Namespace information

The `NS` or `NAMESPACE` command returns information regarding the users, databases and access methods under the namespace in use.

> [!NOTE]
> You must be authenticated as a top-level root user, or a namespace user to execute this command.

> [!NOTE]
> You must have a NAMESPACE selected before running this command.

#### Examples

```surql
INFO FOR NS;
```

```surql title="Sample output"
{
    accesses: {},
    databases: {
        db: 'DEFINE DATABASE db'
    },
    users: {
        n: "DEFINE USER n ON NAMESPACE PASSHASH '' ROLES VIEWER DURATION FOR TOKEN 1h, FOR SESSION NONE",
        username: "DEFINE USER username ON NAMESPACE PASSHASH '$argon2id$v=19$m=19456,t=2,p=1$K9DIBCuzH2IA6w7t3ZVGkQ$KkRODt0cqgUap9OwZCxLJC4ESo6wEToUk55oumhmgA0' ROLES EDITOR DURATION FOR TOKEN 1m, FOR SESSION 12h"
    }
}
```

### Database information

The `DB` or `DATABASE` command returns information regarding the users, tables, params, models, functions, analyzers and access methods under the database in use.

> [!NOTE]
> You must be authenticated as a top-level root user, a namespace user, or a database user to execute this command.

> [!NOTE]
> You must have a NAMESPACE and a DATABASE selected before running this command.

#### Examples

```surql
INFO FOR DB;
```

```surql title="Sample output"
{
    accesses: {},
    analyzers: {},
    apis: {},
    buckets: {},
    configs: {},
    functions: {},
    models: {},
    params: {},
    tables: {
        person: 'DEFINE TABLE person TYPE ANY SCHEMALESS PERMISSIONS NONE'
    },
    users: {
        db_user: "DEFINE USER db_user ON DATABASE PASSHASH '$argon2id$v=19$m=19456,t=2,p=1$S8WJ88AnJwWah2VjqnmnoA$OJcQs9SHC5R5q3kOimiKsV5fIUpwZiax3RUcW8VQupk' ROLES OWNER DURATION FOR TOKEN 1h, FOR SESSION NONE"
    }
}
```

### Table information

The `TABLE` command returns information regarding the events, fields, tables, and live statement configurations on a specific table.

> [!NOTE]
> You must be authenticated as a top-level root user, a namespace user, or a database user to execute this command.

> [!NOTE]
> You must have a NAMESPACE and a DATABASE selected before running this command.

#### Examples

```surql
INFO FOR TABLE user;
```

```surql title="Sample output"
{
    events: {},
    fields: {
        name: 'DEFINE FIELD name ON user TYPE string PERMISSIONS FULL'
    },
    indexes: {},
    lives: {},
    tables: {}
}
```

### User information

The `USER` command returns information for a user [defined](/docs/surrealql/statements/define/user) on either the root, namespace, or database level.

> [!NOTE]
> You must be authenticated as a user equal to or greater than the level of the user you are attempting to obtain information for to execute this command.

#### Examples

```surql
INFO FOR USER root ON ROOT;
INFO FOR USER ns_user ON NAMESPACE;
INFO FOR USER db_user ON DATABASE;
```

If a level after `ON` is not specified, the `INFO` command will default to the database level. Thus, the following two commands are equivalent.

```surql
INFO FOR USER db_user ON DATABASE;
INFO FOR USER db_user;
```

```surql title="Sample output"
"DEFINE USER db_user ON DATABASE PASSHASH '$argon2id$v=19$m=19456,t=2,p=1$S8WJ88AnJwWah2VjqnmnoA$OJcQs9SHC5R5q3kOimiKsV5fIUpwZiax3RUcW8VQupk' ROLES OWNER DURATION FOR TOKEN 1h, FOR SESSION NONE"
```

### Index information

`INFO FOR INDEX` returns the status for an index: started, initial indexing, update indexing, built, or error.

This command only applies when the [`CONCURRENTLY`](/docs/surrealql/statements/define/indexes#using-concurrently-clause) clause is used in a `DEFINE INDEX` command. Without this clause, the following statement will not be executed until the index is fully created, or fails. In this case, the `INFO FOR INDEX` statement will return an empty object: `{}`.


```surql
CREATE |user:50000| SET name = id.id() RETURN NONE;
DEFINE INDEX unique_name ON TABLE user FIELDS name UNIQUE;
INFO FOR INDEX unique_name ON TABLE user;
```

However, when the `CONCURRENTLY` clause is used, the index will build in the background while other statements are permitted to run. In this case, the `INFO FOR INDEX` statement will provide the current status on the index. The following code sample shows such an example in which an index is defined on a large number of records. A [`SLEEP`](/docs/surrealql/statements/sleep) statement is run in between each `INFO FOR INDEX` command to show the progress after each 50 millisecond interval.

```surql
CREATE |user:50000| SET name = id.id() RETURN NONE;
DEFINE INDEX unique_name ON TABLE user FIELDS name UNIQUE CONCURRENTLY;
INFO FOR INDEX unique_name ON user;
SLEEP 50ms;
INFO FOR INDEX unique_name ON user;
SLEEP 50ms;
INFO FOR INDEX unique_name ON user;
SLEEP 50ms;
INFO FOR INDEX unique_name ON user;
```

```surql title="Possible output"
-------- Query 1 --------
{ 
    building: {
        initial: 0,
        pending: 0,
        status: 'indexing', 
        updated: 0
    }
}

-------- Query 2 --------
{ 
    building: {
        initial: 100,
        pending: 20,
        status: 'indexing', 
        updated: 0
    }
}

-------- Query 3 --------
{ 
    building: {
        initial: 100,
        pending: 4,
        status: 'indexing', 
        updated: 16
    }
}

-------- Query 4 --------
{
    building: {
        status: 'ready'
    }
}
```

### The `STRUCTURE` clause

> [!NOTE]
> This clause was originally created for internal use and is subject to change without notice.

Adding the `STRUCTURE` clause changes the structure of the statement from an object that contains objects into an object with fields that each contain an array and often extra info.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ events: {  }, fields: { name: 'DEFINE FIELD name ON user TYPE string PERMISSIONS FULL' }, indexes: {  }, lives: {  }, tables: {  } }"

[[test.results]]
value = "{ events: [], fields: [{ flex: false, kind: 'string', name: 'name', permissions: { create: true, select: true, update: true }, readonly: false, what: 'user' }], indexes: [], lives: [], tables: [] }"

*/

DEFINE TABLE user SCHEMAFULL;
DEFINE FIELD name ON user TYPE STRING;

INFO FOR TABLE user;
INFO FOR TABLE user STRUCTURE;
```

```surql title="Output"

-------- Query --------

{
	events: {},
	fields: {
		name: 'DEFINE FIELD name ON user TYPE string PERMISSIONS FULL'
	},
	indexes: {},
	lives: {},
	tables: {}
}

-------- Query --------

{
	events: [],
	fields: [
		{
			flex: false,
			kind: 'string',
			name: 'name',
			permissions: {
				create: true,
				delete: true,
				select: true,
				update: true
			},
			readonly: false,
			what: 'user'
		}
	],
	indexes: [],
	lives: [],
	tables: []
}
```

### Using the output of `INFO`

<Since v="v3.0.0-alpha.2" />

The output of an `INFO` statement, both with and without the `STRUCTURE` clause, can be used in other operations. As the output of the statement is always a single object, the SurrealQL [object functions](/docs/surrealql/functions/database/object) can also be used on the output for such tasks as schema change tracking.

```surql
LET $cat = CREATE ONLY cat RETURN VALUE id;

LET $first_schema = {
    revision: rand::uuid(),
    schema: INFO FOR DB
};

$first_schema;

CREATE person SET feeds = [$cat];

LET $second_schema = {
    revision: rand::uuid(),
    schema: INFO FOR DB
};

$second_schema;

$first_schema.diff($second_schema);
```

```surql title="Output"
-------- First schema --------

{
	revision: u'019665cc-f730-75f0-8251-894e11fee7d8',
	schema: {
		accesses: {},
		analyzers: {},
		apis: {},
		buckets: {},
		configs: {},
		functions: {},
		models: {},
		params: {},
		tables: {
			cat: 'DEFINE TABLE cat TYPE ANY SCHEMALESS PERMISSIONS NONE'
		},
		users: {}
	}
}

-------- Second schema --------

{
	revision: u'019665cc-f73b-7313-807f-dd22ad1a0685',
	schema: {
		accesses: {},
		analyzers: {},
		apis: {},
		buckets: {},
		configs: {},
		functions: {},
		models: {},
		params: {},
		tables: {
			cat: 'DEFINE TABLE cat TYPE ANY SCHEMALESS PERMISSIONS NONE',
			person: 'DEFINE TABLE person TYPE ANY SCHEMALESS PERMISSIONS NONE'
		},
		users: {}
	}
}

-------- Diff --------

[
	{
		op: 'replace',
		path: '/revision',
		value: u'019665cc-f73b-7313-807f-dd22ad1a0685'
	},
	{
		op: 'add',
		path: '/schema/tables/person',
		value: 'DEFINE TABLE person TYPE ANY SCHEMALESS PERMISSIONS NONE'
	}
]
```


================================================
FILE: src/content/doc-surrealql/statements/insert.mdx
================================================
---
sidebar_position: 12
sidebar_label: INSERT
title: INSERT statement | SurrealQL
description: The INSERT statement can be used to insert or update data into the database, using the same statement syntax as the traditional SQL Insert statement.
---
import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `INSERT` statement

The `INSERT` statement can be used to insert or update data into the database, using the same statement syntax as the traditional SQL Insert statement.

### Statement syntax

<Tabs syncKey="insert-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
INSERT [ RELATION ] [ IGNORE ] INTO @what
	[ @value
	  | (@fields) VALUES (@values)
		[ ON DUPLICATE KEY UPDATE @field = @value ... ]
	]
	[ RETURN NONE | RETURN BEFORE | RETURN AFTER | RETURN DIFF | RETURN @statement_param, ... | RETURN VALUE @statement_param ]
;
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const insertAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "INSERT" },
      { type: "Optional", child: { type: "Terminal", text: "RELATION" } },
      { type: "Optional", child: { type: "Terminal", text: "IGNORE" } },
      { type: "Terminal", text: "INTO" },
      { type: "NonTerminal", text: "@what" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [
        { type: "NonTerminal", text: "@value" },
        { type: "Sequence", children: [ { type: "Terminal", text: "(@fields)" }, { type: "Terminal", text: "VALUES" }, { type: "Terminal", text: "(@values)" }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "ON DUPLICATE KEY UPDATE" }, { type: "NonTerminal", text: "@field = @value ..." } ] } } ] }
      ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "RETURN" }, { type: "Choice", index: 1, children: [ { type: "Terminal", text: "NONE" }, { type: "Terminal", text: "BEFORE" }, { type: "Terminal", text: "AFTER" }, { type: "Terminal", text: "DIFF" }, { type: "NonTerminal", text: "@statement_param, ..." }, { type: "Sequence", children: [ { type: "Terminal", text: "VALUE" }, { type: "NonTerminal", text: "@statement_param" } ] } ] } ] } },
      { type: "Terminal", text: ";" }
    ]}
  ]
};

<RailroadDiagram ast={insertAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

The following query shows example usage of this statement.

```surql
/**[test]

[[test.results]]
value = "[{ founded: '2021-09-10', founders: [person:tobie, person:jaime], id: company:5fc7p7d0kiirdx7accfn, name: 'SurrealDB', tags: ['big data', 'database'] }]"
skip-record-id-key = true

*/

INSERT INTO company {
	name: 'SurrealDB',
	founded: "2021-09-10",
	founders: [person:tobie, person:jaime],
	tags: ['big data', 'database']
};
```

Records can also be inserted by using the `VALUES` keyword. This keyword is preceded by the name of the fields in question, and followed by comma-separated values matching the number of fields specified.

```surql
/**[test]

[[test.results]]
value = "[{ founded: '2021-09-10', id: company:l6luw1w1lqr7v2loau6a, name: 'SurrealDB' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ founded: '1967-05-03', id: company:racyetsf1x1hbu7d5g5s, name: 'Acme Inc.' }, { founded: '1976-04-01', id: company:x9pi148wprp30jfv5o4q, name: 'Apple Inc.' }]"
skip-record-id-key = true

*/

-- Insert a single record
INSERT INTO
	company (name, founded)
	VALUES  ('SurrealDB', '2021-09-10');

-- Insert multiple records
INSERT INTO
	company (name, founded)
	VALUES  ('Acme Inc.', '1967-05-03'), ('Apple Inc.', '1976-04-01');
```

It is possible to update records which already exist or violate a unique index by specifying an `ON DUPLICATE KEY UPDATE` clause. This clause also allows incrementing and decrementing numeric values, and adding or removing values from arrays. To increment a numeric value, or to add an item to an array, use the `+=` operator. To decrement a numeric value, or to remove an value from an array, use the `-=` operator.

```surql
/**[test]

[[test.results]]
value = "[{ id: product:bt4cwqd5cwwmp68w3dps, name: 'Salesforce', url: 'salesforce.com' }]"
skip-record-id-key = true

*/

INSERT INTO product (name, url) VALUES ('Salesforce', 'salesforce.com') ON DUPLICATE KEY UPDATE tags += 'crm';
```

Field names inside `ON DUPLICATE KEY UPDATE` refer to the fields of the existing record. To access the fields of the new record that was attempted to be inserted, prefix the field name with [`$input`](/docs/surrealql/parameters#input):

```surql
/**[test]

[[test.results]]
value = "[{ at_year: 2024, id: city:Calgary, population: 1665000 }]"

*/

INSERT INTO city (id, population, at_year) VALUES ("Calgary", 1665000, 2024)
ON DUPLICATE KEY UPDATE
	population = $input.population,
	at_year = $input.at_year;
```

An example of `ON DUPLICATE KEY UPDATE` when a unique key is encountered shows the same behaviour as that with a duplicate record:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ data_for: user:one, id: user_data:24gujsffwl4vt2zgp2yl, some: 'data' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ data_for: user:one, id: user_data:24gujsffwl4vt2zgp2yl, last_edited: d'2025-10-08T03:22:23.325474Z', some: 'data', times_updated: 1 }]"
skip-record-id-key = true

*/

DEFINE FIELD data_for ON user_data TYPE record<user>;
DEFINE INDEX one_user ON user_data FIELDS data_for UNIQUE;

INSERT INTO user_data {
    data_for: user:one,
    some: "data"
} ON DUPLICATE KEY UPDATE times_updated += 1, last_edited = time::now();

INSERT INTO user_data {
    data_for: user:one,
    some_more: "data"
} ON DUPLICATE KEY UPDATE times_updated += 1, last_edited = time::now();
```

```surql title="Output"
-------- Query --------

[
	{
		for: user:one,
		id: user_data:kp78dubsxmp4f04x0de3,
		some: 'data'
	}
]

-------- Query --------

[
	{
		for: user:one,
		id: user_data:kp78dubsxmp4f04x0de3,
		last_edited: d'2025-07-14T05:15:52.146Z',
		some: 'data',
		times_updated: 1
	}
]
```

Using the insert statement, it is possible to copy records easily between tables. The records being copied will have the same id in the new table, but the record id will signify the new table name.

```surql
/**[test]

[[test.results]]
value = "[]"

*/

INSERT INTO recordings_san_francisco (SELECT * FROM temperature WHERE city = 'San Francisco');
```

Furthermore, it is possible to perform a bulk insert in a single query. The `@what` part of the syntax can be either a single object or an array of objects.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:jaime, name: 'Jaime', surname: 'Morgan Hitchcock' }, { id: person:tobie, name: 'Tobie', surname: 'Morgan Hitchcock' }]"

*/

INSERT INTO person [
   { id: "jaime", name: "Jaime", surname: "Morgan Hitchcock" },
   { id: "tobie", name: "Tobie", surname: "Morgan Hitchcock" },
];
```

### Ignoring duplicates

While attempting to insert one or more records via the `INSERT` statement, if the record ID is already present in the table, the query will encounter an error and fail. If the `IGNORE` clause is supplied, records with an already existing or duplicate ID will be silently ignored.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:jaime, name: 'Jaime', surname: 'Morgan Hitchcock' }, { id: person:tobie, name: 'Tobie', surname: 'Morgan Hitchcock' }]"

*/

INSERT IGNORE INTO person [
   { id: "jaime", name: "Jaime", surname: "Morgan Hitchcock" },
   { id: "tobie", name: "Tobie", surname: "Morgan Hitchcock" },

   { id: "jaime", name: "Jaime", surname: "Morgan Hitchcock" }, -- will not throw an error
];
```

### Return Values

<Since v="v2.0.0" />

By default, the `INSERT` statement returns the record once it has been inserted. To change what is returned, we can use the `RETURN` clause, specifying either `NONE`, `BEFORE`, `AFTER`, `DIFF`, or a comma-separated list of specific fields to return.

`RETURN NONE` can be useful to avoid excess output:

```surql
/**[test]

[[test.results]]
value = "[]"

*/

-- Insert a record and return nothing
INSERT INTO company {
	name: 'SurrealDB',
	founded: "2021-09-10",
	founders: [person:tobie, person:jaime],
	tags: ['big data', 'database']
} RETURN NONE;
```

`RETURN DIFF` returns the changeset diff:

```surql
/**[test]

[[test.results]]
value = "[[{ op: 'replace', path: '', value: { founded: '2021-09-10', founders: [person:tobie, person:jaime], id: company:tmx6q7chr1vt73t95gx8, name: 'SurrealDB', tags: ['big data', 'database'] } }]]"
skip-record-id-key = true

*/

-- Insert a record and return the diff
INSERT INTO company {
	name: 'SurrealDB',
	founded: "2021-09-10",
	founders: [person:tobie, person:jaime],
	tags: ['big data', 'database']
} RETURN DIFF;
```

```surql title="Response"
-------- Query 1 (500µs) --------

[
	[
		{
			op: 'replace',
			path: '/',
			value: {
				founded: '2021-09-10',
				founders: [
					person:tobie,
					person:jaime
				],
				id: company:hu5o1wqbo29t10engbeo,
				name: 'SurrealDB',
				tags: [
					'big data',
					'database'
				]
			}
		}
	]
]
```

`RETURN BEFORE` inside a `INSERT` statement is essentially a synonym for `RETURN NONE`, while `RETURN AFTER` is the default behaviour for `INSERT`.

```surql
/**[test]

[[test.results]]
value = "[NONE]"

*/

-- Before insert will always return NONE as it is the same as the record being inserted
INSERT INTO company {
	name: 'SurrealDB',
	founded: "2021-09-10",
	founders: [person:tobie, person:jaime],
	tags: ['big data', 'database']
} RETURN BEFORE;
```

```surql
/**[test]

[[test.results]]
value = "[{ founded: '2021-09-10', founders: [person:tobie, person:jaime], id: company:yzc8d07g376x3qddxmdn, name: 'SurrealDB', tags: ['big data', 'database'] }]"
skip-record-id-key = true

*/

-- Return the record after creation
INSERT INTO company {
	name: 'SurrealDB',
	founded: "2021-09-10",
	founders: [person:tobie, person:jaime],
	tags: ['big data', 'database']
} RETURN AFTER;
```

You can also return specific fields from a created record, the value of a single field using `VALUE`, as well as ad-hoc fields to modify the output as needed.

```surql
/**[test]

[[test.results]]
value = "[{ age: 46, age_next_year: 47, interests: ['skiing', 'music'] }]"

[[test.results]]
value = "[27, -55]"

*/

INSERT INTO person {
    age: 46,
    username : "john-smith",
    interests : ['skiing', 'music'] }
RETURN
    age,
    interests,
    age + 1 AS age_next_year;

INSERT INTO planet [
	{
		name: 'Venus',
        surface_temp: 462,
        temp_55_km_up: 27
	},
	{
		name: 'Earth',
        surface_temp: 15,
        temp_55_km_up: -55
	}
] RETURN VALUE temp_55_km_up;
```

```surql title="Response"
-------- Query --------

[
	{
		age: 46,
		age_next_year: 47,
		interests: [
			'skiing',
			'music'
		]
	}
]

-------- Query --------

[
	27,
	-55
]
```

## Bulk insert

<Since v="v2.0.0" />

The `INSERT` statement supports bulk insert, which allows multiple records to be inserted in a single query. The `@what` part of the syntax can be either a single object or an array of objects.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:jaime, name: 'Jaime', surname: 'Morgan Hitchcock' }, { id: person:tobie, name: 'Tobie', surname: 'Morgan Hitchcock' }]"

*/

INSERT INTO person [
   { id: "jaime", name: "Jaime", surname: "Morgan Hitchcock" },
   { id: "tobie", name: "Tobie", surname: "Morgan Hitchcock" },
   -- ... 1000 more records
];
```

## Insert relation tables

The `INSERT` statement can also be used to add records into relation tables. The `@what` part of the syntax can be either a single object or an array of objects.

Learn more about creating relationships between tables in the [RELATE](/docs/surrealql/statements/relate) statement. For example:

```surql
/**[test]

[[test.results]]
value = "[{ id: person:1 }, { id: person:2 }, { id: person:3 }]"

[[test.results]]
value = "[{ id: likes:object, in: person:1, out: person:2 }]"

[[test.results]]
value = "[{ id: likes:array, in: person:1, out: person:2 }, { id: likes:array_two, in: person:2, out: person:3 }]"

[[test.results]]
value = "[{ id: likes:values, in: person:1, out: person:2 }]"

[[test.results]]
value = "[[likes:array, likes:object, likes:values], [likes:array_two], []]"

*/

-- Insert records into the person table
INSERT INTO person [
	{ id: 1 },
	{ id: 2 },
	{ id: 3 },
];
-- Insert a single relation
INSERT RELATION INTO likes {
	in: person:1,
	id: 'object',
	out: person:2,
};

-- Insert multiple relations
INSERT RELATION INTO likes [
	{
		in: person:1,
		id: 'array',
		out: person:2,
	},
	{
		in: person:2,
		id: 'array_two',
		out: person:3,
	}
];

-- Insert a relation and return the value of the likes field
INSERT RELATION INTO likes (in, id, out)
	VALUES (person:1, 'values', person:2);

-- Select the value of the likes field
SELECT VALUE ->likes FROM person;

```



================================================
FILE: src/content/doc-surrealql/statements/kill.mdx
================================================
---
sidebar_position: 13
sidebar_label: KILL
title: KILL statement | SurrealQL
description: The KILL statement is used to terminate a running live query.
---

import Since from "@components/shared/Since.astro";
import RailroadDiagram from "@components/RailroadDiagram.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# `KILL` statement

The `KILL` statement is used to terminate a running live query.

While the `KILL` statement does accept a value type, this value must resolve to a UUID. Consequently, it will accept a string literal of a UUID or a param.

### Statement syntax

<Tabs syncKey="kill-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
KILL @value;
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const killAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    {
      type: "Sequence",
      children: [
        { type: "Terminal", text: "KILL" },
        { type: "NonTerminal", text: "@value" },
        { type: "Terminal", text: ";" },
      ],
    },
  ],
};

<RailroadDiagram ast={killAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

### Basic usage

The `KILL` statement expects the UUID of a running [live select](/docs/surrealql/statements/live) query to be passed. This UUID can be found in the output of the `LIVE` statement, and can thereafter be passed into a `KILL` statement once it is no longer needed.

```surql
LIVE SELECT DIFF FROM person;
-- output: u'0189d6e3-8eac-703a-9a48-d9faa78b44b9'

-- Some time later...
KILL u"0189d6e3-8eac-703a-9a48-d9faa78b44b9";
```

The `KILL` statement also allows for parameters to be used.

```surql
-- Define the parameter
LET $live_query_id = u"0189d6e3-8eac-703a-9a48-d9faa78b44b9";
-- Use the parameter
KILL $live_query_id;
```

Using the `KILL` statement on a UUID that does not correspond to a running live query will generate an error.

```surql
LET $rand = rand::uuid();
KILL $rand;
KILL u'9276b05b-e59a-49cd-9dd1-17c6fd15c28f';
```

```surql title="Output"
"Can not execute KILL statement using id '$rand'"
"Can not execute KILL statement using id 'u'9276b05b-e59a-49cd-9dd1-17c6fd15c28f''"
```

## Kill notifications

<Since v="v3.0.0-alpha.4" />

A separate notification is sent out when a `KILL` statement is enacted on a live query ID.

```surql
LIVE SELECT * FROM person;

-- Output is a UUID:
-- u'cf447091-9463-4d75-b32a-08513eb2a07c'

KILL u'cf447091-9463-4d75-b32a-08513eb2a07c';
```

```surql title="Output"
-- Query 1
NONE

-- Notification (action: Killed, live query ID: cf447091-9463-4d75-b32a-08513eb2a07c)
NONE
```


================================================
FILE: src/content/doc-surrealql/statements/let.mdx
================================================
---
sidebar_position: 14
sidebar_label: LET
title: LET statement | SurrealQL
description: The LET statement sets and stores a value which can then be used in a subsequent query.
---

import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `LET` Statement

The `LET` statement allows you to create parameters to store any value, including the results of queries or the outputs of expressions. These parameters can then be referenced throughout your SurrealQL code, making your queries more dynamic and reusable.

## Syntax

The syntax for the `LET` statement is straightforward. The parameter name is prefixed with a `$` symbol.

<Tabs syncKey="let-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
LET $@parameter [: @type_name] = @value;
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const letAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "LET" },
      { type: "Terminal", text: "$" },
      { type: "NonTerminal", text: "@parameter" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: ":" }, { type: "NonTerminal", text: "@type_name" } ] } },
      { type: "Terminal", text: "=" },
      { type: "NonTerminal", text: "@value" },
      { type: "Terminal", text: ";" }
    ]}
  ]
};

<RailroadDiagram ast={letAst} className="my-6" />

  </TabItem>
</Tabs>

## Example Usage

### Basic Parameter Assignment

You can use the `LET` statement to store simple values or query results. For example, storing a string value and then using it in a `CREATE` statement:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: person:qt3itwoql7oodlg3n077, name: 'tobie' }]"
skip-record-id-key = true

*/

-- Define the parameter
LET $name = "tobie";
-- Use the parameter
CREATE person SET name = $name;
```

### Storing Query Results

The `LET` statement is also useful for storing the results of a query, which can then be used in subsequent operations:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[]"

*/

-- Define the parameter
LET $adults = SELECT * FROM person WHERE age > 18;
-- Use the parameter
UPDATE $adults SET adult = true;
```

### Conditional Logic with `IF ELSE`

SurrealQL allows you to define parameters based on conditional logic using `IF ELSE` statements:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "'integer'"

*/

LET $num = 10;

LET $num_type =
         IF type::is_int($num)     { "integer" }
    ELSE IF type::is_decimal($num) { "decimal" }
    ELSE IF type::is_float($num)   { "float"   };

RETURN $num_type;
-- 'integer'
```

## Anonymous Functions

You can define anonymous functions also known as closures using the `LET` statement. These functions can be used to encapsulate reusable logic and can be called from within your queries. Learn more about [anonymous functions](/docs/surrealql/datamodel/closures) in the Data model section.


## Pre-Defined and Protected Parameters

SurrealDB comes with [pre-defined parameters](/docs/surrealql/parameters) that are accessible in any context. However, parameters created using `LET` are not accessible within the scope of these pre-defined parameters.

Furthermore, some pre-defined parameters are protected and cannot be overwritten using `LET`:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "'Before!'"

[[test.results]]
value = "[{ before: { id: person:1 } }, { before: { id: person:2 } }, { before: { id: person:3 } }, { before: { id: person:qt3itwoql7oodlg3n077, name: 'tobie' } }]"
skip-record-id-key = true

[[test.results]]
value = "'Before!'"

*/

LET $before = "Before!";

-- Returns ["Before!"];
RETURN $before;

-- Returns the `person` records before deletion
DELETE person RETURN $before;

-- Returns "Before!" again
RETURN $before;
```

Attempting to redefine protected parameters will result in an error:

```surql
/**[test]

[[test.results]]
error = ""'auth' is a protected variable and cannot be set""

[[test.results]]
error = ""'session' is a protected variable and cannot be set""

*/

LET $auth = 1;
LET $session = 10;
```

```surql title="Output"
-------- Query 1 (0ns) --------

"'auth' is a protected variable and cannot be set"

-------- Query 2 (0ns) --------

"'session' is a protected variable and cannot be set"
```

## Typed LET statements

<Since v="v2.0.0" />

Type safety in a `LET` statement can be ensured by adding a `:` (a colon) and the type name after the `LET` keyword.

```surql
/**[test]

[[test.results]]
error = ""Tried to set `$number`, but couldn't coerce value: Expected `int` but found `'9'`""

*/

LET $number: int = "9";
```

```surql title="Output"
"Tried to set `$number`, but couldn't coerce value: Expected `int` but found `'9'`"
```

### Taking advantage of type safety

Using typed `LET` statements is a good practice when prototyping code or when getting used to SurrealQL for the first time. Take the following example that attempts to count the number of `true` values in a field by filtering out values that are not `true`, without noticing that the field actually contains strings instead of booleans. The query output ends up being 0, rather than the expected 2.

```surql
/**[test]

[[test.results]]
value = "[{ id: some:record, vals: ['true', 'false', 'true'] }]"

[[test.results]]
value = "0"

*/

CREATE some:record SET vals = ["true", "false", "true"];
some:record.vals.filter(|$val| $val = true).len();
```

```surql title="Output"
0
```

Breaking this into multiple typed `LET` statements shows the error right away.

```surql
LET $vals: array<bool> = some:record.vals;
LET $len: number = $vals.filter(|$val| $val = true).len();
$len;
```

```surql title="Output"
-------- Query 1 --------

"Tried to set `$vals`, but couldn't coerce value: Expected `bool` but found `'true'` when coercing an element of `array<bool>`"

-------- Query 2 --------

'There was a problem running the filter() function. no such method found for the none type'

-------- Query 3 --------

NONE
```

With the location of the error in clear sight, a fix is that much easier to implement.

```surql
-- Use .map() to turn each string into a bool
LET $vals: array<bool> = some:record.vals.map(|$val| <bool>$val);
LET $len: number = $vals.filter(|$val| $val = true).len();
$len;
```

```surql title="Output"
2
```

### Typed literal statements

Multiple possible types can be specified in a `LET` statement by adding a `|` (vertical bar) in between each possible type.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

LET $number: int | string = "9";
```

Even complex types such as objects can be included in a typed `LET` statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

LET $error_info: string | { error: string } = { error: "Something went wrong plz help" };
```

For more information on this pattern, see the page on [literals](/docs/surrealql/datamodel/literals).

## Conclusion

The `LET` statement in SurrealDB is versatile, allowing you to store values, results from subqueries, and even define anonymous functions. Understanding how to use `LET` effectively can help you write more concise, readable, and maintainable queries.



================================================
FILE: src/content/doc-surrealql/statements/live.mdx
================================================
---
sidebar_position: 15
sidebar_label: LIVE
title: LIVE SELECT statement | SurrealQL
description: The LIVE SELECT statement can be used to initiate a real-time selection from a table, including the option to apply filters.
---

import Since from "@components/shared/Since.astro";
import RailroadDiagram from "@components/RailroadDiagram.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# `LIVE SELECT` statement

The `LIVE SELECT` statement can be used to initiate a real-time selection from a table, including the option to apply filters.

In practical terms, when you execute a `LIVE SELECT` query, it triggers an ongoing session that captures any subsequent changes to the data in real-time. These changes are then immediately transmitted to the client, ensuring that the client is consistently updated with the latest data modifications.

> [!IMPORTANT]
> Currently, `LIVE SELECT` is only supported in single-node deployments, with multi-node support being actively developed.

### Statement syntax

<Tabs syncKey="live-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
LIVE SELECT
	[
		[ VALUE ] @fields ... [ AS @alias ]
		| DIFF
	]
	FROM @targets
	[ WHERE @conditions ]
	[ FETCH @fields ... ]
;
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const liveAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "LIVE" },
      { type: "Terminal", text: "SELECT" },
      { type: "Choice", index: 1, children: [
        { type: "Sequence", children: [
          { type: "Optional", child: { type: "Terminal", text: "VALUE" } },
          { type: "Sequence", children: [
            { type: "NonTerminal", text: "@field" },
            { type: "ZeroOrMore", child: { type: "Sequence", children: [ { type: "Terminal", text: "," }, { type: "NonTerminal", text: "@field" } ] } }
          ] },
          { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "AS" }, { type: "NonTerminal", text: "@alias" } ] } }
        ] },
        { type: "Terminal", text: "DIFF" }
      ] },
      { type: "Terminal", text: "FROM" },
      { type: "NonTerminal", text: "@targets" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "WHERE" }, { type: "NonTerminal", text: "@conditions" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "FETCH" }, { type: "NonTerminal", text: "@fields ..." } ] } },
      { type: "Terminal", text: ";" }
    ]}
  ]
};

<RailroadDiagram ast={liveAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

### Basic usage

By default, SurrealDB will push the entire record over the websocket when created or updated, and just the record's ID when deleted.

```surql
/**[test]

[[test.results]]
value = "u'0f0d0e40-f371-4a68-8ee0-6d5eb3565b76'"
skip-uuid = true

*/

LIVE SELECT * FROM person;

-- 'b1f1d115-ad0f-460d-8cbf-dbc7ce48851c'
```

The result of the above query will be a UUID. This UUID is the Live Query Unique ID, and is used to differentate between different Live Queries. You will want to keep track of this ID, so that you can differentiate between different notifications being received after this query. You can also use this UUID to [KILL](/docs/surrealql/statements/kill) (stop) the Live Query. The protocol will then send messages that are of a Notification format.

You can find an example of such a message in the [Live Query WebSocket protocol](/docs/surrealdb/integration/rpc#live-websocket-only) description.

### Diff

When using the `DIFF` mode, updates will be sent in the form of an array with [JSON Patch](https://jsonpatch.com/) messages.

```surql
/**[test]

[[test.results]]
value = "u'0f0d0e40-f371-4a68-8ee0-6d5eb3565b76'"
skip-uuid = true

*/

LIVE SELECT DIFF FROM person;

-- 'b87cbb0d-ca15-4f0a-8f86-caa680672aa5'
```

### Filter the live query

You can optionally apply filters with the `WHERE` clause.

```surql
/**[test]

[[test.results]]
value = "u'0f0d0e40-f371-4a68-8ee0-6d5eb3565b76'"
skip-uuid = true

*/

LIVE SELECT * FROM person WHERE age > 18;
```

## Consistency Guarantees

When using Live Queries, it is important to understand the ordering of messages and events when many clients and transactions are running in paralllel. Notifications on live queries are only published for committed transactions.

While a best effort is made to assure ordering is correct, a strict correctness is not yet in place for a full guarantee. As such that some messages may be received out of order from their commit order. However, transactions that are committed from the same client will always be in order.

Security enforcement is always evaluated per notification and will reflect the value of authorisation at the time of publishing the notification. This means that if a transaction is committed, after which the authorisation immediately changes for the live query receiver, the receiver will get the notification under the new rules.

## Fetching inside live queries

<Since v="v2.2.0" />

The `FETCH` clause can be used inside live queries as well.

```surql
/**[test]

[[test.results]]
value = "u'0f0d0e40-f371-4a68-8ee0-6d5eb3565b76'"
skip-uuid = true

*/

LIVE SELECT * FROM person WHERE age > 18 FETCH friends;
```

## Other notes

Currently, it is not possible to use [parameters inside of Live Queries](https://github.com/surrealdb/surrealdb/issues/4026).

```surql
/**[test]

[[test.results]]
value = "u'0f0d0e40-f371-4a68-8ee0-6d5eb3565b76'"
skip-uuid = true

*/

LIVE SELECT * FROM person WHERE $field > $value;
```

It is possible to have parameters for the table reference.

```surql
LIVE SELECT * FROM $table WHERE field > 50;
```


## Parameters in `LIVE SELECT` statements

<Since v="v3.0.0-alpha.11" />

Parameters can also be used inside a `LIVE SELECT` statement.

```surql
LET $table = 'measurement';
LET $location = 'Tallinn';
LIVE SELECT * FROM type::table($table) WHERE location == $location;
```


================================================
FILE: src/content/doc-surrealql/statements/rebuild.mdx
================================================
---
sidebar_position: 16
sidebar_label: REBUILD
title: REBUILD statement | SurrealQL
description: The REBUILD statement is used to rebuild resources.
---

import Since from '@components/shared/Since.astro'
import SurrealistMini from "@components/SurrealistMini.astro"
import RailroadDiagram from "@components/RailroadDiagram.astro"
import Tabs from "@components/Tabs/Tabs.astro"
import TabItem from "@components/Tabs/TabItem.astro"

# `REBUILD` statement

<Since v="v1.5.0" />

The `REBUILD` statement is used to rebuild resources in SurrealDB. It is usually used in relation to a specified [Index](/docs/surrealql/statements/define/indexes) to optimize performance. It is useful to rebuild indexes because sometimes [HNSW](/docs/surrealql/statements/define/indexes#hnsw-hierarchical-navigable-small-world) index performance can degrade due to frequent updates.

Rebuilding the index will ensure the index is fully optimized.

> [!NOTE]
> Rebuilds are concurrent or sync based on how the index is defined. For example, if you define an index with the `CONCURRENTLY` option, the rebuild will be concurrent. Please see the [`CONCURRENTLY` clause](/docs/surrealql/statements/define/indexes#using-concurrently-clause) section for more information. 

### Statement syntax

<Tabs syncKey="rebuild-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
REBUILD [
	INDEX [ IF EXISTS ] @name ON [ TABLE ] @table
]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const rebuildAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "REBUILD" },
      { type: "Sequence", children: [
        { type: "Terminal", text: "INDEX" },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "EXISTS" } ] } },
        { type: "NonTerminal", text: "@name" },
        { type: "Terminal", text: "ON" },
        { type: "Optional", child: { type: "Terminal", text: "TABLE" } },
        { type: "NonTerminal", text: "@table" }
      ] },
      { type: "Terminal", text: ";" }
    ]}
  ]
};

<RailroadDiagram ast={rebuildAst} className="my-6" />

  </TabItem>
</Tabs>

> [!NOTE]
> The `IF EXISTS` and TABLE clauses are optional.

## Example usage

For example, if you have a table called `book` and you have an index called `uniq_isbn` on the `isbn` field, you can rebuild the index using the following query:

```surql
REBUILD INDEX uniq_isbn ON book;
```


<SurrealistMini
url="https://app.surrealdb.com/mini?query=CREATE+book%3A1+SET+title+%3D+%27Rust+Web+Programming%27%2C+isbn+%3D+%27978-1803234694%27%2C+author+%3D+%27Jon+Doe%27%3B%0A%0A%2F%2F+Define+a+unique+index+on+the+isbn+field%0ADEFINE+INDEX+uniq_isbn+ON+book+FIELDS+isbn+UNIQUE%3B%0A%0A%2F%2F+Rebuild+this+index+incase+of+more+updates%0AREBUILD+INDEX+IF+EXISTS+uniq_isbn+ON+book%3B%0A%0A%2F%2F+Check+that+the+index+has+been+created%0AINFO+FOR+TABLE+book%3B%0A%0AREBUILD+INDEX+IF+EXISTS+idx_author+ON+book%3B%0A%0AREBUILD+INDEX+IF+EXISTS+ft_title+ON+book%3B%0A%0A%2F%2F+Define+index+on+the+author+field+%0ADEFINE+INDEX+idx_author+ON+book+FIELDS+author%3B%0A%0A%2F%2F+Define+an+analyzer+which+has+blank+and+class+Tokenizers+and+converts+the+tokens+to+lowercase+%0ADEFINE+ANALYZER+simple+TOKENIZERS+blank%2Cclass+FILTERS+lowercase%3B%0A%0ADEFINE+INDEX+ft_title+ON+book+FIELDS+title+SEARCH+ANALYZER+simple+BM25+HIGHLIGHTS%3B%0A%0AREBUILD+INDEX+uniq_isbn+ON+book%3B%0A%0AREBUILD+INDEX+idx_author+ON+book%3B%0A%0AREBUILD+INDEX+ft_title+ON+book%3B%0A%0A%2F%2F+Check+that+the+index+has+been+created%0AINFO+FOR+TABLE+book%3B%0A%0A%2F%2FChecks+whether+the+term+RUST+IS+found+in+a+full-text+indexed+field.%0ASELECT+*+FROM+book+WHERE+title+%40%40+%27Rust%27%3B&orientation=horizontal"
/>

### Using if exists clause

<Since v="v1.3.0" />

The following queries show an example of how to rebuild resources using the `IF EXISTS` clause, which will only rebuild the resource if it exists.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

REBUILD INDEX IF EXISTS uniq_isbn ON book;
```







================================================
FILE: src/content/doc-surrealql/statements/relate.mdx
================================================
---
sidebar_position: 17
sidebar_label: RELATE
title: RELATE statement | SurrealQL
description: The RELATE statement can be used to generate graph edges between two records in the database.
---
import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `RELATE` statement

The `RELATE` statement can be used to generate graph edges between two records in the database. This allows you to traverse related records efficiently without needing to pull data from multiple tables and merging that data together using SQL JOINs.

Edges created using the RELATE statement are nearly identical to tables created using other statements, and can contain data. The key differences are that:

- Edge tables are deleted once there are no existing relationships left.
- Edge tables have two required fields `in` and `out`, which specify the directions of the relationships. These cannot be modified in schema declarations except to specify that they must be of a certain record type or to [add assertions](/docs/surrealql/statements/define/field#asserting-rules-on-fields).

Otherwise, edge tables behave like normal tables in terms of [updating](/docs/surrealql/statements/update), [defining a schema](/docs/surrealql/statements/define/table) or [indexes](/docs/surrealql/statements/define/indexes).

Another option for connecting data is using [record links](/docs/surrealql/datamodel/records). Record links consist of a field with record IDs that serve as unidirectional links by default, or bidirectional links if reference tracking is used. The key differences are that graph relations have the following benefits over record links:

- Graph relations are kept in a separate table as opposed to a field inside a record.
- Graph relations allow you to store data alongside the relationship.
- Graph relations have their own syntax that makes it easy to build and visualize edge queries.

Graph relations offer built-in bidirectional querying and referential integrity. As of SurrealDB 2.2.0, record links also offer these two advantages if they are defined inside a [`DEFINE FIELD`](/docs/surrealql/statements/define/field) statement using the `REFERENCES` clause. For more information, see [the page on record references](/docs/surrealql/datamodel/references).

### Statement syntax

<Tabs syncKey="relate-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
RELATE [ ONLY ] @from_record -> @table -> @to_record
	[ CONTENT @value
	  | SET @field = @value ...
	]
	[ RETURN NONE | RETURN BEFORE | RETURN AFTER | RETURN DIFF | RETURN @statement_param, ... | RETURN VALUE @statement_param ]
	[ TIMEOUT @duration ]
;
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const relateAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "RELATE" },
      { type: "Optional", child: { type: "Terminal", text: "ONLY" } },
      { type: "NonTerminal", text: "@from_record" },
      { type: "Terminal", text: "->" },
      { type: "NonTerminal", text: "@table" },
      { type: "Terminal", text: "->" },
      { type: "NonTerminal", text: "@to_record" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [
        { type: "Sequence", children: [ { type: "Terminal", text: "CONTENT" }, { type: "NonTerminal", text: "@value" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "SET" }, { type: "NonTerminal", text: "@field = @value ..." } ] }
      ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "RETURN" }, { type: "Choice", index: 1, children: [
        { type: "Terminal", text: "NONE" },
        { type: "Terminal", text: "BEFORE" },
        { type: "Terminal", text: "AFTER" },
        { type: "Terminal", text: "DIFF" },
        { type: "NonTerminal", text: "@statement_param, ..." },
        { type: "Sequence", children: [ { type: "Terminal", text: "VALUE" }, { type: "NonTerminal", text: "@statement_param" } ] }
      ] } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "TIMEOUT" }, { type: "NonTerminal", text: "@duration" } ] } },
      { type: "Terminal", text: ";" }
    ]}
  ]
};

<RailroadDiagram ast={relateAst} className="my-6" />

  </TabItem>
</Tabs>

> [!NOTE]
> `RELATE` will create a relation regardless of whether the records to relate to exist or not. As such, it is advisable to [create the records](/docs/surrealql/statements/create) you want to relate to before using `RELATE`, or to at least ensure that they exist before making a query on the relation. If the records to relate to don't exist, a query on the relation will still work but will return an empty array. To override this behaviour and return an error if no records exist to relate, you can use a [`DEFINE TABLE`](/docs/surrealql/statements/define/table) statement that includes the `ENFORCED` keyword.

### Example usage

#### Basic usage

The following query shows the basic structure of the `RELATE` statement, which creates a relationship between a record in the `person` table and a record in the `article` table.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:aristotle }, { id: article:on_sleep_and_sleeplessness }]"

[[test.results]]
value = "[{ id: wrote:2m9047thgn9j9oc05iqh, in: person:aristotle, out: article:on_sleep_and_sleeplessness }]"
skip-record-id-key = true

*/

CREATE person:aristotle, article:on_sleep_and_sleeplessness;
RELATE person:aristotle->wrote->article:on_sleep_and_sleeplessness;
```

```surql title="Response"
[
	{
		id: wrote:bpbrj5kd7smu3ahlf55r,
		in: person:aristotle,
		out: article:on_sleep_and_sleeplessness
	}
]
```

There is no relationship information stored in either the `person` or `article` table.

```surql
SELECT * FROM person, article;
```

```surql title="Response"
[
	{
		id: person:aristotle
	},
	{
		id: article:on_sleep_and_sleeplessness
	}
]
```

Instead, an edge table (in this case a table called `wrote`) stores the relationship information.

```surql
SELECT * FROM wrote;
```

The structure `in -> id -> out` mirrors the record IDs from the `RELATE` statement, with the addition of the automatically generated ID for the `wrote` edge table.

```surql title="Response"
[
	{
		id: wrote:bpbrj5kd7smu3ahlf55r,
		in: person:aristotle,
		out: article:on_sleep_and_sleeplessness
	}
]
```

The same structure can be used in a `SELECT` query, as well as directly from a record ID.

```surql
-- Aristotle's id and the articles he wrote
SELECT id, ->wrote->article FROM person:aristotle;
-- Every `person`'s id and written articles
-- Same output as above as the database has a single `person` record
SELECT id, ->wrote->article FROM person;
-- Directly follow the path from Aristotle to his written articles
RETURN person:aristotle->wrote->article;
```

```surql title="Response"
-------- Query --------

[
	{
		"->wrote": {
			"->article": [
				article:on_sleep_and_sleeplessness
			]
		},
		id: person:aristotle
	}
]

-------- Query --------

[
	article:on_sleep_and_sleeplessness
]
```

By default, the edge table gets created as a schemaless table when you execute the `RELATE` statement. You can make the table schemafull by [defining a schema](/docs/surrealql/statements/define/table).

A common use case is to make sure only unique relationships get created. You can do that by [defining an index](/docs/surrealql/statements/define/indexes).

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE INDEX unique_relationships
    ON TABLE wrote
    COLUMNS in, out UNIQUE;
```

As edge tables are bidirectional by default, there is nothing stopping a query like the following in which an article writes a person instead of the other way around.

```surql
/**[test]

[[test.results]]
value = "[{ id: wrote:ymz181gxo9ugcrse7nmo, in: article:on_sleep_and_sleeplessness, out: person:aristotle }]"
skip-record-id-key = true

*/

RELATE article:on_sleep_and_sleeplessness->wrote->person:aristotle;
```

To enforce unidirectional relationships, you can restrict the type definition using a [`DEFINE FIELD`](/docs/surrealql/statements/define/field) definition.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

DEFINE FIELD in  ON TABLE wrote TYPE record<person>;
DEFINE FIELD out ON TABLE wrote TYPE record<article>;
```

#### Always two records there are - no more, no less

An edge table will always include exactly one record for the `in` field and one record for the `out` field.

Knowing this, one would assume that a `RELATE` statement like the following would fail as it seems to be attempting to insert two `cat` records at the `in` field.

```surql
/**[test]

[[test.results]]
value = "[{ id: cat:mr_meow }, { id: cat:mrs_meow }, { id: cat:kitten }]"

[[test.results]]
value = "[{ id: parent_of:a3pm72b0xvltb61s5poy, in: cat:mr_meow, out: cat:kitten }, { id: parent_of:7h1wd7vu01o0kwmns9k1, in: cat:mrs_meow, out: cat:kitten }]"
skip-record-id-key = true

*/

CREATE cat:mr_meow, cat:mrs_meow, cat:kitten;
RELATE [cat:mr_meow, cat:mrs_meow]->parent_of->cat:kitten;
```

However, the query works just fine. Instead of trying to create a single `parent_of` graph edge, it will create one for each record in the first array: one between `cat:mr_meow` and `cat:kitten`, and another between `cat:mrs_meow` and `cat:kitten`.


```surql title="Response"
[
	{
		id: parent_of:uahudi4qr68k640fcjbg,
		in: cat:mr_meow,
		out: cat:kitten
	},
	{
		id: parent_of:hi79yfazjppv8b3kyi36,
		in: cat:mrs_meow,
		out: cat:kitten
	}
]
```

Similarly, a `RELATE` statement that involves two arrays will return a number of graph edges equal to their product (2 * 2 in this case):

```surql
/**[test]

[[test.results]]
value = "[{ id: cat:kitten2 }]"

[[test.results]]
value = "[{ id: parent_of:bsgtxiltlv2pd9hf5eqz, in: cat:mr_meow, out: cat:kitten }, { id: parent_of:cr7chl0lot6g4gfj84fe, in: cat:mr_meow, out: cat:kitten2 }, { id: parent_of:y3dtskf9sme2y0hmumlu, in: cat:mrs_meow, out: cat:kitten }, { id: parent_of:lc39ib0lbzw0x1azkee9, in: cat:mrs_meow, out: cat:kitten2 }]"
skip-record-id-key = true

*/

CREATE cat:kitten2;
RELATE [cat:mr_meow, cat:mrs_meow]->parent_of->[cat:kitten, cat:kitten2];
```

```surql title="Response"
[
	{
		id: parent_of:ysbab20nv5568ogba6ns,
		in: cat:mr_meow,
		out: cat:kitten
	},
	{
		id: parent_of:0ltm6xr94pkblyxf0m6c,
		in: cat:mr_meow,
		out: cat:kitten2
	},
	{
		id: parent_of:71cfl0nvj5frve0r1npv,
		in: cat:mrs_meow,
		out: cat:kitten
	},
	{
		id: parent_of:4gbid7nzo6cwr1t8k090,
		in: cat:mrs_meow,
		out: cat:kitten2
	}
]
```

### Adding data using `SET` and `CONTENT`

Graph edges are standalone tables that can hold other fields besides the default `in`, `out`, and `id`. These can be added during a `RELATE` statement or during an `UPDATE` in the same manner as any other SurrealDB table.

Let's look at the two ways you can add record data in the `RELATE` statement. Both of these queries will produce the same result.

```surql
/**[test]

[[test.results]]
value = "[{ id: wrote:oapxwx4gdbpfsz1yxhih, in: person:l19zjikkw1p1h9o6ixrg, metadata: { location: 'Tallinn', time_written: d'2025-10-08T04:28:09.169160Z' }, out: article:8nkk6uj4yprt49z7y3zm }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: wrote:fvrxtrn5cj2fnz2gliyw, in: person:l19zjikkw1p1h9o6ixrg, metadata: { location: 'Tallinn', time_written: d'2025-10-08T04:28:09.171256Z' }, out: article:8nkk6uj4yprt49z7y3zm }]"
skip-record-id-key = true

*/

RELATE person:l19zjikkw1p1h9o6ixrg->wrote->article:8nkk6uj4yprt49z7y3zm
    SET 
		metadata.time_written = time::now(),
		metadata.location = "Tallinn";


RELATE person:l19zjikkw1p1h9o6ixrg->wrote->article:8nkk6uj4yprt49z7y3zm
	CONTENT {
		metadata: {
			time_written: time::now(),
			location: "Tallinn"
		}
	};
```

```surql title="Response"
[
	{
		id: wrote:rva8hentypdu8lcgwjmf,
		in: person:l19zjikkw1p1h9o6ixrg,
		metadata: {
			location: 'Tallinn',
			time_written: d'2024-11-26T01:52:01.169Z'
		},
		out: article:8nkk6uj4yprt49z7y3zm
	}
]
```

Here is an example of the graph edge being updated in the same way as any other SurrealDB record:

```surql
-- Add a small synopsis composed of the table name and article ID
UPDATE wrote SET
    metadata.description = meta::tb(out) + ' written by ' + <string>in;
```

```surql title="Response"
[
	{
		id: wrote:k9d8ynbfxgb8jqjv2ob5,
		in: person:l19zjikkw1p1h9o6ixrg,
		metadata: {
			description: 'article written by person:l19zjikkw1p1h9o6ixrg',
			location: 'Tallinn',
			time_written: d'2024-11-26T01:53:51.350Z'
		},
		out: article:8nkk6uj4yprt49z7y3zm
	}
]
```

### Passing variables in `CONTENT` and `SET`

<Since v="v1.5.0" />

You can also pass variables in the `CONTENT` block. This is useful when you want to pass a variable that is not a record ID.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: wrote:9zyb1fytya4cykc47j0o, in: person:l19zjikkw1p1h9o6ixrg, out: article:8nkk6uj4yprt49z7y3zm, time: { written: d'2025-10-08T04:28:53.000469Z' } }]"
skip-record-id-key = true

*/

LET $time = time::now();
RELATE person:l19zjikkw1p1h9o6ixrg->wrote->article:8nkk6uj4yprt49z7y3zm
    CONTENT {
        time: {
            written: $time
        }
    };
```

```surql title="Response"
    {
        "id": "wrote:ctwsll49k37a7rmqz9rr",
        "in": "person:l19zjikkw1p1h9o6ixrg",
        "out": "article:8nkk6uj4yprt49z7y3zm",
        "time": {
            "written": "2021-09-29T14:00:00Z"
        }
    }
```

Below is an example of how you can pass a variable in the `SET` block:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: wrote:o6kz4fqcqgqok1xqoqm0, in: person:l19zjikkw1p1h9o6ixrg, out: article:8nkk6uj4yprt49z7y3zm, time: { written: d'2025-10-08T04:29:36.089521Z' } }]"
skip-record-id-key = true

*/

LET $time = time::now();

RELATE person:l19zjikkw1p1h9o6ixrg->wrote->article:8nkk6uj4yprt49z7y3zm
    SET time.written = $time;
```

```surql title="Response"
{
	"id": "wrote:ctwsll49k37a7rmqz9rr",
	"in": "person:l19zjikkw1p1h9o6ixrg",
	"out": "article:8nkk6uj4yprt49z7y3zm",
	"time": {
		"written": "2021-09-29T14:00:00Z"
	}
}
```


### Creating a single relation with the `ONLY` keyword

Using the ONLY keyword, just an object for the relation in question will be returned. This, instead of an array with a single object.

```surql
/**[test]

[[test.results]]
value = "{ id: wrote:lrddm6wuqashha9wjv6s, in: person:l19zjikkw1p1h9o6ixrg, out: article:8nkk6uj4yprt49z7y3zm }"
skip-record-id-key = true

*/

RELATE ONLY person:l19zjikkw1p1h9o6ixrg->wrote->article:8nkk6uj4yprt49z7y3zm;
```

```surql title="Response"
{
	id: wrote:k9f1rqn3oikolr1560u3,
	in: person:l19zjikkw1p1h9o6ixrg,
	out: article:8nkk6uj4yprt49z7y3zm
}
```

### Using [`LET`](/docs/surrealql/statements/let) parameters in RELATE statements

You can also use [parameters](/docs/surrealql/parameters) to specify the record IDs.

```surql
-- These two statements store the result of the subquery in a parameter
-- The subquery returns an array of IDs
LET $person =  (SELECT VALUE id FROM person);
LET $article = (SELECT VALUE id FROM article);

-- This statement creates a relationship record for every combination of Record IDs
-- Such that if we have 10 records each in the person and article table
-- We get 100 records in the wrote edge table (10*10 = 100)
-- In this case it would mean that each article would have 10 authors
RELATE $person->wrote->$article SET time.written = time::now();
```

### Modifying output with the [`RETURN`](/docs/surrealql/statements/return) clause

By default, the relate statement returns the record value once the changes have been made. To change the return value of each record, specify a RETURN clause, specifying either `NONE`, `BEFORE`, `AFTER`, `DIFF`, or a comma-separated list of specific fields to return.

```surql
/**[test]

[[test.results]]
value = "[]"
skip-record-id-key = true
skip-datetime = true

[[test.results]]
value = "[{ op: 'replace', path: '', value: { id: wrote:me0vergol3jkvn7me15x, in: person:l19zjikkw1p1h9o6ixrg, out: article:8nkk6uj4yprt49z7y3zm, time: { written: d'2025-10-08T04:30:34.214973Z' } } }]"
skip-record-id-key = true
skip-datetime = true

[[test.results]]
value = "NONE"
skip-record-id-key = true
skip-datetime = true

[[test.results]]
value = "[{ id: wrote:pwatbr0s0f2ddwcwqls7, in: person:l19zjikkw1p1h9o6ixrg, out: article:8nkk6uj4yprt49z7y3zm, time: { written: d'2025-10-08T04:30:34.218213Z' } }]"
skip-record-id-key = true
skip-datetime = true

[[test.results]]
value = "[{ time: { written: d'2025-10-08T04:30:34.219729Z' } }]"
skip-datetime = true

[[test.results]]
value = "[{ written: d'2025-10-08T04:30:34.221383Z' }]"
skip-datetime = true

*/

-- Don't return any result
RELATE person:l19zjikkw1p1h9o6ixrg->wrote->article:8nkk6uj4yprt49z7y3zm
    SET time.written = time::now()
    RETURN NONE;

-- Return the changeset diff
RELATE person:l19zjikkw1p1h9o6ixrg->wrote->article:8nkk6uj4yprt49z7y3zm
    SET time.written = time::now()
    RETURN DIFF;

-- Return the record before changes were applied
RELATE person:l19zjikkw1p1h9o6ixrg->wrote->article:8nkk6uj4yprt49z7y3zm
    SET time.written = time::now()
    RETURN BEFORE;

-- Return the record after changes were applied (the default)
RELATE person:l19zjikkw1p1h9o6ixrg->wrote->article:8nkk6uj4yprt49z7y3zm
    SET time.written = time::now()
    RETURN AFTER;

-- Return a specific field only from the updated records
RELATE person:l19zjikkw1p1h9o6ixrg->wrote->article:8nkk6uj4yprt49z7y3zm
    SET time.written = time::now()
    RETURN time;

-- Return only the value of a specific field without the field name
RELATE person:l19zjikkw1p1h9o6ixrg->wrote->article:8nkk6uj4yprt49z7y3zm
    SET time.written = time::now()
    RETURN VALUE time;
```

### Using the `TIMEOUT` clause

Adding the `TIMEOUT` keyword to specify a timeout duration for the statement can be useful when processing a large result set with many interconnected records. If the statement continues beyond this duration, then the transaction will fail, and the statement will return an error.

```surql
/**[test]

[[test.results]]
value = "[]"

*/

-- Cancel this conditional filtering based on graph edge properties
-- if not finished within 5 seconds
SELECT * FROM person WHERE ->knows->person->(knows WHERE influencer = true) TIMEOUT 5s;
```

Using a `TIMEOUT` is particularly useful when experimenting with complex queries with an extent that is difficult to imagine, especially if the query [is recursive](#recursive-graph-queries).

### Deleting graph edges

You can also delete graph edges between two records in the database by using the [DELETE statement](/docs/surrealql/statements/delete).

For example the graph edge below:

```surql
/**[test]

[[test.results]]
value = "[{ id: bought:z8xw3m3mmbg79tr21oj7, in: person:tobie, out: product:iphone }]"
skip-record-id-key = true

*/

RELATE person:tobie->bought->product:iphone;
```

```surql title="Response"

[
	{
		id: bought:ctwsll49k37a7rmqz9rr,
		in: person:tobie,
		out: product:iphone
	}
]
```

Can be deleted by:

```surql
DELETE person:tobie->bought WHERE out=product:iphone RETURN BEFORE;
```

As mentioned above, a graph edge will also automatically be deleted if it is no longer connected to a record at both `in` and `out`.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:one }, { id: person:two }, { id: person:three }]"

[[test.results]]
value = "[{ id: likes:qv1sjo66j48irzu1hsik, in: person:one, out: person:two }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: likes:w4n1on9bim3w1d7r3tg3, in: person:two, out: person:three }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: likes:1jopms33qaetjmtv3ygs, in: person:three, out: person:one }]"
skip-record-id-key = true

[[test.results]]
value = "[]"

[[test.results]]
value = "[{ id: likes:1jopms33qaetjmtv3ygs, in: person:three, out: person:one }]"
skip-record-id-key = true

*/

-- Create three people
CREATE person:one, person:two, person:three;

-- And a love triangle involving them all
RELATE person:one  ->likes->person:two;
RELATE person:two  ->likes->person:three;
RELATE person:three->likes->person:one;

-- Person two moves to Venus permanently, so delete
DELETE person:two;

-- Only one `likes` relationship is left
SELECT * FROM likes;
```

```surql title="Output"
[
	{
		id: likes:55szjin5yfqwl4sbmy1f,
		in: person:three,
		out: person:one
	}
]
```


### Using RELATE on non-existent records

As mentioned at the top of the page, `RELATE` can be used for records that do not yet exist. While this behaviour can be overridden by using the `ENFORCED` keyword, it can be useful in certain situations.

For example, the `VALUE` clause inside a [`DEFINE FIELD`](/docs/surrealql/statements/define/field) statement is calculated every time a record is altered (that is, every time it is created or updated). If this value depends on a graph edge, creating the record first will cause `VALUE` to calculate it based on a nonexistent path.

In the following example, a `house` table has a field called `has_road_access` that depends on whether any `->has_road` paths return an output that is not empty. Meanwhile, the city has a new road under construction but no houses are present and their details have not been set yet.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: road:ohl5o501eh7ylfzcqwm3, length: 10.5f, name: 'Dalhurst Way' }]"
skip-record-id-key = true

*/

-- Returns true if $this->has_road path is not empty
DEFINE FIELD has_road_access ON TABLE house VALUE !!$this->has_road->road;
CREATE road SET name = "Dalhurst Way", length = 10.5;
```

As the addresses of the upcoming houses have been decided, the `->has_road` path can be set ahead of time by giving the `house` records an ID based on their exact address.

```surql
LET $road = SELECT * FROM ONLY road WHERE name = "Dalhurst Way" LIMIT 1;
RELATE [
    house:["Dalhurst Way", 218],
    house:["Dalhurst Way", 222],
    house:["Dalhurst Way", 226],
]->has_road->$road;
```

Later on, two new houses are completed in the city and registered in the database. As the path to `house:["Dalhurst Way", 218]` has already been set up, the `has_road_access` field will evaluate to `true`, while the other house in the middle of nowhere will evaluate to `false`.

```surql
/**[test]

[[test.results]]
value = "[{ bedrooms: 5, floors: 2, id: house:['Dalhurst Way', 218] }]"

[[test.results]]
value = "[{ bedrooms: 12, floors: 4, id: house:['Middle of nowhere', 0] }]"

*/

CREATE house:["Dalhurst Way", 218] SET floors = 2, bedrooms = 5;
CREATE house:["Middle of nowhere", 0] SET floors = 4, bedrooms = 12;
```

```surql
-------- Query --------

[
	{
		bedrooms: 5,
		floors: 2,
		id: house:[
			'Dalhurst Way',
			218
		],
		street: []
	}
]

-------- Query --------

[
	{
		bedrooms: 12,
		floors: 4,
		id: house:[
			'Middle of nowhere',
			0
		],
		street: []
	}
]
```

## Querying graphs

### Different ways to reach similar results

For the questions below, each of the queries will give you largely the same answer. Note that whether `->` and `<-` are parsed as `in` or `out` depends on their direction in relation to the graph edge `wrote`. An arrow pointing towards `wrote` corresponds to `in`, and vice versa.

The following examples show how to make similar queries in a number of different ways, in the context of a database with one person who wrote two articles.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:aristotle }, { id: article:on_sleep_and_sleeplessness }, { id: article:on_dreams }]"

[[test.results]]
value = "[{ id: wrote:j0i75u90qswob99b779m, in: person:aristotle, out: article:on_sleep_and_sleeplessness, time_written: d'-0330-01-01T00:00:00Z' }, { id: wrote:cyqldu8ma76nh1q9jprq, in: person:aristotle, out: article:on_dreams, time_written: d'-0330-01-01T00:00:00Z' }]"
skip-datetime = true 
skip-record-id-key = true

*/

CREATE 
	person:aristotle,
	article:on_sleep_and_sleeplessness,
	article:on_dreams;
RELATE person:aristotle->wrote->[
		article:on_sleep_and_sleeplessness,
		article:on_dreams
	]
	// Written sometime around the year 330 BC
	SET time_written = d"-0330-01-01";
```

Who wrote the articles?

```surql
-- All queries lead to `person:artistotle` twice,
-- via different paths and thus different field names
-- and/or structure

-- Directly from the `wrote` table
SELECT in FROM wrote;

-- From a single `person` record
SELECT ->wrote.in FROM person;
SELECT ->wrote<-person FROM person;

-- From two `article` records
SELECT <-wrote.in FROM article;
SELECT <-wrote<-person FROM article;
```

Which articles did the person write?

```surql
SELECT out FROM wrote;

SELECT ->wrote.out FROM person;
SELECT ->wrote->article FROM person;

SELECT <-wrote.out FROM article;
SELECT <-wrote->article FROM article;
```

When was the article written?

```surql
SELECT time_written FROM wrote;
SELECT ->wrote.time_written as time_written FROM person;
SELECT <-wrote.time_written as time_written FROM article;
```

### Parsing graph queries

For a more complicated query like the one below you can use a simple rule of thumb:
Place the subject in front of the graph selection, then read it backward.

```surql
-- This query
SELECT ->purchased->product<-purchased<-person->purchased->product FROM person:tobie

-- Then becomes
person:tobie->purchased->product<-purchased<-person->purchased->product SELECT
```

Reading this backwards then makes more sense:

> Select every product that was purchased by a person who purchased a product that was also purchased by person Tobie.

Alternatively, you can break it down into steps over multiple lines.

```surql
-- Starting with Tobie
person:tobie
-- move on to his purchased products
->purchased->product
-- that were also purchased by persons...
<-purchased<-person
-- what are all of those persons' purchased products?
->purchased->product
```

Putting it all together it would be: based on all the products Tobie purchased, which person also purchased those products and what did they purchase? This sort of query could be used on a social network site to recommend to the user `person:tobie` a list of people that have similar interests.

### Using parentheses to refine graph query logic

Parentheses can be added at any step of a graph query to refine the logic, such as filtering relations based on specific conditions using the `WHERE` clause.

For example, suppose we want to limit the query to only take recent purchases into account. We can filter `purchased` graph edge to only include purchases made in last 3 weeks:

```surql
-- Select products purchased by people in the last 3 weeks who have purchased the same products that tobie purchased
SELECT 
	->purchased->product
	<-purchased<-person->(purchased WHERE created_at > time::now() - 3w)
	->purchased->product
FROM person:tobie;
```

If the `purchased` graph table can lead to both a `product` or a `subscription`, they can both be added to the query.

```surql
SELECT 
	->purchased->(product, subscription)
	<-purchased<-person
	->purchased->(product, subscription)
FROM person:tobie;
```

The `?` wildcard operator can also be used to search for any and all linked records. The following query will allow purchased `product`, `subscription`, `insurance`, or any other linked records to show up.

```surql
SELECT 
	->purchased->(?)
	<-purchased<-person
	->purchased->(?)
FROM person:tobie;
```

The `?` operator on its own can thus be used to see all of the relations that a record has.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:hermann_hesse }, { id: person:abigail }, { id: city:calw }, { id: book:demian }]"

[[test.results]]
value = "[{ id: wrote:lj0hszy4vbti435r0gza, in: person:hermann_hesse, out: book:demian, written_in: d'1919-01-01T00:00:00Z' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: born_in:0mdrzu8ubnff42lder2c, in: person:hermann_hesse, out: city:calw }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: likes:8pbzxj55dcad7rbrt55y, in: person:abigail, out: person:hermann_hesse }]"
skip-record-id-key = true

[[test.results]]
value = "[{ what_hesse_did: [{ id: born_in:0mdrzu8ubnff42lder2c, in: person:hermann_hesse, out: city:calw }, { id: wrote:lj0hszy4vbti435r0gza, in: person:hermann_hesse, out: book:demian, written_in: d'1919-01-01T00:00:00Z' }], what_others_did_to_hesse: [{ id: likes:8pbzxj55dcad7rbrt55y, in: person:abigail, out: person:hermann_hesse }] }]"
skip-record-id-key = true

*/

CREATE person:hermann_hesse, person:abigail, city:calw, book:demian;
RELATE person:hermann_hesse->wrote->book:demian SET written_in = d'1919-01-01';
RELATE person:hermann_hesse->born_in->city:calw;
RELATE person:abigail->likes->person:hermann_hesse;

SELECT 
	-- all tables in which the record is at `in`
    ->(?).* AS what_hesse_did,
	-- all tables in which the record is at `out`
    <-(?).* AS what_others_did_to_hesse
FROM person:hermann_hesse;
```

```surql title="Output"
[
	{
		what_hesse_did: [
			{
				id: born_in:k3adylof24a2r5kio8l5,
				in: person:hermann_hesse,
				out: city:calw
			},
			{
				id: wrote:ncbo9w0d8t3xd7lvl4dx,
				in: person:hermann_hesse,
				out: book:demian,
				written_in: d'1919-01-01T00:00:00Z'
			}
		],
		what_others_did_to_hesse: [
			{
				id: likes:6gubmldm14gzasoyypay,
				in: person:abigail,
				out: person:hermann_hesse
			}
		]
	}
]
```

The `?` operator can also be used to find all the relations between one record and another. To do this, use the [`<-> operator`](/docs/surrealql/statements/relate#bidirectional-relation-querying) to see all relations in which the record ID in question is either at the `in` or the `out` of the graph edge. Follow this with `(?)` to avoid filtering by graph table name, then use a [`WHERE`](/docs/surrealql/datamodel/arrays#mapping-and-filtering-on-arrays) filter on the output (an array of record IDs) to see if the record ID is present in either the `in` or the `out` field of the graph edge.

A small example of this using some of the relations between Anakin Skywalker (Darth Vader), Palpatine (the Emperor), and Luke Skywalker:

```surql
CREATE person:anakin_skywalker, person:luke_skywalker, person:the_emperor;
RELATE person:anakin_skywalker->served->person:the_emperor;
RELATE person:anakin_skywalker->attacked->person:the_emperor SET won = true;
RELATE person:the_emperor->attacked->person:luke_skywalker SET won = false;
RELATE person:luke_skywalker->son_of->person:anakin_skywalker;
RELATE person:the_emperor->fooled->person:anakin_skywalker SET date = "19 BBY";

-- As a SELECT statement
SELECT VALUE <->(?)[WHERE person:the_emperor IN [in, out]] FROM ONLY person:anakin_skywalker;
SELECT VALUE <->(?)[WHERE person:luke_skywalker IN [in, out]] FROM ONLY person:anakin_skywalker;

-- Or returned directly from the record ID
person:anakin_skywalker<->(?)[WHERE person:the_emperor IN [in, out]];
person:anakin_skywalker<->(?)[WHERE person:luke_skywalker IN [in, out]];
```

```surql title="Output"
-------- Anakin and Emperor relations --------

[
	{
		date: '19 BBY',
		id: fooled:irm2w6jvd1dmppjr7kh2,
		in: person:the_emperor,
		out: person:anakin_skywalker
	},
	{
		id: attacked:r8b4z5yr627wy9i73jkh,
		in: person:anakin_skywalker,
		out: person:the_emperor,
		won: true
	},
	{
		id: served:30oyjvv5uutnj255w4oy,
		in: person:anakin_skywalker,
		out: person:the_emperor
	}
]

-------- Anakin and Luke relations --------

[
	{
		id: son_of:h8oosl7s27n21kh3c2iq,
		in: person:luke_skywalker,
		out: person:anakin_skywalker
	}
]
```

Parentheses can be used at each point of a graph query. The example below includes `person` records (authors) connected to `book` records by the `wrote` table. As both the `person` and `book` tables have fields that can be useful when filtering, they can be isolated with parentheses at this point of the graph query in order to filter using the `WHERE` clause.

```surql
/**[test]

[[test.results]]
value = "[{ born: d'1891-01-03T00:00:00Z', id: person:j_r_r_tolkien, name: 'J.R.R. Tolkien' }]"

[[test.results]]
value = "[{ born: '-0428-06-01', id: person:plato, name: 'Plato' }]"

[[test.results]]
value = "[{ id: book:fotr, name: 'The Fellowship of the Ring' }]"

[[test.results]]
value = "[{ id: book:republic, name: 'The Republic', original_name: 'Πολιτεία' }]"

[[test.results]]
value = "[{ id: wrote:j6lto05qluv9nivz4ens, in: person:j_r_r_tolkien, out: book:fotr, written_at: 'North Oxford' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: wrote:y9ydvugxwhrpns6qn4s9, in: person:plato, out: book:republic, written_at: 'Athens' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ books_written_in_athens: [], name: 'J.R.R. Tolkien' }, { books_written_in_athens: [{ id: book:republic, name: 'The Republic', original_name: 'Πολιτεία' }], name: 'Plato' }]"

[[test.results]]
value = "[{ books_about_rings: [{ id: book:fotr, name: 'The Fellowship of the Ring' }], name: 'J.R.R. Tolkien' }, { books_about_rings: [], name: 'Plato' }]"

*/

CREATE person:j_r_r_tolkien SET
	name = "J.R.R. Tolkien",
	born = d'1891-01-03';
-- Very approximate date of birth
CREATE person:plato SET 
	name = "Plato", 
	born = "-0428-06-01";

CREATE book:fotr SET 
	name = "The Fellowship of the Ring";
CREATE book:republic SET 
	name = "The Republic",
	original_name = "Πολιτεία";

RELATE person:j_r_r_tolkien->wrote->book:fotr SET written_at = "North Oxford";
RELATE person:plato->wrote->book:republic SET written_at = "Athens";

SELECT 
	name,
	-- Isolate 'wrote' to use WHERE
	->(wrote WHERE written_at = "Athens")->book.* AS books_written_in_athens
FROM person;

SELECT 
	name, 
	-- Isolate 'book' to use WHERE
	->wrote->(book WHERE "Ring" IN name).* AS books_about_rings
FROM person;
```

```surql title="Output"
-------- Query --------

[
	{
		books_written_in_athens: [],
		name: 'J.R.R. Tolkien'
	},
	{
		books_written_in_athens: [
			{
				id: book:republic,
				name: 'The Republic',
				original_name: 'Πολιτεία'
			}
		],
		name: 'Plato'
	}
]

-------- Query --------

[
	{
		books_about_rings: [
			{
				id: book:fotr,
				name: 'The Fellowship of the Ring'
			}
		],
		name: 'J.R.R. Tolkien'
	},
	{
		books_about_rings: [],
		name: 'Plato'
	}
]
```

As of SurrealDB 2.0, [destructuring](/docs/surrealql/datamodel/idioms#destructuring) can also be used to pick and choose which fields to access inside a graph query. The following query will return the same output as above, except that `original_name: 'Πολιτεία'` will no longer show up.

```surql
SELECT 
	name, 
	->(wrote WHERE written_at = "Athens")->book.{ name, id } AS books_written_in_athens
FROM person;
```

### Bidirectional relation querying

All of the queries up to now have been clear about what sort of record is found at the `in` and `out` fields: `in` is the record that is doing something, while `out` is the record that has something done to it:

* A `person` who writes an `article`: the person **writes**, the article **is written**.
* A `person` who purchases a `product`: the person **purchases**, the product **is purchased**.

However, sometimes a relation is such that it is impossible to determine which record is located at the `in` part of a graph table, and which is located at the `out` part. This is the case when a relationship is truly bidirectional and equal, such as a friendship, marriage, or sister cities:

```surql
/**[test]

[[test.results]]
value = "[{ id: city:calgary }, { id: city:daejeon }]"

[[test.results]]
value = "[{ id: sister_of:crb0gb01iybgjhmed1ia, in: city:calgary, out: city:daejeon }]"
skip-record-id-key = true

*/

CREATE city:calgary, city:daejeon;
RELATE city:calgary->sister_of->city:daejeon;
```

This relation could just as well have been established with the statement `RELATE city:daejeon->sister_of->city:calgary`.

In such a case, a query on the relationship makes it appear as if one city has a twin city but the other does not.

```surql
SELECT id, ->sister_of->city AS sister_cities FROM city;
```

```surql title="Response"
[
	{
		id: city:calgary,
		sister_cities: [
			city:daejeon
		]
	},
	{
		id: city:daejeon,
		sister_cities: []
	}
]
```

To solve this, we can use the `<->` operator instead of `->`. Using `<->` will access both the `in` and `out` fields, instead of just one.

```surql
SELECT id, <->sister_of<->city AS sister_cities FROM city;
```

This brings up another issue in which a city now appears to be a sister city of itself.

```surql
[
	{
		id: city:calgary,
		sister_cities: [
			city:calgary,
			city:daejeon
		]
	},
	{
		id: city:daejeon,
		sister_cities: [
			city:calgary,
			city:daejeon
		]
	}
]
```

Here we can use the [`array::complement`](/docs/surrealql/functions/database/array#arraycomplement) function to return only items from one array that are not present in another array.

```surql
SELECT id, array::complement(<->sister_of<->city, [id]) AS sister_cities FROM city;
```

```surql title="Response"
[
	{
		id: city:calgary,
		sister_cities: [
			city:daejeon
		]
	},
	{
		id: city:daejeon,
		sister_cities: [
			city:calgary
		]
	}
]
```

Adding a unique key is a good practice for this sort of relation, as it will prevent it from being created twice. This can be done by [defining a field](/docs/surrealql/statements/define/field) as a unique key based on the ordered record IDs involved, followed by a [`DEFINE INDEX`](/docs/surrealql/statements/define/field) statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

DEFINE FIELD key ON TABLE sister_of VALUE <string>array::sort([in, out]);
DEFINE INDEX only_one_sister_city ON TABLE sister_of FIELDS key UNIQUE;
```

With the index in place, a relation set from one record to the other now cannot be created a second time.

```surql
RELATE city:calgary->sister_of->city:daejeon; -- OK
RELATE city:daejeon->sister_of->city:calgary;
-- "Database index `only_one_sister_city` already contains '[city:calgary, city:daejeon]', with record `sister_of:npab0uoxogmrvpwsvfoa`"
```

### Refining the `in` and `out` fields of a relation

As mentioned above, the `in` and `out` fields of a graph table are mandatory but can be modified to specify their record type or make assertions.

Thus, the following field declarations will work:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

DEFINE FIELD in ON TABLE wrote TYPE record<author>;
DEFINE FIELD out ON TABLE wrote TYPE record<book>;
```

But any attempt to outright redefine the `in` or `out` fields as a different type will be ignored.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

DEFINE FIELD in ON TABLE wrote TYPE string;
DEFINE FIELD out ON TABLE wrote TYPE int;
```

An example of an assertion on one of the fields of a record table for a library which is not yet ready to handle non-English books:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: book:demian, language: 'German', title: 'Demian. Die Geschichte von Emil Sinclairs Jugend' }]"

[[test.results]]
value = "[{ id: author:hesse, name: 'Hermann Hesse' }]"

[[test.results]]
error = ""Found book:demian for field `out`, with record `wrote:l4xjcgqkgm7vmqqt4iah`, but field must conform to: $value.language = 'English'""

*/

DEFINE FIELD out ON TABLE wrote TYPE record<book> ASSERT $value.language = "English";

CREATE book:demian SET title = "Demian. Die Geschichte von Emil Sinclairs Jugend", language = "German";
CREATE author:hesse SET name = "Hermann Hesse";

RELATE author:hesse->wrote->book:demian;
```

```surql title="Output"
"Found book:demian for field `out`, with record `wrote:l4xjcgqkgm7vmqqt4iah`, but field must conform to: $value.language = 'English'"
```

### Structure of queries on relations

Using an alias is a common practice in both regular and relation queries in SurrealDB to make output more readable and collapse nested structures. You can create an alias using the `AS` clause.

```surql
/**[test]

[[test.results]]
value = "[{ id: cat:one }, { id: cat:two }, { id: cat:three }]"

[[test.results]]
value = "[{ id: friends_with:8tuumzamsov3pro9tz3j, in: cat:one, out: cat:two }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: friends_with:ro94pfxfpff35x94kgmy, in: cat:two, out: cat:three }]"
skip-record-id-key = true

[[test.results]]
value = "[{ "->friends_with": { "->cat": { "->friends_with": { "->cat": [cat:three] } } } }]"

[[test.results]]
value = "[{ friends_of_friends: [cat:three] }]"

*/

CREATE cat:one, cat:two, cat:three;

RELATE cat:one->friends_with->cat:two;
RELATE cat:two->friends_with->cat:three;

SELECT ->friends_with->cat->friends_with->cat FROM cat:one;
-- create an alias for the result using the `AS` clause.
SELECT ->friends_with->cat->friends_with->cat AS friends_of_friends FROM cat:one;
```

```surql
// Output without alias
{
	"->friends_with": {
		"->cat": {
			"->friends_with": {
				"->cat": [
					cat:three
				]
			}
		}
	}
}

// Output with alias
{
	friends_of_friends: [
		cat:three
	]
}
```

However, an alias might not be preferred in a case where you have multiple graph queries that resolve to the fields of a large nested structure. Take the following data for example:

```surql
CREATE country:usa SET name = "USA";
CREATE state:pennsylvania SET population = 12970000;
CREATE state:michigan SET population = 10030000;
CREATE city:philadelphia, city:pittsburgh, city:detroit, city:grand_rapids;

RELATE country:usa->contains->[state:pennsylvania, state:michigan];
RELATE state:pennsylvania->contains->[city:philadelphia, city:pittsburgh];
RELATE state:michigan->contains->[city:detroit, city:grand_rapids];
```

A query on the states and cities of these records using aliases would return the data in a structure remade to fit the aliases declared in the query.

```surql
SELECT
    name,
    ->contains->state AS states,
    ->contains->state->contains->city AS cities
FROM country:usa;
```

```surql title="Output"
[
	{
		cities: [
			city:philadelphia,
			city:pittsburgh,
			city:grand_rapids,
			city:detroit
		],
		name: 'USA',
		states: [
			state:pennsylvania,
			state:michigan
		]
	}
]
```

However, opting to not use an alias will return the original graph structure which makes the levels of depth of the query clearer. In addition, the `population` field is clearly the population for the states.

```surql
SELECT
    id,
    ->contains->state.id,
    ->contains->state.population,
    ->contains->state->contains->city.id
FROM country:usa;
```

If using SurrealDB versions 2.0 and above, [destructuring syntax](/docs/surrealql/datamodel/idioms#destructuring) can be used to reduce some typing. Here is the same query as the last using destructuring syntax instead of one line for each field.

```surql
SELECT
    id,
	-- access id and population on a single line
    ->contains->state.{id, population},
    ->contains->state->contains->city.id
FROM country:usa;
```

```surql title="Output"
[
	{
		"->contains": {
			"->state": {
				"->contains": {
					"->city": {
						id: [
							city:philadelphia,
							city:pittsburgh,
							city:grand_rapids,
							city:detroit
						]
					}
				},
				id: [
					state:pennsylvania,
					state:michigan
				],
				population: [
					12970000,
					10030000
				]
			}
		},
		id: country:usa
	}
]
```

As the query that uses aliases does not maintain the original graph structure, adding `population` would require clever renaming such as `->contains->state.population AS state_populations` to make it clear that the numbers represent state and not city populations.

### Multiple graph tables vs. fields

Being able to set fields on graph tables opens up a large variety of custom query methods, one of which is explored here.

Imagine a database that holds detailed information on the relations between NPCs in a game that are made to be as realistic as possible. Two of the characters have a rocky past but finally end up married. During this period, we might have tracked their relationship by adding and removing graph edges between the two of them as they move from a stage of being friends, to dating, to hating each other, to finally ending up married.

```surql
CREATE person:one, person:two;
-- These three relations would end up deleted
RELATE person:one->friends_with->person:two;
RELATE person:one->dating->person:two;
RELATE person:one->hates->person:two;
-- Finally this would be the graph edge connecting the two
RELATE person:one->married->person:two;
```

This works well to track the current state of the relationship, but creating a more general table such as `knows` along with a number of fields can be a better method to track the changing relationship over time. The following shows the relationship between the two `person` records, along with a third record called `person:three` who went to the same school and once dated `person:one`.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:one }, { id: person:two }, { id: person:three }]"

[[test.results]]
value = "[{ has_been_friends: true, has_dated: true, has_hated: true, id: knows:i7yz3l6dcje9it8qbuwo, in: person:one, married_to: true, out: person:two }]"
skip-record-id-key = true

[[test.results]]
value = "[{ has_dated: true, id: knows:0xfnkabcg0um428rtj2o, in: person:one, out: person:three, same_high_school: true }]"
skip-record-id-key = true

*/

CREATE person:one, person:two, person:three;
RELATE person:one->knows->person:two SET
    has_been_friends = true,
    has_dated = true,
    has_hated = true,
    married_to = true;

RELATE person:one->knows->person:three SET
    same_high_school = true,
    has_dated = true;
```

With these fields in place, it is possible to use a `WHERE` clause to do refined searches on relationships of a certain type.

```surql
SELECT 
	->knows->person AS knows,
	->knows[WHERE has_dated]->person AS has_dated,
	->knows[WHERE same_high_school AND has_dated]->person AS dated_and_same_school
 FROM person:one;
```

```surql title="Response"
[
	{
		dated_and_same_school: [
			person:three
		],
		has_dated: [
			person:two,
			person:three
		],
		knows: [
			person:two,
			person:three
		]
	}
]
```

Because the `WHERE` clause simply checks for [truthiness](/docs/surrealql/datamodel/values#values-and-truthiness) (whether a value is present and not empty), these fields do not necessarily need to be booleans and can even be complex objects.

```surql
/**[test]

[[test.results]]
value = "[{ has_been_friends: true, has_dated: { from: d'2020-12-25T00:00:00Z', to: d'2023-12-25T00:00:00Z' }, has_hated: { from: d'2023-12-25T00:00:00Z', to: d'2024-03-01T00:00:00Z' }, id: knows:dzj9fmhh22kodz8h2nhl, in: person:one, married_to: { since: d'2024-03-01T00:00:00Z' }, out: person:two, same_high_school: false }]"
skip-record-id-key = true

[[test.results]]
value = "[{ has_dated: { from: d'2019-09-10T00:00:00Z', to: d'2020-12-31T00:00:00Z' }, id: knows:gc5993blynpzf5l52qs4, in: person:one, out: person:three, same_high_school: true }]"
skip-record-id-key = true

*/

RELATE person:one->knows->person:two SET
	same_high_school = false,
    has_been_friends = true,
    has_dated = {
		from: d'2020-12-25',
		to: d'2023-12-25'
	},
    has_hated = {
		from: d'2023-12-25',
		to: d'2024-03-01'
	},
    married_to = {
		since: d'2024-03-01'
	};

RELATE person:one->knows->person:three SET
    same_high_school = true,
    has_dated = {
		from: d'2019-09-10',
		to: d'2020-12-31'
	};
```

With these objects, a jealous `person:two` could do a check on `person:one` to see how many relationships with `has_dated` have an end time that overlaps with the `has_dated` period of `person:one` and `person:two`.

```surql
SELECT id, ->knows[WHERE same_high_school AND has_dated.to > d'2020-12-25']->person FROM person:one;
```

### Recursive graph queries

<Since v="v2.1.0" />

Graph edges can also be queried recursively. For a full explanation of this syntax, see the page on [recursive paths](/docs/surrealql/datamodel/idioms#recursive-paths).

Take the following example which creates five cities, each of which is connected to the next by some type of road of random length.

```surql
-- Note: 1..6 used to be inclusive until SurrealDB 3.0.0
-- Now creates 1 up to but not including 6
CREATE |city:1..=6| SET name = <string>id.id() + 'ville';
FOR $pair IN (<array>(1..=5)).windows(2) {
  	LET $city1 = type::record("city", $pair[0]);
    LET $city2 = type::record("city", $pair[1]);
    RELATE $city1->to->$city2 SET 
        type = rand::enum(["train", "road", "bike path"]),
        distance = <int>(rand::float() * 100).ceil()
};
```

While it is possible to manually move three levels down this road network, it involves a good deal of manual typing.

```surql
SELECT ->to->city->to->city->to->city AS fourth_city FROM city:1;
```

```surql title="Response"
[
	{
		fourth_city: [
			city:4
		]
	}
]
```

This can be replaced by a `@` to refer to the current record, followed by `.{3}` to represent three levels down the `to` graph edge. A level between 1 and 256 can be specified here.

```surql
SELECT @.{3}->to->city AS fourth_city FROM city:1;
```

A traditional query to show the final road info from `city:1` to the city three stops away would look like this.

```surql
SELECT ->to->city->to->city->to.* AS third_journey FROM city:1;
```

```surql title="Response"
[
	{
		fourth_city: [
			[
				{
					distance: 80,
					id: to:sw2pery99jomfhibzfrh,
					in: city:3,
					out: city:4,
					type: 'train'
				}
			]
		]
	}
]
```

To use the same query recursively, wrap the part that must be repeated (`->to->city`) inside parentheses. This will ensure that the `.{2}` part of the query only repeats `->to->city` twice, and not the final `->to.*` portion.

```surql
SELECT @.{2}(->to->city)->to.* AS third_journey FROM city:1;
```

A range can be added inside the `{}` braces. The following query that uses a range of 1 to 20 will follow the `->to->city` path up to 20 times, but will stop at the 5th and final depth because the next level returns an empty array.

```surql
city:1.{1..20}->to->city;
```

```surql title="Response"
[
	city:5
]
```

Ranges can be followed with the destructuring operator to collect fields on each depth, returning them in a single response. The following query goes five depths down the `to` graph table, returning each city and road along the way.

```surql
SELECT @.{1..5}.{ 
    id, 
    next_roads: ->to.*,
    next_cities: ->to->city
} FROM city;
```

```surql title="Response"
[
	{
		id: city:1,
		next_cities: [
			city:2
		],
		next_roads: [
			{
				distance: 33,
				id: to:bl6i9djau0pg24pqrwd9,
				in: city:1,
				out: city:2,
				type: 'road'
			}
		]
	},
	{
		id: city:2,
		next_cities: [
			city:3
		],
		next_roads: [
			{
				distance: 45,
				id: to:ybugfnlzv6kcrkaj49ig,
				in: city:2,
				out: city:3,
				type: 'road'
			}
		]
	},
	{
		id: city:3,
		next_cities: [
			city:4
		],
		next_roads: [
			{
				distance: 80,
				id: to:sw2pery99jomfhibzfrh,
				in: city:3,
				out: city:4,
				type: 'train'
			}
		]
	},
	{
		id: city:4,
		next_cities: [
			city:5
		],
		next_roads: [
			{
				distance: 29,
				id: to:42hlspf4z5lpqceyv68p,
				in: city:4,
				out: city:5,
				type: 'train'
			}
		]
	},
	{
		id: city:5,
		next_cities: [],
		next_roads: []
	}
]
```

As noted above, a `TIMEOUT` can be set for queries that may be computationally expensive. This is particularly useful when experimenting with recursive queries, which, if care is not taken, can run all the way to the maximum possible depth of 256.

Take the following example with two `person` records that like each other. Following the `likes` edge will run until the query recurses 256 times and gives up.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:one }, { id: person:two }]"

[[test.results]]
value = "[{ id: likes:0ng6fka1m8iwp7y5lgul, in: person:one, out: person:two }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: likes:50kdcb8awc7jwsxzr7ra, in: person:two, out: person:one }]"
skip-record-id-key = true

[[test.results]]
error = "'Exceeded the idiom recursion limit of 256.'"

*/

CREATE person:one, person:two;
RELATE person:one->likes->person:two;
RELATE person:two->likes->person:one;
-- Open-ended range
person:one.{..}->likes->person;
```

```surql title="Response"
'Exceeded the idiom recursion limit of 256.'
```

Take the following example in which three `person` records of created, each of which likes the other two `person` records. A query on the `->likes->person` path shows that the number of records doubles each time.

```surql
CREATE |person:1..4|;
FOR $person IN (SELECT * FROM person) {
  LET $others = (SELECT * FROM person WHERE id != $person.id);
    FOR $other IN $others {
        RELATE $person->likes->$other;
    }
};
RETURN [
	person:1.{2}->likes->person,
	person:1.{3}->likes->person,
	person:1.{4}->likes->person
];
```

```surql title="Response"
[
	[
		person:1,
		person:2,
		person:1,
		person:3
	],
	[
		person:3,
		person:2,
		person:1,
		person:3,
		person:3,
		person:2,
		person:1,
		person:2
	],
	[
		person:1,
		person:2,
		person:1,
		person:3,
		person:3,
		person:2,
		person:1,
		person:2,
		person:1,
		person:2,
		person:1,
		person:3,
		person:3,
		person:2,
		person:1,
		person:3
	]
]
```

Since an open-ended range can be specified in a recursive query, this would result in a full 256 attempts to recurse, multiplying the number of results by two each time for a total of 115792089237316195423570985008687907853269984665640564039457584007913129639936 records by the end.

When experimenting with recursive queries, especially open-ended ranges, it is thus recommended to use a timeout.

```surql
SELECT @.{..}.{ id, likes: ->likes->person.@ } FROM person TIMEOUT 1s;
```

### Graph clauses

<Since v="v2.2.0" />

The same clauses available to a `SELECT` statement can be used inside a graph query. Take the following relations for example:

```surql
CREATE person:one, person:two, person:three;
RELATE person:one->knows->person:two SET
	friends = true,
    dated = true,
    married_to = true;

RELATE person:one->knows->person:three SET
    dated = true;

RELATE person:two->knows->person:three SET
	friends = true;
```

At the `knows` path, parentheses can be used to insert clauses or an entirely new SELECT statement based on the records turned up at this point. In the following example, the `FROM knows` portion applies to all the records that a `person` knows, not the `knows` table as a whole.

```surql
SELECT 
	id, 
	->(SELECT out.id AS counterpart, !!dated AS dated FROM knows) AS acquaintances
FROM person;
```

```surql title="Output"
[
	{
		acquaintances: [
			{
				counterpart: person:three,
				dated: true
			},
			{
				counterpart: person:two,
				dated: true
			}
		],
		id: person:one
	},
	{
		acquaintances: [],
		id: person:three
	},
	{
		acquaintances: [
			{
				counterpart: person:three,
				dated: false
			}
		],
		id: person:two
	}
]
```

In some cases, the dot or destructuring operator can produce the same output. The following queries are equivalent.

```surql
SELECT ->(SELECT * FROM knows) FROM person:one;
SELECT ->knows.* FROM person:one;
```

```surql title="Output"
[
	{
		"->knows": [
			{
				dated: true,
				id: knows:2tsz3aomelegp060ii7d,
				in: person:one,
				out: person:three
			},
			{
				dated: true,
				friends: true,
				id: knows:g54z9zapdkssxb4p4pjc,
				in: person:one,
				married_to: true,
				out: person:two
			}
		]
	}
]
```

However, clauses available in [`SELECT` statements](/docs/surrealql/statements/select) such as `WHERE`, `LIMIT`, `GROUP BY`, aliases and so on can be used, making a graph clause a most flexible option.

```surql
SELECT ->(SELECT *, time::now() AS queried_at FROM knows LIMIT 1) FROM person:one;
```

```surql title="Output"
[
	{
		"->knows": [
			{
				dated: true,
				id: knows:2tsz3aomelegp060ii7d,
				in: person:one,
				out: person:three,
				queried_at: d'2025-01-24T02:16:31.811Z'
			}
		]
	}
]
```

Some other examples of possible graph clauses:

```surql
CREATE |person:1..4|;

RELATE person:1->likes->person:2 SET like_strength = 20, know_in_person = true;
RELATE person:1->likes->person:3 SET like_strength = 5,  know_in_person = false;
RELATE person:2->likes->person:1 SET like_strength = 10, know_in_person = true;
RELATE person:2->likes->person:3 SET like_strength = 12, know_in_person = false;
RELATE person:3->likes->person:1 SET like_strength = 2,  know_in_person = false;
RELATE person:3->likes->person:2 SET like_strength = 9,  know_in_person = false;

SELECT ->likes AS likes FROM person;
SELECT ->(SELECT like_strength FROM likes) AS likes FROM person;
SELECT ->(SELECT like_strength FROM likes WHERE like_strength > 10) AS likes FROM person;
SELECT ->(likes WHERE like_strength > 10) AS likes FROM person;
SELECT ->(SELECT like_strength, know_in_person FROM likes ORDER BY like_strength DESC) AS likes FROM person;
SELECT ->(SELECT count() as count, know_in_person FROM likes GROUP BY know_in_person) AS likes FROM person;
SELECT ->(likes LIMIT 1) AS likes FROM person;
SELECT ->(likes START 1) AS likes FROM person;
```

Multiple graph tables can be selected by separating each table with a comma, in the same way as in any other `SELECT` statement. In addition, all tables can be selected by using `?` as a wildcard operator.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:one, name: 'Þor' }]"

[[test.results]]
value = "[{ id: dog:one, name: 'Fenrir' }]"

[[test.results]]
value = "[{ id: cat:one, name: 'Jólakötturinn' }]"

[[test.results]]
value = "[{ at: d'2025-10-08T05:00:18.418734Z', id: feeds:150g6q4l8lzscu7j57sj, in: person:one, out: cat:one }]"
skip-datetime = true 
skip-record-id-key = true

[[test.results]]
value = "[{ at: d'2025-10-08T05:00:18.420350Z', id: plays_with:itzsltgkyboieenc7rmz, in: dog:one, out: cat:one }]"
skip-datetime = true 
skip-record-id-key = true

[[test.results]]
value = "[{ "<-(SELECT * FROM feeds, plays_with ORDER BY at
)": [{ at: d'2025-10-08T05:00:18.418734Z', id: feeds:150g6q4l8lzscu7j57sj, in: person:one, out: cat:one }, { at: d'2025-10-08T05:00:18.420350Z', id: plays_with:itzsltgkyboieenc7rmz, in: dog:one, out: cat:one }] }]"
skip-datetime = true 
skip-record-id-key = true

[[test.results]]
value = "[{ "<-(SELECT * FROM ? ORDER BY at
)": [{ at: d'2025-10-08T05:00:18.418734Z', id: feeds:150g6q4l8lzscu7j57sj, in: person:one, out: cat:one }, { at: d'2025-10-08T05:00:18.420350Z', id: plays_with:itzsltgkyboieenc7rmz, in: dog:one, out: cat:one }] }]"
skip-datetime = true 
skip-record-id-key = true

*/

CREATE person:one SET name = "Þor";
CREATE dog:one SET name = "Fenrir";
CREATE cat:one SET name = "Jólakötturinn";
RELATE person:one->feeds->cat:one SET at = time::now();
RELATE dog:one->plays_with->cat:one SET at = time::now();

-- Select from both 'feeds' and 'plays_with'
SELECT <-(SELECT * FROM feeds, plays_with ORDER BY at) FROM cat:one;
-- Or any graph table
SELECT <-(SELECT * FROM ? ORDER BY at) FROM cat:one;
```

### Ranges inside graph queries

<Since v="v2.3.0" />

Range syntax can also be used on the edges of a graph query.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:one }, { id: person:two }, { id: person:three }, { id: person:four }]"

[[test.results]]
value = "[{ id: likes:1, in: person:one, out: person:two }]"

[[test.results]]
value = "[{ id: likes:2, in: person:one, out: person:three }]"

[[test.results]]
value = "[{ id: likes:3, in: person:one, out: person:four }]"

[[test.results]]
value = "[person:three, person:four]"

*/

CREATE person:one, person:two, person:three, person:four;

RELATE person:one->likes:1->person:two;
RELATE person:one->likes:2->person:three;
RELATE person:one->likes:3->person:four;

person:one->likes:2..=4->person;
```

```surql title="Output"
[
	person:three,
	person:four
]
```

A common usage of range syntax on edges is when their ID has been defined as a ULID, making the `id` field random yet sortable and significant in terms of time.

```surql
RELATE character:one->speaks_to:ulid()->character:two SET content = "Greetings, adventurer!";
RELATE character:one->speaks_to:ulid()->character:two SET content = "Can you please help me? My sheep have run amok.";

SELECT
	// Grab the latter part of the record ID, turn it into a datetime
    time::from_ulid(id.id()) AS at,
    content
FROM
    // ULID from 2025-04-25, well before today's date
    character:one->speaks_to:01JSNG0KZSY3HJ5QSZ7JSMQMGR..;
```

```surql title="Output"
[
	{
		at: d'2025-04-25T03:37:53.246Z',
		content: 'Greetings, adventurer!'
	},
	{
		at: d'2025-04-25T03:37:53.248Z',
		content: 'Can you please help me? My sheep have run amok.'
	}
]
```

Array-based record IDs also work well inside range queries on edges.

```surql
CREATE planet:venus, telescope:one;

RELATE telescope:one->observed:[d'2025-04-24T02:02:18.204Z']->planet:venus CONTENT { 
      temperature_profile: {
        surface: 735.0,
        upper_atmosphere: 300.0
      },
      composition: {
        CO2: 96.5,
        N2: 3.5,
        SO2: 0.015
      },
};

RELATE telescope:one->observed:[d'2025-04-25T02:02:18.204Z']->planet:venus CONTENT {
      temperature_profile: {
        surface: 737.0,
        upper_atmosphere: 298.5
      },
      composition: {
        CO2: 96.6,
        N2: 3.4,
        SO2: 0.015
    }
};

SELECT id, (<-observed:[d'2025-04-24']..).{
    at: id[0], 
    surface: temperature_profile.surface,
    atmosphere: temperature_profile.upper_atmosphere
} AS observations FROM planet;
```

```surql title="Output"
[
	{
		id: planet:venus,
		observations: [
			{
				at: d'2025-04-24T02:02:18.204Z',
				atmosphere: 300,
				surface: 735
			},
			{
				at: d'2025-04-25T02:02:18.204Z',
				atmosphere: 298.5f,
				surface: 737
			}
		]
	}
]
```


================================================
FILE: src/content/doc-surrealql/statements/remove.mdx
================================================
---
sidebar_position: 18
sidebar_label: REMOVE
title: REMOVE statement | SurrealQL
description: The REMOVE statement is used to remove resources such as databases, tables, indexes, events and more.
---
import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `REMOVE` statement

The `REMOVE` statement is used to remove resources such as databases, tables, indexes, events and more.
Similar to an SQL DROP statement.

### Statement syntax

<Tabs syncKey="remove-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
REMOVE [
	NAMESPACE [ IF EXISTS ] @name
	| DATABASE [ IF EXISTS] @name
	| USER [ IF EXISTS ] @name ON [ ROOT | NAMESPACE | DATABASE ]
	| ACCESS [ IF EXISTS ] @name ON [ NAMESPACE | DATABASE ]
	| EVENT [ IF EXISTS ] @name ON [ TABLE ] @table
	| FIELD [ IF EXISTS ] @name ON [ TABLE ] @table
	| INDEX [ IF EXISTS ] @name ON [ TABLE ] @table
    | ANALYZER [ IF EXISTS ] @name
    | FUNCTION [ IF EXISTS ] fn::@name
    | PARAM [ IF EXISTS ] $@name
	| TABLE [ IF EXISTS ] @name
]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const removeAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "REMOVE" },
      { type: "Choice", index: 1, children: [
        { type: "Sequence", children: [ { type: "Terminal", text: "NAMESPACE" }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "EXISTS" } ] } }, { type: "NonTerminal", text: "@name" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "DATABASE" }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "EXISTS" } ] } }, { type: "NonTerminal", text: "@name" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "USER" }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "EXISTS" } ] } }, { type: "NonTerminal", text: "@name" }, { type: "Terminal", text: "ON" }, { type: "Choice", index: 1, children: [ { type: "Terminal", text: "ROOT" }, { type: "Terminal", text: "NAMESPACE" }, { type: "Terminal", text: "DATABASE" } ] } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "ACCESS" }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "EXISTS" } ] } }, { type: "NonTerminal", text: "@name" }, { type: "Terminal", text: "ON" }, { type: "Choice", index: 1, children: [ { type: "Terminal", text: "NAMESPACE" }, { type: "Terminal", text: "DATABASE" } ] } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "EVENT" }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "EXISTS" } ] } }, { type: "NonTerminal", text: "@name" }, { type: "Terminal", text: "ON" }, { type: "Optional", child: { type: "Terminal", text: "TABLE" } }, { type: "NonTerminal", text: "@table" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "FIELD" }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "EXISTS" } ] } }, { type: "NonTerminal", text: "@name" }, { type: "Terminal", text: "ON" }, { type: "Optional", child: { type: "Terminal", text: "TABLE" } }, { type: "NonTerminal", text: "@table" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "INDEX" }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "EXISTS" } ] } }, { type: "NonTerminal", text: "@name" }, { type: "Terminal", text: "ON" }, { type: "Optional", child: { type: "Terminal", text: "TABLE" } }, { type: "NonTerminal", text: "@table" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "ANALYZER" }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "EXISTS" } ] } }, { type: "NonTerminal", text: "@name" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "FUNCTION" }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "EXISTS" } ] } }, { type: "Terminal", text: "fn::" }, { type: "NonTerminal", text: "@name" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "PARAM" }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "EXISTS" } ] } }, { type: "Terminal", text: "$" }, { type: "NonTerminal", text: "@name" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "TABLE" }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "EXISTS" } ] } }, { type: "NonTerminal", text: "@name" } ] }
      ] }
    ]}
  ]
};

<RailroadDiagram ast={removeAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage
### Basic usage

The following queries show an example of how to remove resources.

```surql
REMOVE NAMESPACE surrealdb;

REMOVE DATABASE blog;

REMOVE USER writer ON NAMESPACE;

REMOVE USER writer ON DATABASE;

REMOVE ACCESS token ON NAMESPACE;

REMOVE ACCESS user ON DATABASE;

REMOVE EVENT new_post ON TABLE article;

-- Only works for Schemafull tables (i.e. tables with a schema)
REMOVE FIELD tags ON TABLE article;

REMOVE INDEX authors ON TABLE article;

REMOVE ANALYZER example_ascii;

REMOVE FUNCTION fn::update_author;

REMOVE PARAM $author;

REMOVE TABLE article;
```

### Using if exists clause

<Since v="v1.3.0" />

The following queries show an example of how to remove resources using the `IF EXISTS` clause, which will only remove the resource if it exists.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

REMOVE NAMESPACE IF EXISTS surrealdb;

REMOVE DATABASE IF EXISTS blog;

REMOVE USER IF EXISTS writer ON NAMESPACE;

REMOVE USER IF EXISTS writer ON DATABASE;

REMOVE ACCESS IF EXISTS token ON NAMESPACE;

REMOVE ACCESS IF EXISTS user ON DATABASE;

REMOVE EVENT IF EXISTS new_post ON TABLE article;

-- Only works for Schemaful tables (i.e. tables with a schema)
REMOVE FIELD IF EXISTS tags ON TABLE article;

REMOVE INDEX IF EXISTS authors ON TABLE article;

REMOVE ANALYZER IF EXISTS example_ascii;

REMOVE FUNCTION IF EXISTS fn::update_author;

REMOVE PARAM IF EXISTS $author;

REMOVE TABLE IF EXISTS article;
```



================================================
FILE: src/content/doc-surrealql/statements/return.mdx
================================================
---
sidebar_position: 19
sidebar_label: RETURN
title: RETURN statement | SurrealQL
description: The RETURN statement can be used to return an implicit value or the result of a query, and to set the return value for a transaction, block or function.
---

import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `RETURN` statement

The `RETURN` statement can be used to return an implicit value or the result of a query, and to set the return value for a transaction, block, or function.

### Statement syntax

<Tabs syncKey="return-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
RETURN @value
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const returnAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "RETURN" },
      { type: "NonTerminal", text: "@value" }
    ]}
  ]
};

<RailroadDiagram ast={returnAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage
### Basic usage

`RETURN` is always followed by a value. As every data type in SurrealDB is a type of [value](/docs/surrealql/datamodel/values), the `RETURN` statement can return anything from simple values to the result of queries.

```surql
/**[test]

[[test.results]]
value = "123"

[[test.results]]
value = "'I am a string!'"

[[test.results]]
value = "{ prop: 'value' }"

[[test.results]]
value = "[]"

[[test.results]]
value = "[person:mbn3r0epzxiz5hoqr2ls]"
skip-record-id-key = true

*/

-- Return a simple value
RETURN 123;
RETURN "I am a string!";
RETURN {
	prop: "value"
};

-- Return the result of a query
RETURN SELECT * FROM person;
RETURN (CREATE person).id;
```

Values on their own are treated as if they have an implicit `RETURN` in front. As such, the following queries return the same output as in the previous example.

```surql
/**[test]

[[test.results]]
value = "123"

[[test.results]]
value = "'I am a string!'"

[[test.results]]
value = "{ prop: 'value' }"

[[test.results]]
value = "[]"

[[test.results]]
value = "[person:mbn3r0epzxiz5hoqr2ls]"
skip-record-id-key = true

*/

123;
"I am a string!";
{
	prop: "value"
};
SELECT * FROM person;
(CREATE person).id;
```

## Transaction return value

`RETURN` statements can set the result of any transaction. This includes transactions, blocks and functions.

```surql title="Transaction return value"
/**[test]

[[test.results]]
value = "person:79e0p1et39n2dyongjzx"
skip-record-id-key = true

*/

BEGIN TRANSACTION;

-- We are executing quite a few queries here
LET $firstname = "John";
LET $lastname = "Doe";

LET $person = CREATE ONLY person CONTENT {
	firstname: $firstname,
	lastname: $lastname,
};

-- But because we end with a RETURN query, only the person's ID will be returned
-- The results of the other queries will be omitted.
RETURN $person.id;

-- One issue with this approach is that query errors are generic.
-- To get around that, use a block, which is executed as a transaction by itself.

COMMIT TRANSACTION;
```

## Return breaks execution

<Since v="v2.0.0" />
Unlike `RETURN` in SurrealDB `1.x`, `RETURN` now breaks execution of statements, functions and transactions.

```surql title="Function return value"
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[person:e71cnhnwdb6yuz8is8kq]"
skip-record-id-key = true

[[test.results]]
value = "[{ firstname: 'Thanos', id: person:e71cnhnwdb6yuz8is8kq, lastname: 'Johnson' }]"
skip-record-id-key = true

*/

DEFINE FUNCTION fn::person::create($firstname: string, $lastname: string) {
	LET $person = CREATE person CONTENT {
		firstname: $firstname,
		lastname: $lastname,
	};

	-- The RETURN statement will set the return value of the custom function, and further queries will not be executed.
	RETURN $person.id;

    -- This query will never be executed
    CREATE person SET firstname = "Stephen", lastname = "Strange";
};

fn::person::create("Thanos", "Johnson");
SELECT * FROM person;
```

```surql title="Functions"
DEFINE FUNCTION fn::round::up($num: number) {
    IF $num % 2 == 0 {
        RETURN $num; -- Breaks execution for the function
    };

    -- This is only executed if the RETURN inside the IF statement did not break execution
    RETURN $num + 1;
};
```

```surql title="Transactions"
BEGIN;
RETURN 1; -- Is executed
CREATE a; -- Is not executed
RETURN 2; -- Is not executed
COMMIT;
```

Lastly, if not executed inside a transaction or function, `RETURN` will break execution until the most top-level statement it is executed in. RETURN will **not** prevent top level statements from being executed, nor will it adjust their output.

```surql title="Statements"
LET $id = 123;
LET $id = {
    IF $id {
        RETURN type::record('table', $id);
    };

    RETURN table:rand();
};

-- This still executes. The `RETURN` statement only broke until the block in the variable assignment.
$id;
```



================================================
FILE: src/content/doc-surrealql/statements/select.mdx
================================================
---
sidebar_position: 20
sidebar_label: SELECT
title: SELECT statement | SurrealQL
description: The SELECT statement can be used for selecting and querying data in a database.
---

import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `SELECT` statement

The `SELECT` statement can be used for selecting and querying data in a database. Each SELECT statement supports selecting from multiple targets, which can include tables, records, edges, subqueries, parameters, arrays, objects, and other values.

In the [Learn more](#learn-more) section, you can find a video that explains how to use the `SELECT` statement to retrieve and query data from SurrealDB.

### Statement syntax

<Tabs syncKey="select-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
SELECT 
    VALUE @field | @fields [ AS @alias ] [ OMIT @fields ... ]
    FROM [ ONLY ] @targets
    [ WITH [ NOINDEX | INDEX @indexes ... ]]
    [ WHERE @conditions ]
    [ SPLIT [ ON ] @field, ... ]
    [ GROUP [ ALL | [ BY ] @field, ... ]]
    [ ORDER [ BY ] 
        @field [ COLLATE ] [ NUMERIC ] [ ASC | DESC ], ...
        | RAND() ]
    [ LIMIT [ BY ] @limit ]
    [ START [ AT ] @start 0 ]
    [ FETCH @fields ... ]
    [ TIMEOUT @duration ]
    [ TEMPFILES ]
    [ EXPLAIN [ FULL ]]
;
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const selectAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    {
      type: "Sequence",
      children: [
        { type: "Terminal", text: "SELECT" },
        {
          type: "Choice",
          index: 1,
          children: [
            { type: "Sequence", children: [ { type: "Terminal", text: "VALUE" }, { type: "NonTerminal", text: "@field" } ] },
            { type: "NonTerminal", text: "@fields" }
          ]
        },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "AS" }, { type: "NonTerminal", text: "@alias" } ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "OMIT" }, { type: "NonTerminal", text: "@fields ..." } ] } },
        { type: "Terminal", text: "FROM" },
        { type: "Optional", child: { type: "Terminal", text: "ONLY" } },
        { type: "NonTerminal", text: "@targets" },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "WITH" }, { type: "Choice", index: 1, children: [ { type: "Terminal", text: "NOINDEX" }, { type: "Sequence", children: [ { type: "Terminal", text: "INDEX" }, { type: "NonTerminal", text: "@indexes ..." } ] } ] } ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "WHERE" }, { type: "NonTerminal", text: "@conditions" } ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "SPLIT" }, { type: "Optional", child: { type: "Terminal", text: "ON" } }, { type: "NonTerminal", text: "@field, ..." } ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "GROUP" }, { type: "Choice", index: 1, children: [ { type: "Terminal", text: "ALL" }, { type: "Sequence", children: [ { type: "Optional", child: { type: "Terminal", text: "BY" } }, { type: "NonTerminal", text: "@field, ..." } ] } ] } ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "ORDER" }, { type: "Optional", child: { type: "Terminal", text: "BY" } }, { type: "Choice", index: 1, children: [ { type: "Sequence", children: [ { type: "NonTerminal", text: "@field" }, { type: "Optional", child: { type: "Terminal", text: "COLLATE" } }, { type: "Optional", child: { type: "Terminal", text: "NUMERIC" } }, { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "ASC" }, { type: "Terminal", text: "DESC" } ] } } ] }, { type: "Terminal", text: "RAND()" } ] } ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "LIMIT" }, { type: "Optional", child: { type: "Terminal", text: "BY" } }, { type: "NonTerminal", text: "@limit" } ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "START" }, { type: "Optional", child: { type: "Terminal", text: "AT" } }, { type: "NonTerminal", text: "@start" } ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "FETCH" }, { type: "NonTerminal", text: "@fields ..." } ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "TIMEOUT" }, { type: "NonTerminal", text: "@duration" } ] } },
        { type: "Optional", child: { type: "Terminal", text: "TEMPFILES" } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "EXPLAIN" }, { type: "Optional", child: { type: "Terminal", text: "FULL" } } ] } },
        { type: "Terminal", text: ";" },
      ]
    }
  ]
};

<RailroadDiagram ast={selectAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage
### Basic usage

By default, SurrealDB returns an array of JSON-like objects called records instead of a tabular structure of rows and columns.

```surql
/**[test]

[[test.results]]
value = "[{ address: '1 Bagshot Row', email: 'tobie@surrealdb.com', id: person:tobie, name: { first: 'Tobie' } }]"

[[test.results]]
value = "[{ address: '1 Bagshot Row', email: 'tobie@surrealdb.com', id: person:tobie, name: { first: 'Tobie' } }]"

[[test.results]]
value = "[{ address: '1 Bagshot Row', email: 'tobie@surrealdb.com', name: { first: 'Tobie' } }]"

[[test.results]]
value = "[{ address: '1 Bagshot Row', email: 'tobie@surrealdb.com', id: person:tobie, name: { first: 'Tobie' } }]"

[[test.results]]
value = "[{ address: '1 Bagshot Row', email: 'tobie@surrealdb.com', name: { first: 'Tobie' } }]"

[[test.results]]
value = "{ address: '1 Bagshot Row', email: 'tobie@surrealdb.com', id: person:tobie, name: { first: 'Tobie' } }"

*/

CREATE person:tobie SET
	name.first = "Tobie",
	address = "1 Bagshot Row",
	email = "tobie@surrealdb.com";

-- Select all fields from a table
SELECT * FROM person;

-- Select specific fields from a table
SELECT name, address, email FROM person;

-- Select all fields from a specific record
SELECT * FROM person:tobie;

-- Select specific fields from a specific record
SELECT name, address, email FROM person:tobie;

-- Select just a single record
-- Using the ONLY keyword, just an object
-- for the record in question will be returned.
-- This, instead of an array with a single object.
SELECT * FROM ONLY person:tobie;
```

An alias can be used to rename fields or change the structure of an object.

```surql
SELECT * FROM person;

-- Field `address` now shows up as "string::uppercase"
-- name.first structure now flattened into a simple field
SELECT
	name.first AS user_name,
	string::uppercase(address)
FROM person;

-- "Morgan Hitchcock" added to `name` field structure,
-- `angry_address` for field name instead of automatically
-- generated "string::uppercase(address) + '!!!'"
SELECT
	name.first,
	"Morgan Hitchcock" AS name.last,
	string::uppercase(address) + "!!!" AS angry_address
FROM person;
```

```surql title="Output"
-------- Query --------

[
	{
		address: '1 Bagshot Row',
		email: 'tobie@surrealdb.com',
		id: person:tobie,
		name: {
			first: 'Tobie'
		}
	}
]

-------- Query --------

[
	{
		"string::uppercase": '1 BAGSHOT ROW',
		user_name: 'Tobie'
	}
]

-------- Query --------

[
	{
		angry_address: '1 BAGSHOT ROW!!!',
		name: {
			first: 'Tobie',
			last: 'Morgan Hitchcock'
		}
	}
]
```

SurrealDB can also return specific fields as an array of values instead of the default array of objects. This only works if you select a single un-nested field from a table or a record.

```surql
-- Select the values of a single field from a table
SELECT VALUE name FROM person;

-- Select the values of a single field from a specific record
SELECT VALUE name FROM person:00e1nc508h9f7v63x72O;
```

### Advanced expressions

SELECT queries support advanced expression in the field projections.

```surql
-- Select nested objects/values
SELECT address.city FROM person;

-- Select all nested array values
-- note the .* syntax works to select everything from an array or object-like values
SELECT address.*.coordinates AS coordinates FROM person;
-- Equivalent to
SELECT address.coordinates AS coordinates FROM person;

-- Select one item from an array
SELECT address.coordinates[0] AS latitude FROM person;

-- Select unique values from an array
SELECT array::distinct(tags) FROM article;

-- Select unique values from a nested array across an entire table
SELECT array::group(tags) AS tags FROM article GROUP ALL;

-- Use mathematical calculations in a select expression
SELECT
	(( celsius * 1.8 ) + 32) AS fahrenheit
	FROM temperature;

-- Return boolean expressions with an alias
SELECT rating >= 4 as positive FROM review;

-- Select manually generated object structure
SELECT
	{ weekly: false, monthly: true } AS `marketing settings`
FROM user;

-- Select filtered nested array values
SELECT address[WHERE active = true] FROM person;

-- Select a person who has reacted to a post using a celebration
-- Path can be conceptualized as:
-- person->(reacted_to WHERE type='celebrate')->post
SELECT * FROM person WHERE ->(reacted_to WHERE type='celebrate')->post;

-- Select a remote field from connected out graph edges
SELECT ->likes->friend.name AS friends FROM person:tobie;

-- Use the result of a subquery as a returned field
SELECT *, (SELECT * FROM events WHERE type = 'activity' LIMIT 5) AS history FROM user;

-- Restructure objects in a select expression after `.` operator (since version 2.0.0)
SELECT address.{city, country} FROM person;
```

## Using parameters

Parameters can be used like variables to store a value which can then be used in a subsequent query.

More info on the `$parent` parameter in the second example can be seen on [the page for predefined variables](/docs/surrealql/parameters).

```surql
-- Store the subquery result in a variable and query that result.
LET $avg_price = (
	SELECT math::mean(price) AS avg_price FROM product GROUP ALL
).avg_price;

-- Find the name of the product where the price is higher than the avg price
SELECT name FROM product
WHERE [price] > $avg_price;

-- Use the parent instance's field in a subquery (predefined variable)
SELECT *, (SELECT * FROM events WHERE host == $parent.id) AS hosted_events FROM user;
```

## Numeric ranges in a `WHERE` clause

<Since v="v2.0.0" />

A numeric range inside a `WHERE` clause can improve performance if the range is able to replace multiple checks on a certain condition. The following code should show a modest but measurable improvement in performance between the first and second `SELECT` statement, as only one condition needs to be checked instead of two.

```surql
DELETE person;
CREATE |person:20000| SET age = (rand::float() * 120).round() RETURN NONE;

-- Assign output to a parameter so the SELECT output is not displayed
LET $_ = SELECT * FROM person WHERE age > 18 AND age < 65;
LET $_ = SELECT * FROM person WHERE age in 18..=65;
```

A numeric range inside a `WHERE` also tends to produce shorter code that is easier to read and maintain.

```surql
SELECT * FROM person WHERE age >= 18 AND age <= 65;
SELECT * FROM person WHERE age IN 18..=65;
```

## Record ranges

SurrealDB supports the ability to query a range of records, using the record ID. The record ID ranges, retrieve records using the natural sorting order of the record IDs. These range queries can be used to query a range of records in a timeseries context. You can see more here about [array-based Record IDs](/docs/surrealql/datamodel/ids#array-based-record-ids).

```surql
-- Select all person records with IDs between the given range
SELECT * FROM person:1..1000;
-- Select all records for a particular location, inclusive
SELECT * FROM temperature:['London', NONE]..=['London', time::now()];
-- Select all temperature records with IDs less than a maximum value
SELECT * FROM temperature:..['London', '2022-08-29T08:09:31'];
-- Select all temperature records with IDs greater than a minimum value
SELECT * FROM temperature:['London', '2022-08-29T08:03:39']..;
-- Select all temperature records with IDs between the specified range
SELECT * FROM temperature:['London', '2022-08-29T08:03:39']..['London', '2022-08-29T08:09:31'];
```

Using a record range is more performant than the `WHERE` clause, as it does not require a table scan.

```surql
-- Create 5000 `person` records
CREATE |person:1..5000| RETURN NONE;

-- Set the starting time
LET $now = time::now();
-- Put the output somewhere so it won't clutter the screen
LET $_ = SELECT * FROM person:1..5000;
-- Get the elapsed time
LET $time1 = time::now() - $now;

LET $now = time::now();
LET $_ = SELECT * FROM person WHERE id >= 1 and id <= 5000;
LET $time2 = time::now() - $now;
RETURN [$time1, $time2];
```



## Skip certain fields using the `OMIT` clause

Sometimes, especially with tables containing numerous columns, it is desirable to select all columns except a few specific ones. The `OMIT` clause can be used in this case.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:tobie, name: 'Tobie', opts: { enabled: true, security: 'secure' }, password: '123456' }]"

[[test.results]]
value = "[{ id: person:jaime, name: 'Jaime', opts: { enabled: false, security: 'secure' }, password: 'asdfgh' }]"

[[test.results]]
value = "[{ id: person:jaime, name: 'Jaime', opts: { enabled: false, security: 'secure' }, password: 'asdfgh' }, { id: person:tobie, name: 'Tobie', opts: { enabled: true, security: 'secure' }, password: '123456' }]"

[[test.results]]
value = "[{ id: person:jaime, name: 'Jaime', opts: { enabled: false } }, { id: person:tobie, name: 'Tobie', opts: { enabled: true } }]"

[[test.results]]
value = "[{ id: person:jaime, name: 'Jaime', opts: {  } }, { id: person:tobie, name: 'Tobie', opts: {  } }]"

*/

CREATE person:tobie SET
	name = 'Tobie',
	password = '123456',
	opts.security = 'secure',
	opts.enabled = true;
CREATE person:jaime SET
	name = 'Jaime',
	password = 'asdfgh',
	opts.security = 'secure',
	opts.enabled = false;

SELECT * FROM person;
-- Omit the password field and security field in the options object
SELECT * OMIT password, opts.security FROM person;

-- Using destructuring syntax (since 2.0.0)
SELECT * OMIT password, opts.{ security, enabled } FROM person;
```

## More on using the `FROM` clause

The `FROM` clause can be used on targets beyond just a single table or record name.

```surql
-- Selects all records from both 'user' and 'admin' tables.
SELECT * FROM user, admin;

-- Selects all records from the table named in the variable '$table',
-- but only if the 'admin' field of those records is true.
-- Equivalent to 'SELECT * FROM user WHERE admin = true'.
LET $table = "user";
SELECT * FROM type::table($table) WHERE admin = true;

-- Selects a single record from:
-- * the table named in the variable '$table',
-- * and the identifier named in the variable '$id'.
-- This query is equivalent to 'SELECT * FROM user:admin'.
LET $table = "user";
LET $id = "admin";
SELECT * FROM type::record($table, $id);

-- Selects all records for specific users 'tobie' and 'jaime',
-- as well as all records for the company 'surrealdb'.
SELECT * FROM user:tobie, user:jaime, company:surrealdb;

-- Selects records from a list of identifiers. The identifiers can be numerical,
-- string, or specific records such as 'person:lrym5gur8hzws72ux5fa'.
SELECT * FROM [3648937, "test", person:lrym5gur8hzws72ux5fa, person:4luro9170uwcv1xrfvby];

-- Selects data from an object that includes a 'person' key,
-- which is associated with a specific person record, and an 'embedded' key set to true.
SELECT * FROM { person: person:lrym5gur8hzws72ux5fa, embedded: true };

-- This command first performs a subquery, which selects all 'user' records and adds a
-- computed 'adult' field that is true if the user's 'age' is 18 or older.
-- The main query then selects all records from this subquery where 'adult' is true.
SELECT * FROM (SELECT age >= 18 AS adult FROM user) WHERE adult = true;
```

## Filter queries using the `WHERE` clause

As with traditional SQL queries, a SurrealDB SELECT query supports conditional filtering using a `WHERE` clause. If the expression in the `WHERE` clause [is truthy](/docs/surrealql/datamodel/values#values-and-truthiness) (is present and not an empty value), then the respective record will be returned.

```surql
-- Simple conditional filtering
SELECT * FROM article WHERE published = true;

-- Conditional filtering based on graph edges
SELECT * FROM profile WHERE count(->experience->organisation) > 3;

-- Conditional filtering based on graph edge properties
SELECT * FROM person WHERE ->(reaction WHERE type='celebrate')->post;

-- Conditional filtering with boolean logic
SELECT * FROM user WHERE (admin AND active) OR owner = true;

-- Select filtered nested array values
SELECT address[WHERE active = true] FROM person;

-- Select names for 'person' records as long as 'name' is present
-- and not an empty string ""
SELECT name FROM person WHERE name;
```

## The `SPLIT` clause

As SurrealDB supports arrays and nested fields within arrays, it is possible to use the [`SPLIT`](/docs/surrealql/clauses/split) clause to split the result on a specific field name, returning each value in an array as a separate value, along with the record content itself. This is useful in data analysis contexts.

```surql
/**[test]

[[test.results]]
value = "[{ emails: ['me@me.com', 'longer_email@other_service.com'], id: user:czs7vds6shgb6m2hbwgj, name: 'Name' }]"

[[test.results]]
value = "[{ emails: 'me@me.com', id: user:czs7vds6shgb6m2hbwgj, name: 'Name' }, { emails: 'longer_email@other_service.com', id: user:czs7vds6shgb6m2hbwgj, name: 'Name' }]"

*/

CREATE user SET
    name = "Name",
    emails = ["me@me.com", "longer_email@other_service.com"];

-- Split the results by each value in an array
SELECT * FROM user SPLIT emails;
```

```surql title="Output"
[
	{
		emails: 'me@me.com',
		id: user:tr5sxe8iygdco05faoh0,
		name: 'Name'
	},
	{
		emails: 'longer_email@other_service.com',
		id: user:tr5sxe8iygdco05faoh0,
		name: 'Name'
	}
]
```

Other examples using the `SPLIT` clause:

```surql
-- Split the results by each value in a nested array
SELECT * FROM country SPLIT locations.cities;

-- Filter the result of a subquery
SELECT * FROM (SELECT * FROM person SPLIT loggedin) WHERE loggedin > '2023-05-01';
```

## The `GROUP BY` and `GROUP ALL` clause

SurrealDB supports data aggregation and grouping, with support for multiple fields, nested fields, and aggregate functions. In SurrealDB, every field which appears in the field projections of the select statement (and which is not an aggregate function), must also be present in the [`GROUP BY`](/docs/surrealql/clauses/group-by) clause.

```surql
-- Group records by a single field
SELECT country FROM user GROUP BY country;

-- Group results by a nested field
SELECT settings.published FROM article GROUP BY settings.published;

-- Group results by multiple fields
SELECT gender, country, city FROM person GROUP BY gender, country, city;

-- Use an aggregate function to select unique values from a nested array across an entire table
SELECT array::group(tags) AS tags FROM article GROUP ALL;
```

A longer example of grouping using aggregate functions:

```surql
/**[test]

[[test.results]]
value = "[{ age: 20, country: 'Japan', gender: 'M', id: person:btiyllegvd4qiy1vspj8 }, { age: 25, country: 'Japan', gender: 'M', id: person:mf73xwobyhqyxc4suxdl }, { age: 23, country: 'US', gender: 'F', id: person:45u27tit21osibawb3zm }, { age: 30, country: 'US', gender: 'F', id: person:t950ztxmelm5nlqzuplz }, { age: 25, country: 'Korea', gender: 'F', id: person:t8toz5e3muclr3hxe74z }, { age: 45, country: 'UK', gender: 'F', id: person:s6mme1k3txzppbg5zx92 }]"
skip-record-id-key = true

[[test.results]]
value = "[{ average_age: 25, country: 'Korea', gender: 'F', total: 1 }, { average_age: 45, country: 'UK', gender: 'F', total: 1 }, { average_age: 26.5f, country: 'US', gender: 'F', total: 2 }, { average_age: 22.5f, country: 'Japan', gender: 'M', total: 2 }]"

[[test.results]]
value = "[{ number_of_records: 6 }]"

*/

INSERT INTO person [
    { gender: "M", age: 20, country: "Japan" },
    { gender: "M", age: 25, country: "Japan" },
    { gender: "F", age: 23, country: "US" },
    { gender: "F", age: 30, country: "US" },
    { gender: "F", age: 25, country: "Korea" },
    { gender: "F", age: 45, country: "UK" },
];

SELECT
	count() AS total,
	math::mean(age) AS average_age,
	gender,
	country
FROM person
GROUP BY gender, country;

-- Get the total number of records in a table
SELECT count() AS number_of_records FROM person GROUP ALL;
```

```surql title="Output"
-------- Query --------

[
	{
		average_age: 25,
		country: 'Korea',
		gender: 'F',
		total: 1
	},
	{
		average_age: 45,
		country: 'UK',
		gender: 'F',
		total: 1
	},
	{
		average_age: 26,
		country: 'US',
		gender: 'F',
		total: 2
	},
	{
		average_age: 22,
		country: 'Japan',
		gender: 'M',
		total: 2
	}
]

-------- Query --------

[
	{
		number_of_records: 6
	}
]
```

### Using a `COUNT` index to speed up `count()` in `GROUP ALL` queries

<Since v="v3.0.0-alpha.10" />

To speed up the `count()` function along with `GROUP ALL` to get the total number of records in a table, a `COUNT` index can be used. This keeps track of the total number of records as a single value as opposed to a dynamic iteration of the table to get the full count every time a query is run.

```surql
DEFINE INDEX person_count ON person COUNT;
SELECT count() AS number_of_records FROM person GROUP ALL;
```

### `math::stddev()` and `math::variance()` in table views

<Since v="v3.0.0-alpha.11" />

The `math::stddev()` and `math::variance()` functions can also be used in table views.

```surql
DEFINE TABLE person SCHEMALESS;
DEFINE TABLE person_stats AS
	SELECT
		count(),
		age,
		math::stddev(score) AS score_stddev,
		math::variance(score) AS score_variance
	FROM person
	GROUP BY age;

INSERT INTO person [
    { id: person:alice,          age: 25, score: 80 },
    { id: person:alices_rival,   age: 25, score: 88 },
    { id: person:bob,            age: 24, score: 90 },
    { id: person:bobs_rival,     age: 24, score: 99 },
    { id: person:charlie,        age: 23, score: 70 },
    { id: person:charlies_rival, age: 23, score: 77 }
];

SELECT * FROM person_stats WHERE age >= 24;
```

Output:

```surql
[
	{
		age: 24,
		count: 2,
		id: person_stats:[
			24
		],
		score_stddev: 6.363961030678927719607599259dec,
		score_variance: 40.50dec
	},
	{
		age: 25,
		count: 2,
		id: person_stats:[
			25
		],
		score_stddev: 5.656854249492380195206754897dec,
		score_variance: 32dec
	}
]
```

## Sort records using the `ORDER BY` clause

To sort records, SurrealDB allows ordering on multiple fields and nested fields. Use the `ORDER BY` clause to specify a comma-separated list of field names that should be used to order the resulting records. The `ASC` and `DESC` keywords can be used to specify whether results should be sorted in an ascending or descending manner. The `COLLATE` keyword can be used to use Unicode collation when ordering text in string values, ensuring that different cases, and different languages are sorted in a consistent manner. Finally, the `NUMERIC` can be used to correctly sort text which contains numeric values.

```surql
-- Order records randomly
SELECT * FROM user ORDER BY rand();

-- Order records descending by a single field
SELECT * FROM song ORDER BY rating DESC;

-- Order records by multiple fields independently
SELECT * FROM song ORDER BY artist ASC, rating DESC;

-- Order text fields with Unicode collation
SELECT * FROM article ORDER BY title COLLATE ASC;

-- Order text fields with which include numeric values
SELECT * FROM article ORDER BY title NUMERIC ASC;
```

## The `LIMIT` clause

To limit the number of records returned, use the `LIMIT` clause.

```surql
-- Select only the top 50 records from the person table
SELECT * FROM person LIMIT 50;
```

When using the `LIMIT` clause, it is possible to paginate results by using the `START` clause to start from a specific record from the result set. It is important to note that the `START` count starts from 0.

```surql
-- Start at record 50 and select the following 50 records
SELECT * FROM user LIMIT 50 START 50;
```

The `LIMIT` clause followed by 1 is often used along with the `ONLY` clause to satisfy the requirement that only up to a single record can be returned.

```surql
-- Record IDs are unique so guaranteed to be no more than 1
SELECT * FROM ONLY person:jamie;

-- Error because no guarantee that this will return a single record
SELECT * FROM ONLY person WHERE name = "Jaime";

-- Add `LIMIT 1` to ensure that only up to one record will be returned
SELECT * FROM ONLY person WHERE name = "Jaime" LIMIT 1;
```

```surql
/**[test]

[[test.results]]
value = "[5, 6, 7, 8, 9]"

*/

-- Select the first 5 records from the array
SELECT * FROM [1,2,3,4,5,6,7,8,9,10] LIMIT 5 START 4; 
```

```surql title="Result"
[
	5,
	6,
	7,
	8,
	9
]
```

## Connect targets using the FETCH clause

Two of the most powerful features in SurrealDB are [record links](/docs/surrealql/datamodel/records) and [graph connections](/docs/surrealql/statements/relate).

Instead of pulling data from multiple tables and merging that data together, SurrealDB allows you to traverse related records efficiently without needing to use JOINs.

To fetch and replace records with the remote record data, use the [`FETCH`](/docs/surrealql/clauses/fetch) clause to specify the fields and nested fields which should be fetched in-place, and returned in the final statement response output.

```surql
-- Select all the review information
-- and the artist's email from the artist table
SELECT *, artist.email FROM review FETCH artist;

-- Select all the article information
-- only if the author's age (from the author table) is under 30.
SELECT * FROM article WHERE author.age < 30 FETCH author;
```

## The `TIMEOUT` clause

When processing a large result set with many interconnected records, it is possible to use the `TIMEOUT` keyword to specify a timeout duration for the statement. If the statement continues beyond this duration, then the transaction will fail, and the statement will return an error.

```surql
-- Cancel this conditional filtering based on graph edge properties
-- if it's not finished within 5 seconds
SELECT * FROM person WHERE ->knows->person->(knows WHERE influencer = true) TIMEOUT 5s;
```

## The `TEMPFILES` clause

<Since v="v2.0.0" />

When processing a large result set with many records, it is possible to use the `TEMPFILES` clause to specify that the statement should be processed in temporary files rather than memory.

This significantly reduces memory usage in exchange for slower performance.

```surql
-- Select every person and order them by name using temporary files rather than memory.
SELECT * FROM person ORDER BY name TEMPFILES;
```

This requires the temporary directory to be set in the server configuration or when using the [`surreal start`](/docs/surrealdb/cli/start) command.

## The `EXPLAIN` clause

When `EXPLAIN` is used, the `SELECT` statement returns an explanation, essentially revealing the execution plan to provide transparency and understanding of the query performance. `EXPLAIN` can be followed by `FULL` to see the number of executed rows.

Here is the result when the field 'email' is not indexed. We can see that the execution plan will iterate over the whole table.

```surql
/**[test]

[[test.results]]
value = "[{ address: '1 Bagshot Row', email: 'tobie@surrealdb.com', id: person:tobie, name: 'Tobie' }]"

[[test.results]]
value = "[{ detail: { direction: 'forward', table: 'person' }, operation: 'Iterate Table' }, { detail: { type: 'Memory' }, operation: 'Collector' }]"

[[test.results]]
value = "[{ detail: { direction: 'forward', table: 'person' }, operation: 'Iterate Table' }, { detail: { type: 'Memory' }, operation: 'Collector' }, { detail: { type: 'KeysAndValues' }, operation: 'RecordStrategy' }, { detail: { count: 1 }, operation: 'Fetch' }]"

*/

CREATE person:tobie SET
	name = "Tobie",
	address = "1 Bagshot Row",
	email = "tobie@surrealdb.com";

SELECT * FROM person WHERE email='tobie@surrealdb.com' EXPLAIN;
SELECT * FROM person WHERE email='tobie@surrealdb.com' EXPLAIN FULL;
```

```surql title="Output"
-------- Query --------

[
	{
		detail: {
			table: 'person'
		},
		operation: 'Iterate Table'
	},
	{
		detail: {
			type: 'Memory'
		},
		operation: 'Collector'
	}
]

-------- Query --------

[
	{
		detail: {
			table: 'person'
		},
		operation: 'Iterate Table'
	},
	{
		detail: {
			type: 'Memory'
		},
		operation: 'Collector'
	},
	{
		detail: {
			count: 1
		},
		operation: 'Fetch'
	}
]
```

Here is the result when the 'email' field is indexed. We can see that the execution plan will proceed by utilizing the index.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ address: '1 Bagshot Row', email: 'tobie@surrealdb.com', id: person:tobie, name: 'Tobie' }]"

[[test.results]]
value = "[{ detail: { plan: { index: 'fast_email', operator: '=', value: 'tobie@surrealdb.com' }, table: 'person' }, operation: 'Iterate Index' }, { detail: { type: 'Memory' }, operation: 'Collector' }]"

[[test.results]]
value = "[{ detail: { plan: { index: 'fast_email', operator: '=', value: 'tobie@surrealdb.com' }, table: 'person' }, operation: 'Iterate Index' }, { detail: { type: 'Memory' }, operation: 'Collector' }, { detail: { type: 'KeysAndValues' }, operation: 'RecordStrategy' }, { detail: { count: 1 }, operation: 'Fetch' }]"

*/

DEFINE INDEX fast_email ON TABLE person FIELDS email;

CREATE person:tobie SET
	name = "Tobie",
	address = "1 Bagshot Row",
	email = "tobie@surrealdb.com";

SELECT * FROM person WHERE email='tobie@surrealdb.com' EXPLAIN;
SELECT * FROM person WHERE email='tobie@surrealdb.com' EXPLAIN FULL;
```

```surql title="Output"
-------- Query --------

[
	{
		detail: {
			plan: {
				index: 'fast_email',
				operator: '=',
				value: 'tobie@surrealdb.com'
			},
			table: 'person'
		},
		operation: 'Iterate Index'
	},
	{
		detail: {
			type: 'Memory'
		},
		operation: 'Collector'
	}
]

-------- Query --------

[
	{
		detail: {
			plan: {
				index: 'fast_email',
				operator: '=',
				value: 'tobie@surrealdb.com'
			},
			table: 'person'
		},
		operation: 'Iterate Index'
	},
	{
		detail: {
			type: 'Memory'
		},
		operation: 'Collector'
	},
	{
		detail: {
			count: 1
		},
		operation: 'Fetch'
	}
]
```

## The `WITH` clause

The query planner can replace the standard table iterator with one or several index iterators based on the structure and requirements of the query. However, there may be situations where manual control over these potential optimizations is desired or required.

For instance, the cardinality of an index can be high, potentially even equal to the number of records in the table. The sum of the records iterated by several indexes may end up being larger than the number of records obtained by iterating over the table. In such cases, if there are different index possibilities, the most probable optimal choice would be to use the index known with the lowest cardinality.

- `WITH INDEX @indexes ...` restricts the query planner to using only the specified index(es)
- `WITH NOINDEX` forces the query planner to use the table iterator.

```surql
-- forces the query planner to use the specified index(es):
SELECT * FROM person
WITH INDEX ft_email
WHERE
	email = 'tobie@surrealdb.com' AND
	company = 'SurrealDB';

-- forces the usage of the table iterator
SELECT name FROM person WITH NOINDEX WHERE job = 'engineer' AND gender = 'm';
```

## The `ONLY` clause

If you are selecting just one single resource, it's possible to use the `ONLY` clause to filter that result from an array.

```surql
SELECT * FROM ONLY person:john;
```

If you are selecting from a resource where it is possible that multiple resources are returned, it is required to `LIMIT` the result to just one.
This is needed, because the query would otherwise not be deterministic.

```surql
-- Fails
SELECT * FROM ONLY table_name;
-- Succeeds
SELECT * FROM ONLY table_name LIMIT 1;
```

## The `VERSION` clause

<Since v="v2.0.0" />

When you are starting a new database with [SurrealKV as the storage engine](/docs/surrealkv) with versioning enabled, you can specify a version for each record. This is useful for time-travel queries. You can query a specific version of a record by using the `VERSION` clause. The `VERSION` clause is always followed by a [datetime](/docs/surrealql/datamodel/datetimes) and when the specified timestamp does not exist, an empty array is returned.


> [!NOTE]
> The `VERSION` clause is currently in alpha and is subject to change. We do not recommend this for production.

```surql
-- Create a new record
CREATE user:john SET name = 'John' VERSION d'2024-08-19T08:00:00Z';
[[{ id: user:john, name: 'John' }]]

-- Select the record as it is now
SELECT * FROM user:john;
[[{ id: user:john, name: 'John' }]]

-- Select the record as it was at a specific point in time
SELECT * FROM user:john VERSION d'2024-08-19T08:00:00Z';
[[{ id: user:john, name: 'John' }]]

-- Select the record as it was at a specific point in time that doesn't exist
SELECT * FROM user:john VERSION d'2024-08-19T07:00:00Z';
[[]]

-- Update the record to the user john
update user:john Set hight ="55"
[[{ hight: '55', id: user:john, name: 'John' }]]

-- Confirm that the record is updated
SELECT * FROM user:john;
[[{ hight: '55', id: user:john, name: 'John' }]]

-- Select the record for the timestamp before the update
SELECT * FROM user:john VERSION d'2024-08-19T08:00:00Z';
[[{ id: user:john, name: 'John' }]]
```

<Since v="v2.1.0" />

The `VERSION` clause can also take a dynamic value or parameter that resolves to a datetime.

```surql
SELECT * FROM user VERSION time::now();

LET $now = time::now();
SELECT * FROM user VERSION $now;

DEFINE FUNCTION fn::yesterday() { time::now() - 1d };
SELECT * FROM user VERSION fn::yesterday();
```

## Selecting inside graph queries

<Since v="v2.2.0" />

A `SELECT` statement and/or its clauses can be used inside graph queries as well at the graph edge portion of the query.

```surql
-- Note: 1..4 used to be inclusive until SurrealDB 3.0.0
-- Now creates 1 up to but not including 4
CREATE |person:1..4|;

RELATE person:1->likes->person:2 SET like_strength = 20, know_in_person = true;
RELATE person:1->likes->person:3 SET like_strength = 5,  know_in_person = false;
RELATE person:2->likes->person:1 SET like_strength = 10, know_in_person = true;
RELATE person:2->likes->person:3 SET like_strength = 12, know_in_person = false;
RELATE person:3->likes->person:1 SET like_strength = 2,  know_in_person = false;
RELATE person:3->likes->person:2 SET like_strength = 9,  know_in_person = false;

SELECT ->likes AS likes FROM person;
SELECT ->(SELECT like_strength FROM likes) AS likes FROM person;
SELECT ->(SELECT like_strength FROM likes WHERE like_strength > 10) AS likes FROM person;
SELECT ->(likes WHERE like_strength > 10) AS likes FROM person;
SELECT ->(SELECT like_strength, know_in_person FROM likes ORDER BY like_strength DESC) AS likes FROM person;
SELECT ->(SELECT count() as count, know_in_person FROM likes GROUP BY know_in_person) AS likes FROM person;
SELECT ->(likes LIMIT 1) AS likes FROM person;
SELECT ->(likes START 1) AS likes FROM person;
```

For more examples, see the [graph clauses](/docs/surrealql/statements/relate#graph-clauses) section of the page on the `RELATE` statement.

## Learn more

To learn more about using the `SELECT` statement to retrieve data from SurrealDB, check out this explainer video:


<iframe width="100%" src="https://www.youtube.com/embed/TyX45cyZ-W0?si=S9M59afDEiqxeC5d" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" 
style={{aspectRatio: 1.7, paddingTop: '20px'}} allowfullscreen></iframe>




================================================
FILE: src/content/doc-surrealql/statements/show.mdx
================================================
---
sidebar_position: 21
sidebar_label: SHOW
title: SHOW statement | SurrealQL
description: The SHOW statement can be used to replay changes made to a table.
---

# `SHOW` statement

The `SHOW` statement can be used to replay changes made to a table.

import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

## Requirements
- You must first [`DEFINE`](/docs/surrealql/statements/define/table#example-usage) a [Change Feed](/features/change-data-capture).

### Statement syntax

<Tabs syncKey="show-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
SHOW CHANGES FOR TABLE @tablename
	SINCE @timestamp | @versionstamp
	[ LIMIT @number ]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const showAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "SHOW" },
      { type: "Terminal", text: "CHANGES" },
      { type: "Terminal", text: "FOR" },
      { type: "Terminal", text: "TABLE" },
      { type: "NonTerminal", text: "@tablename" },
      { type: "Terminal", text: "SINCE" },
      { type: "Choice", index: 1, children: [ { type: "NonTerminal", text: "@timestamp" }, { type: "NonTerminal", text: "@versionstamp" } ] },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "LIMIT" }, { type: "NonTerminal", text: "@number" } ] } }
    ]}
  ]
};

<RailroadDiagram ast={showAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

### Basic usage

The following expression shows usage of the SHOW statement.

```surql
-- Define the change feed and its duration
DEFINE TABLE reading CHANGEFEED 3d;

-- Create some records in the reading table
CREATE reading SET story = "Once upon a time";
CREATE reading SET story = "there was a database";

-- Replay changes to the reading table since a date
SHOW CHANGES FOR TABLE reading SINCE d"2023-09-07T01:23:52Z" LIMIT 10;
-- Replay changes to the reading table since a versionstamp
SHOW CHANGES FOR TABLE reading SINCE 1 LIMIT 10;
```

Assuming the datetime above matches with the one when the changefeed was established, the response for both queries will be as follows.

```surql title="Response"
[
	{
		changes: [
			{
				define_table: {
					name: 'reading'
				}
			}
		],
		versionstamp: 65536
	},
	{
		changes: [
			{
				update: {
					id: reading:bavjgpnhkgvudfg4mg16,
					story: 'Once upon a time'
				}
			}
		],
		versionstamp: 131072
	},
	{
		changes: [
			{
				update: {
					id: reading:liq4e7hzjaw7bp5t4pn1,
					story: 'there was a database'
				}
			}
		],
		versionstamp: 196608
	}
]
```

Note the following when working with the versionstamps of a changefeed:

* Changefeeds defined on tables are implemented via a single `CHANGEFEED` on the database level. As such, `SHOW CHANGES FOR TABLE sometable` will only show versionstamps in sequential order if `sometable` is the database's only table.
* The `versionstamp` output above is due to an extra two bytes needed for more detailed ordering needed in the FoundationDB distributed [SurrealDB backend](/docs/surrealdb/introduction/architecture). To turn these versionstamps into a normal sequence of numbers, a right shift of sixteen bits (`>> 16`) can be used.
* A `SINCE <number` greater than the current sequential number will return an empty array.
* `SINCE <time>` needs to be a datetime after which the `CHANGEFEED` was defined.

Versionstamps carry the following two guarantees:

* Versionstamps monotonically increase.
* Versionstamp format is universal across various backends.



================================================
FILE: src/content/doc-surrealql/statements/sleep.mdx
================================================
---
sidebar_position: 22
sidebar_label: SLEEP
title: SLEEP statement | SurrealQL
description: The SLEEP statement is used to introduce a delay or pause in the execution of a query or a batch of queries for a specific amount of time.
---

# `SLEEP` statement

The `SLEEP` statement is used to introduce a delay or pause in the execution of a query or a batch of queries for a specific amount of time.

### Statement syntax

import RailroadDiagram from "@components/RailroadDiagram.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

<Tabs syncKey="sleep-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
SLEEP @duration;
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const sleepAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    {
      type: "Sequence",
      children: [
        { type: "Terminal", text: "SLEEP" },
        { type: "NonTerminal", text: "@duration" },
        { type: "Terminal", text: ";" },
      ],
    },
  ],
};

<RailroadDiagram ast={sleepAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

The following query shows example usage of this statement.

```surql
-- Sleep one second
SLEEP 1s;
-- Sleep 100 milliseconds
SLEEP 100ms;
```

For more dynamic usage of sleep, see SurrealDB's [sleep](/docs/surrealql/functions/database/sleep) function.

## SLEEP during parallel operations

A `SLEEP` statement does not interfere with operations that are underway in the background, such as a [`DEFINE INDEX`](/docs/surrealql/statements/define/indexes) statement using the `CONCURRENTLY` clause.

```surql
CREATE |user:50000| SET name = id.id() RETURN NONE;
DEFINE INDEX unique_name ON TABLE user FIELDS name UNIQUE CONCURRENTLY;
INFO FOR INDEX unique_name ON TABLE user;
SLEEP 50ms;
INFO FOR INDEX unique_name ON TABLE user;
SLEEP 50ms;
INFO FOR INDEX unique_name ON TABLE user;
SLEEP 50ms;
INFO FOR INDEX unique_name ON TABLE user;
```

```surql title="Possible output"
-------- Query 1 --------
{
	building: {
		count: 0,
		status: 'initial'
	}
}

-------- Query 2 --------
{
	building: {
		count: 17250,
		status: 'initial'
	}
}

-------- Query 3 --------
{
	building: {
		count: 33542,
		status: 'initial'
	}
}

-------- Query 4 --------
{
	building: {
		status: 'built'
	}
}
```

## Use cases

`SLEEP` can be useful in a small number of situations, such as:

* Testing and debugging: can be used to understand how concurrent transactions interact, test how systems handle timeouts and delays, simulate behaviour in more distant regions with longer latency
* Throttling: can be used to throttle the execution of operations to prevent the database from being overwhelmed by too many requests at once
* Security measures: can be used to slow down the response rate of login attempts to mitigate the risk of brute force attacks



================================================
FILE: src/content/doc-surrealql/statements/throw.mdx
================================================
---
sidebar_position: 23
sidebar_label: THROW
title: THROW statement | SurrealQL
description: The THROW statement can be used to stop execution of a query and return information on the underlying problem
---

# `THROW` statement

The `THROW` statement can be used to throw an error in a place where something unexpected is happening. Execution of the query will be aborted and the error will be returned to the client. While a string is most commonly seen after a `THROW` statement, any [value](/docs/surrealql/datamodel/values) at all can be used as error output.

import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

### Statement syntax

<Tabs syncKey="throw-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
THROW @error
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const throwAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "THROW" },
      { type: "NonTerminal", text: "@error" }
    ]}
  ]
};

<RailroadDiagram ast={throwAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

The following query shows example usage of this statement.

```surql
/**[test]

[[test.results]]
error = "'An error occurred: some error message'"

*/

-- Throw an error
THROW "some error message";
```
The following query shows the `THROW` statement being used to send back a custom error to the client.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- In this example, we throw a custom error when a user provides invalid signin details
DEFINE ACCESS user ON DATABASE TYPE RECORD
	SIGNIN {
		LET $user = (SELECT * FROM user WHERE username = $username AND crypto::argon2::compare(password, $password));
		IF !$user {
			THROW "You either provided invalid credentials, or a user with the username " + <string> $username + " might not exist.";
		};

		RETURN $user;
	}
	DURATION FOR SESSION 1w
;
```

`THROW` can contain any value: arrays, objects, and so on. It can even take the value of a separate `SELECT` statement:

```surql
/**[test]

[[test.results]]
value = "[{ id: event:one, time: d'2025-10-08T07:15:04.994633Z' }]"

[[test.results]]
value = "[{ id: event:two, time: d'2025-10-08T07:15:04.996995Z' }]"

[[test.results]]
error = ""An error occurred: [{ id: event:one, time: d'2025-10-08T07:15:04.994633Z' }, { id: event:two, time: d'2025-10-08T07:15:04.996995Z' }]""

*/

CREATE event:one SET time = d'2025-10-08T07:15:04.994633Z';
CREATE event:two SET time = d'2025-10-08T07:15:04.996995Z';
THROW SELECT * FROM event;
```

```surql title="Response"
"An error occurred: [{ id: event:one, time: d'2025-10-08T07:15:04.994633Z' }, { id: event:two, time: d'2025-10-08T07:15:04.996995Z' }]"
```

`THROW` can also be used to cancel a transaction, usually inside an `IF` statement checking a condition.

```surql
BEGIN TRANSACTION;
LET $transfer_amount = 150;
CREATE account:one SET dollars =  100;
CREATE account:two SET dollars =  100;
UPDATE account:one SET dollars -= $transfer_amount;
UPDATE account:two SET dollars += $transfer_amount;
IF account:one.dollars < 0 {
    THROW "Insufficient funds, would have $" + <string>account:one.dollars + " after transfer"
};
COMMIT TRANSACTION;
SELECT * FROM account;
```

```surql title="Output when $transfer_amount set to 150"
'An error occurred: Insufficient funds, would have $-50 after transfer'
```

```surql title="Output when $transfer_amount set to 50"
[
	{
		dollars: 50,
		id: account:one
	},
	{
		dollars: 150,
		id: account:two
	}
]
```



================================================
FILE: src/content/doc-surrealql/statements/update.mdx
================================================
---
sidebar_position: 24
sidebar_label: UPDATE
title: UPDATE statement | SurrealQL
description: The UPDATE statement can be used to update records in the database. If they already exist, they will be updated. If they do not exist, no records will be updated.
---
import Since from '@components/shared/Since.astro'
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";
import RailroadDiagram from "@components/RailroadDiagram.astro";

# `UPDATE` statement

The `UPDATE` statement can be used to update existing records in the database. If the record does not exist, the statement will succeed but no records will be updated.

> [!NOTE]
> This statement can not be used to create graph relationships. For that, use the [`RELATE`](/docs/surrealql/statements/relate) or [`INSERT`](/docs/surrealql/statements/insert) statement.

> [!NOTE]
> UPDATE on a single record in SurrealDB 1.x will create the record if it does not exist. This behaviour is no longer the case in SurrealDB 2.0. To update and create a record if it does not exist in SurrealDB 2.0, use the [`UPSERT`](/docs/surrealql/statements/upsert) statement.

### Statement syntax

<Tabs syncKey="update-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
UPDATE [ ONLY ] @targets
	[ CONTENT @value
	  | MERGE @value
	  | PATCH @value
	  | REPLACE @value
	  | [ SET @field = @value, ... | UNSET @field, ... ]
	]
	[ WHERE @condition ]
	[ RETURN NONE | RETURN BEFORE | RETURN AFTER | RETURN DIFF | RETURN @statement_param, ... | RETURN VALUE @statement_param ]
	[ TIMEOUT @duration ]
	[ EXPLAIN [ FULL ]]
;
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const updateAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    {
      type: "Sequence",
      children: [
        { type: "Terminal", text: "UPDATE" },
        { type: "Optional", child: { type: "Terminal", text: "ONLY" } },
        { type: "NonTerminal", text: "@targets" },
        { type: "Optional", child: { type: "Choice", index: 1, children: [
          { type: "Sequence", children: [ { type: "Terminal", text: "CONTENT" }, { type: "NonTerminal", text: "@value" } ] },
          { type: "Sequence", children: [ { type: "Terminal", text: "MERGE" }, { type: "NonTerminal", text: "@value" } ] },
          { type: "Sequence", children: [ { type: "Terminal", text: "PATCH" }, { type: "NonTerminal", text: "@value" } ] },
          { type: "Sequence", children: [ { type: "Terminal", text: "REPLACE" }, { type: "NonTerminal", text: "@value" } ] },
          { type: "Sequence", children: [ { type: "Choice", index: 1, children: [ { type: "Terminal", text: "SET" }, { type: "Terminal", text: "UNSET" } ] }, { type: "NonTerminal", text: "@field (=|,) @value ..." } ] }
        ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "WHERE" }, { type: "NonTerminal", text: "@condition" } ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "RETURN" }, { type: "Choice", index: 1, children: [
          { type: "Terminal", text: "NONE" }, { type: "Terminal", text: "BEFORE" }, { type: "Terminal", text: "AFTER" }, { type: "Terminal", text: "DIFF" }, { type: "NonTerminal", text: "@statement_param, ..." }, { type: "Sequence", children: [ { type: "Terminal", text: "VALUE" }, { type: "NonTerminal", text: "@statement_param" } ] }
        ] } ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "TIMEOUT" }, { type: "NonTerminal", text: "@duration" } ] } },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "EXPLAIN" }, { type: "Optional", child: { type: "Terminal", text: "FULL" } } ] } },
        { type: "Terminal", text: ";" },
      ]
    }
  ]
};

<RailroadDiagram ast={updateAst} className="my-6" />

  </TabItem>
</Tabs>

> [!NOTE]
> `@target` refers to either record output including an `id` field, or a [record ID](/docs/surrealql/datamodel/ids) on its own.

## Example usage

Let's look at some examples of how to use the `UPDATE` statement. First we'll create two `person` records with the [`CREATE`](/docs/surrealql/statements/create) statement so that the examples will produce a meaningful output.

```surql
/**[test]

[[test.results]]
value = "[{ company: 'Surrealist', id: person:1iberbyuqfpoi6girgv9, name: 'John', skills: ['JavaScript', 'Go', 'SurrealQL'] }]"
skip-record-id-key = true

[[test.results]]
value = "[{ company: 'SurrealDB', id: person:tobie, name: 'Tobie', skills: ['JavaScript', 'Go', 'SurrealQL'] }]"

*/

-- Create a Schemaless person table with a random id
CREATE person CONTENT {
    name: 'John',
    company: 'Surrealist',
    skills: ['JavaScript', 'Go' , 'SurrealQL']
};

-- Create another person with a specific id
CREATE person:tobie CONTENT {
    name: 'Tobie',
    company: 'SurrealDB',
    skills: ['JavaScript', 'Go' , 'SurrealQL']
};
```

Let's say we wanted to update the `person` table with a new field `enjoys` (an array), a new skill `breathing` to the existing `skills` field (another array), add a new numeric field called `dollars`, and a `last_name` field that relies on the existing `name` field to set its value.

To do this we would use the following query.

```surql
-- Update all records in a table
-- The `enjoys` field will also be an array.
-- The += operator alone is enough to infer the type
UPDATE person SET 
	dollars = 50,
	skills += 'breathing',
	enjoys += 'reading',
	full_name = name + ' Mc' + name + 'erson';
```

```surql title="Output"
[
	{
		company: 'Surrealist',
		dollars: 50,
		enjoys: [
			'reading'
		],
		full_name: 'John McJohnerson',
		id: person:j1qov2pxey3p8s6hqlev,
		name: 'John',
		skills: [
			'JavaScript',
			'Go',
			'SurrealQL',
			'breathing'
		]
	},
	{
		company: 'SurrealDB',
		dollars: 50,
		enjoys: [
			'reading'
		],
		full_name: 'Tobie McTobieerson',
		id: person:tobie,
		name: 'Tobie',
		skills: [
			'JavaScript',
			'Go',
			'SurrealQL',
			'breathing'
		]
	}
]
```

For more specific updates, you can specify a record ID to update a single record. The following query will update the record with the ID `person:tobie` to add "Rust" as a skill.

```surql
-- Update a record with a specific string id to add a new skill: 'Rust'
UPDATE person:tobie SET skills += 'Rust';
```

```surql title="Output"
[
	{
		company: 'SurrealDB',
		dollars: 50,
		enjoys: [
			'reading'
		],
		full_name: 'Tobie McTobieerson',
		id: person:tobie,
		name: 'Tobie',
		skills: [
			'JavaScript',
			'Go',
			'SurrealQL',
			'breathing',
			'Rust'
		]
	}
]
```

The `-=` operator can be used to remove an item from an array or reduce a numeric value by a certain value.

```surql
UPDATE person:tobie SET 
	skills -= 'Go', 
	dollars -= 1;
```

```surql title="Output"
[
	{
		company: 'SurrealDB',
		dollars: 49,
		enjoys: [
			'reading'
		],
		full_name: 'Tobie McTobieerson',
		id: person:tobie,
		name: 'Tobie',
		skills: [
			'JavaScript',
			'SurrealQL',
			'breathing',
			'Rust'
		]
	}
]
```

You can also remove a field from a record using the `UNSET` keyword or by setting the field to `NONE`.

```surql
-- Remove the company field by setting it to NONE or using the UNSET keyword
UPDATE person:tobie SET company = NONE;

UPDATE person:tobie UNSET company;
```

```surql title="Output"
[
	{
		dollars: 49,
		enjoys: [
			'reading'
		],
		full_name: 'Tobie McTobieerson',
		id: person:tobie,
		name: 'Tobie',
		skills: [
			'JavaScript',
			'SurrealQL',
			'breathing',
			'Rust'
		]
	}
]
```

## Conditional Update with `WHERE` clause

The `UPDATE` statement supports conditional matching of records using a `WHERE` clause. If the expression in the `WHERE` clause evaluates to `true`, then the respective record will be updated.

```surql
-- Update all records which match the condition that `company` is not equal to "SurrealDB"
UPDATE person SET skills += "System design" WHERE company != "SurrealDB";
```

```surql title="Output"
[
	{
		company: 'Surrealist',
		dollars: 50,
		enjoys: [
			'reading'
		],
		full_name: 'John McJohnerson',
		id: person:i5z3i64cpqpo8jtr6jww,
		name: 'John',
		skills: [
			'JavaScript',
			'Go',
			'SurrealQL',
			'breathing',
			'System design'
		]
	},
	{
		dollars: 49,
		enjoys: [
			'reading'
		],
		full_name: 'Tobie McTobieerson',
		id: person:tobie,
		name: 'Tobie',
		skills: [
			'JavaScript',
			'SurrealQL',
			'breathing',
			'Rust',
			'System design'
		]
	}
]
```

## CONTENT clause

Instead of specifying record data using the `SET` clause, it is also possible to use the `CONTENT` keyword to specify the record data using a SurrealQL object.

```surql
-- Update all records with the same content
UPDATE person CONTENT {
	name: 'John',
	company: 'SurrealDB',
	skills: ['Rust', 'Go', 'JavaScript'],
};

-- Oops, now they are both named John.
-- Update a specific record with some content
UPDATE person:tobie CONTENT {
	name: 'Tobie',
	company: 'SurrealDB',
	skills: ['Rust', 'Go', 'JavaScript'],
};
```

Since version `2.1.0`, a statement with a `CONTENT` clause will bypass `READONLY` fields instead of generating an error.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ age: 90, created: d'2024-01-01T00:00:00Z', id: person:gladys }]"

[[test.results]]
value = "[{ age: 70, created: d'2024-01-01T00:00:00Z', id: person:gladys }]"

*/

DEFINE FIELD created ON person TYPE datetime DEFAULT d'2024-01-01T00:00:00Z' READONLY;
CREATE person:gladys SET age = 90;
-- Does not try to modify `created` field, no error
UPDATE person:gladys CONTENT { age: 70 };
```

<Tabs groupId="content">
<TabItem value="Before" label="Output before 2.1.0" >

```surql
-------- Query --------
[
	{
		age: 90,
		created: d'2024-01-01T00:00:00Z',
		id: person:gladys
	}
]

-------- Query --------
'Found changed value for field `created`, with record `person:gladys`, but field is readonly'
```
</TabItem>

<TabItem value="After" label="Output after 2.1.0" >

```surql
-------- Query --------
[
	{
		age: 90,
		created: d'2024-01-01T00:00:00Z',
		id: person:gladys
	}
]

-------- Query --------
[
	{
		age: 70,
		created: d'2024-01-01T00:00:00Z',
		id: person:gladys
	}
]
```
</TabItem>
</Tabs>

## REPLACE clause

Originally an alias for `CONTENT`, the `REPLACE` clause maintains the previous behaviour regarding `READONLY` fields. If the content following `REPLACE` does not match a record's `READONLY` fields, an error will be generated.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ age: 90, created: d'2024-01-01T00:00:00Z', id: person:gladys }]"

[[test.results]]
error = "'Found changed value for field `created`, with record `person:gladys`, but field is readonly'"

[[test.results]]
value = "[{ age: 70, created: d'2024-01-01T00:00:00Z', id: person:gladys }]"

*/

DEFINE FIELD created ON person TYPE datetime DEFAULT d'2024-01-01T00:00:00Z' READONLY;
CREATE person:gladys SET age = 90;
-- Attempts to change `created` field, error
UPDATE person:gladys REPLACE { age: 70 };
-- `created` equals current value, query works
UPDATE person:gladys REPLACE { age: 70, created: d'2024-01-01T00:00:00Z' };
```

```surql title="Output"
-------- Query --------
[
	{
		age: 90,
		created: d'2024-01-01T00:00:00Z',
		id: person:gladys
	}
]

-------- Query --------
'Found changed value for field `created`, with record `person:gladys`, but field is readonly'

-------- Query --------
[
	{
		age: 70,
		created: d'2024-01-01T00:00:00Z',
		id: person:gladys
	}
]
```

## MERGE clause

Instead of specifying the full record data using `CONTENT` or one field at a time using `SET`, it is also possible to merge-update only specific fields by using the `MERGE` keyword followed by on object containing the fields which are to be upserted.

```surql
-- Update certain fields on all records
UPDATE person MERGE {
	settings: {
		marketing: true,
	},
};

-- Update certain fields on a specific record
UPDATE person:tobie MERGE {
	settings: {
		marketing: true,
	},
};
```

```surql title="Output"
[
	{
		company: 'SurrealDB',
		id: person:i5z3i64cpqpo8jtr6jww,
		name: 'John',
		settings: {
			marketing: true
		},
		skills: [
			'Rust',
			'Go',
			'JavaScript'
		]
	},
	{
		company: 'SurrealDB',
		id: person:tobie,
		name: 'Tobie',
		settings: {
			marketing: true
		},
		skills: [
			'Rust',
			'Go',
			'JavaScript'
		]
	}
]
```

## PATCH clause

You can also specify changes to be applied to your query response, using the PATCH command which works similar to the [JSON Patch specification](https://jsonpatch.com/)

```surql
-- Patch the JSON response
UPDATE person:tobie PATCH [
	{
		"op": "add",
		"path": "Engineering",
		"value": "true"
	}
]
```

```surql title="Output"
[
	{
		Engineering: 'true',
		company: 'SurrealDB',
		id: person:tobie,
		name: 'Tobie',
		settings: {
			marketing: true
		},
		skills: [
			'Rust',
			'Go',
			'JavaScript'
		]
	}
]
```

## Alter the `RETURN` value

By default, the update statement returns the record value once the changes have been made. To change the return value of each record, use the `RETURN` clause, specifying `NONE`, `BEFORE`, `AFTER`, `DIFF`, a comma-separated list of specific fields or ad-hoc fields, or `VALUE` for a single field without its key name.

```surql
-- Don't return any result
UPDATE person SET skills += 'reading' RETURN NONE;

-- Return the changeset diff
UPDATE person SET skills += 'reading' RETURN DIFF;

-- Return the record before changes were applied
UPDATE person SET skills += 'reading' RETURN BEFORE;

-- Return the record after changes were applied (the default)
UPDATE person SET skills += 'reading' RETURN AFTER;

-- Return the value of the 'skills' field without the field name
UPDATE person SET skills += 'reading' RETURN VALUE skills;

-- Return a specific field only from the updated records
UPDATE person:tobie SET skills = ['skiing', 'music'] RETURN name, interests;
```

## Using a timeout

When processing a large result set with many interconnected records, it is possible to use the `TIMEOUT` keyword to specify a timeout duration for the statement. If the statement continues beyond this duration, then the transaction will fail, no records will be updated in the database, and the statement will return an error.

```surql
UPDATE person 
	SET important = true 
	WHERE ->knows->person->(knows WHERE influencer = true) 
	TIMEOUT 5s;
```

## UPDATE inside database exports

As `UPDATE` before version 2.0.0 used to create a specified record ID if it did not exist, it was used in the `.surql` files generated by the [`surreal export`](/docs/surrealdb/cli/export) command to export existing records in a database. As of version 2.0.0, the [`INSERT`](/docs/surrealql/statements/insert) statement is used instead.

## The `EXPLAIN` clause

When `EXPLAIN` is used:

1. The `UPDATE` statement returns an explanation, essentially revealing the execution plan to provide transparency and understanding of the query performance.
2. The records are not updated.

`EXPLAIN` can be followed by `FULL` to see the number of executed rows.


================================================
FILE: src/content/doc-surrealql/statements/upsert.mdx
================================================
---
sidebar_position: 25
sidebar_label: UPSERT
title: UPSERT statement | SurrealQL
description: The UPSERT statement can be used to insert records or modify records that already exist
---
import Since from '@components/shared/Since.astro'
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";
import RailroadDiagram from "@components/RailroadDiagram.astro";

# `UPSERT` statement

<Since v="v2.0.0" />

The `UPSERT` statement can be used to insert records into the database, or to update them if they exist.

> [!NOTE]
> In versions of SurrealDB between 2.0.0 and 2.0.4, an UPSERT statement was treated as an "UPDATE, otherwise INSERT" statement. It has since been changed to a statement which defaults to insertion, and updates otherwise. Please see the examples below for details.

### Statement syntax

<Tabs syncKey="upsert-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
UPSERT [ ONLY ] @targets
    [ CONTENT @value
      | MERGE @value
      | PATCH @value
	  | REPLACE @value
      | [ SET @field = @value, ... | UNSET @field, ... ]
    ]
    [ WHERE @condition ]
    [ RETURN NONE | RETURN BEFORE | RETURN AFTER | RETURN DIFF | RETURN @statement_param, ... | RETURN VALUE @statement_param ]
    [ TIMEOUT @duration ]
	[ EXPLAIN [ FULL ]]
;
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const upsertAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "UPSERT" },
      { type: "Optional", child: { type: "Terminal", text: "ONLY" } },
      { type: "NonTerminal", text: "@targets" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [
        { type: "Sequence", children: [ { type: "Terminal", text: "CONTENT" }, { type: "NonTerminal", text: "@value" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "MERGE" }, { type: "NonTerminal", text: "@value" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "PATCH" }, { type: "NonTerminal", text: "@value" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "REPLACE" }, { type: "NonTerminal", text: "@value" } ] },
        { type: "Sequence", children: [ { type: "Choice", index: 1, children: [ { type: "Terminal", text: "SET" }, { type: "Terminal", text: "UNSET" } ] }, { type: "NonTerminal", text: "@field (=|,) @value ..." } ] }
      ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "WHERE" }, { type: "NonTerminal", text: "@condition" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "RETURN" }, { type: "Choice", index: 1, children: [ { type: "Terminal", text: "NONE" }, { type: "Terminal", text: "BEFORE" }, { type: "Terminal", text: "AFTER" }, { type: "Terminal", text: "DIFF" }, { type: "NonTerminal", text: "@statement_param, ..." }, { type: "Sequence", children: [ { type: "Terminal", text: "VALUE" }, { type: "NonTerminal", text: "@statement_param" } ] } ] } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "TIMEOUT" }, { type: "NonTerminal", text: "@duration" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "EXPLAIN" }, { type: "Optional", child: { type: "Terminal", text: "FULL" } } ] } },
      { type: "Terminal", text: ";" }
    ]}
  ]
};

<RailroadDiagram ast={upsertAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

Conceptually, an `UPSERT` statement can be thought of as an "`INSERT`, otherwise `UPDATE`" statement.

### `UPSERT` without a `WHERE` clause

As an `UPSERT` statement is primarily an `INSERT` statement, one without a `WHERE` clause will not perform an update.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:5014eu5j3ysw6ifsmk8v, name: 'Billy' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: person:89m30prs5ph4azxluwww, name: 'Bobby' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: person:5014eu5j3ysw6ifsmk8v, name: 'Billy' }, { id: person:89m30prs5ph4azxluwww, name: 'Bobby' }]"
skip-record-id-key = true

*/

UPSERT person SET name = 'Billy';
UPSERT person SET name = 'Bobby';
SELECT * FROM person;
```

As the output shows, the second `UPSERT` simply inserted another `person` record with the name "Bobby", rather than updating the existing record.

```surql title="Output"
-------- Query --------
[
	{
		id: person:c2bl54ahi551fcx9dqri,
		name: 'Billy'
	}
]

-------- Query --------
[
	{
		id: person:886dcoe1ayul217nl2fu,
		name: 'Bobby'
	}
]

-------- Query --------
[
	{
		id: person:886dcoe1ayul217nl2fu,
		name: 'Bobby'
	},
	{
		id: person:c2bl54ahi551fcx9dqri,
		name: 'Billy'
	}
]
```

### Using the `WHERE` clause

#### Without a specified ID

When using the `WHERE` clause and no specified ID, SurrealDB will check to see if any records match the clause. If nothing matches, a new record will be created.

As such, the following `UPSERT` statement will return a new record:

```surql
/**[test]

[[test.results]]
value = "[{ id: person:39v37mew631umqb63bfq, name: 'Jaime' }]"
skip-record-id-key = true

*/

UPSERT person SET name = 'Jaime' WHERE name = 'Jaime';
```

```surql title="Output"
[
	{
		id: person:7ilunylkcjgbg9gf0tqn,
		name: 'Jaime'
	}
]
```

Since a record with the name 'Jaime' exists, an `UPSERT` followed by `WHERE name = 'Jaime'` will update the existing record instead of creating a new one.

```surql
UPSERT person SET name = 'Tobie' WHERE name = 'Jaime';
```

```surql title="Output"
[
	{
		id: person:7ilunylkcjgbg9gf0tqn,
		name: 'Tobie'
	}
]
```

Now that no records have the name `'Jaime'`, the same query as above will now create a new record because no records match the `WHERE` clause. The database will now have two `person` records.

```surql
UPSERT person SET name = 'Tobie' WHERE name = 'Jaime';
SELECT * FROM person;
```

```surql title="Output"
-- Query
[
	{
		id: person:0n0ddlkmhe6mdb6ikkui,
		name: 'Tobie'
	}
]

-- Query
[
	{
		id: person:0n0ddlkmhe6mdb6ikkui,
		name: 'Tobie'
	},
	{
		id: person:7ilunylkcjgbg9gf0tqn,
		name: 'Tobie'
	}
]
```

#### With a specified ID

`UPSERT` behaviour with a specific ID and a `WHERE` clause differs slightly from the examples above. In this case, there is the possibility that a record ID already exists but the `WHERE` clause does not match. As such, there is no way to create a new record as the statement only pertains to an ID for an already existing record.

The following query will return a record, because the `person:test` record does not yet exist. The `WHERE` clause makes no difference as there is no record to apply it to.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:test, name: 'Jaime' }]"

*/

UPSERT person:test SET name = 'Jaime' WHERE name = 'Jaime';
```

```surql title="Output"
[
	{
		id: person:test,
		name: 'Jaime'
	}
]
```

The following query will update the `person:test` record, because the record exists and the `WHERE` clause matches. The `person:test` record will now have the name `'Tobie'`.

```surql
UPSERT person:test SET name = 'Tobie' WHERE name = 'Jaime';
```

```surql title="Output"
[
	{
		id: person:test,
		name: 'Tobie'
	}
]
```

However, this third query will return nothing. The `WHERE` clause does not match and thus `person:test` cannot be updated, and the statement itself only pertains to the `person:test` record, so a new record using a random ID will not be returned.

```surql
UPSERT person:test SET name = 'Billy' WHERE name = 'Jaime';
```

```surql title="Output"
[]
```

### Improved performance via UPSERT and a unique index

[Unique indexes](/docs/surrealql/statements/define/indexes#unique-index) can be used to ensure that no field or combination of fields is ever present more than once. For example, a game might have a rule that duplicate names can exist, but not within the same class.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ class: 'wizard', id: user:billy, metadata: { likes: ['strawberries'] }, name: 'Billy', official_name: 'Billy the wizard' }]"

[[test.results]]
value = ""Database index `unique_key` already contains ['Billy', 'wizard'], with record `user:billy`""

*/

DEFINE INDEX unique_key ON TABLE user FIELDS name, class UNIQUE;
DEFINE FIELD official_name ON TABLE user VALUE name + " the " + class;
CREATE user:billy SET name = "Billy", class = "wizard", metadata = { likes: ["strawberries"] };
CREATE user:billy_der_zweite SET name = "Billy", class = "wizard", metadata = { likes: ["strawberries", "fields"] };
```

As the output shows, the unique index prevents the creation of a second user with the name and class as the first.

```surql title="Output"
-------- Query --------
[
	{
		id: user:billy,
		metadata: {
			likes: [
				'strawberries'
			]
		},
		name: 'Billy',
		official_name: 'Billy the wizard',
		class: 'wizard'
	}
]

-------- Query --------
"Database index `unique_key` already contains ['Billy', 'wizard'], with record `user:billy`"
```

To change an existing record's `metadata` field to the value `{ likes: ["strawberries", "fields"] }`, an `UPDATE` with a `WHERE` can be used. This performs a scan on the `user` table to check for all records that match the `WHERE` clause.

```surql
UPDATE user SET
	metadata = { likes: ["strawberries", "fields"] }
WHERE
	name = "Billy" AND
	class = "wizard";
```

However, a much more efficient method is available if you only need to update one record and have a unique index that can be used instead. This optimization is available when using `UPSERT` and a unique index, because the statement will always access the index in any case to first see if the record is a duplicate.

```surql
-- Checks the index for ["Mandy", "wizard"], no existing
-- record found so no problem
UPSERT user SET name = "Mandy", class = "wizard";

-- Fails because statement tries to upsert a new user:mandy
-- on top of the previous randomly generated one
UPSERT user:mandy SET 
	name = "Mandy",
	class = "wizard",
	metadata = { likes: ["strawberries" ]};
```

```surql title="Output"
-------- Query --------

[
	{
		class: 'wizard',
		id: user:kdvh401gofckvvy6nbiw,
		name: 'Mandy',
		official_name: 'Mandy the wizard'
	}
]

-------- Query --------

"Database index `unique_key` already contains ['Mandy', 'wizard'], with record `user:kdvh401gofckvvy6nbiw`"
```

Since an `UPSERT` statement already checks unique indexes by default, it uses this to recognize that the user with `name = "Billy"` and `the = "Wizard"` corresponds to the record `user:j2ecdb2tf4ou29mr0yp5` and update it without needing to scan the entire `user` table.

```surql
UPSERT user SET
	name = "Billy",
	class = "wizard",
	metadata = { likes: ["strawberries", "fields"] };
```

```surql title="Output"
-------- Query --------
[
	{
		id: user:j2ecdb2tf4ou29mr0yp5,
		metadata: {
			likes: [
				'strawberries'
			]
		},
		name: 'Billy',
		official_name: 'Billy the wizard',
		class: 'wizard'
	}
]
```

To compare the performance difference between using a `WHERE` clause and a unique index yourself, here is an example that creates a crowded field of 50000 `user` records, followed by one more `user` named "Billy". An `UPDATE` using `WHERE name = "Billy" AND class = "wizard"` requires a full table scan, while an `UPSERT` using the two fields used to build the index is much faster.

```surql
DEFINE INDEX unique_key ON TABLE user FIELDS name, class UNIQUE;
DEFINE FIELD official_name ON TABLE user VALUE name + " the " + class;

-- Add 50000 users to fill up the database
FOR $i IN <array>0..50000 { CREATE user SET name = <string>$i, class = <string>$i; };

-- Create Billy, one of 50,001 records
CREATE user SET name = "Billy", class = "wizard";

-- Updating Billy requires a table scan
UPDATE user SET
	interests += "music"
WHERE
	name = "Billy" AND
	class = "wizard";

-- But UPSERT uses 'name' and 'class' to check the index anyway,
-- and thus can use it to access the record without a scan
UPSERT user SET
	name = "Billy",
	class = "wizard",
	interests += "travel";
```

## Using the ONLY clause

The `ONLY` clause can be used to return a single record instead of an array of records.

```surql
/**[test]

[[test.results]]
value = "{ company: 'SurrealDB', id: person:tobie, name: 'Tobie', skills: ['Rust', 'Go', 'JavaScript'] }"

*/

-- UPSERT just a single record
-- Using the ONLY keyword, just an object for the record in question will be returned.
-- This, instead of an array with a single object.
UPSERT ONLY person:tobie SET 
	name = 'Tobie', 
	company = 'SurrealDB', 
	skills = ['Rust', 'Go', 'JavaScript'];
```

## Type inference when using UPSERT

The `+=` operator in the following query is enough for SurrealDB to infer that the `interests` field must be an `array<string>`.

```surql
/**[test]

[[test.results]]
value = "[{ company: 'SurrealDB', id: person:tobie, interests: ['Java'], name: 'Tobie', skills: ['Rust', 'Go', 'JavaScript'] }]"

*/

-- UPSERT a document and remove a tag from an array
UPSERT person:tobie SET interests += 'Java';
```

Type inference will also work with a numeric value such as the `click_count` field below, in which case it will infer the field to be of type `int` with a default value of 0.

```surql
/**[test]

[[test.results]]
value = "[{ click_count: 1, id: webpage:home }]"

*/

-- UPSERT a document and increment a numeric value
UPSERT webpage:home SET click_count += 1;
```

Creating a record by default makes the `UPSERT` statement an ideal way to manage an incrementing field.

```surql
UPSERT event_for:[time::now().format("%Y-%m-%d")] SET
    number += 1;
```

```surql title="Possible output"
[
	{
		id: event_for:[
			'2024-09-18'
		],
		number: 1
	}
]
```

Doing the same with an `UPDATE` statement would require much more manual work.

```surql
IF (SELECT * FROM event_for:[time::now().format("%Y-%m-%d")]).is_empty() {
    CREATE event_for:[time::now().format("%Y-%m-%d")] SET number = 1;
} ELSE {
    UPDATE event_for:[time::now().format("%Y-%m-%d")] SET number += 1;
};
```

## CONTENT clause

Instead of specifying record data using the `SET` clause, it is also possible to use the `CONTENT` keyword to specify the record data using a SurrealQL object.

```surql
/**[test]

[[test.results]]
value = "[{ company: 'SurrealDB', id: person:6vfpq64z5r6bpe8cb91q, name: 'Tobie', skills: ['Rust', 'Go', 'JavaScript'] }]"

[[test.results]]
value = "[{ company: 'SurrealDB', id: person:tobie, name: 'Tobie', skills: ['Rust', 'Go', 'JavaScript'] }]"

*/

-- UPSERT all records with the same content
UPSERT person CONTENT {
	name: 'Tobie',
	company: 'SurrealDB',
	skills: ['Rust', 'Go', 'JavaScript'],
};

-- UPSERT a specific record with some content
UPSERT person:tobie CONTENT {
	name: 'Tobie',
	company: 'SurrealDB',
	skills: ['Rust', 'Go', 'JavaScript'],
};
```

Since version `2.1.0`, a statement with a `CONTENT` clause will bypass `READONLY` fields instead of generating an error.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ age: 90, created: d'2024-01-01T00:00:00Z', id: person:gladys }]"

[[test.results]]
value = "[{ age: 70, created: d'2024-01-01T00:00:00Z', id: person:gladys }]"

*/

DEFINE FIELD created ON person TYPE datetime DEFAULT d'2024-01-01T00:00:00Z' READONLY;
UPSERT person:gladys SET age = 90;
-- Does not try to modify `created` field, no error
UPSERT person:gladys CONTENT { age: 70 };
```

<Tabs groupId="content">

<TabItem value="Before" label="Output before 2.1.0" >

```surql
-------- Query --------
[
	{
		age: 90,
		created: d'2024-01-01T00:00:00Z',
		id: person:gladys
	}
]

-------- Query --------
'Found changed value for field `created`, with record `person:gladys`, but field is readonly'
```
</TabItem>

<TabItem value="After" label="Output after 2.1.0" >

```surql
-------- Query --------
[
	{
		age: 90,
		created: d'2024-01-01T00:00:00Z',
		id: person:gladys
	}
]

-------- Query --------
[
	{
		age: 70,
		created: d'2024-01-01T00:00:00Z',
		id: person:gladys
	}
]
```
</TabItem>
</Tabs>

## REPLACE clause

Originally an alias for `CONTENT`, the `REPLACE` clause maintains the previous behaviour regarding `READONLY` fields. If the content following `REPLACE` does not match a record's `READONLY` fields, an error will be generated.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ age: 90, created: d'2024-01-01T00:00:00Z', id: person:gladys }]"

[[test.results]]
error = "'Found changed value for field `created`, with record `person:gladys`, but field is readonly'"

[[test.results]]
value = "[{ age: 70, created: d'2024-01-01T00:00:00Z', id: person:gladys }]"

*/

DEFINE FIELD created ON person TYPE datetime DEFAULT d'2024-01-01T00:00:00Z' READONLY;
UPSERT person:gladys SET age = 90;
-- Attempts to change `created` field, error
UPSERT person:gladys REPLACE { age: 70 };
-- `created` equals current value, query works
UPSERT person:gladys REPLACE { age: 70, created: d'2024-01-01T00:00:00Z' };
```

```surql title="Output"
-------- Query --------
[
	{
		age: 90,
		created: d'2024-01-01T00:00:00Z',
		id: person:gladys
	}
]

-------- Query --------
'Found changed value for field `created`, with record `person:gladys`, but field is readonly'

-------- Query --------
[
	{
		age: 70,
		created: d'2024-01-01T00:00:00Z',
		id: person:gladys
	}
]
```

## MERGE clause 

Instead of specifying the full record data using the `SET` clause or the `CONTENT` keyword, it is also possible to merge-UPSERT only specific fields by using the `MERGE` keyword and specifying only the fields which are to be upserted.

```surql
/**[test]

[[test.results]]
value = "[{ id: person:8v3or7b2uqfnscvptzkd, settings: { marketing: true } }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: person:tobie, settings: { marketing: true } }]"

*/

-- Inserts a new record with a single field and random ID
UPSERT person MERGE {
	settings: {
		marketing: true,
	},
};

-- Updates certain fields on a specific record
UPSERT person:tobie MERGE {
	settings: {
		marketing: true,
	},
};
```

## PATCH clause

You can also specify changes to be applied to your query response, using the `PATCH` clause which works similar to the [JSON Patch specification](https://jsonpatch.com/)

```surql
/**[test]

[[test.results]]
value = "[{ Engineering: 'true', id: person:tobie }]"

*/

-- Patch the JSON response
UPSERT person:tobie PATCH [
	{
		"op": "add",
		"path": "Engineering",
		"value": "true"
	}
];
```

## Alter the `RETURN` value

By default, the UPSERT statement returns the record value once the changes have been made. To change the return value of each record, specify a `RETURN` clause, specifying either `NONE`, `BEFORE`, `AFTER`, `DIFF`, or a comma-separated list of specific fields to return.

```surql
/**[test]

[[test.results]]
value = "[]"

[[test.results]]
value = "[[{ op: 'add', path: '/interests/1', value: 'reading' }]]"

[[test.results]]
value = "[{ id: person:tobie, interests: ['reading', 'reading'] }]"

[[test.results]]
value = "[{ id: person:tobie, interests: ['reading', 'reading', 'reading', 'reading'] }]"

[[test.results]]
value = "[{ interests: ['skiing', 'music'], name: NONE }]"

*/

-- Don't return any result
UPSERT person:tobie SET interests += 'reading' RETURN NONE;

-- Return the changeset diff
UPSERT person:tobie SET interests += 'reading' RETURN DIFF;

-- Return the record before changes were applied
UPSERT person:tobie SET interests += 'reading' RETURN BEFORE;

-- Return the record after changes were applied (the default)
UPSERT person:tobie SET interests += 'reading' RETURN AFTER;

-- Return a specific field only from the upserted records
UPSERT person:tobie SET interests = ['skiing', 'music'] RETURN name, interests;
```

When processing a large result set with many interconnected records, it is possible to use the `TIMEOUT` keywords to specify a timeout duration for the statement. If the statement continues beyond this duration, then the transaction will fail, no records will be upserted in the database, and the statement will return an error.

```surql
/**[test]

[[test.results]]
value = ""

*/

UPSERT person:3 SET important = true WHERE ->knows->person->(knows WHERE influencer = true) TIMEOUT 5s;
```

## The `EXPLAIN` clause

When `EXPLAIN` is used:

1. The `UPSERT` statement returns an explanation, essentially revealing the execution plan to provide transparency and understanding of the query performance.
2. The records are not updated.

`EXPLAIN` can be followed by `FULL` to see the number of executed rows.


================================================
FILE: src/content/doc-surrealql/statements/use.mdx
================================================
---
sidebar_position: 26
sidebar_label: USE
title: USE statement | SurrealQL
description: The USE statement specifies a namespace and / or a database to use for the subsequent SurrealQL statements when switching between namespaces and databases.
---

import Since from "@components/shared/Since.astro";
import RailroadDiagram from "@components/RailroadDiagram.astro";
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# `USE` statement

The `USE` statement specifies a namespace and / or a database to use for the subsequent SurrealQL statements when switching between namespaces and databases. If you have a single namespace and database, you can define them in the [sql command](/docs/surrealdb/cli/sql#example-usage).

Ensure that your database and namespace exist and you have [started your database](/docs/surrealdb/cli/start) before using the Sql command option.

### Statement syntax

<Tabs syncKey="use-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
USE [ NS @ns ] [ DB @db ];
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const useAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    {
      type: "Sequence",
      children: [
        { type: "Terminal", text: "USE" },
        {
          type: "Optional",
          child: {
            type: "Sequence",
            children: [
              { type: "Terminal", text: "NS" },
              { type: "NonTerminal", text: "@ns" },
            ],
          },
        },
        {
          type: "Optional",
          child: {
            type: "Sequence",
            children: [
              { type: "Terminal", text: "DB" },
              { type: "NonTerminal", text: "@db" },
            ],
          },
        },
        { type: "Terminal", text: ";" },
      ],
    },
  ],
};

<RailroadDiagram ast={useAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

The following query shows example usage of this statement if you have multiple namespaces and databases.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

USE NS test; -- Switch to the 'test' Namespace
```

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

USE DB test; -- Switch to the 'test' Database
```

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

USE NS test DB test; -- Switch to the 'test' Namespace and 'test' Database
```

You can also use the [INFO Statement](/docs/surrealql/statements/info) to check the current namespace and database.

```surql
INFO FOR NS; -- Check the current Namespace
```

```surql
INFO FOR DB; -- Check the current Database
```

## `USE` statement behaviour when resource does not exist

<Since v="v3.0.0-alpha.8" />

The behaviour of the `USE` statement differs depending on which mode the database server is run in.

When run in regular mode, a `USE` statement will create the namespace or database indicated if it does not already exist.

```surql
USE NS ns; -- Output: NONE (success)
(INFO FOR ROOT).namespaces; -- Output: { ns: 'DEFINE NAMESPACE ns' }
```

In [strict mode](/docs/surrealdb/cli/start#strict-mode), a resource will not be created unless it is already defined. In this case, the `USE` statement will return an error.

```surql
USE NS ns; -- Output: "The namespace 'ns' does not exist"
DEFINE NS ns;
USE NS ns; -- Now defined, no error
```


================================================
FILE: src/content/doc-surrealql/statements/define/analyzer.mdx
================================================
---
sidebar_position: 2
sidebar_label: DEFINE ANALYZER
title: DEFINE ANALYZER statement | SurrealQL
description: In the context of a database, an analyzer plays a crucial role in text processing and searching. It is defined by its name, a set of tokenizers, and a collection of filters.
---
import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `DEFINE ANALYZER` statement

> [!NOTE]
> Before SurrealDB version 3.0.0-alpha.8, the `FULLTEXT ANALYZER` clause used the syntax `SEARCH ANALYZER`.

In the context of a database, an analyzer plays a crucial role in text processing and searching. It is defined by its name, a set of tokenizers, and a collection of filters.

The output of an analyzer can be experimented with by using the [`search::analyze()`](/docs/surrealql/functions/database/search#searchhighlight) function.

## Requirements
- You must be authenticated as a root, namespace, or database user before you can use the `DEFINE ANALYZER` statement.
- [You must select your namespace and database](/docs/surrealql/statements/use) before you can use the `DEFINE ANALYZER` statement.

## Statement syntax

<Tabs syncKey="define-analyzer-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
DEFINE ANALYZER [ OVERWRITE | IF NOT EXISTS ] @name [ FUNCTION @function ] [ TOKENIZERS @tokenizers ] [ FILTERS @filters ] [ COMMENT @string ]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const defineAnalyzerAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "ANALYZER" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OVERWRITE" }, { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] } ] } },
      { type: "NonTerminal", text: "@name" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "FUNCTION" }, { type: "NonTerminal", text: "@function" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "TOKENIZERS" }, { type: "NonTerminal", text: "@tokenizers" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "FILTERS" }, { type: "NonTerminal", text: "@filters" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "COMMENT" }, { type: "NonTerminal", text: "@string" } ] } }
    ]}
  ]
};

<RailroadDiagram ast={defineAnalyzerAst} className="my-6" />

  </TabItem>
</Tabs>

## The `FUNCTION` clause

Using the `FUNCTION` clause allows a [user-defined function](/docs/surrealql/statements/define/function) to be executed on the initial input. The function must take and return a `string`.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "['BDlaerruS', 'ekil', 'I']"

*/

DEFINE FUNCTION fn::backwardsify($input: string) -> string {
    $input.split('').fold('', |$a, $b| $b + $a);
};

DEFINE ANALYZER backwards FUNCTION fn::backwardsify TOKENIZERS blank;

search::analyze("backwards", "I like SurrealDB");
```

```surql title="Output"
[
	'BDlaerruS',
	'ekil',
	'I'
]
```

## Tokenizers

Tokenizers are responsible for breaking down a given text into individual tokens based on a set of instructions. There are a couple of tokenizers that can be used while defining an analyzer as seen below:

### `blank`

The blank tokenizer breaks down a text into tokens by creating a new token each time it encounters a space, tab, or newline character. It's a straightforward way to split text into words or chunks based on whitespace.

```surql
DEFINE ANALYZER example_blank TOKENIZERS blank;
search::analyze("example_blank", "hello world");
```

```surql title="Output"
[
	'hello',
	'world'
]
```

### `camel`

The camel tokenizer is used for identifying and creating tokens when the next character in the text is uppercase. This is particularly useful for processing camelCase or PascalCase text, common in programming, to split them into meaningful words.

```surql
DEFINE ANALYZER example_camel TOKENIZERS camel;
search::analyze("example_camel", "helloWorld");
```

```surql title="Output"
[
	'hello',
	'World'
]
```

### `class`

The class tokenizer segments text into tokens by detecting changes (digit, letter, punctuation, blank) in the Unicode class of characters. It creates a new token when the character class changes, distinguishing between digits, letters, punctuation, and blanks. This allows for flexible tokenization based on character types.

```surql
DEFINE ANALYZER example_class TOKENIZERS class;
search::analyze("example_class", "123abc!XYZ");
```

```surql title="Output"
[
	'123',
	'abc',
	'!',
	'XYZ'
]
```

### `punct`

The punct tokenizer generates tokens by breaking the text whenever a punctuation character is encountered. It's suitable for tokenizing sentences or breaking text into smaller units based on punctuation marks.

```surql
DEFINE ANALYZER example_punct TOKENIZERS punct;
search::analyze("example_punct", "Hello, World!");
```

```surql title="Output"
[
	'Hello',
	',',
	'World',
	'!'
]
```

## Filters

Filters take on the task of transforming these tokens for further processing and analysis.

### `ascii`

The ascii filter is responsible for processing tokens by replacing or removing diacritical marks (accents and special characters) from the text. It helps standardize text by converting accented characters to their basic ASCII equivalents, making it more suitable for various text analysis tasks.

```surql
DEFINE ANALYZER example_ascii TOKENIZERS class FILTERS ascii;
search::analyze("example_ascii", "résumé café");
```

```surql title="Output"
[
	'resume',
	'cafe'
]
```

### `lowercase`

The lowercase filter converts tokens to lowercase, ensuring that text is consistently in lowercase format. This is often used to make text case-insensitive for search and analysis purposes.

```surql
DEFINE ANALYZER example_lowercase TOKENIZERS class FILTERS lowercase;
search::analyze("example_lowercase", "Hello World");
```

```surql title="Output"
[
	'hello',
	'world'
]
```

### `uppercase`

The uppercase filter converts tokens to uppercase, ensuring text consistency in uppercase format. It can be useful when case-insensitivity is required for specific analysis or search operations.

For example, if you had the text **"Hello World"**, the uppercase filter would create two tokens, **["HELLO", "WORLD"]**. Below is an example of how to use the uppercase filter:

```surql
DEFINE ANALYZER example_uppercase TOKENIZERS class FILTERS uppercase;
search::analyze("example_uppercase", "Hello World");
```

```surql title="Output"
[
	'HELLO',
	'WORLD'
]
```

### `edgengram(min,max)`

The edgengram filter is used to create tokens that represent prefixes of terms. It generates a sequence of tokens that gradually build up a term, which can be useful for autocomplete or searching based on partial words. It accepts two parameters `min` and `max` which define the minimum and maximum amount of characters in the prefix.

For example, if you had the text **"apple banana"**, the edgengram filter would create six tokens, **["a", "ap", "app", "b", "ba", "ban"]**. Below is an example of how to use the edgengram filter:

```surql
DEFINE ANALYZER example_edgengram TOKENIZERS class FILTERS edgengram(1,3);
search::analyze("example_edgengram", "apple banana");
```

```
[
	'a',
	'ap',
	'app',
	'b',
	'ba',
	'ban'
]
```

{/* Add Since here once next version out */}

### `mapper(path)`

The mapping filter is designed to enable lemmatization within SurrealDB.

Lemmatization is the process of reducing words to their base or dictionary form. The mapper mechanism allows users to specify a custom dictionary file that maps terms to their base forms. This dictionary file is then used by SurrealDB’s analyzer to standardize terms as they are indexed, improving search consistency.

This is particularly useful for handling irregular verbs and other terms that the default "snowball" filter cannot handle. Lemmatization files are easy to put together and to find online, making it possible to customize full-text search for smaller languages.

How does the mapper work?

Configuration: In the SQL statement below, the mapper parameter is specified within the analyzer definition.
This parameter points to the file that contains the term mappings for lemmatization.

```surql
DEFINE ANALYZER lemme_english TOKENIZERS blank,class FILTERS lowercase,mapper('../tests/data/lemmatization-en.txt');

RETURN [
    search::analyze("lemme_english", "He drove and swam"),
];
```

```surql title="Output"
[
	[
		'he',
		'drive',
		'and',
		'swim'
	]
]
```

Dictionary File Structure: The file specified in the mapper parameter must follow this format:

- Each line contains a pair of terms separated by a tab.
- The first term represents the canonical (base form) of the word.
- The second term is the form to be mapped to this base form.

Example file format:

```
drive	driven
drive	drives
drive	driving
drive	drove
swim	swam
swim	swimming
swim	swims
swim	swum
```

Usage: When this analyzer is applied to a text, any word that matches the mapped term in the dictionary file will be replaced by its base form before indexing. This helps ensure consistency in search results by consolidating different forms of a word to a single, standardized entry.

By using this custom dictionary-based mapper, you can control how irregular forms and other variations of terms are indexed,
making search behavior more predictable and comprehensive.

The following example shows how lemmatization can be used to generate a list of words and their respective frequencies. Other notable functionalities in the example are the [`string::is_alpha()`](/docs/surrealql/functions/database/string#stringis_alpha) function inside [`array::filter()`](/docs/surrealql/functions/database/array#arrayfilter) to remove all non-alphabetic strings, the [`type::record()`](/docs/surrealql/functions/database/type#typerecord) function to construct a record ID from two strings, and an [`UPSERT`](/docs/surrealql/statements/upsert) statement to create a record if one does not exist, or update it otherwise.

```surql
DEFINE ANALYZER lemme_english TOKENIZERS blank,class FILTERS lowercase,mapper('../tests/data/lemmatization-en.txt');

LET $text = "The Wheel of Time turns, and Ages come and pass, leaving memories that become legend. Legend fades to myth, and even myth is long forgotten when the Age that gave it birth comes again. In one Age, called the Third Age by some, an Age yet to come, an Age long past, a wind rose in the Mountains of Mist. The wind was not the beginning. There are neither beginnings nor endings to the turning of the Wheel of Time. But it was a beginning.";

LET $words = search::analyze("lemme_english", $text)
    .filter(|$c| $c.is_alpha());
FOR $word IN $words {
    UPSERT type::record("word", $word) SET frequency += 1;
};

SELECT * FROM word WHERE frequency >=3 ORDER BY frequency DESC;
```

```surql title="Output"
[
	{
		frequency: 8,
		id: word:the
	},
	{
		frequency: 6,
		id: word:age
	},
	{
		frequency: 4,
		id: word:a
	},
	{
		frequency: 4,
		id: word:be
	},
	{
		frequency: 4,
		id: word:of
	},
	{
		frequency: 3,
		id: word:and
	},
	{
		frequency: 3,
		id: word:come
	},
	{
		frequency: 3,
		id: word:to
	}
]
```

A mapper can also be used for ad-hoc filtering, as long as the file referenced contains two single words separated by a tab. Take the following file for example:

```title="error_filter.txt"
NOT_FOUND	File_not_found
NOT_FOUND	Datei_nicht_gefunden
NOT_FOUND	Fichier_non_trouvé
TIMEOUT	Timed_out
TIMEOUT	Délai_expiré
TIMEOUT	Zeitüberschreitung
```

An analyzer that uses a single mapper filter can then use this lemmatizer to unify multilingual error messages into a single output.

```surql
DEFINE ANALYZER error_filter FILTERS mapper('error_filter.txt');

LET $messages = 
	["File not found", "Datei nicht gefunden", "Zeitüberschreitung"]
	.map(|$word| $word.replace(' ', '_'))
	.join(' ');
search::analyze("error_filter", $messages);
```

```surql title="Output"
[
	'NOT_FOUND',
	'NOT_FOUND',
	'TIMEOUT'
]
```

Example using the same mapper to search for errors in multiple languages:

```surql
DEFINE ANALYZER error_filter FILTERS mapper('error_filter.txt');
DEFINE INDEX OVERWRITE errors ON TABLE error FIELDS message FULLTEXT ANALYZER error_filter;

FOR $message IN ["File not found", "Datei nicht gefunden", "Zeitüberschreitung"] {
	CREATE error SET message = $message.replace(' ', '_'), at = time::now();
};

SELECT * FROM error WHERE message @@ "NOT_FOUND";
```

```surql title="Output"
[
	{
		at: d'2024-11-13T03:56:12.039252Z',
		id: error:acbc044syhnx54wzs3n9,
		message: 'File_not_found'
	},
	{
		at: d'2024-11-13T03:56:12.043643Z',
		id: error:5ifxic9s750x24ts4zof,
		message: 'Datei_nicht_gefunden'
	}
]
```

### `ngram(min,max)`

The ngram filter is used to create a sequence of 'n' tokens from a given sample of text or speech. These items can be syllables, letters, words or base pairs according to the application. It accepts two parameters `min` and `max` which indicates that you want to create n-grams starting from min to size of max.

```surql
DEFINE ANALYZER example_ngram TOKENIZERS class FILTERS ngram(1,3);
search::analyze("example_ngram", "apple banana");
```

```surql title="Output"
[
	'a',
	'ap',
	'app',
	'p',
	'pp',
	'ppl',
	'p',
	'pl',
	'ple',
	'l',
	'le',
	'e',
	'b',
	'ba',
	'ban',
	'a',
	'an',
	'ana',
	'n',
	'na',
	'nan',
	'a',
	'an',
	'ana',
	'n',
	'na',
	'a'
]
```

### `snowball(language)`

The snowball filter applies Snowball stemming to tokens, reducing them to their root form and converts the case to lowercase. The following supported languages can be passed as a parameter in snowball: Arabic, Danish, Dutch, English, French, German, Greek, Hungarian, Italian, Norwegian, Portuguese, Romanian, Russian, Spanish, Swedish, Tamil, Turkish.

```surql
DEFINE ANALYZER english_snowball TOKENIZERS class FILTERS snowball(english);
DEFINE ANALYZER german_snowball TOKENIZERS class FILTERS snowball(german);

RETURN [
    search::analyze("english_snowball", "Looking at some running cats"),
    search::analyze("german_snowball", "Sollen wir was trinken gehen?")
];
```

```surql title="Output"
[
	[
		'look',
		'at',
		'some',
		'run',
		'cat'
	],
	[
		'soll',
		'wir',
		'was',
		'trink',
		'geh',
		'?'
	]
]
```

## Using `IF NOT EXISTS` clause

<Since v="v1.3.0" />

The `IF NOT EXISTS` clause can be used to define an analyzer only if it does not already exist. You should use the `IF NOT EXISTS` clause when defining an analyzer in SurrealDB if you want to ensure that the analyzer is only created if it does not already exist. If the analyzer already exists, the `DEFINE ANALYZER` statement will return an error.

It's particularly useful when you want to safely attempt to define a analyzer without manually checking its existence first.

On the other hand, you should not use the `IF NOT EXISTS` clause when you want to ensure that the analyzer definition is updated regardless of whether it already exists. In such cases, you might prefer using the `OVERWRITE` clause, which allows you to define a analyzer and overwrite an existing one if it already exists, ensuring that the latest version of the analyzer definition is always in use.

```surql
-- Create an ANALYZER if it does not already exist
DEFINE ANALYZER IF NOT EXISTS example TOKENIZERS blank;
```

## Using `OVERWRITE` clause

<Since v="v2.0.0" />

The `OVERWRITE` clause can be used to create an analyzer and overwrite an existing one if it already exists. You should use the `OVERWRITE` clause when you want to modify an existing analyzer definition. If the analyzer already exists, the `DEFINE ANALYZER` statement will overwrite the existing analyzer definition with the new one.

```surql
-- Create an ANALYZER and overwrite if it already exists
DEFINE ANALYZER OVERWRITE example TOKENIZERS blank;
```

## More examples

Examples on application of analyzers to indexes can be found in the documenation on [`DEFINE INDEX`](/docs/surrealql/statements/define/indexes) statement

This example creates an analyzer that tokenizes text based on the class of characters and then applies the lowercase filter to the tokens.

```surql
-- Creates a simple analyzer removing diacritics marks
DEFINE ANALYZER ascii TOKENIZERS class FILTERS lowercase,ascii;
```

This example creates an analyzer specifically designed for processing English texts.

```surql
-- Creates an analyzer suitable for English text
DEFINE ANALYZER english TOKENIZERS class FILTERS snowball(english);
```

This example creates an analyzer specifically designed for auto-completion tasks.

```surql
-- Creates an analyzer suitable for auto-completion.
DEFINE ANALYZER autocomplete FILTERS lowercase,edgengram(2,10);
```

This example creates an analyzer specifically designed for source code analysis.

```surql
-- Creates an analyzer suitable for source code analysis.
DEFINE ANALYZER code TOKENIZERS class,camel FILTERS lowercase,ascii;
```



================================================
FILE: src/content/doc-surrealql/statements/define/api.mdx
================================================
---
sidebar_position: 3
sidebar_label: DEFINE API
title: DEFINE API statement | SurrealQL
description: A DEFINE API statement can be used to set endpoints with custom middleware and permissions.
---
import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'


# DEFINE API statement

<Since v="v2.2.0" />

> [!CAUTION]
> Currently, this is an experimental feature as such, it may be subject to breaking changes and may present unidentified security issues. Do not rely on this feature in production applications. To enable this, set the `SURREAL_CAPS_ALLOW_EXPERIMENTAL` [environment variable](/docs/surrealdb/cli/start) to `define_api`.

The `DEFINE API` statements allows a custom endpoint to be created. Each endpoint created by a `DEFINE API` statement is located at the `/api/:namespace/:database/:endpoint_name` path. For example, an endpoint for the path `get_users` for the namespace `my_namespace` and database `my_database` will have the path `/api/my_namespace/my_database/get_users`.

The response is an object with a combination of the following properties:
* `raw` - A boolean that when set to `true` sends the response back as raw bytes or a string.
* `status` - A valid HTTP status code.
* `headers` - An object of valid header key value pairs.
* `body` - A SurrealQL value, automatically encoded back into how the user requested it. When `raw` is set to `true`, this needs to be a string or bytes value.

## Statement syntax

<Tabs syncKey="define-api-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
DEFINE API [ OVERWRITE | IF NOT EXISTS ] @endpoint
    [ FOR @HTTP_method, .. ]
    [ MIDDLEWARE @function, .. ]
    [ THEN { @value } ]
    [ PERMISSIONS [ NONE | FULL | @expression ]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const defineApiAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "API" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OVERWRITE" }, { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] } ] } },
      { type: "NonTerminal", text: "@endpoint" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "NonTerminal", text: "@HTTP_method, .." } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "MIDDLEWARE" }, { type: "NonTerminal", text: "@function, .." } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "THEN" }, { type: "Terminal", text: "{" }, { type: "NonTerminal", text: "@value" }, { type: "Terminal", text: "}" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "PERMISSIONS" }, { type: "Choice", index: 1, children: [ { type: "Terminal", text: "NONE" }, { type: "Terminal", text: "FULL" }, { type: "NonTerminal", text: "@expression" } ] } ] } }
    ]}
  ]
};

<RailroadDiagram ast={defineApiAst} className="my-6" />

  </TabItem>
</Tabs>


`DEFINE API` is often used in conjunction with a [capabilities flag](/docs/surrealdb/security/capabilities) or [environment variable](/docs/surrealdb/cli/env) to disable arbitrary queries, thereby forcing record and anonymous users to interact with the database via API endpoints alone.

## Quick example

```surql title="Defining an API endpoint"
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE API "/test"
    FOR get, post 
        MIDDLEWARE
            api::req::raw_body(false)
        THEN {
            RETURN {
                status: 200,
                body: {
                    request: $request.body,
                    response: "The server works"
                },
                headers: {
                    'last-modified': time::now(),
                    'expires': time::now() + 4d
                }
            };
        };
```

An API endpoint can be tested using the [`api::invoke` function](/docs/surrealql/functions/database/api), which takes either the path as a single string or the path along with a request body. It can also be tested via [CURL or other means by directly using the endpoint](/docs/surrealdb/integration/http) along with the namespace and database in the headers.

```surql
api::invoke("/test");

api::invoke("/test", {
    body: {
       hi: "please",
        give: "me",
        the: "information"
    }
});
```

```surql title="Output"
-------- Query --------

{
	body: {
		request: NONE,
		response: 'The server works'
	},
	headers: {
		"access-control-allow-origin": '*',
		expires: '2025-02-24T02:43:50.137321Z',
		"last-modified": '2025-02-20T02:43:50.137326Z'
	},
	raw: false,
	status: 200
}

-------- Query --------

{
	body: {
		request: {
			give: 'me',
			hi: 'please',
			the: 'information'
		},
		response: 'The server works'
	},
	headers: {
		"access-control-allow-origin": '*',
		expires: '2025-02-24T02:43:50.137455Z',
		"last-modified": '2025-02-20T02:43:50.137457Z'
	},
	raw: false,
	status: 200
}
```

## API paths

The path of a `DEFINE API` statement can be static, such as `"/test"`, dynamic, or the remainder of a URL.

A dynamic path uses a `:` (colon) followed by a name, which will match on anything passed in at that section of a path.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ body: { some: 'data' }, headers: {  }, raw: false, status: 200 }"

[[test.results]]
value = "{ body: { some: 'data' }, headers: {  }, raw: false, status: 200 }"

[[test.results]]
value = "NONE"

*/

DEFINE API OVERWRITE "/test/:anything_goes" FOR get THEN {
    RETURN {
        body: {
            some: "data"
        }
    }
};

api::invoke("/test/this_matches");
api::invoke("/test/same_here");
api::invoke("/test/but/this/wont/match");
```

The first two `api::invoke` calls return the output below, but the third returns nothing as `:anything_goes` only applies to a single path segment.

```surql title="Output"
{
	body: {
		some: 'data'
	},
	headers: {},
	raw: false,
	status: 200
}
```

To match on the remainder of a URL, change the `:` (colon) to a `*` (star).

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ body: { some: 'data' }, headers: {  }, raw: false, status: 200 }"

[[test.results]]
value = "{ body: { some: 'data' }, headers: {  }, raw: false, status: 200 }"

[[test.results]]
value = "{ body: { some: 'data' }, headers: {  }, raw: false, status: 200 }"

*/

DEFINE API OVERWRITE "/test/*anything_goes" FOR get THEN {
    RETURN {
        body: {
            some: "data"
        }
    }
};

api::invoke("/test/this_matches");
api::invoke("/test/same_here");
api::invoke("/test/works/with/multiple/paths/now");
```

All three `api::invoke` calls will now show the following output.

```surql title="Output"
{
	body: {
		some: 'data'
	},
	headers: {},
	raw: false,
	status: 200
}
```


================================================
FILE: src/content/doc-surrealql/statements/define/bucket.mdx
================================================
---
sidebar_position: 4
sidebar_label: DEFINE BUCKET
title: DEFINE BUCKET statement | SurrealQL
description: A DEFINE BUCKET statement can be used to set endpoints with custom middleware and permissions.
---
import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'


# DEFINE BUCKET statement

<Since v="v3.0.0-alpha.1" />

> [!NOTE]
> The `DEFINE BUCKET` statement is currently experimental and subject to change. To use this feature, please ensure you are on the latest supported alpha version of SurrealDB. To enable it, either pass `--allow-experimental files` when [starting the database](/docs/surrealdb/cli/start) or set the `SURREAL_CAPS_ALLOW_EXPERIMENTAL` environment variable to `files`.

The `DEFINE BUCKET` statement lets you create a bucket that can hold files.

## Statement syntax

<Tabs syncKey="define-bucket-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
DEFINE BUCKET [ OVERWRITE | IF NOT EXISTS ] @name [ @backend ]
[ PERMISSIONS ] @expression [ COMMENT @string ]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const defineBucketAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "BUCKET" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OVERWRITE" }, { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] } ] } },
      { type: "NonTerminal", text: "@name" },
      { type: "Optional", child: { type: "NonTerminal", text: "@backend" } },
      { type: "Optional", child: { type: "Terminal", text: "PERMISSIONS" } },
      { type: "NonTerminal", text: "@expression" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "COMMENT" }, { type: "NonTerminal", text: "@string" } ] } }
    ]}
  ]
};

<RailroadDiagram ast={defineBucketAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

A bucket backend can be set as "memory" for non-persistent in-memory storage, or as "file:/", followed by the path, for storage on disk.

### Memory backend

The simplest way to experiment with a bucket for files is by using the memory backend:

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE BUCKET my_bucket BACKEND "memory";
```

Once this is defined, `my_bucket` can be accessed by using a file pointer: a path prefixed by an `f`.

```surql
-- Create a file by adding some content
f"my_bucket:/my_book.txt".put("Once there were four children whose names were Peter, Susan, Edmund, and Lucy.");
-- Copy it to a new file name
f"my_bucket:/my_book.txt".copy("lion_witch_wardrobe.txt");
-- Read the file as bytes
f"my_bucket:/lion_witch_wardrobe.txt".get();
-- Cast the bytes to a string
<string>f"my_bucket:/lion_witch_wardrobe.txt".get();
```

```surql title="Output"
-------- Query --------

b"4F6E6365207468657265207765726520666F7572206368696C6472656E2077686F7365206E616D657320776572652050657465722C20537573616E2C2045646D756E642C20616E64204C7563792E"

-------- Query --------

'Once there were four children whose names were Peter, Susan, Edmund, and Lucy.'
```

### File backend

A file backend can be chosen for a bucket by typing `"file:"` and then the rest of the path, if necessary.

```surql
DEFINE BUCKET my_bucket BACKEND "file:/some_directory";
DEFINE BUCKET my_bucket BACKEND "file:/some_directory";
```

A check will then be made to see if the `SURREAL_FILE_ALLOWLIST` environment variable contains the path, without which the following error will be generated.

```surql
'File access denied: /some_directory'
```

The following command can be used to start running an instance in which a bucket with a file backend can be defined.

```bash
# Unix
SURREAL_FILE_ALLOWLIST="/" surreal start --user root --pass secret --allow-experimental files

# Windows (PowerShell)
$env:SURREAL_FILE_ALLOWLIST = "/" 
surreal start --user root --pass secret --allow-experimental files
```

### Global backend

A global backend can also be selected, allowing all namespaces and databases access to the same file storage.

If no backend is selected, the database will search for the environment variable `SURREAL_GLOBAL_BUCKET` and assign this as the global bucket. In this case, files will have a `namespace/database` prefix added (e.g. `my_global_bucket:/test_ns/test_db/somefile.txt`). A second `SURREAL_GLOBAL_BUCKET_ENFORCED` environment variable can also be used, which when set to `true` will enforce usage of the global bucket.

If a global backend is set, then a `DEFINE BUCKET` statement can be as short as `DEFINE BUCKET` plus its local name, as the rest of the logic is done via environment variables.

```surql
DEFINE BUCKET my_bucket;

-- Writes to e.g. `my_global_bucket:/test_ns/test_db/my_bucket/my_book.txt`
f"my_bucket:/my_book.txt".put("Once there were four children whose names were Peter, Susan, Edmund, and Lucy.");
```

## Setting permissions on buckets

By default, the permissions on a bucket will be set to FULL unless otherwise specified.

```surql
DEFINE BUCKET my_bucket BACKEND "memory";
INFO FOR DB;
```

```surql title="Response"
{
  accesses: {},
  analyzers: {},
  apis: {},
  buckets: {
    my_bucket: "DEFINE BUCKET my_bucket BACKEND 'memory' PERMISSIONS FULL"
  },
  configs: {},
  functions: {},
  models: {},
  modules: {},
  params: {},
  sequences: {},
  tables: {},
  users: {}
}
```

You can set permissions on buckets to control who can perform operations on the files stored in them using the `PERMISSIONS` clause. In the clause three additional variables are available:
- `$action`: The action to be executed (`put`, `get`, `head`, `delete`, `copy`, `rename`, `exists`, `list`)
- `$file`: The [file pointer](/docs/surrealql/datamodel/files) of the file to be accessed
- `$target`: The target [file pointer](/docs/surrealql/datamodel/files) in copy/rename operations

```surql
-- Set permissions for the bucket
DEFINE BUCKET admin_bucket BACKEND "memory"
  PERMISSIONS WHERE $auth.admin = true
```


================================================
FILE: src/content/doc-surrealql/statements/define/config.mdx
================================================
---
sidebar_position: 5
sidebar_label: DEFINE CONFIG
title: DEFINE CONFIG statement | SurrealQL
description: This statement allows you to set external configurations on the database, either for API middleware and permissions, or for how the database's tables and functions are exposed via the GraphQL API.
---
import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'


# `DEFINE CONFIG` statement

The `DEFINE CONFIG` statement allows you to set external configurations on your database. It can be used to configure API middleware and permissions, or to configure how the database's tables and functions are exposed via the GraphQL API.

> [!WARNING]
> By running SurrealDB with configurations for the database API or the GraphQL module, you are opting into an experimental feature. While these features are fully functional, they are still considered experimental and may not be as stable as the core SurrealQL module which means we cannot guarantee that it will provide the same security guarantees. They are not recommended for production use. We welcome your feedback and contributions to help improve the feature and make it more robust.

## Requirements

- You **must** be authenticated as a **root**, **namespace**, or **database** user before you can use the `DEFINE CONFIG GRAPHQL` statement.
- You **must** select your **namespace** and **database** before you can use the `DEFINE CONFIG GRAPHQL` statement.
- You **must** define at least one table in your database for the GraphQL API to function.
- You **must** have started the SurrealDB instance with the `SURREAL_CAPS_ALLOW_EXPERIMENTAL` environment variable set to `"graphql"`.

## Statement syntax

<Tabs syncKey="define-config-statement">
  <TabItem label="SurrealQL Syntax">

```surql title="SurrealQL Syntax"

DEFINE CONFIG [ OVERWRITE | IF NOT EXISTS ]
  ( API [ MIDDLEWARE @expression, .. ] [ PERMISSIONS [ NONE | FULL | @expression ] ]
  | GRAPHQL 
      [ AUTO | NONE ]
      [ TABLES (AUTO | NONE | INCLUDE table1, table2, ...) ]
      [ FUNCTIONS (AUTO | NONE | INCLUDE [function1, function2, ...] | EXCLUDE [function1, function2, ...]) ]
  )

```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const defineConfigAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "CONFIG" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OVERWRITE" }, { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] } ] } },
      { type: "Choice", index: 1, children: [
        { type: "Sequence", children: [
          { type: "Terminal", text: "API" },
          { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "MIDDLEWARE" }, { type: "NonTerminal", text: "@expression, .." } ] } },
          { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "PERMISSIONS" }, { type: "Choice", index: 1, children: [ { type: "Terminal", text: "NONE" }, { type: "Terminal", text: "FULL" }, { type: "NonTerminal", text: "@expression" } ] } ] } }
        ] },
        { type: "Sequence", children: [
          { type: "Terminal", text: "GRAPHQL" },
          { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "AUTO" }, { type: "Terminal", text: "NONE" } ] } },
          { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "TABLES" }, { type: "Choice", index: 1, children: [ { type: "Terminal", text: "AUTO" }, { type: "Terminal", text: "NONE" }, { type: "Sequence", children: [ { type: "Terminal", text: "INCLUDE" }, { type: "NonTerminal", text: "table1, table2, ..." } ] } ] } ] } },
          { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "FUNCTIONS" }, { type: "Choice", index: 1, children: [ { type: "Terminal", text: "AUTO" }, { type: "Terminal", text: "NONE" }, { type: "Sequence", children: [ { type: "Terminal", text: "INCLUDE" }, { type: "NonTerminal", text: "[function1, function2, ...]" } ] }, { type: "Sequence", children: [ { type: "Terminal", text: "EXCLUDE" }, { type: "NonTerminal", text: "[function1, function2, ...]" } ] } ] } ] } }
        ] }
      ] }
    ]}
  ]
};

<RailroadDiagram ast={defineConfigAst} className="my-6" />

  </TabItem>
</Tabs>

## DEFINE CONFIG API

The `DEFINE CONFIG API` statement can be used to set middleware and permissions in order to alter the behaviour of the database for guest and [record users](/docs/surrealql/statements/define/access/record). This middleware can be used in cases such as rate limiting on the query language and setting how many resources a client can read or alter at a time.

`DEFINE CONFIG API` is often used in conjunction with a [flag](/docs/surrealdb/security/capabilities) or [environment variable](/docs/surrealdb/cli/env) to disable arbitrary queries, thereby forcing record and anonymous users to interact with the database via API endpoints alone.

The following is an example of a `DEFINE CONFIG` statement that includes a timeout and a single header in the responses of all API endpoints.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE CONFIG API
    MIDDLEWARE 
        api::timeout(10s),
        api::res::headers({
            'Access-Control-Allow-Origin': '*'
        });
```

To set the actual API endpoints and their middleware, a [`DEFINE API`](/docs/surrealql/statements/define/api) statement is used for each endpoint.

The behaviour of API endpoints can be tested using the `api::invoke` method, or through a regular HTTP call to the endpoint that [includes the namespace and database name](/docs/surrealdb/integration/http#custom-endpoint-at-apinsdbendpoint).

This next example uses `DEFINE CONFIG` to set a single response header, followed by two endpoints that return different output.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ headers: { "access-control-allow-origin": '*' }, raw: false, status: 200 }"

[[test.results]]
value = "{ body: { some: 'data' }, headers: { "access-control-allow-origin": '*' }, raw: false, status: 200 }"

*/

DEFINE CONFIG API
    MIDDLEWARE 
        api::res::headers({
            'Access-Control-Allow-Origin': '*'
        });

DEFINE API "/test" FOR get THEN {};
DEFINE API "/test2" FOR get THEN {
    RETURN {
        body: {
            some: "data"
        }
    }
};

api::invoke("/test");
api::invoke("/test2");
```

The query shows that the endpoints return a combination of the `DEFINE CONFIG` middleware and the response object set in the `DEFINE API` statements.

```surql
-------- Query --------

{
	headers: {
		"access-control-allow-origin": '*'
	},
	raw: false,
	status: 200
}

-------- Query --------

{
	body: {
		some: 'data'
	},
	headers: {
		"access-control-allow-origin": '*'
	},
	raw: false,
	status: 200
}
```

Note that the middleware and permissions inside individual `DEFINE API` statements will override the middleware in a `DEFINE CONFIG API` statement. In the following example, the default `10s` timeout is set to a single microsecond for the `"/test"` endpoint, giving the intended query no time to complete.

```surql
DEFINE CONFIG API
    MIDDLEWARE 
        api::timeout(10s),
        api::res::headers({
            'Access-Control-Allow-Origin': '*'
        });

DEFINE API OVERWRITE "/test"
    FOR get 
        MIDDLEWARE
            api::timeout(1µs)
        THEN {
            RETURN {
                status: 200,
                body: { 
                    data: SELECT * FROM person,
                    however: "This will probably never return because the timeout is 1 microsecond"
                }
            };
        };

api::invoke("/test");
```

```surql title="Output"
'The query was not executed because it exceeded the timeout'
```

## DEFINE CONFIG GRAPHQL

The configuration set using the `DEFINE CONFIG GRAPHQL` is essential for enabling GraphQL functionality in your database, specifying which tables and functions should be included or excluded from the GraphQL schema.

The GraphQL configuration defined using this statement dictates how clients interact with your database through GraphQL queries and mutations.

### Important Notes

- The `DEFINE CONFIG GRAPHQL` statement **must** be executed before any GraphQL queries can be made.
- If you attempt to use the GraphQL API without defining the configuration, you will receive a `NotConfigured` error.
- If no tables are defined in the database, you will receive an error stating "No tables found in database" when attempting to use the GraphQL API.

### Example usage

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Define GraphQL configuration
DEFINE CONFIG GRAPHQL  AUTO;
```

### Tables Configuration

The `TABLES` clause in the `DEFINE CONFIG GRAPHQL` statement specifies how tables are exposed via GraphQL. There are four options for the `TABLES` configuration:

- `AUTO`: Automatically include all tables in the GraphQL schema.
- `NONE`: Do not include any tables in the GraphQL schema.
- `INCLUDE`: Specify a list of tables to include in the GraphQL schema.
- `EXCLUDE`: Specify a list of tables to exclude from the GraphQL schema.

#### `AUTO`

When you specify `TABLES AUTO`, all tables in the database are automatically included in the GraphQL schema.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE CONFIG GRAPHQL TABLES AUTO;
```

#### `NONE`

When you specify `TABLES NONE`, no tables are included in the GraphQL schema.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE CONFIG GRAPHQL TABLES NONE;
```

#### `INCLUDE`

You can specify a list of tables to include in the GraphQL schema using the `INCLUDE` clause. The list of tables is specified as a comma-separated list without brackets.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE CONFIG GRAPHQL TABLES INCLUDE user, post, comment;
```

> [!NOTE]
> The `EXCLUDE` option for `TABLES` is currently not implemented.

### Functions Configuration

The `FUNCTIONS` clause in the `DEFINE CONFIG GRAPHQL` statement specifies how functions are exposed via GraphQL. There are four options for the `FUNCTIONS` configuration:

- `AUTO`: Automatically include all functions in the GraphQL schema.
- `NONE`: Do not include any functions in the GraphQL schema.
- `INCLUDE`: Specify a list of functions to include in the GraphQL schema.
- `EXCLUDE`: Specify a list of functions to exclude from the GraphQL schema.

#### `AUTO`

When you specify `FUNCTIONS AUTO`, all functions in the database are automatically included in the GraphQL schema.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE CONFIG GRAPHQL FUNCTIONS AUTO;
```

#### `NONE`

When you specify `FUNCTIONS NONE`, no functions are included in the GraphQL schema.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE CONFIG GRAPHQL FUNCTIONS NONE;
```

#### `INCLUDE`

You can specify a list of functions to include in the GraphQL schema using the `INCLUDE` clause. The list of functions is specified as a comma-separated list enclosed in square brackets `[]`.

```surql
DEFINE CONFIG GRAPHQL FUNCTIONS INCLUDE [getUser, listPosts, searchComments];
```

#### `EXCLUDE`

You can specify a list of functions to exclude from the GraphQL schema using the `EXCLUDE` clause. The list of functions is specified as a comma-separated list enclosed in square brackets `[]`.

```surql
DEFINE CONFIG GRAPHQL FUNCTIONS EXCLUDE [debugFunction, testFunction];
```

### Using `IF NOT EXISTS` clause

The `IF NOT EXISTS` clause can be used to define the GraphQL configuration only if it does not already exist. This is useful when you want to ensure that the configuration is only created if it does not already exist, preventing errors due to duplicate definitions.

```surql
-- Define GraphQL configuration only if it does not already exist
DEFINE CONFIG GRAPHQL IF NOT EXISTS TABLES AUTO FUNCTIONS AUTO;
```

### Using `OVERWRITE` clause

The `OVERWRITE` clause can be used to redefine the GraphQL configuration, overwriting any existing configuration. This is useful when you want to update or modify the existing GraphQL configuration.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Redefine GraphQL configuration, overwriting existing configuration
DEFINE CONFIG OVERWRITE GRAPHQL TABLES INCLUDE user, post FUNCTIONS NONE;
```

### Examples

#### Example 1: Include specific tables and functions

This example defines a GraphQL configuration that includes specific tables and functions.

```surql
DEFINE CONFIG GRAPHQL TABLES INCLUDE user, post FUNCTIONS INCLUDE [getUser, listPosts];
```

#### Example 2: Automatically include all tables and functions

This example defines a GraphQL configuration that automatically includes all tables and functions.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE CONFIG GRAPHQL TABLES AUTO FUNCTIONS AUTO;
```

#### Example 3: Exclude specific functions

This example defines a GraphQL configuration that includes all functions except specific ones.

```surql
DEFINE CONFIG GRAPHQL FUNCTIONS EXCLUDE [debugFunction, testFunction];
```


### Error Handling

#### NotConfigured Error

If you attempt to access the GraphQL endpoint without defining the GraphQL configuration, you will receive a `NotConfigured` error.

```surql title="Error Response"
{
  "error": "NotConfigured: GraphQL endpoint is not configured. Please define the GraphQL configuration using DEFINE CONFIG GRAPHQL."
}
```

Execute the `DEFINE CONFIG GRAPHQL` statement to define the GraphQL configuration.

```surql
-- Define GraphQL configuration
DEFINE CONFIG GRAPHQL TABLES AUTO FUNCTIONS AUTO;
```

#### No Tables Found Error

If you have defined the GraphQL configuration but no tables are defined in the database, you will receive an error stating "No tables found in database" when attempting to use the GraphQL API. You can fix this by defining at least one table in your database using the [`DEFINE TABLE`](/docs/surrealql/statements/define/table) statement.

```surql title="Error Response"
{
  "error": "No tables found in database. Please define at least one table to use the GraphQL API."
}
```

**Solution**: Define at least one table in your database.

```surql
DEFINE TABLE foo SCHEMAFUL;
DEFINE FIELD val ON foo TYPE int;
CREATE foo:1 SET val = 42;
```

### Authentication Errors When Accessing Data via GraphQL

**Cause**: Insufficient permissions or incorrect authentication credentials.

**Solution**: Ensure you are authenticated as a user with the necessary permissions and that the permissions on tables and fields are correctly configured.

#### Authentication and Permissions

- The GraphQL API respects SurrealDB's authentication and permission model.
- You must authenticate using the appropriate credentials to access data via GraphQL.
- Permissions set on tables and fields will affect the data accessible through the GraphQL API.
- If you attempt to access data without sufficient permissions, you will receive an authentication error.



#### Example: Basic Authentication

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ email: 'user@example.com', id: foo:1, val: 42 }]"

[[test.results]]
value = "[{ email: 'other@example.com', id: foo:2, val: 43 }]"

*/

-- Define a user with access permissions
DEFINE USER my_user ON DATABASE PASSWORD 'my_password';
DEFINE ACCESS user ON DATABASE TYPE RECORD
  SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
  SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
  DURATION FOR SESSION 60s, FOR TOKEN 1d;

-- Define a table with permissions
DEFINE TABLE foo SCHEMAFUL PERMISSIONS FOR select WHERE $auth.email = email;
DEFINE FIELD email ON foo TYPE string;
DEFINE FIELD val ON foo TYPE int;

-- Insert data
CREATE foo:1 SET val = 42, email = "user@example.com";
CREATE foo:2 SET val = 43, email = "other@example.com";
```

When querying the GraphQL API as `user@example.com`, only the records where `email = "user@example.com"` will be accessible due to the permissions set.

### Examples

#### Example 1: Defining GraphQL Configuration and Fetching Data

```surql
-- Define GraphQL configuration to include all tables automatically
DEFINE CONFIG GRAPHQL TABLES AUTO;

-- Define a table and insert data
DEFINE TABLE foo SCHEMAFUL;
DEFINE FIELD val ON foo TYPE int;
CREATE foo:1 SET val = 42;
CREATE foo:2 SET val = 43;
```

Now, you can fetch data via GraphQL:

```graphql
query {
  foo {
    id
    val
  }
}
```

**Response:**

```json
{
  "data": {
    "foo": [
      {
        "id": "foo:1",
        "val": 42
      },
      {
        "id": "foo:2",
        "val": 43
      }
    ]
  }
}
```

#### Example 2: Including Specific Tables

```surql
-- Define GraphQL configuration to include only specific tables
DEFINE CONFIG OVERWRITE GRAPHQL TABLES INCLUDE foo;
```

When querying the GraphQL schema, only the included tables will be available.

#### Example 3: Using Limit, Start, Order, and Filter in GraphQL Queries

You can use `limit`, `start`, `order`, and `filter` in your GraphQL queries to control the data returned.

##### Limit

```graphql
query {
  foo(limit: 1) {
    id
    val
  }
}
```

##### Start

```graphql
query {
  foo(start: 1) {
    id
    val
  }
}
```

##### Order

```graphql
query {
  foo(order: { desc: val }) {
    id
    val
  }
}
```

##### Filter

```graphql
query {
  foo(filter: { val: { eq: 42 } }) {
    id
    val
  }
}
```

### More Information

The `DEFINE CONFIG GRAPHQL` statement is essential for enabling and configuring the GraphQL API in SurrealDB. By specifying which tables and functions are included or excluded, you can fine-tune the GraphQL schema to match your application's needs.

- **Authentication**: Ensure you are authenticated with the appropriate credentials.
- **Permissions**: Set up permissions on tables and fields to control access via GraphQL.
- **Configuration**: The GraphQL configuration must be defined before using the GraphQL API.
- **Error Handling**: Be aware of possible errors when the configuration is missing or incomplete.

> [!IMPORTANT]
> Always ensure you have the necessary permissions and have selected the appropriate namespace and database before using the `DEFINE CONFIG GRAPHQL` statement.


## Summary

- Use `DEFINE CONFIG GRAPHQL` to enable and configure the GraphQL API.
- Define your tables and set up permissions to control data access.
- Use the `OVERWRITE` and `IF NOT EXISTS` clauses as needed to manage your configuration.
- Always authenticate with appropriate credentials when accessing the GraphQL API.
- Utilize GraphQL query features like `limit`, `start`, `order`, and `filter` to control the data returned.

By following these guidelines, you can effectively use the `DEFINE CONFIG GRAPHQL` statement to configure and interact with your SurrealDB database via GraphQL.



================================================
FILE: src/content/doc-surrealql/statements/define/database.mdx
================================================
---
sidebar_position: 6
sidebar_label: DEFINE DATABASE
title: DEFINE DATABASE statement | SurrealQL
description: The DEFINE DATABASE statement allows you to instantiate a named database, enabling you to specify security and configuration options.
---
import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `DEFINE DATABASE` statement

The `DEFINE DATABASE` statement allows you to instantiate a named database, enabling you to specify security and configuration options.

## Requirements

- You must be authenticated as a root owner or editor, or namespace owner or editor before you can use the `DEFINE DATABASE` statement.
- [You must select your namespace](/docs/surrealql/statements/use) before you can use the `DEFINE DATABASE` statement.

## Statement syntax

<Tabs syncKey="define-database-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
DEFINE DATABASE [ OVERWRITE | IF NOT EXISTS ] @name [ COMMENT @string ]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const defineDatabaseAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "DATABASE" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OVERWRITE" }, { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] } ] } },
      { type: "NonTerminal", text: "@name" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "COMMENT" }, { type: "NonTerminal", text: "@string" } ] } }
    ]}
  ]
};

<RailroadDiagram ast={defineDatabaseAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage
Below shows how you can create a database using the DEFINE DATABASE statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Specify the namespace for the database
USE NS abcum;

-- Define database
DEFINE DATABASE app_vitalsense;
```

## Using `IF NOT EXISTS` clause

<Since v="v1.3.0" />

The `IF NOT EXISTS` clause can be used to define a database only if it does not already exist. You should use the `IF NOT EXISTS` clause when defining a database in SurrealDB if you want to ensure that the database is only created if it does not already exist. If the database already exists, the `DEFINE DATABASE` statement will return an error.

It's particularly useful when you want to safely attempt to define a database without manually checking its existence first.

On the other hand, you should not use the `IF NOT EXISTS` clause when you want to ensure that the database definition is updated regardless of whether it already exists. In such cases, you might prefer using the `OVERWRITE` clause, which allows you to define a database and overwrite an existing one if it already exists, ensuring that the latest version of the definition is always in use.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a database if it does not already exist
DEFINE DATABASE IF NOT EXISTS app_vitalsense;
```

## Using `OVERWRITE` clause

<Since v="v2.0.0" />

The `OVERWRITE` clause can be used to define a database and overwrite an existing one if it already exists. You should use the `OVERWRITE` clause when you want to modify an existing database definition. If the database already exists, the `DEFINE DATABASE` statement will overwrite the existing definition with the new one.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a database and overwrite if it already exists
DEFINE DATABASE OVERWRITE app_vitalsense;
```



================================================
FILE: src/content/doc-surrealql/statements/define/event.mdx
================================================
---
sidebar_position: 7
sidebar_label: DEFINE EVENT
title: DEFINE EVENT statement | SurrealQL
description: The DEFINE EVENT statement can be used to create events which can be triggered after any change or modification to the data in a record.
---

import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `DEFINE EVENT` statement

Events allow you to define custom logic that is executed when a record is created, updated, or deleted. These events are triggered automatically within the current transaction after data modifications in the record, giving you access to the state of the record [before `$before` and after `$after`](/docs/surrealql/parameters#before-after) the change.

> [!NOTE]
> Events are a side effect of other operations and thus are not triggered when data is [imported](/docs/surrealdb/cli/import).

### Key Concepts

- **Events**: Triggered after changes (create, update, delete) to records in a table.
* **$event**: A preset parameter containing the type of event as a string, will always be one of "CREATE", "UPDATE", or "DELETE".
- **$before / $after**: Refer to the record state before and after the modification. Learn more about the `$before` and `$after` parameters in the [parameters documentation](/docs/surrealql/parameters#before-after).
- **$value**: The record in question. For a `CREATE` or `UPDATE` event, this will be the record after the changes were made. For a `DELETE` statement, this will be the record before it was deleted.
- **WHEN condition**: Determines when the event should be triggered.

## Requirements

- You must be authenticated as a root owner or editor, namespace owner or editor, or database owner or editor before you can use the `DEFINE EVENT` statement.
- [You must select your namespace and database](/docs/surrealql/statements/use) before you can use the `DEFINE EVENT` statement.

## Statement syntax

<Tabs syncKey="define-event-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
DEFINE EVENT [ OVERWRITE | IF NOT EXISTS ] @name ON [ TABLE ] @table [ WHEN @expression ] THEN @expression [ COMMENT @string ]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const defineEventAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "EVENT" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OVERWRITE" }, { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] } ] } },
      { type: "NonTerminal", text: "@name" },
      { type: "Terminal", text: "ON" },
      { type: "Optional", child: { type: "Terminal", text: "TABLE" } },
      { type: "NonTerminal", text: "@table" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "WHEN" }, { type: "NonTerminal", text: "@expression" } ] } },
      { type: "Terminal", text: "THEN" },
      { type: "NonTerminal", text: "@expression" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "COMMENT" }, { type: "NonTerminal", text: "@string" } ] } }
    ]}
  ]
};

<RailroadDiagram ast={defineEventAst} className="my-6" />

  </TabItem>
</Tabs>

### Clauses:

- **OVERWRITE**: Replaces the existing event if it already exists.
- **IF NOT EXISTS**: Only creates the event if it doesn't already exist.
- **WHEN**: Conditional logic that controls whether the event is triggered.
- **THEN**: Specifies the action(s) to execute when the event is triggered.
- **COMMENT**: Optional comment for describing the event.

## Example usage

-  **Email Change Detection**: Create an event that logs whenever a user's email is updated.

In this example:
- The `WHEN` clause checks if the email has changed.
- The `THEN` clause records this change in a `log` table.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ email: 'old_email@test.com', id: user:test }]"

[[test.results]]
value = "[{ email: 'new_email@test.com', id: user:test }]"

[[test.results]]
value = "[]"

[[test.results]]
value = "[{ action: 'email created', at: d'2025-10-07T05:57:35.399269Z', id: log:ehhri1t7006hxcsg8bb5, new_email: 'old_email@test.com', old_email: '', user: user:test }, { action: 'email updated', at: d'2025-10-07T05:57:39.687764Z', id: log:rg89w4a05zcgictbdk8d, new_email: 'new_email@test.com', old_email: 'old_email@test.com', user: user:test }, { action: 'email deleted', at: d'2025-10-07T05:58:15.120426Z', id: log:11dpjy6rrk23jse8ee8b, new_email: '', old_email: 'new_email@test.com', user: user:test }]"
skip-record-id-key = true
skip-datetime = true

*/

-- Create a new event whenever a user changes their email address
-- One-statement event
DEFINE EVENT OVERWRITE test ON TABLE user WHEN $before.email != $after.email THEN (
    CREATE log SET 
        user       = $value.id,
        // Turn events like "CREATE" into string "email created"
        action     = 'email' + ' ' + $event.lowercase() + 'd',
        // `email` field may be NONE, log as '' if so
        old_email  = $before.email ?? '',
        new_email  = $after.email  ?? '',
        at         = time::now()
);
UPSERT user:test SET email = 'old_email@test.com';
UPSERT user:test SET email = 'new_email@test.com';
DELETE user:test;
SELECT * FROM log ORDER BY at ASC;
```

```surql title="Output"
[
	{
		action: 'email created',
		at: d'2024-11-25T02:59:41.003Z',
		id: log:e3thw1l0q7xiapznar1f,
		new_email: 'old_email@test.com',
		old_email: '',
		user: user:test
	},
	{
		action: 'email updated',
		at: d'2024-11-25T02:59:41.003Z',
		id: log:uaarfyk191jgod06xobm,
		new_email: 'new_email@test.com',
		old_email: 'old_email@test.com',
		user: user:test
	},
	{
		action: 'email deleted',
		at: d'2024-11-25T02:59:41.003Z',
		id: log:mlkag8h1xotglpz9wt2i,
		new_email: '',
		old_email: 'new_email@test.com',
		user: user:test
	}
]
```

### More complex logic:

-  **Purchase Event with Multiple Actions**: Log a purchase and establish relationships between the customer and product.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE EVENT purchase_made ON TABLE purchase
    WHEN $before == NONE
    THEN {
        LET $customer = (SELECT * FROM customer WHERE id = $after.customer);
        LET $product = (SELECT * FROM product WHERE id = $after.product);

        RELATE $customer->bought->$product CONTENT {
            quantity: $after.quantity,
            total: $after.total,
            status: 'Pending',
        };

        CREATE log SET
            customer_id = $after.customer,
            product_id = $after.product,
            action = 'purchase_created',
            timestamp = time::now();
    };
```

In this example:

- We perform multiple actions when a purchase is created: establishing relationships using the [RELATE](/docs/surrealql/statements/relate) statement and creating a log entry.

## Specific events

You can trigger events based on specific events. You can use the variable $event to detect what type of event is triggered on the table.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- CREATE event is triggered when a new record is inserted into the table.
-- Here we are updating the status of the post to PUBLISHED
-- when a new record is inserted into the publish_post table.
DEFINE EVENT publish_post ON TABLE publish_post
    WHEN $event = "CREATE"
    THEN (
        UPDATE post SET status = "PUBLISHED" WHERE id = $after.post_id
    );

-- UPDATE event
-- Here we are creating a notification when a user is updated.
DEFINE EVENT user_updated ON TABLE user
    WHEN $event = "UPDATE"
    THEN (
        CREATE notification SET message = "User updated", user_id = $after.id, created_at = time::now()
    );

-- DELETE event is triggered when a record is deleted from the table.
-- Here we are creating a notification when a user is deleted.
DEFINE EVENT user_deleted ON TABLE user
    WHEN $event = "DELETE"
    THEN (
        CREATE notification SET message = "User deleted", user_id = $before.id, created_at = time::now()
    );

-- You can combine multiple events based on your use cases.
-- Here we are creating a log when a user is created, updated or deleted.
DEFINE EVENT user_event ON TABLE user
    WHEN $event = "CREATE" OR $event = "UPDATE" OR $event = "DELETE"
    THEN (
        CREATE log SET
            table = "user",
            event = $event,
            happened_at = time::now()
    );
```

## Using `IF NOT EXISTS` clause

<Since v="v1.3.0" />

The `IF NOT EXISTS` clause can be used to define an event only if it does not already exist. You should use the `IF NOT EXISTS` clause when defining an event in SurrealDB if you want to ensure that the event is only created if it does not already exist. If the event already exists, the `DEFINE EVENT` statement will return an error.

It's particularly useful when you want to safely attempt to define a event without manually checking its existence first.

On the other hand, you should not use the `IF NOT EXISTS` clause when you want to ensure that the event definition is updated regardless of whether it already exists. In such cases, you might prefer using the `OVERWRITE` clause, which allows you to define a event and overwrite an existing one if it already exists, ensuring that the latest version of the event definition is always in use

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a EVENT if it does not already exist
DEFINE EVENT IF NOT EXISTS example ON example THEN {};
```

## Using `OVERWRITE` clause

<Since v="v2.0.0" />

The `OVERWRITE` clause can be used to define an event and overwrite an existing one if it already exists. You should use the `OVERWRITE` clause when you want to modify an existing event definition. If the event already exists, the `DEFINE EVENT` statement will overwrite the existing event definition with the new one.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create an EVENT and overwrite if it already exists
DEFINE EVENT OVERWRITE example ON example THEN {};
```

## Events and permissions

Queries inside the event always execute without any permission checks, even when triggered by changes made by the currently authenticated user. This can be very useful to perform additional checks and changes that involve tables/records that are inaccessible for the user.

Consider a CREATE query sent by a record user that has CREATE access to the `comment` table only:

```surql
CREATE comment SET
    post = post:tomatosoup,
    content = "So delicious!",
    author = $auth.id
;
```

By having the following event defined, SurrealDB will perform the additional checks and changes:

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE EVENT on_comment_created ON TABLE comment
    WHEN $event = "CREATE"
    THEN {
        -- Check if the post allows for adding comments.
        -- User record doesn't have access to the `post` table.
        IF $after.post.disable_comments {
            THROW "Can't create a comment - Comments are disabled for this post";
        };

        -- Set the `approved` field on the new comment - automatically approve
        -- comments made by the author of the post.
        -- For security reasons, record users don't have any permissions for the `approved` field.
        UPDATE $after.id SET
            approved = $after.post.author == $after.author;
    };
```

## Accessing `$input` in events

<Since v="v3.0.0-alpha.11" />

The behaviour of events can be further refined via the `$input` parameter, which represents the record in question for the event.

```surql
-- Set CREATE in event to only trigger when record has `true` for `log_event`
DEFINE EVENT something ON person WHEN $input.log_event = true THEN {
    CREATE log SET at = time::now(), of = $input;
};

-- Set to `false`, does not trigger CREATE
CREATE person:debug SET name = "Billy", log_event = false;
-- Triggers CREATE
CREATE person:real SET name = "Bobby", log_event = true;

SELECT * FROM log;
```

Output:

```surql
[
	{
		at: d'2025-10-14T06:15:21.141Z',
		id: log:svbr2qhjywml20mufb0o,
		of: {
			log_event: true,
			name: 'Bobby'
		}
	}
]
```


================================================
FILE: src/content/doc-surrealql/statements/define/field.mdx
================================================
---
sidebar_position: 8
sidebar_label: DEFINE FIELD
title: DEFINE FIELD statement | SurrealQL
description: The DEFINE FIELD statement allows you to instantiate a named field on a table, enabling you to set the field's achema and configuration.
---

import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `DEFINE FIELD` statement

The `DEFINE FIELD` statement allows you to instantiate a named field on a table, enabling you to set the field's data type, set a default value, apply assertions to protect data consistency, and set permissions specifying what operations can be performed on the field.

## Requirements

- You must be authenticated as a root owner or editor, namespace owner or editor, or database owner or editor before you can use the `DEFINE FIELD` statement.
- [You must select your namespace and database](/docs/surrealql/statements/use) before you can use the `DEFINE FIELD` statement.

## Statement syntax

<Tabs syncKey="define-field-statement">
  <TabItem label="Regular Field Syntax">

### Regular fields

```syntax title="SurrealQL Syntax"
DEFINE FIELD [ OVERWRITE | IF NOT EXISTS ] @name ON [ TABLE ] @table
	[ [ FLEXIBLE ] TYPE @type ]
	[ REFERENCE 
		[   ON DELETE REJECT | 
			ON DELETE CASCADE | 
			ON DELETE IGNORE |
			ON DELETE UNSET | 
			ON DELETE THEN @expression ]
	]
	[ DEFAULT [ALWAYS] @expression ]
  [ READONLY ]
	[ VALUE @expression ]
	[ ASSERT @expression ]
	[ PERMISSIONS [ NONE | FULL
		| FOR select @expression
		| FOR create @expression
		| FOR update @expression
	] ]
  [ COMMENT @string ]
```

  </TabItem>
  <TabItem label="Computed Field Syntax">

### Computed fields

<Since v="v3.0.0-alpha.8" />

> [!NOTE]
> In versions of SurrealDB before 3.0.0-alpha.8, `COMPUTED` fields were implemented using a data type called a `future`. Please see [the page on futures](/docs/surrealql/datamodel/futures) in this case.

A `COMPUTED` field is one that is not stored but computed every time it is accessed. Such fields have a more limited set of clauses that can be used. Furthermore, a `COMPUTED` field cannot be defined on the `id` field of a record, nor any nested fields (i.e. a field `metadata` can be defined as computed, but not `medatata.can_drive`).

```syntax title="SurrealQL Syntax"
DEFINE FIELD [ OVERWRITE | IF NOT EXISTS ] @name ON [ TABLE ] @table
	COMPUTED @expression
	[ TYPE @type ]
	[ PERMISSIONS [ NONE | FULL
		| FOR select @expression
		| FOR create @expression
		| FOR update @expression
	] ]
  [ COMMENT @string ]
```

  </TabItem>
  <TabItem label="Railroad Diagram (Regular)">

export const defineFieldRegularAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "FIELD" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OVERWRITE" }, { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] } ] } },
      { type: "NonTerminal", text: "@name" },
      { type: "Terminal", text: "ON" },
      { type: "Optional", child: { type: "Terminal", text: "TABLE" } },
      { type: "NonTerminal", text: "@table" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Optional", child: { type: "Terminal", text: "FLEXIBLE" } }, { type: "Terminal", text: "TYPE" }, { type: "NonTerminal", text: "@type" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "REFERENCE" }, { type: "Optional", child: { type: "Choice", index: 1, children: [
        { type: "Sequence", children: [ { type: "Terminal", text: "ON" }, { type: "Terminal", text: "DELETE" }, { type: "Terminal", text: "REJECT" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "ON" }, { type: "Terminal", text: "DELETE" }, { type: "Terminal", text: "CASCADE" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "ON" }, { type: "Terminal", text: "DELETE" }, { type: "Terminal", text: "IGNORE" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "ON" }, { type: "Terminal", text: "DELETE" }, { type: "Terminal", text: "UNSET" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "ON" }, { type: "Terminal", text: "DELETE" }, { type: "Terminal", text: "THEN" }, { type: "NonTerminal", text: "@expression" } ] }
      ] } } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "DEFAULT" }, { type: "Optional", child: { type: "Terminal", text: "ALWAYS" } }, { type: "NonTerminal", text: "@expression" } ] } },
      { type: "Optional", child: { type: "Terminal", text: "READONLY" } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "VALUE" }, { type: "NonTerminal", text: "@expression" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "ASSERT" }, { type: "NonTerminal", text: "@expression" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "PERMISSIONS" }, { type: "Choice", index: 1, children: [
        { type: "Terminal", text: "NONE" },
        { type: "Terminal", text: "FULL" },
        { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "select" }, { type: "NonTerminal", text: "@expression" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "create" }, { type: "NonTerminal", text: "@expression" } ] },
        { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "update" }, { type: "NonTerminal", text: "@expression" } ] }
      ] } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "COMMENT" }, { type: "NonTerminal", text: "@string" } ] } }
    ]}
  ]
};

<RailroadDiagram ast={defineFieldRegularAst} className="my-6" />

  </TabItem>
  <TabItem label="Railroad Diagram (Computed)">

export const defineFieldComputedAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "FIELD" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OVERWRITE" }, { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] } ] } },
      { type: "NonTerminal", text: "@name" },
      { type: "Terminal", text: "ON" },
      { type: "Optional", child: { type: "Terminal", text: "TABLE" } },
      { type: "NonTerminal", text: "@table" },
      { type: "Terminal", text: "COMPUTED" },
      { type: "NonTerminal", text: "@expression" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "TYPE" }, { type: "NonTerminal", text: "@type" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "PERMISSIONS" }, { type: "Choice", index: 1, children: [ { type: "Terminal", text: "NONE" }, { type: "Terminal", text: "FULL" }, { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "select" }, { type: "NonTerminal", text: "@expression" } ] }, { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "create" }, { type: "NonTerminal", text: "@expression" } ] }, { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "update" }, { type: "NonTerminal", text: "@expression" } ] } ] } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "COMMENT" }, { type: "NonTerminal", text: "@string" } ] } }
    ]}
  ]
};

<RailroadDiagram ast={defineFieldComputedAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

The following expression shows the simplest way to use the `DEFINE FIELD` statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Declare the name of a field.
DEFINE FIELD email ON TABLE user;
```

The fields of an object and the items in an array can be defined individually using the `.` operator for objects, or the indexing operator for arrays.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Define nested object property types
DEFINE FIELD emails.address ON TABLE user TYPE string;
DEFINE FIELD emails.primary ON TABLE user TYPE bool;

-- Define individual fields on an array
DEFINE FIELD metadata[0] ON person TYPE datetime;
DEFINE FIELD metadata[1] ON person TYPE int;
```

## Defining data types

The `DEFINE FIELD` statement allows you to set the data type of a field. For a full list of supported data types, see [Data types](/docs/surrealql/datamodel).

From version `v2.2.0`, when defining nested fields, where both the parent and the nested fields have types defined, it is no longer possible to have mismatching types, to prevent any impossible type issues once the schema is defined.

For example, the following will fail:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
error = "'Cannot set field `fd.*` with type `number` as it mismatched with field `fd` with type `{ a: string, b: number }`'"

*/

DEFINE FIELD OVERWRITE fd ON c TYPE { a: string, b: number };
DEFINE FIELD OVERWRITE fd.* ON c TYPE number;
```

The above will fail with the following error:

```
'Cannot set field `fd.*` with type `number` as it mismatched with field `fd` with type `{ a: string, b: number }`'
```


### Simple data types

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Set a field to have the string data type
DEFINE FIELD email ON TABLE user TYPE string;

-- Set a field to have the datetime data type
DEFINE FIELD created ON TABLE user TYPE datetime;

-- Set a field to have the bool data type
DEFINE FIELD locked ON TABLE user TYPE bool;

-- Set a field to have the number data type
DEFINE FIELD login_attempts ON TABLE user TYPE number;
```

A `|` vertical bar can be used to allow a field to be one of a set of types. The following example shows a field that can be a [`UUID`](/docs/surrealql/datamodel/uuid) or an [`int`](/docs/surrealql/datamodel/numbers#integer-numbers), perhaps for `user` records that have varying data due to two diffent legacy ID types.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Set a field to have either the uuid or int type
DEFINE FIELD user_id ON TABLE user TYPE uuid|int;
```

### Array type

You can also set a field to have the array data type. The array data type can be used to store a list of values. You can also set the data type of the array's contents, as well as the maximum number of items that it can hold.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Set a field to have the array data type
DEFINE FIELD roles ON TABLE user TYPE array<string>;

-- Set a field to have the array data type, equivalent to `array<any>`
DEFINE FIELD posts ON TABLE user TYPE array;

-- Set a field to have the array object data type
DEFINE FIELD emails ON TABLE user TYPE array<object>;

-- Field for a block in a game showing the possible directions a character can move next.
-- The array can contain no more than four directions
DEFINE FIELD next_paths ON TABLE block TYPE array<"north" | "east" | "south" | "west", 4>;
```

### Making a field optional

You can make a field optional by wrapping the inner type in an `option`, which allows you to store `NONE` values in the field.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- A user may enter a biography, but it is not required.
-- By using the option type you also allow for NONE values.
DEFINE FIELD biography ON TABLE user TYPE option<string>;
```

The example below shows how to define a field `user` on a `POST` table. The field is of type [record](/docs/surrealql/datamodel/records). This means that the field can store a `record<user>` or `NONE`.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE FIELD user ON TABLE post TYPE option<record<user>>;
```

### Flexible data types

Flexible types allow you to have `SCHEMALESS` functionality on a `SCHEMAFULL` table. This is necessary for working with nested `object` types that need to be able to accept fields that have not yet been defined.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

DEFINE TABLE user SCHEMAFULL;
DEFINE FIELD name ON TABLE user TYPE string;
DEFINE FIELD metadata ON TABLE user FLEXIBLE TYPE object;
DEFINE FIELD metadata.user_id ON TABLE user TYPE int;
```

Taking the following `CREATE` statement:

```surql
CREATE ONLY user SET
    name = "User1",
    metadata = {
        user_id: 8876687,
        country_code: "ee",
        time_zone: "EEST",
        age: 25
};
```

Without `FLEXIBLE`, the `metadata` field will effectively be a `SCHEMAFULL` object with only a single defined field and thus unable to hold any of the other values that the user attempted to pass in.

```surql
{
	id: user:ke8w4u38gbm3ofp2u8fb,
	metadata: {
		user_id: 8876687
	},
	name: 'User1'
}
```

With `FLEXIBLE`, the output will be as expected as the schema now allows any sort of object to be a field on the `user` table — as long as values for `name` and `metadata.user_id` are present.

```surql title="Response"
{
	id: user:lsdk473e279oik1k484b,
	metadata: {
		age: 25,
		country_code: 'ee',
		time_zone: 'EEST',
		user_id: 8876687
	},
	name: 'User1'
}
```

The same `user` record without any defined fields or the `FLEXIBLE` clause would not fail, but none of the data besides the ID for the `user` record would be recognized.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ id: user:lhf0vbxdftn4abw070tu, metadata: {  } }"
skip-record-id-key = true

*/

DEFINE TABLE user SCHEMAFULL;
DEFINE FIELD metadata ON TABLE user TYPE object;

CREATE ONLY user SET
    name = "User1",
    metadata = {
        user_id: 8876687,
        country_code: "ee",
        time_zone: "EEST",
        age: 25
};
```

```surql title="Response"

{
	id: user:6qjj67lh6z4y1cvpsalx,
	metadata: {}
}
```

### Using the `DEFAULT` clause to set a default value

You can set a default value for a field using the `DEFAULT` clause. The default value will be used if no value is provided for the field.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- A user is not locked by default.
DEFINE FIELD locked ON TABLE user TYPE bool
-- Set a default value if empty
  DEFAULT false;
```

### Using the `DEFAULT` and `ALWAYS` clause

<Since v="v2.2.0" />

In addition to the `DEFAULT` clause, you can use the `DEFAULT ALWAYS` clause to set a default value for a field. The `ALWAYS` keyword indicates that the `DEFAULT` clause is used not only on `CREATE`, but also on `UPDATE` if the value is empty (NONE).


```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

DEFINE TABLE product SCHEMAFULL;
-- Set a default value of 123.456 for the primary field
DEFINE FIELD primary ON product TYPE number DEFAULT ALWAYS 123.456;
```

With the above definition, the `primary` field will be set to `123.456` when a new `product` is created without a value for the `primary` field or with a value of `NONE`, and when an existing `product` is updated if the value is specified the result will be the new value. 

In the case of `NULL` or a mismatching type, an error will be returned.

```surql
-- This will return an error
CREATE product:test SET primary = NULL;

-- result 
"Couldn't coerce value for field `primary` of `product:test`: Expected `number` but found `NULL`"
```

On the other hand, if a valid number is provided during creation or update, that number will be used instead of the default value. In this case, `123.456`.

```surql
-- This will set the value of the `primary` field to `123.456`
CREATE product:test;

-- This will set the value of the `primary` field to `463.456`
UPSERT product:test SET primary = 463.456;

-- This will set the value of the `primary` field to `123.456`
UPSERT product:test SET primary = NONE;

```

```surql title="Query"
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: post:test, tags: [] }]"

[[test.results]]
value = "[{ id: post:test, tags: [{ color: 'red', name: 'test' }] }]"

[[test.results]]
value = "[{ id: post:test, tags: [{ color: 'red', name: 'test' }, { color: 'blue', name: 'test' }] }]"

*/

DEFINE TABLE post SCHEMAFULL;
DEFINE FIELD tags ON post TYPE array<object> DEFAULT ALWAYS [];
DEFINE FIELD tags.*.color ON post TYPE string DEFAULT ALWAYS 'red';
DEFINE FIELD tags.*.name ON post TYPE string;
--
CREATE post:test;
UPSERT post:test SET tags += { name: 'test' };
UPSERT post:test SET tags += { name: 'test', color: 'blue' };
```

```surql title="Response"
[{ id: post:test, tags: [] }]

[{ id: post:test, tags: [{ color: 'red', name: 'test' }] }]

[{ id: post:test, tags: [{ color: 'red', name: 'test' }, { color: 'blue', name: 'test' }] }]
```

### Using the `VALUE` clause to set a field's value

The `VALUE` clause differs from `DEFAULT` in that a default value is calculated if no other is indicated, otherwise accepting the value given in a query.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: user:a856d1al1kiw5aasfu23, updated: d'1900-01-01T00:00:00Z' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ id: user:a856d1al1kiw5aasfu23, updated: d'1910-01-01T00:00:00Z' }]"
skip-record-id-key = true

*/

DEFINE FIELD updated ON TABLE user DEFAULT time::now();

-- Set `updated` to the year 1900
CREATE user SET updated = d"1900-01-01";
-- Then set to the year 1910
UPDATE user SET updated = d"1910-01-01";
```

A `VALUE` clause, on the other hand, will ignore attempts to set the field to any other value.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: user:059nm0eomnrwvq692i3i, updated: d'2025-10-07T07:48:06.852628Z' }]"
skip-record-id-key = true
skip-datetime = true

[[test.results]]
value = "[{ id: user:059nm0eomnrwvq692i3i, updated: d'2025-10-07T07:48:06.855302Z' }]"
skip-record-id-key = true
skip-datetime = true

*/

DEFINE FIELD updated ON TABLE user VALUE time::now();

-- Ignores 1900 date, sets `updated` to current time
CREATE user SET updated = d"1900-01-01";
-- Ignores again, updates to current time
UPDATE user SET updated = d"1900-01-01";
```

As the example above shows, a `VALUE` clause sets the value every time a record is modified (created or updated). However, the value will not be recalculated in a `SELECT` statement, which simply accesses the current set value.

```surql
DEFINE FIELD updated ON TABLE user VALUE time::now();

CREATE user:one;
SELECT * FROM ONLY user:one;
-- Sleep for one second
SLEEP 1s;
-- `updated` is still the same
SELECT * FROM ONLY user:one;
```

To create a field that is calculated each time it is accessed, a [`computed field`](/docs/surrealql/statements/define/field#computed-fields) can be used.

```surql
DEFINE FIELD accessed_at ON TABLE user COMPUTED time::now();

CREATE user:one;
SELECT * FROM ONLY user:one;
-- Sleep for one second
SLEEP 1s;
-- `accessed_at` is a different value now
SELECT * FROM ONLY user:one;
```

### Altering a passed value

You can alter a passed value using the `VALUE` clause. This is useful for altering the value of a field before it is stored in the database.

In the example below, the `VALUE` clause is used to ensure that the email address is always stored in lowercase characters by using the [`string::lowercase`](/docs/surrealql/functions/database/string#stringlowercase) function.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Ensure that an email address is always stored in lowercase characters
DEFINE FIELD email ON TABLE user TYPE string
  VALUE string::lowercase($value);
```

## Asserting rules on fields

You can take your field definitions even further by using asserts. Assert can be used to ensure that your data remains consistent. For example you can use asserts to ensure that a field is always a valid email address, or that a number is always positive.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Give the user table an email field. Store it in a string
DEFINE FIELD email ON TABLE user TYPE string
  -- Check if the value is a properly formatted email address
  ASSERT string::is_email($value);
```

As the `ASSERT` clause expects an expression that returns a boolean, an assertion with a custom message can be manually created by returning `true` in one case and using a [`THROW`](/docs/surrealql/statements/throw) clause otherwise.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
error = "'An error occurred: Tried to make a { id: data:one, num: 11 } but `num` field requires an even number'"

*/

DEFINE FIELD num ON data TYPE int ASSERT {
    IF $input % 2 = 0 {
        RETURN true
    } ELSE {
        THROW "Tried to make a " + <string>$this + " but `num` field requires an even number"
    }
};

CREATE data:one SET num = 11;
```

```surql title="Error output"
'An error occurred: Tried to make a { id: data:one, num: 11 } but `num` field requires an even number'
```

### Making a field `READONLY`

<Since v="v1.2.0" />

The `READONLY` clause can be used to prevent any updates to a field. This is useful for fields that are automatically updated by the system. To make a field `READONLY`, add the `READONLY` clause to the `DEFINE FIELD` statement. As seen in the example below, the `created` field is set to `READONLY`.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE FIELD created ON resource VALUE time::now() READONLY;
```

## Using `IF NOT EXISTS` clause

<Since v="v1.3.0" />

The `IF NOT EXISTS` clause can be used to define a field only if it does not already exist. You should use the `IF NOT EXISTS` clause when defining a field in SurrealDB if you want to ensure that the field is only created if it does not already exist. If the field already exists, the `DEFINE FIELD` statement will return an error.

It's particularly useful when you want to safely attempt to define a field without manually checking its existence first.

On the other hand, you should not use the `IF NOT EXISTS` clause when you want to ensure that the field definition is updated regardless of whether it already exists. In such cases, you might prefer using the `OVERWRITE` clause, which allows you to define a field and overwrite an existing one if it already exists, ensuring that the latest version of the definition is always in use

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a field if it does not already exist
DEFINE FIELD IF NOT EXISTS email ON TABLE user TYPE string;
```

## Using `OVERWRITE` clause

<Since v="v2.0.0" />

The `OVERWRITE` clause can be used to define a field and overwrite an existing one if it already exists. You should use the `OVERWRITE` clause when you want to modify an existing field definition. If the field already exists, the `DEFINE FIELD` statement will overwrite the existing definition with the new one.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Overwrite the current field definition if it already exists
DEFINE FIELD OVERWRITE example ON TABLE user TYPE string;
```

## Setting permissions on fields

By default, the permissions on a field will be set to FULL unless otherwise specified.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ events: {  }, fields: { some_info: 'DEFINE FIELD some_info ON some_table TYPE string PERMISSIONS FULL' }, indexes: {  }, lives: {  }, tables: {  } }"

*/

DEFINE FIELD some_info ON TABLE some_table TYPE string;
INFO FOR TABLE some_table;
```

```surql title="Response"
{
	events: {},
	fields: {
		info: 'DEFINE FIELD info ON some_table TYPE string PERMISSIONS FULL'
	},
	indexes: {},
	lives: {},
	tables: {}
}
```

You can set permissions on fields to control who can perform operations on them using the `PERMISSIONS` clause. The `PERMISSIONS` clause can be used to set permissions for `SELECT`, `CREATE`, and `UPDATE` operations. The `DELETE` operation only relates to records and, as such, is not available for fields.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Set permissions for the email field
DEFINE FIELD email ON TABLE user
  PERMISSIONS
    FOR select WHERE published=true OR user=$auth.id
    FOR update WHERE user=$auth.id OR $auth.role="admin";
```

## Array with allowed values
By using an Access Control List as an example we can show how we can restrict what values can be stored in an array. In this example we are using an array to store the permissions for a user on a resource. The permissions are restricted to a specific set of values.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ email: 'Tobie.Hitchcock@surrealdb.com', firstName: 'Tobie', id: user:tobie, lastName: 'Hitchcock' }]""
skip-record-id-key = true

[[test.results]]
value = "[{ email: 'c@d.com', firstName: 'A', id: user:abc, lastName: 'B' }]"

[[test.results]]
value = "[{ email: 'g@h.com', firstName: 'E', id: user:efg, lastName: 'F' }]""

[[test.results]]
value = "[{ id: document:SurrealDB_whitepaper, name: 'some messaging queue' }]"

[[test.results]]
value = "[{ id: acl:8xq08j6rackxaydwu5u9, permissions: ['create', 'write', 'read'], resource: document:SurrealDB_whitepaper, user: user:tobie }]"

[[test.results]]
value = "[{ id: acl:lov6b2y9jf7m05jsjzrc, permissions: ['read', 'delete'], resource: document:SurrealDB_whitepaper, user: user:abc }]"

[[test.results]]
error = ""Found [] for field `permissions`, with record `acl:invalid`, but field must conform to: (array::len($value) > 0) AND ($value ALLINSIDE ['create', 'read', 'write', 'delete'])""

[[test.results]]
error = ""Found ['all'] for field `permissions`, with record `acl:also_invalid`, but field must conform to: (array::len($value) > 0) AND ($value ALLINSIDE ['create', 'read', 'write', 'delete'])""

*/

-- An ACL can be applied to any kind of resource (record)
DEFINE FIELD resource ON TABLE acl TYPE record;
-- We associate the acl with a user using record<user>
DEFINE FIELD user ON TABLE acl TYPE record<user>;

-- The permissions for the user+resource will be stored in an array.
DEFINE FIELD permissions ON TABLE acl TYPE array
  -- The array must not be empty because at least one permission is required to make a valid ACL
  -- The items in the array must also be restricted to specific permissions
  ASSERT
      array::len($value) > 0
      AND $value ALLINSIDE ["create", "read", "write", "delete"];

-- SEE IT IN ACTION
-- 1: Add users
CREATE user:tobie SET firstName = 'Tobie', lastName = 'Hitchcock',
  email = 'Tobie.Hitchcock@surrealdb.com';
CREATE user:abc SET firstName = 'A', lastName = 'B',
  email = 'c@d.com';
CREATE user:efg SET firstName = 'E', lastName = 'F',
  email = 'g@h.com';

-- 2: Create a resource
CREATE document:SurrealDB_whitepaper SET
  name = "some messaging queue";

-- 3: Associate with ACL
CREATE acl SET user = user:tobie, resource = document:SurrealDB_whitepaper, permissions = ["create", "write", "read"];
CREATE acl SET user = user:abc, resource = document:SurrealDB_whitepaper, permissions = ["read", "delete"];

-- Test Asserts using failure examples
-- A: Create ACL without permissions field
CREATE acl:invalid SET
  user = user:efg,
  permissions = [], # FAIL - permissions must not be empty
  resource = document:SurrealDB_whitepaper;
-- B: Create acl with invalid permisson
CREATE acl:also_invalid SET
  user = user:efg,
  permissions = ["all"], # FAIL - This value is not allowed in the array
  resource = document:SurrealDB_whitepaper;
```
## Using RegEX to validate a string

You can use the `ASSERT` clause to apply a regular expression to a field to ensure that it matches a specific pattern. In the example below, the `ASSERT` clause is used to ensure that the `countrycode` field is always a valid ISO-3166 country code.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Specify a field on the user table
DEFINE FIELD countrycode ON user TYPE string
	-- Ensure country code is ISO-3166
	ASSERT $value = /[A-Z]{3}/
	-- Set a default value if empty
	VALUE $value OR $before OR 'GBR'
;
```

## Interacting with other fields of the same record

While a `DEFINE TABLE` statement represents a template for any subsequent records to be created, a `DEFINE FIELD` statement pertains to concrete field data of a record. As such, a `DEFINE FIELD` statement gives access to the record's other fields through their names, as well as the current field through the [`$value`](/docs/surrealql/parameters#value) parameter.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ first_name: 'bob', id: person:bpkup0u5zv84xqxne2j5, last_name: 'bobson', name: 'bob bobson' }]"
skip-record-id-key = true

*/

DEFINE TABLE person SCHEMAFULL;

DEFINE FIELD first_name ON TABLE person TYPE string VALUE string::lowercase($value);
DEFINE FIELD last_name  ON TABLE person TYPE string VALUE string::lowercase($value);
DEFINE FIELD name       ON TABLE person             VALUE first_name + ' ' + last_name;

// Creates a `person` with the name "bob bobson"
CREATE person SET first_name = "BOB", last_name = "BOBSON";
```

The `$this` parameter gives access to the entire record on which a field is defined.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ age: 6, extra_self: { age: 6, id: person:one, name: 'Little person' }, id: person:one, name: 'Little person' }]"

*/

DEFINE FIELD extra_self ON TABLE person VALUE $this;
CREATE person:one SET name = "Little person", age = 6;
```

```surql title="Output"
[
	{
		age: 6,
		extra_self: {
			age: 6,
			id: person:one,
			name: 'Little person'
		},
		id: person:one,
		name: 'Little person'
	}
]
```

## Order of operations when setting a field's value

As `DEFINE FIELD` statements are computed in alphabetical order, be sure to keep this in mind when using fields that rely on the values of others.

The following example is identical to the above except that `full_name` has been chosen for the previous field `name`. The `full_name` field will be calculated after `first_name`, but before `last_name`.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ first_name: 'bob', full_name: 'bob BOBSON', id: person:l07j1ly4oher21g80fr4, last_name: 'bobson' }]"
skip-record-id-key = true

*/

DEFINE TABLE person SCHEMAFULL;

DEFINE FIELD first_name ON TABLE person TYPE string VALUE string::lowercase($value);
DEFINE FIELD last_name  ON TABLE person TYPE string VALUE string::lowercase($value);
DEFINE FIELD full_name  ON TABLE person             VALUE first_name + ' ' + last_name;

// Creates a `person` with `full_name` of "bob BOBSON", not "bob bobson"
CREATE person SET first_name = "Bob", last_name = "BOBSON";
```

A good rule of thumb is to organize your `DEFINE FIELD` statements in alphabetical order so that the field definitions show up in the same order as that in which they are computed.

## Defining a literal on a field

<Since v="v2.0.0" />

A field can also be defined as a [literal type](/docs/surrealql/datamodel/literals), by specifying one or more possible values and/or permitted types.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ coffee: { special_order: 'Venti Quadruple Ristretto Half-Decaf Soy Latte with 4 pumps of sugar-free vanilla syrup' }, id: order:good }]"

[[test.results]]
error = ""Couldn't coerce value for field `coffee` of `order:bad`: Expected `'regular' | 'large' | { special_order: string }` but found `'small'`""

*/

DEFINE FIELD coffee ON TABLE order TYPE "regular" | "large" | { special_order: string };

CREATE order:good SET coffee = { special_order: "Venti Quadruple Ristretto Half-Decaf Soy Latte with 4 pumps of sugar-free vanilla syrup" };
CREATE order:bad SET coffee = "small";
```

```surql title="Response"
-------- Query --------

[
	{
		coffee: {
			special_order: 'Venti Quadruple Ristretto Half-Decaf Soy Latte with 4 pumps of sugar-free vanilla syrup'
		},
		id: order:good
	}
]

-------- Query --------
"Found 'small' for field `coffee`, with record `order:bad`, but expected a 'regular' | 'large' | { special_order: string }"
```

One more example of a literal containing settings for a [full text search](/docs/surrealdb/models/full-text-search) filter:

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE FIELD filter ON TABLE search_settings TYPE
      "None"
    | { type: "Ascii" }
    | { type: "EdgeNgram", from: int, to: int }
    | { type: "Lowercase" }
    | { type: "Ngram", from: int, to: int }
    | { type: "Snowball", language: string }
    | { type: "Uppercase" };
```


## Defining a `TYPE` for the `id` field

The `DEFINE FIELD` statement can be defined for the `id` field to specify the acceptable type of ID.

```surql
DEFINE FIELD id ON TABLE something TYPE string;
DEFINE FIELD id ON TABLE something TYPE int;
DEFINE FIELD id ON TABLE something TYPE uuid;
```

Complex IDs can be specified as well.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
error = ""Couldn't coerce value for field `id` of `log:bad`: Expected `[record, 'info' | 'warn' | 'error', datetime]` but found `'bad'`""

[[test.results]]
value = "[{ id: log:[user:one, 'info', d'2025-10-08T00:53:28.328764Z'], message: 'Database started' }]"
skip-datetime = true

*/

-- using multiple data types for a Complex Record ID
DEFINE FIELD id ON TABLE log TYPE [record, "info" | "warn" | "error", datetime];

-- Incorrect ID format, generates an error
CREATE log:bad SET level = "info", time = time::now(), message = "Database started";

-- Acceptable ID format
CREATE log:[user:one, "info", time::now()] SET message = "Database started";
```

```surql title="Output"
-------- Query --------

"Couldn't coerce value for field `id` of `log:bad`: Expected `[record, 'info' | 'warn' | 'error', datetime]` but found `'bad'`"

-------- Query --------

[
	{
		id: log:[
			user:one,
			'info',
			d'2025-03-25T03:36:16.323Z'
		],
		message: 'Database started'
	}
]
```

## Defining a reference

<Since v="v2.2.0" />

A field that is a record link (type `record`, `option<record>`, `array<record<person>>`, and so on) can be defined as a `REFERENCE`. If this clause is used, any linked to record will be able to define a field of its own of type `references` which will be aware of the incoming links.

For more information, see [the page in the datamodel section on references](/docs/surrealql/datamodel/references).



================================================
FILE: src/content/doc-surrealql/statements/define/function.mdx
================================================
---
sidebar_position: 9
sidebar_label: DEFINE FUNCTION
title: DEFINE FUNCTION statement | SurrealQL
description: The DEFINE FUNCTION statement allows you to define custom functions that can be reused throughout a database.
---

import SurrealistMini from "@components/SurrealistMini.astro";
import Since from '@components/shared/Since.astro'
import Image from '@components/Image.astro'
import RecursiveStar from "@img/image/recursive_star.png";

# `DEFINE FUNCTION` statement

The `DEFINE FUNCTION` statement allows you to define custom functions that can be reused throughout a database. When using the `DEFINE FUNCTION` statement, you can define a function that takes one or more arguments and returns a value. You can then call this function in other SurrealQL statements.

Functions can be used to encapsulate logic that you want to reuse in multiple queries. They can also be used to simplify complex queries by breaking them down into smaller, more manageable pieces. The are particularly useful when you have a complex query that you need to run multiple times with different arguments.

## Requirements

- You must be authenticated as a root owner or editor, namespace owner or editor, or database owner or editor before you can use the `DEFINE FUNCTION` statement.
- [You must select your namespace and database](/docs/surrealql/statements/use) before you can use the `DEFINE FUNCTION` statement.

## Statement syntax

```syntax title="SurrealQL Syntax"
DEFINE FUNCTION [ OVERWRITE | IF NOT EXISTS ] fn::@name( [ @argument: @type ... ] ) {
	[ @query ... ]
	[ RETURN @returned ]
} [ COMMENT @string ] [ PERMISSIONS [ NONE | FULL | WHERE @condition]]
```

## Example usage
Below shows how you can define a custom function using the `DEFINE FUNCTION` statement, and how to call it.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "'Hello, Tobie!'"

*/

-- It is necessary to prefix the name of your function with "fn::"
-- This indicates that it's a custom function
DEFINE FUNCTION fn::greet($name: string) {
	RETURN "Hello, " + $name + "!";
};

-- Returns: "Hello, Tobie!"
RETURN fn::greet("Tobie");
```
To showcase a slightly more complex custom function, this will check if a relation between two nodes exists:

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Define a function that checks if a relation exists between two nodes
DEFINE FUNCTION fn::relation_exists(
	$in: record,
	$tb: string,
	$out: record
) {
	-- Check if a relation exists between the two nodes.
	LET $results = SELECT VALUE id FROM type::table($tb) WHERE in = $in AND out = $out;
	-- Return true if a relation exists, false otherwise
    RETURN array::len($results) > 0;
};
```

## Optional arguments
If one or more ending arguments have the `option<T>` type, they can be omitted when you run the invoke the function.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ optional_present: true, required_present: true }"

[[test.results]]
value = "{ optional_present: false, required_present: true }"

*/

DEFINE FUNCTION fn::last_option($required: number, $optional: option<number>) {
	RETURN {
		required_present: type::is_number($required),
		optional_present: type::is_number($optional),
	}
};

RETURN fn::last_option(1, 2);
-- { required_present: true, optional_present: true }

RETURN fn::last_option(1);
-- { required_present: true, optional_present: false };
```

## Recursive functions

A function is able to call itself, making it a recursive function. One example of a recursive function is the one below which creates a relation between each and every record passed in.

Consider a situation in which seven person records exist. First, `person:1` will need to be related to the rest of the `person` records, after which there are no more relations to create for it. Following this, the relations for `person:2` and all the other records except for `person:1` will need to be created, and so on.

This can be done in a recursive function by creating all the relations between the first record and the remaining records, after which the function calls itself by passing in all the records except the first. This continues until the function receives less than two records, in which case it ceases calling itself by doing nothing, thereby ending the recursion.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ id: person:1 }, { id: person:2 }, { id: person:3 }, { id: person:4 }, { id: person:5 }, { id: person:6 }]"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ "->to": { "->?": [person:3, person:4, person:6, person:5, person:2] }, id: person:1 }, { "->to": { "->?": [person:6, person:3, person:5, person:4] }, id: person:2 }, { "->to": { "->?": [person:6, person:5, person:4] }, id: person:3 }, { "->to": { "->?": [person:5, person:6] }, id: person:4 }, { "->to": { "->?": [person:6] }, id: person:5 }, { "->to": { "->?": [] }, id: person:6 }]"

*/

DEFINE FUNCTION fn::relate_all($records: array<record>) {
  IF $records.len() < 2 {
      -- Don't do anything, ending the recursion
  }  ELSE {
      LET $first = $records[0];
      LET $remainder = $records[1..];
      FOR $counterpart IN $remainder {
          RELATE $first->to->$counterpart;
      };
      fn::relate_all($remainder);
  }
};

CREATE |person:1..8|;

fn::relate_all(SELECT VALUE id FROM person);

SELECT id, ->to->? FROM person;
```

The last query [can be viewed graphically](/blog/whats-new-in-surrealist-3-2#graph-visualisation) inside Surrealist, leading to an output showing a seven-pointed star.

<Image
  alt="An image of a seven-pointed star created visually by relating seven records to each other and displayed inside Surrealist's graph view."
  src={{
    light: RecursiveStar,
    dark: RecursiveStar,
  }}
/>

## Permissions

You can set the permissions for a custom function using the `PERMISSIONS` clause. The `PERMISSIONS` clause is mostly used to restrict who can access a function and what data they can access. It can be set to `NONE`, `FULL`, or `WHERE @condition`.

- `FULL`: When Full permissions are granted [record](/docs/surrealdb/security/authentication#record-users) users have access to the function. This is the default permission when not specified.
- `NONE`: When this permission is granted, [record](/docs/surrealdb/security/authentication#record-users) users have no access to the defined function.
- `WHERE @condition`: Permissions are granted to the function based on the specified condition.


> [!NOTE]
> The examples below use the [`Surreal Deal Store`](/docs/surrealql/demo#surreal-deal-store---there-is-a-lot-in-store-for-you-recommended) dataset.

### Using the `FULL` permission

The `FULL` permission grants all users access to the function. The following example defines a function that fetches all products from the `product` table and grants the function full permissions to access the data to all users.

<SurrealistMini url="https://app.surrealdb.com/mini?query=--+Define+a+function+to+fetch+all+products.+All+users+can+access+this+function%0ADEFINE+FUNCTION+fn%3A%3AfetchAllProducts%28%29+%7B%0A%09RETURN+%28SELECT+*+FROM+product+LIMIT+10%29%3B%0A%7D+PERMISSIONS+FULL%3B%0A%0A--+Returns%3A+The+first+10+products+in+the+product+table%0ARETURN+fn%3A%3AfetchAllProducts%28%29%3B&dataset=surreal-deal-store&orientation=horizontal"/>

### Using the `NONE` permission

The `NONE` permission denies all [record](/docs/surrealdb/security/authentication#record-users) users access to the function. The following example defines a function that fetches all products from the `product` table

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "[]"

*/

-- Define a function that fetches all expiration years from the payment_details table and denies access to all none-admin users
DEFINE FUNCTION fn::fetchAllPaymentDetails() {
	RETURN (SELECT stored_cards.expiry_year FROM payment_details LIMIT 5);
} PERMISSIONS NONE;

RETURN fn::fetchAllPaymentDetails();
```

### Using the `WHERE` clause

The `WHERE` clause allows you to specify a condition that determines the permissions granted to the function. The condition must evaluate to a boolean value. If the condition evaluates to `true`, the function is granted permissions. If the condition evaluates to `false`, the function is not granted permissions.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Define a function that fetches all products with the condition that only admin users can access it
DEFINE FUNCTION fn::fetchAllProducts() {
	RETURN (SELECT * FROM product LIMIT 10);
} PERMISSIONS WHERE $auth.admin = true;
```

## Using `IF NOT EXISTS` clause

<Since v="v1.3.0" />

The `IF NOT EXISTS` clause can be used to define a function only if it does not already exist. You should use the `IF NOT EXISTS` clause when defining a function in SurrealDB if you want to ensure that the function is only created if it does not already exist. If the function already exists, the `DEFINE FUNCTION` statement will return an error.

It's particularly useful when you want to safely attempt to define a function without manually checking its existence first.

On the other hand, you should not use the `IF NOT EXISTS` clause when you want to ensure that the function definition is updated regardless of whether it already exists. In such cases, you might prefer using the `OVERWRITE` clause, which allows you to define a function and overwrite an existing one if it already exists, ensuring that the latest version of the function definition is always in use

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a FUNCTION if it does not already exist
DEFINE FUNCTION IF NOT EXISTS fn::example() {};
```

## Using `OVERWRITE` clause

<Since v="v2.0.0" />

The `OVERWRITE` clause can be used to define a function and overwrite an existing one if it already exists. You should use the `OVERWRITE` clause when you want to modify an existing user definition. If the user already exists, the `DEFINE FUNCTION` statement will overwrite the existing definition with the new one.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create an FUNCTION and overwrite if it already exists
DEFINE FUNCTION OVERWRITE fn::example() {};
```



================================================
FILE: src/content/doc-surrealql/statements/define/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Overview
title: DEFINE statement | SurrealQL
description: The DEFINE statement can be used to specify authentication access and behaviour, global parameters, table configurations, table events, schema definitions, and indexes.
---

# DEFINE statement

The DEFINE statement can be used to specify instructions to the schema such as  authentication access and behaviour, global parameters, table configurations, table events, analyzers, and indexes.

> [!NOTE]
> Before SurrealDB version 3.0.0-alpha.8, the `FULLTEXT ANALYZER` clause used the syntax `SEARCH ANALYZER`.

```syntax title="SurrealQL Syntax"
DEFINE [
	NAMESPACE [ OVERWRITE | IF NOT EXISTS ] @name
	| DATABASE [ OVERWRITE | IF NOT EXISTS ] @name
	| USER [ OVERWRITE | IF NOT EXISTS ] @name ON [ ROOT | NAMESPACE | DATABASE ] [ PASSWORD @pass | PASSHASH @hash ] ROLES @roles
	| TABLE [ OVERWRITE | IF NOT EXISTS ] @name
		[ DROP ]
		[ SCHEMAFULL | SCHEMALESS ]
		[ AS SELECT @projections
			FROM @tables
			[ WHERE @condition ]
			[ GROUP [ BY ] @groups ]
		]
		[ PERMISSIONS [ NONE | FULL
			| FOR select @expression
			| FOR create @expression
			| FOR update @expression
			| FOR delete @expression
		] ]
	| EVENT [ OVERWRITE | IF NOT EXISTS ] @name ON [ TABLE ] @table WHEN @expression THEN @expression
	| FIELD [ OVERWRITE | IF NOT EXISTS ] @name ON [ TABLE ] @table
		[ [ FLEXIBLE ] TYPE @type ]
		[ VALUE @expression ]
		[ ASSERT @expression ]
		[ PERMISSIONS [ NONE | FULL
			| FOR select @expression
			| FOR create @expression
			| FOR update @expression
			| FOR delete @expression
		] ]
	| PARAM [ OVERWRITE | IF NOT EXISTS ] $@name VALUE @value
	| FUNCTION [ OVERWRITE | IF NOT EXISTS ] fn::@name ( [ ( @argument:@type ... ) ] ) { [@query] [RETURNS @returned] }
	| ANALYZER [ OVERWRITE | IF NOT EXISTS ] @name
		[ TOKENIZERS @tokenizers ]
		[ FILTERS @filters ]
	| INDEX [ OVERWRITE | IF NOT EXISTS ] @name ON [ TABLE ] @table [ FIELDS | COLUMNS ] @fields
		[ UNIQUE | FULLTEXT ANALYZER @analyzer [ BM25 [(@k1, @b)] ] [ HIGHLIGHTS ] ]
	| SEQUENCE [ OVERWRITE | IF NOT EXISTS ] @name
		[ BATCH @batch ]
		[ START @start ]
	| ACCESS [ OVERWRITE | IF NOT EXISTS ] @name ON [ NAMESPACE | DATABASE ]
		TYPE [
			JWT [ ALGORITHM @algorithm KEY @key | URL @url ]
			| RECORD
				[ SIGNUP @expression ]
				[ SIGNIN @expression ]
				[ WITH JWT [ ALGORITHM @algorithm KEY @key | URL @url ] [ WITH ISSUER KEY @key ] ]
		]
		[ DURATION [ FOR TOKEN @duration ] [ FOR SESSION @duration ] ]
    [ COMMENT @string ]
]
```

The [INFO](/docs/surrealql/statements/info) statement can be used to see which definition statements currently exist in a database connection. All `DEFINE` statements can be followed up with a `COMMENT`.

An example of defining a field on a table, followed by an `INFO` command for the same table:

```surql
DEFINE FIELD name ON TABLE person TYPE string COMMENT "Todo: add assertion for maximum length";
INFO FOR TABLE person;
```

```surql output="Response"
{
	events: {},
	fields: {
		name: "DEFINE FIELD name ON person TYPE string COMMENT 'Todo: add assertion for maximum length' PERMISSIONS FULL"
	},
	indexes: {},
	lives: {},
	tables: {}
}
```

An example of defining a user and a table for a database, followed by an `INFO` command for the current database:

```surql
DEFINE USER db_user ON DATABASE PASSWORD "strongpassword" ROLES OWNER;
DEFINE TABLE person SCHEMAFULL;
INFO FOR DB;
```

```surql output="Response"
{
    "accesses": {},
    "analyzers": {},
    "functions": {},
    "models": {},
    "params": {},
    "tables": {
        "person": "DEFINE TABLE person TYPE ANY SCHEMAFULL PERMISSIONS NONE"
    },
    "users": {
        "db_user": "DEFINE USER db_user ON DATABASE PASSHASH '$argon2id$v=19$m=19456,t=2,p=1$P5nVYXOMvk6rEz67kjL5Dg$0T/XNmgIaB+lK0IPspg1l8LruzNK96jd/PvktRCB/ww' ROLES OWNER"
    }
}
```



================================================
FILE: src/content/doc-surrealql/statements/define/indexes.mdx
================================================
---
sidebar_position: 10
sidebar_label: DEFINE INDEX
title: DEFINE INDEX statement | SurrealQL
description: Just like in other databases, SurrealDB uses indexes to help optimize query performance. An index can consist of one or more fields in a table and can enforce a uniqueness constraint.
---
import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

import SurrealistMini from "@components/SurrealistMini.astro";

> [!NOTE]
> Before SurrealDB version 3.0.0-alpha.8, the `FULLTEXT ANALYZER` clause used the syntax `SEARCH ANALYZER`.

# `DEFINE INDEX` statement

Just like in other databases, SurrealDB uses indexes to help optimize query performance. An index can consist of one or more fields in a table and can enforce a uniqueness constraint. If you don't intend for your index to have a uniqueness constraint, then the fields you select for your index should have a high degree of cardinality, meaning that there is a high amount of diversity between the data in the indexed table records.

## Requirements

- You must be authenticated as a root owner or editor, namespace owner or editor, or database owner or editor before you can use the `DEFINE INDEX` statement.
- [You must select your namespace and database](/docs/surrealql/statements/use) before you can use the `DEFINE INDEX` statement.

## Statement syntax

<Tabs syncKey="define-index-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="Basic syntax"
DEFINE INDEX [ OVERWRITE | IF NOT EXISTS ] @name
    ON [ TABLE ] @table 
    [ FIELDS | COLUMNS ] @fields
    [ @special_clause ]
    [ COMMENT @string ]
    [ CONCURRENTLY ]
```

The `@special_clause` part of the statement is an optional part in which an index can be declared for special usage such as guaranteeing unique values, full-text search, and so on. The available clauses are:

```syntax title="Special index clauses"
UNIQUE
| COUNT
| FULLTEXT ANALYZER @analyzer [ BM25 [(@k1, @b)] ] [ HIGHLIGHTS ]
| HNSW DIMENSION @dimension [ TYPE @type ] [DIST @distance] [ EFC @efc ] [ M @m ]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const defineIndexAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "INDEX" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [
        { type: "Terminal", text: "OVERWRITE" },
        { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] }
      ] } },
      { type: "NonTerminal", text: "@name" },
      { type: "Terminal", text: "ON" },
      { type: "Optional", child: { type: "Terminal", text: "TABLE" } },
      { type: "NonTerminal", text: "@table" },
      { type: "Choice", index: 1, children: [ { type: "Terminal", text: "FIELDS" }, { type: "Terminal", text: "COLUMNS" } ] },
      { type: "NonTerminal", text: "@fields" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [
        { type: "Terminal", text: "UNIQUE" },
        { type: "Terminal", text: "COUNT" },
        { type: "Sequence", children: [
          { type: "Terminal", text: "FULLTEXT" },
          { type: "Terminal", text: "ANALYZER" },
          { type: "NonTerminal", text: "@analyzer" },
          { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "BM25" }, { type: "Optional", child: { type: "Terminal", text: "(@k1, @b)" } } ] } },
          { type: "Optional", child: { type: "Terminal", text: "HIGHLIGHTS" } }
        ] },
        { type: "Sequence", children: [
          { type: "Terminal", text: "HNSW" },
          { type: "Terminal", text: "DIMENSION" },
          { type: "NonTerminal", text: "@dimension" },
          { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "TYPE" }, { type: "NonTerminal", text: "@type" } ] } },
          { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "DIST" }, { type: "NonTerminal", text: "@distance" } ] } },
          { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "EFC" }, { type: "NonTerminal", text: "@efc" } ] } },
          { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "M" }, { type: "NonTerminal", text: "@m" } ] } }
        ] }
      ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "COMMENT" }, { type: "NonTerminal", text: "@string" } ] } },
      { type: "Optional", child: { type: "Terminal", text: "CONCURRENTLY" } }
    ]}
  ]
};

<RailroadDiagram ast={defineIndexAst} className="my-6" />

  </TabItem>
</Tabs>

## Index types

SurrealDB offers a range of indexing capabilities designed to optimize data retrieval and search efficiency.

### Standard (non-unique) index

An index without any special clauses allows for the indexing of attributes that may have non-unique values, facilitating efficient data retrieval. Non-unique indexes help index frequently appearing data in queries that do not require uniqueness, such as categorization tags or status indicators.

Let's create a non-unique index for an age field on a user table.

```surql
-- optimise queries looking for users of a given age
DEFINE INDEX userAgeIndex ON TABLE user COLUMNS age;
```

### Unique index

Ensures each value in the index is unique. A unique index helps enforce uniqueness across records by preventing duplicate entries in fields such as user IDs, email addresses, and other unique identifiers.

Let's create a unique index for the email address field on a user table.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Makes sure that the email address in the user table is always unique
DEFINE INDEX userEmailIndex ON TABLE user COLUMNS email UNIQUE;
```

The created index can be tested using the [`INFO` statement](/docs/surrealql/statements/info).

```surql
INFO FOR TABLE user;
```
The `INFO` statement will help you understand what indexes are defined in your `TABLE`.

```surql
{
    "events": {},
    "fields": {},
    "indexes": {
        "userEmailIndex": {
            sql: "DEFINE INDEX userEmailIndex ON user FIELDS email UNIQUE"
        }
    },
    "lives": {},
    "tables": {}
}
```

As we defined a `UNIQUE` index on the `email` column, a duplicate entry for that column or field will throw an error.

```surql
-- Create a user record and set an email ID.
CREATE user:1 SET email = 'test@surrealdb.com';
```

```surql title="Response"
[
    {
        "email": "test@surrealdb.com",
        "id": "user:1"
    }
]
```

Creating another record with the same email ID will throw an error.

```surql
-- Create another user record and set the same email ID.
CREATE user:2 SET email = 'test@surrealdb.com';
```

```surql title="Response"
Database index `userEmailIndex` already contains 'test@surrealdb.com',
with record `user:1`
```

To set the same email for `user:2`, the original record must be deleted

```surql
DELETE user:1;
CREATE user:2 SET email = 'test@surrealdb.com'
```
```
[
    {
        "email": "test@surrealdb.com",
        "id": "user:2"
    }
]
```

### Composite index

A composite index spans multiple fields and columns of a table. Composite indexes are mainly used to create a unique index when the definition of what is unique pertains to more than one field.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create an index on the account and email fields of the user table
DEFINE INDEX test ON user FIELDS account, email UNIQUE;
```

### Count index

<Since v="v3.0.0-alpha.10" />

An index using the `COUNT` clause is used to maintain a count of the number of records in a table. This is used together with the `count()` function and `GROUP ALL` inside a query. Without a count index, the `count()` function will iterate through the records of a table when it is called.

```surql
DEFINE INDEX idx ON indexed_reading COUNT;

FOR $_ IN 0..100000 {
    CREATE reading SET temperature = rand::int(0, 10);
};

FOR $_ IN 0..100000 {
    CREATE indexed_reading SET temperature = rand::int(0, 10);
};

-- Wait a moment before running these two
-- queries to ensure the index is built
SELECT count() FROM reading GROUP ALL;
SELECT count() FROM indexed_reading GROUP ALL;
```

As a count index is declared on a table as a whole, it cannot use the `FIELDS` / `COLUMNS` clause.

```surql
-- Other clauses like `COMMENT` are fine
DEFINE INDEX idx ON users COUNT
    COMMENT "Users are expected to grow substantially so index the count"
    CONCURRENTLY;

-- But not `FIELD`
DEFINE INDEX idx2 ON person FIELD name;
```

```surql title="Output"
'There was a problem with the database: Parse error: Unexpected token `FIELD`, expected Eof
 --> [1:29]
  |
1 | DEFINE INDEX idx2 ON person FIELD name;
  |                             ^^^^^ 
'
```

### Full-text search (`FULLTEXT`) index

Enables efficient searching through textual data, supporting advanced text-matching features like proximity searches and keyword highlighting.

The [Full-Text search](/docs/surrealdb/models/full-text-search) index helps implement comprehensive search functionalities in applications, such as searching through articles, product descriptions, and user-generated content.

Let's create a full-text search index for a `name` field on a `user` table.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Define the an analyzer with
DEFINE ANALYZER example_ascii TOKENIZERS class FILTERS ascii;
-- Since 3.0.0-alpha.8: only FULLTEXT used to benefit from concurrent full-text search
DEFINE INDEX userNameIndex ON TABLE user COLUMNS name FULLTEXT ANALYZER example_ascii BM25 HIGHLIGHTS;
```

- `SEARCH` or `FULLTEXT`: By using the `SEARCH` keyword, you enable full-text search on the specified column.
- `ANALYZER ascii`: Uses a custom [analyzer](/docs/surrealql/statements/define/analyzer) called `example_ascii` which uses the class tokenizier and `ascii` filter to analyzing the text input.
- `BM25`: Ranking algorithm used for relevance scoring.
- `HIGHLIGHTS`: Allows keyword highlighting in search results output when using the [`search::highlight`](/docs/surrealql/functions/database/search#searchhighlight) function
- `FIELDS`: a full-text search index can only be used on one field at a time. To use full-text search on more than one field, use a separate `DEFINE INDEX` statement for each one.

#### `FULLTEXT` vs. `SEARCH`

Since version 3.0.0-alpha.8, using `FULLTEXT ANALYZER` is the syntax used for a text analyzer. The `FULLTEXT` clause allows for more performant [concurrent full-text search](https://github.com/surrealdb/surrealdb/pull/5571), as well as the ability to [use the `OR` operator](https://github.com/surrealdb/surrealdb/pull/6179).

## Vector search indexes

Vector search indexes in SurrealDB support efficient [k-nearest neighbors](https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm) (kNN) and [Approximate Nearest Neighbor](https://en.wikipedia.org/wiki/Nearest_neighbor_search) (ANN) operations, which are pivotal in performing similarity searches within complex, high-dimensional datasets and data types. Refer to the [Vector Search Cheat Sheet](docs/surrealdb/models/vector#vector-search-cheat-sheet) for the parameters allowed.

### Types

When defining a vector index with [HNSW](#hnsw-hierarchical-navigable-small-world), you can define the types the vector will be stored in. The `TYPE` clause is optional and can be used to specify the data type of the vector. SurrealDB supports the following types:
`F64` | `F32` | `I64` | `I32` | `I16`

- `F64`: Represents 64-bit floating-point numbers (double precision floating-point numbers).
- `F32`: Represents 32-bit floating-point numbers (single precision floating-point numbers).
- `I64`: Represents 64-bit signed integers.
- `I32`: Represents 32-bit signed integers.
- `I16`: Represents 16-bit signed integers.


> [!NOTE]
> In SurrealDB the default type for vectors is `F64`.

For example, to define a vector index with 64-bit signed integers, you can use the following query:

```surql
DEFINE INDEX idx_mtree_embedding ON Document FIELDS items.embedding HNSW DIMENSION 4 TYPE I64;
```

### HNSW (Hierarchical Navigable Small World)

<Since v="v1.5.0" />

This method uses a graph-based approach to efficiently navigate and search in high-dimensional spaces.
While it is an approximate technique, it offers a high-performance balance between speed and accuracy, making it ideal for very large datasets.


> [!NOTE]
> Keep in mind the in-memory nature of HNSW when considering system resource allocation.


<SurrealistMini
url="https://app.surrealdb.com/mini?query=CREATE+pts%3A3+SET+point+%3D+%5B8%2C9%2C10%2C11%5D%3B%0A%0ADEFINE+INDEX+mt_pts+ON+pts+FIELDS+point+HNSW+DIMENSION+4+DIST+EUCLIDEAN+EFC+150+M+12%3B%0A%0A%2F%2F+See+output+for+info+on+EFC%2CM%2CMO+AND+LM+%0AINFO+FOR+TABLE+pts%3B%0A%0ASELECT+id+FROM+pts+WHERE+point+%3C%7C10%2C40%7C%3E+%5B2%2C3%2C4%2C5%5D%3B&orientation=horizontal"
/>

In the example above, you may notice the `EFC` and `M` parameters. These are optional to your query but are parameters of the [HNSW algorithm](https://arxiv.org/abs/1603.09320) and can be used to tune the index for better performance.

- M (Max Connections per Element):
Defines the maximum number of bidirectional links (neighbors) per node in each layer of the graph, except for the lowest layer. This parameter controls the connectivity and overall structure of the network. Higher values of MM generally improve search accuracy but increase memory usage and construction time.

- EFC (EF construction):
Stands for "exploration factor during construction." This parameter determines the size of the dynamic list for the nearest neighbor candidates during the graph construction phase. A larger efConstruction value leads to a more thorough construction, improving the quality and accuracy of the search but increasing construction time. The default value is 150.

- M0 (Max Connections in the Lowest Layer):
Similar to M, but specifically for the bottom layer (the base layer) of the graph. This layer contains the actual data points. M0 is often set to twice the value of M to enhance search performance and connectivity at the base layer, at the cost of increased memory usage.

- LM (Multiplier for Level Generation):
Used to determine the maximum level ll for a new element during its insertion into the hierarchical structure. It is used in the formula l←⌊−ln⁡(unif(0..1))⋅mL⌋, where unif(0..1) is a uniform random variable between 0 and 1. This parameter influences the distribution of elements across different levels, impacting the overall balance and efficiency of the search structure.


> [!NOTE]
> You can only provide TYPE, M, and EFC. SurrealDB automatically computes M0 and LM with the most appropriate value. If not specified, M AND EFC are set to 12 and 150, respectively.  Refer to the [Vector Search Cheat Sheet](docs/surrealdb/models/vector#vector-search-cheat-sheet) for the parameters allowed.

#### Memory cache usage for HNSW indexes

<Since v="v3.0.0-beta.1" />

HNSW vector search uses a bounded memory cache by default, reducing memory spikes and improving stability under load. The default size for the cache is 256 MiB, and can be modified via the `SURREAL_HNSW_CACHE_SIZE` [environment variable](/docs/surrealdb/cli/env).

### Brute Force method

The Brute Force method is suitable for tasks with smaller datasets or when the highest accuracy is required.
Brute Force currently supports [Euclidean](/docs/surrealql/functions/database/vector#vectordistanceeuclidean), [Cosine](/docs/surrealql/functions/database/vector#vectorsimilaritycosine), [Manhattan](/docs/surrealql/functions/database/vector#vectordistancemanhattan) and [Minkowski](/docs/surrealql/functions/database/vector#vectordistanceminkowski) distance functions.

In the example below, the query searches for points closest to the vector `[2,3,4,5]` and uses [vector functions](/docs/surrealql/functions/database/vector) to calculate the distance between two points, indicated by `<|2|>`.

<SurrealistMini
url="https://app.surrealdb.com/mini?query=CREATE+pts%3A1+SET+point+%3D+%5B1%2C2%2C3%2C4%5D%3B%0ACREATE+pts%3A2+SET+point+%3D+%5B4%2C5%2C6%2C7%5D%3B%0ACREATE+pts%3A3+SET+point+%3D+%5B8%2C9%2C10%2C11%5D%3B%0ALET+%24pt+%3D+%5B2%2C3%2C4%2C5%5D%3B%0ASELECT+id%2C+vector%3A%3Adistance%3A%3Aeuclidean%28point%2C+%24pt%29+AS+dist+FROM+pts+WHERE+point+%3C%7C2%2CEUCLIDEAN%7C%3E+%24pt%3B%0ASELECT+id+FROM+pts+WHERE+point+%3C%7C2%7C%3E+%24pt+EXPLAIN%3B&orientation=horizontal"
/>


## Verifying Index Utilization in Queries

The [`EXPLAIN` clause](/docs/surrealql/statements/select#the-explain-clause) from SurrealQL helps you understand the execution plan of the query and provides transparency around index utilization.

```surql
SELECT * FROM user WHERE email='test@surrealdb.com' EXPLAIN FULL;
```

It also reveals details about which `operation` was used by the query planner and how many records matched the search criteria.

```surql
[
    {
        "detail": {
            "plan": {
                "index": "userEmailIndex",
                "operator": "=",
                "value": "test@surrealdb.com"
            },
            "table": "user"
        },
        "operation": "Iterate Index"
    },
    {
        "detail": {
            "count": 1
        },
        "operation": "Fetch"
    }
]
```

## Rebuilding Indexes

<Since v="v1.5.0" />

Indexes can be rebuilt using the [`REBUILD`](/docs/surrealql/statements/rebuild) statement. This can be useful when you want to update the index definition or when you want to rebuild the index to optimize performance.

You may want to rebuild an index overtime to ensure that the index is up-to-date with the latest data in the table.

```surql
/**[test]

[[test.results]]
error = ""The index 'userEmailIndex' does not exist""

*/

REBUILD INDEX userEmailIndex ON user;
```


## Using `IF NOT EXISTS` clause

<Since v="v1.3.0" />

The `IF NOT EXISTS` clause can be used to define an index only if it does not already exist. You should use the `IF NOT EXISTS` clause when defining a index in SurrealDB if you want to ensure that the index is only created if it does not already exist. If the index already exists, the `DEFINE INDEX` statement will return an error.

It's particularly useful when you want to safely attempt to define a index without manually checking its existence first.

On the other hand, you should not use the `IF NOT EXISTS` clause when you want to ensure that the index definition is updated regardless of whether it already exists. In such cases, you might prefer using the `OVERWRITE` clause, which allows you to define a index and overwrite an existing one if it already exists, ensuring that the latest version of the index definition is always in use

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a INDEX if it does not already exist
DEFINE INDEX IF NOT EXISTS example ON example FIELDS example;
```

## Using `OVERWRITE` clause

<Since v="v2.0.0" />

The `OVERWRITE` clause can be used to define an index and overwrite an existing one if it already exists. You should use the `OVERWRITE` clause when you want to modify an existing index definition. If the index already exists, the `DEFINE INDEX` statement will overwrite the existing definition with the new one.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create an INDEX and overwrite if it already exists
DEFINE INDEX OVERWRITE example ON example FIELDS example;
```

## Using `CONCURRENTLY` clause

<Since v="v2.0.0" />

Building indexes can be lengthy and may time out before they're completed. Use the `CONCURRENTLY` option to build the index without blocking operations. The statement will return immediately, allowing you to monitor the index-building progress by executing the [INFO](/docs/surrealql/statements/info) statement.

```surql
-- Create an INDEX concurrently
DEFINE INDEX test ON user FIELDS email CONCURRENTLY;
INFO FOR INDEX test ON user;
INFO FOR INDEX test ON user;
```

When building an index concurrently, SurrealDB starts the index creation as a background process. You can monitor the status of this process using the `INFO FOR INDEX` statement. The output includes a building block that provides several key details:

```surql
-- Check the indexing status
INFO FOR INDEX test ON user;
```

```surql title="Possible response"
-- Query

{
    building:  {
        initial: 8143,
        pending: 19,
        status: 'indexing',
        updated: 80
    }
}
```
The indexing process consists of two stages: **initial** and **update**.

1. **Initial Stage:**

   During this stage, SurrealDB indexes all existing records. The number of indexed records is represented by the `initial` property. While this stage is in progress, any new inserts, updates, or deletions are tracked as `pending`.

2. **Update Stage:**

   Once the initial stage is completed, SurrealDB begins indexing the pending records accumulated during the initial phase. At this point:

   - The `initial` count remains stable.
   - The `pending` count should gradually decrease as these records are processed; however, it may temporarily increase if new modifications occur during indexing.
   - The `updated` property indicates the number of pending records that have been indexed during this stage.

When both stages are complete, the index status changes to **ready**, meaning that the index is now automatically updated within the same transaction that inserts, updates, or deletes records.

```surql
-- Query

{
	building: {
		status: 'ready'
	}
}
```

## Performance Implications

When defining indexes, it's essential to consider the fields most frequently queried or used to optimize performance.

Indexes may improve the performance of SurrealQL statements. This may not be noticeable with small tables but it can be significant for large tables; especially when the indexed fields are used in the `WHERE` clause of a [`SELECT`](/docs/surrealql/statements/insert) statement.

Indexes can also impact the performance of write operations ([INSERT](/docs/surrealql/statements/insert), [UPDATE](/docs/surrealql/statements/update), [DELETE](/docs/surrealql/statements/delete)) since the index needs to be updated accordingly. Therefore, it's essential to balance the need for read performance with write performance.



================================================
FILE: src/content/doc-surrealql/statements/define/module.mdx
================================================
---
sidebar_position: 11
sidebar_label: DEFINE MODULE
title: DEFINE MODULE statement | SurrealQL
description: Just like in other databases, SurrealDB uses indexes to help optimize query performance. An index can consist of one or more fields in a table and can enforce a uniqueness constraint.
---
import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

> [!NOTE]
> The `surrealism` experimental feature must be enabled before you can use a `DEFINE MODULE` statement.

<Since v="v3.0.0-alpha.12" />

# `DEFINE MODULE` statement

A `DEFINE MODULE` statement is used to define a module via which [Surrealism](/docs/surrealdb/querying/surrealism) functions can be called.

## Statement syntax

<Tabs syncKey="define-module-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
DEFINE MODULE [ OVERWRITE | IF NOT EXISTS ] @mod::@sub AS @file_name
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const defineModuleAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "MODULE" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OVERWRITE" }, { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] } ] } },
      { type: "NonTerminal", text: "@mod::@sub" },
      { type: "Terminal", text: "AS" },
      { type: "NonTerminal", text: "@file_name" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "COMMENT" }, { type: "NonTerminal", text: "@string" } ] } }
    ]}
  ]
};


<RailroadDiagram ast={defineModuleAst} className="my-6" />

  </TabItem>
</Tabs>

## Example

A module includes a module and a sub, followed by `AS` and a pointer to the `.surli` file containing the Rust code compiled to WASM through the Surrealism CLI.

```surql
DEFINE MODULE mod::test AS f"test:/demo.surli";
```

Once the module is defined, functions can be accessed through this path.

Assuming these two functions in the Rust code before compilation to WASM via the Surrealism CLI:

```rust
#[surrealism]
fn returns_true() -> bool { true };

#[surrealism]
fn check_num_size(num: i32) -> Result<i32, &'static str> {
    if num >= 500 {
        Err("Number is too big!")
    } else {
        Ok(num)
    }
}
```

They will then be accessible using the following paths.

```surql
RETURN mod::test::returns_true();
-- true

RETURN mod::test::check_num_size(100);
-- 100
```


================================================
FILE: src/content/doc-surrealql/statements/define/namespace.mdx
================================================
---
sidebar_position: 12
sidebar_label: DEFINE NAMESPACE
title: DEFINE NAMESPACE statement | SurrealQL
description: The DEFINE NAMESPACE statement can be used to setup namespaces, which can contain multiple databases.
---
import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `DEFINE NAMESPACE` statement

SurrealDB has a multi-tenancy model which allows you to scope databases to a namespace. There is no limit to the number of databases that can be in a namespace, nor is there a limit to the number of namespaces allowed. Only users with root access are authorized to create namespaces.

Let's say that you're using SurrealDB to create a multi-tenant SaaS application. You can guarantee that the data of each tenant will be kept separate from other tenants if you put each tenant's databases into separate namespaces. In other words, this will ensure that information will remain siloed so user will only have access the information in the namespace they are a member of.

## Requirements

- You must be authenticated as a root owner or editor before you can use the `DEFINE NAMESPACE` statement.

## Statement syntax

<Tabs syncKey="define-namespace-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
DEFINE NAMESPACE [ OVERWRITE | IF NOT EXISTS ] @name [ COMMENT @string ]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const defineNamespaceAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "NAMESPACE" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OVERWRITE" }, { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] } ] } },
      { type: "NonTerminal", text: "@name" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "COMMENT" }, { type: "NonTerminal", text: "@string" } ] } }
    ]}
  ]
};

<RailroadDiagram ast={defineNamespaceAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage
Below shows how you can create a namespace using the `DEFINE NAMESPACE` statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Namespace for Abcum Ltd.
DEFINE NAMESPACE abcum;
```

## Using `IF NOT EXISTS` clause

<Since v="v1.3.0" />

The `IF NOT EXISTS` clause can be used to define a namespace only if it does not already exist. You should use the `IF NOT EXISTS` clause when defining a namespace in SurrealDB if you want to ensure that the namespace is only created if it does not already exist. If the namespace already exists, the `DEFINE NAMESPACE` statement will return an error.

It's particularly useful when you want to safely attempt to define a namespace without manually checking its existence first.

On the other hand, you should not use the `IF NOT EXISTS` clause when you want to ensure that the namespace definition is updated regardless of whether it already exists. In such cases, you might prefer using the `OVERWRITE` clause, which allows you to define a namespace and overwrite an existing one if it already exists, ensuring that the latest version of the namespace definition is always in use

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a NAMESPACE if it does not already exist
DEFINE NAMESPACE IF NOT EXISTS example;
```

## Using `OVERWRITE` clause

<Since v="v2.0.0" />

The `OVERWRITE` clause can be used to define a namespace and overwrite an existing one if it already exists. You should use the `OVERWRITE` clause when you want to modify an existing namespace definition. If the namespace already exists, the `DEFINE NAMESPACE` statement will overwrite the existing namespace definition with the new one.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create an NAMESPACE and overwrite if it already exists
DEFINE NAMESPACE OVERWRITE example;
```



================================================
FILE: src/content/doc-surrealql/statements/define/param.mdx
================================================
---
sidebar_position: 13
sidebar_label: DEFINE PARAM
title: DEFINE PARAM statement | SurrealQL
description: The DEFINE PARAM statement allows you to define global (database-wide) parameters that are available to every client.
---

import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `DEFINE PARAM` statement

The `DEFINE PARAM` statement allows you to define global (database-wide) parameters that are available to every client.

## Requirements

- You must be authenticated as a root owner or editor, namespace owner or editor, or database owner or editor before you can use the `DEFINE PARAM` statement.
- [You must select your namespace and database](/docs/surrealql/statements/use) before you can use the `DEFINE PARAM` statement.

## Statement syntax

<Tabs syncKey="define-param-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
DEFINE PARAM [ OVERWRITE | IF NOT EXISTS ] $@name 
    VALUE @value
    [ COMMENT @string ]
    [ PERMISSIONS [ NONE | FULL | WHERE @condition ] ]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const defineParamAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "PARAM" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OVERWRITE" }, { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] } ] } },
      { type: "Terminal", text: "$" },
      { type: "NonTerminal", text: "@name" },
      { type: "Terminal", text: "VALUE" },
      { type: "NonTerminal", text: "@value" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "COMMENT" }, { type: "NonTerminal", text: "@string" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "PERMISSIONS" }, { type: "Choice", index: 1, children: [ { type: "Terminal", text: "NONE" }, { type: "Terminal", text: "FULL" }, { type: "Sequence", children: [ { type: "Terminal", text: "WHERE" }, { type: "NonTerminal", text: "@condition" } ] } ] } ] } }
    ]}
  ]
};

<RailroadDiagram ast={defineParamAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage
Below shows how you can create a parameter using the `DEFINE PARAM` statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE PARAM $endpointBase VALUE "https://dummyjson.com";
```

Then, simply use the global parameter like you would with any variable.

```surql
RETURN http::get($endpointBase + "/products");
```

## Using `IF NOT EXISTS` clause

<Since v="v1.3.0" />

The `IF NOT EXISTS` clause can be used to define a param only if it does not already exist. You should use the `IF NOT EXISTS` clause when defining a param in SurrealDB if you want to ensure that the param is only created if it does not already exist. If the param already exists, the `DEFINE PARAM` statement will return an error.

It's particularly useful when you want to safely attempt to define a param without manually checking its existence first.

On the other hand, you should not use the `IF NOT EXISTS` clause when you want to ensure that the param definition is updated regardless of whether it already exists. In such cases, you might prefer using the `OVERWRITE` clause, which allows you to define a param and overwrite an existing one if it already exists, ensuring that the latest version of the param definition is always in use

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a PARAM if it does not already exist
DEFINE PARAM IF NOT EXISTS $example VALUE 123;
```

## Using `OVERWRITE` clause

<Since v="v2.0.0" />

The `OVERWRITE` clause can be used to define a param and overwrite an existing one if it already exists. You should use the `OVERWRITE` clause when you want to modify an existing param definition. If the param already exists, the `DEFINE PARAM` statement will overwrite the existing param definition with the new one.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create an PARAM and overwrite if it already exists
DEFINE PARAM OVERWRITE $example VALUE 123;
```



================================================
FILE: src/content/doc-surrealql/statements/define/scope.mdx
================================================
---
sidebar_position: 14
sidebar_label: DEFINE SCOPE
title: DEFINE SCOPE statement | SurrealQL
description: Setting scope access allows SurrealDB to operate as a web database. With scopes you can set authentication and access rules which enable fine-grained access to tables and fields.
---

> [!WARNING]
> This statement was deprecated in favour of `DEFINE ACCESS ... TYPE RECORD` in SurrealDB versions 2.x, and has been removed as of SurrealDB 3.0. Learn more in the [DEFINE ACCESS](/docs/surrealql/statements/define/access).

import Since from '@components/shared/Since.astro'

# `DEFINE SCOPE` statement

Setting scope access allows SurrealDB to operate as a web database. With scopes you can set authentication and access rules which enable fine-grained access to tables and fields.

## Requirements

- You must be authenticated as a root or namespace user before you can use the `DEFINE SCOPE` statement.
- [You must select your namespace and database](/docs/surrealql/statements/use) before you can use the `DEFINE SCOPE` statement.

## Statement syntax

```syntax title="SurrealQL Syntax"
DEFINE SCOPE [ OVERWRITE | IF NOT EXISTS ] @name SESSION @duration SIGNUP @expression SIGNIN @expression [ COMMENT @string ]
```

## Example usage
Below shows how you can create a scope using the `DEFINE SCOPE` statement.

```surql
-- Enable scope authentication directly in SurrealDB
DEFINE SCOPE account SESSION 24h
	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
;
```

## Using `IF NOT EXISTS` clause

<Since v="v1.3.0" />

The `IF NOT EXISTS` clause can be used to define a scope only if it does not already exist. If the scope already exists, the `DEFINE SCOPE` statement will return an error.

```surql
-- Create a SCOPE if it does not already exist
DEFINE SCOPE IF NOT EXISTS example;
```



================================================
FILE: src/content/doc-surrealql/statements/define/sequence.mdx
================================================
---
sidebar_position: 15
sidebar_label: DEFINE SEQUENCE
title: DEFINE SEQUENCE statement | SurrealQL
description: A DEFINE SEQUENCE statement defines a distributed generator of monotonically increasing numeric sequences.
---
import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `DEFINE SEQUENCE` statement

<Since v="v3.0.0-alpha.2" />

A sequence is used to generate reliable, monotonically increasing numeric sequences in both single-node and clustered SurrealDB deployments (multiple compute nodes backed by TiKV). It uses a batch-allocation strategy to minimise coordination while guaranteeing global uniqueness.

The key features of a sequence are as follows:

* Batch allocation: Nodes request ranges of sequence values at once, reducing network chatter and coordination overhead.
* Node ownership tagging: Every batch is tagged with the requesting node's UUID to prevent overlap between nodes.
* Durable Persistence: Sequence metadata is stored in the underlying key-value store to survive restarts and network partitions.
* Concurrent, thread-safe access: A DashMap caches active sequences, allowing lock-free reads on the hot path.
* Exponential back-off with full jitter: When a batch-allocation attempt fails, the node retries with an exponential delay that includes full jitter to avoid thundering-herd effects across the cluster.
* Automatic cleanup: Listens for namespace and database-removal events and purges the corresponding sequence state.

The sequence implementation avoids contention by having each node reserve a range of sequence values, allowing it to serve multiple requests locally without requiring distributed coordination for every request. When a node exhausts its allocated range, it acquires a new batch from the distributed store.

## Statement syntax

<Tabs syncKey="define-sequence-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
DEFINE SEQUENCE [ OVERWRITE | IF NOT EXISTS ] @name [ BATCH @batch ] [ START @start ] [ TIMEOUT @duration ]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const defineSequenceAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "SEQUENCE" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OVERWRITE" }, { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] } ] } },
      { type: "NonTerminal", text: "@name" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "BATCH" }, { type: "NonTerminal", text: "@batch" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "START" }, { type: "NonTerminal", text: "@start" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "TIMEOUT" }, { type: "NonTerminal", text: "@duration" } ] } }
    ]}
  ]
};

<RailroadDiagram ast={defineSequenceAst} className="my-6" />

  </TabItem>
</Tabs>

## Examples

A sequence can be created with nothing more than a name.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE SEQUENCE mySeq;
```

The `BATCH`, `START`, and 'TIMEOUT' clauses can be included to configure the sequence.

```surql
DEFINE SEQUENCE mySeq2 BATCH 1000 START 100 TIMEOUT 5s;
sequence::nextval('mySeq2');
-- Output: 100

DEFINE SEQUENCE mySeq3 BATCH 1000 START 100 TIMEOUT 0ns;
sequence::nextval('mySeq3');
-- Possible output: 'The query was not executed because it exceeded the timeout'
```

## See also

* [Sequence functions](/docs/surrealql/functions/database/sequence)


================================================
FILE: src/content/doc-surrealql/statements/define/table.mdx
================================================
---
sidebar_position: 16
sidebar_label: DEFINE TABLE
title: DEFINE TABLE statement | SurrealQL
description: The DEFINE TABLE statement allows you to declare your table by name, enabling you to apply strict controls to a table's schema and access permissions.
---
import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `DEFINE TABLE` statement

The `DEFINE TABLE` statement allows you to declare your table by name, enabling you to apply strict controls to a table's schema by making it `SCHEMAFULL`, create a foreign table view, and set permissions specifying what operations can be performed on the table.

> [!NOTE]
> The fields of a table are not defined using `DEFINE TABLE`, but via individual [`DEFINE FIELD`](/docs/surrealql/statements/define/field) statements.

## Requirements

- You must be authenticated as a root owner or editor, namespace owner or editor, or database owner or editor before you can use the `DEFINE TABLE` statement.
- [You must select your namespace and database](/docs/surrealql/statements/use) before you can use the `DEFINE TABLE` statement.

## Statement syntax

<Tabs syncKey="define-table-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
DEFINE TABLE [ OVERWRITE | IF NOT EXISTS ] @name
	[ DROP ]
	[ SCHEMAFULL | SCHEMALESS ]
	[ TYPE [ ANY | NORMAL | RELATION [ IN | FROM ] @table [ OUT | TO ] @table [ ENFORCED ]]]
	[ AS SELECT @projections
		FROM @tables
		[ WHERE @condition ]
		[ GROUP [ BY @groups | ALL ] ]
	]
	[ CHANGEFEED @duration [ INCLUDE ORIGINAL ] ]
	[ PERMISSIONS [ NONE | FULL
		| FOR select @expression
		| FOR create @expression
		| FOR update @expression
		| FOR delete @expression
	] ]
    [ COMMENT @string ]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const defineTableAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "TABLE" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OVERWRITE" }, { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] } ] } },
      { type: "NonTerminal", text: "@name" },
      { type: "Optional", child: { type: "Terminal", text: "DROP" } },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "SCHEMAFULL" }, { type: "Terminal", text: "SCHEMALESS" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [
        { type: "Terminal", text: "TYPE" },
        { type: "Choice", index: 1, children: [
          { type: "Terminal", text: "ANY" },
          { type: "Terminal", text: "NORMAL" },
          { type: "Sequence", children: [
            { type: "Terminal", text: "RELATION" },
            { type: "Optional", child: { type: "Sequence", children: [ { type: "Choice", index: 1, children: [ { type: "Terminal", text: "IN" }, { type: "Terminal", text: "FROM" } ] }, { type: "NonTerminal", text: "@table" } ] } },
            { type: "Optional", child: { type: "Sequence", children: [ { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OUT" }, { type: "Terminal", text: "TO" } ] }, { type: "NonTerminal", text: "@table" } ] } },
            { type: "Optional", child: { type: "Terminal", text: "ENFORCED" } }
          ] }
        ] }
      ] } },
      { type: "Optional", child: { type: "Sequence", children: [
        { type: "Terminal", text: "AS" }, { type: "Terminal", text: "SELECT" }, { type: "NonTerminal", text: "@projections" },
        { type: "Terminal", text: "FROM" }, { type: "NonTerminal", text: "@tables" },
        { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "WHERE" }, { type: "NonTerminal", text: "@condition" } ] } },
        { type: "Optional", child: { type: "Sequence", children: [
          { type: "Terminal", text: "GROUP" },
          { type: "Choice", index: 1, children: [
            { type: "Sequence", children: [ { type: "Terminal", text: "BY" }, { type: "NonTerminal", text: "@groups" } ] },
            { type: "Terminal", text: "ALL" }
          ] }
        ] } }
      ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "CHANGEFEED" }, { type: "NonTerminal", text: "@duration" }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "INCLUDE" }, { type: "Terminal", text: "ORIGINAL" } ] } } ] } },
      { type: "Optional", child: { type: "Sequence", children: [
        { type: "Terminal", text: "PERMISSIONS" },
        { type: "Choice", index: 1, children: [
          { type: "Terminal", text: "NONE" },
          { type: "Terminal", text: "FULL" },
          { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "select" }, { type: "NonTerminal", text: "@expression" } ] },
          { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "create" }, { type: "NonTerminal", text: "@expression" } ] },
          { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "update" }, { type: "NonTerminal", text: "@expression" } ] },
          { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "delete" }, { type: "NonTerminal", text: "@expression" } ] }
        ] }
      ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "COMMENT" }, { type: "NonTerminal", text: "@string" } ] } }
    ]}
  ]
};

<RailroadDiagram ast={defineTableAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage

Below shows how you can create a table using the `DEFINE TABLE` statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Declare the name of a table.
DEFINE TABLE reading;
```

The following example uses the `DROP` portion of the `DEFINE TABLE` statement. Marking a table as `DROP` disallows creating or updating records.

`DROP` tables are useful in combination with events or foreign (view) tables, as you can compute a record and essentially drop the input.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- By marking a table as DROP, you disallow any records to be created or updated.
-- Records that currently exist in the table will not automatically be deleted, you can still remove them manually.
DEFINE TABLE reading DROP;
```

The following expression shows how you can define a `CHANGEFEED` for a table. After creating, updating, and deleting records in the table as usual, using `SHOW CHANGES FOR` will show the changes that have taken place during this time.

```surql
-- Define the change feed and its duration
-- Optionally, append INCLUDE ORIGINAL to include info
-- on the current record before a change took place
DEFINE TABLE reading CHANGEFEED 3d;

-- Create some records in the reading table
CREATE reading SET story = "Once upon a time";
CREATE reading SET story = "there was a database";

-- Replay changes to the reading table since a certain date
-- Must be after the timestamp at which the changefeed began
SHOW CHANGES FOR TABLE reading SINCE d"2023-09-07T01:23:52Z" LIMIT 10;

-- Alternatively, show the changes for the table since a version number
SHOW CHANGES FOR TABLE reading SINCE 0 LIMIT 10;
```

```surql title="Response without INCLUDE ORIGINAL"
[
    {
        "changes": [
            {
                "define_table": {
                    "name": "reading"
                }
            }
        ],
        "versionstamp": 29
    },
    {
        "changes": [
            {
                "update": {
                    "id": "reading:h1gcbc7ykbpslellh2g2",
                    "story": "Once upon a time"
                }
            }
        ],
        "versionstamp": 30
    },
    {
        "changes": [
            {
                "update": {
                    "id": "reading:l9qfcncklhnlklby1avf",
                    "story": "there was a database"
                }
            }
        ],
        "versionstamp": 31
    }
]
```

```surql title="Response with INCLUDE ORIGINAL"
[
    {
        "changes": [
            {
                "define_table": {
                    "name": "reading"
                }
            }
        ],
        "versionstamp": 29
    },
    {
        "changes": [
            {
                "current": {
                    "id": "reading:2j3rc2yw1jzspcuvfe9v",
                    "story": "Once upon a time"
                },
                "update": [
                    {
                        "op": "replace",
                        "path": "/",
                        "value": null
                    }
                ]
            }
        ],
        "versionstamp": 30
    },
    {
        "changes": [
            {
                "current": {
                    "id": "reading:iuiurhi0y2ka0by0skqi",
                    "story": "there was a database"
                },
                "update": [
                    {
                        "op": "replace",
                        "path": "/",
                        "value": null
                    }
                ]
            }
        ],
        "versionstamp": 31
    }
]
```

## Schemafull tables

The following example demonstrates the `SCHEMAFULL` portion of the `DEFINE TABLE` statement. When a table is defined as schemafull, the database strictly enforces any schema definitions that are specified using the `DEFINE TABLE` statement. New fields can not be added to a `SCHEMAFULL` table unless they are defined via the [`DEFINE FIELD`](/docs/surrealql/statements/define/field) statement.


> [!NOTE]
> Since `v2.0.0`, schemafull tables are implicitly type [`NORMAL`](/docs/surrealql/statements/define/table#table-with-specialized-type-clause) tables by default.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ email: 'Tobie.Hitchcock@surrealdb.com', firstName: 'Tobie', id: user:9hizvimsgva1rosul33j, lastName: 'Hitchcock' }]"
skip-record-id-key = true

[[test.results]]
value = "[{ email: 'Tobie.Hitchcock@surrealdb.com', firstName: 'Tobie', id: user:9hizvimsgva1rosul33j, lastName: 'Hitchcock' }]"
skip-record-id-key = true

*/

-- Create schemafull user table.
DEFINE TABLE user SCHEMAFULL;

-- Define some fields.
DEFINE FIELD firstName ON TABLE user TYPE string;
DEFINE FIELD lastName ON TABLE user TYPE string;
DEFINE FIELD email ON TABLE user TYPE string
  ASSERT string::is_email($value);
DEFINE INDEX userEmailIndex ON TABLE user COLUMNS email UNIQUE;

-- SEE IT IN ACTION
-- 1: Add a user with all required fields and an undefined one, 'photoURI'.
CREATE user CONTENT {
    firstName: 'Tobie',
    lastName: 'Hitchcock',
    email: 'Tobie.Hitchcock@surrealdb.com',
    photoURI: 'photo/yxCFi22Jw2.webp'
};
-- 2: Statement will not fail but photoURI will be ignored as it is not a
--    defined field.

-- 3: Query the data
SELECT * FROM user;
```

## Schemaless tables

The following example demonstrates the `SCHEMALESS` portion of the `DEFINE TABLE` statement. This allows you to explicitly state that the specified table has no schema.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ email: 'Tobie.Hitchcock@surrealdb.com', firstName: 'Tobie', id: user:tobie, lastName: 'Hitchcock', photoURI: 'photo/yxCFi22Jw2.webp' }]"

[[test.results]]
error = ""Found 'Jamie.Hitchcock' for field `email`, with record `user:jaime`, but field must conform to: string::is_email($value)""

*/

-- Create schemaless user table.
DEFINE TABLE user SCHEMALESS;

-- Define some fields.
DEFINE FIELD firstName ON TABLE user TYPE string;
DEFINE FIELD lastName ON TABLE user TYPE string;
DEFINE FIELD email ON TABLE user TYPE string
  ASSERT string::is_email($value);
DEFINE INDEX userEmailIndex ON TABLE user COLUMNS email UNIQUE;

-- SEE IT IN ACTION - Example 1
-- 1: Add a user with all required fields and an undefined one.
CREATE user:tobie SET firstName = 'Tobie', lastName = 'Hitchcock', email = 'Tobie.Hitchcock@surrealdb.com', photoURI = 'photo/yxCFi22Jw2.webp';
-- 2: Statement will succeed because user is a SCHEMALESS table.

-- SEE IT IN ACTION - Example 2
-- 1: Add a user with an invalid email address and include a new field that was never defined.
CREATE user:jaime SET firstName = 'Jamie', lastName = 'Hitchcock', email = 'Jamie.Hitchcock', photoURI = 'photo/yxCFi22Jw2.webp';
-- 2: Statement will fail because the value for email was not valid.
```

## Interaction between fields

While a `DEFINE TABLE` statement represents a template for any subsequent records to be created, a `DEFINE FIELD` statement pertains to concrete field data of a record. As such, a `DEFINE FIELD` statement gives access to the record's other fields through their names, as well as the current field through the [`$value`](/docs/surrealql/parameters#value) parameter.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[{ first_name: 'Bob', id: person:5o2zt3el25z7kbuzsf47, last_name: 'Bobson', name: 'Bob Bobson' }]"
skip-record-id-key = true

*/

DEFINE TABLE person SCHEMAFULL;

DEFINE FIELD first_name ON TABLE person TYPE string ASSERT string::len($value) < 20;
DEFINE FIELD last_name  ON TABLE person TYPE string ASSERT string::len($value) < 20;
DEFINE FIELD name       ON TABLE person             VALUE first_name + ' ' + last_name;

// Creates a `person` with the name "Bob Bobson"
CREATE person SET first_name = "Bob", last_name = "Bobson";
```

## Pre-computed table views

In SurrealDB, like in other databases, you can create views. The way you create views is using the `DEFINE TABLE` statement like you would for any other table, then adding the `AS` clause at the end with your `SELECT` query.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "[]"

*/

DEFINE TABLE review DROP;
-- Define a table as a view which aggregates data from the review table
DEFINE TABLE avg_product_review TYPE NORMAL AS
SELECT
	count() AS number_of_reviews,
	math::mean(<float> rating) AS avg_review,
	->product.id AS product_id,
	->product.name AS product_name
FROM review
GROUP BY product_id, product_name;

-- Query the projection
SELECT * FROM avg_product_review;
```

There are a few important things which make our views far more powerful than a typical relational database view and a few limitations to keep in mind.

Starting with what makes them powerful. Our pre-computed table views are most similar to event-based, incrementally updating, materialised views. Let's explain what that means.

- Event-based, meaning that when you run add or remove data from the underlying table, in our example, the `review` table, it triggers a matching event on the `avg_product_review` table view.
- Materialised view, meaning that the first time we run the table view query, it will run the query like a normal `SELECT` statement, but then materialise the result. Instead of normal views which behave like bookmarked `SELECT` queries, that just look like tables to the user.
- Incrementally updating, meaning that for any subsequent run, it will listen for the event trigger and perform the most efficient operation possible to always keep the result up to date, instead of just running the `SELECT` statement again.

While this functionality can be replicated in many other databases, it is usually only done by expert users as it can be very complicated to set up and maintain. Therefore, the true power of our pre-computed table views is making this advanced functionality accessible to everyone.

As mentioned though, there are a few limitations to keep in mind.

- First, while subsequent runs are very efficient, the initial run of large analytical queries can be slow and use a lot of resources, because its just a normal `SELECT` statement. Therefore indexing and query optimisation are still very important.
- Second, while both graph relations and record links are supported, the table view update event, only gets triggered based on the table we have in our `FROM` clause. In our case, just the `review` table, not the `product` we are also using in the query. Meaning that if you delete a `review` the `avg_product_review`  will reflect that in near real-time. However if you delete a `product`, it will still show up in `avg_product_review`.

Also note that table views are not triggered when importing data.

## Defining permissions

By default, the permissions on a table will be set to NONE unless otherwise specified.

```surql
/**[test]

[[test.results]]
value = "[{ id: some_table:8o6rh2r3ovpmu07elc3r }]"

[[test.results]]
value = "NONE"

[[test.results]]
value = "{ accesses: {  }, analyzers: {  }, apis: {  }, buckets: {  }, configs: {  }, functions: {  }, models: {  }, params: {  }, sequences: {  }, tables: { some_other_table: 'DEFINE TABLE some_other_table TYPE ANY SCHEMALESS PERMISSIONS NONE', some_table: 'DEFINE TABLE some_table TYPE ANY SCHEMALESS PERMISSIONS NONE' }, users: {  } }"

*/

CREATE some_table;
DEFINE TABLE some_other_table;

INFO FOR DB;
```

```surql title="Response"
{
	analyzers: {},
	functions: {},
	models: {},
	params: {},
	scopes: {},
	tables: {
		some_other_table: 'DEFINE TABLE some_other_table TYPE ANY SCHEMALESS PERMISSIONS NONE',
		some_table: 'DEFINE TABLE some_table TYPE ANY SCHEMALESS PERMISSIONS NONE'
	},
	tokens: {},
	users: {}
}
```

The following shows how to set table level `PERMISSIONS` using the `DEFINE TABLE` statement. This allows you to set independent permissions for selecting, creating, updating, and deleting data.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Specify access permissions for the 'post' table
DEFINE TABLE post SCHEMALESS
	PERMISSIONS
		FOR select
			-- Published posts can be selected
			WHERE published = true
			-- A user can select all their own posts
			OR user = $auth.id
		FOR create, update
			-- A user can create or update their own posts
			WHERE user = $auth.id
		FOR delete
			-- A user can delete their own posts
			WHERE user = $auth.id
			-- Or an admin can delete any posts
			OR $auth.admin = true
;
```

## Using `IF NOT EXISTS` clause

<Since v="v1.3.0" />

The `IF NOT EXISTS` clause can be used to define a table only if it does not already exist. You should use the `IF NOT EXISTS` clause when defining a table in SurrealDB if you want to ensure that the table is only created if it does not already exist. If the table already exists, the `DEFINE TABLE` statement will return an error.

It's particularly useful when you want to safely attempt to define a table without manually checking its existence first.

On the other hand, you should not use the `IF NOT EXISTS` clause when you want to ensure that the table definition is updated regardless of whether it already exists. In such cases, you might prefer using the `OVERWRITE` clause, which allows you to define a table and overwrite an existing one if it already exists, ensuring that the latest version of the table definition is always in use

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a TABLE if it does not already exist
DEFINE TABLE IF NOT EXISTS reading;
```

## Using `OVERWRITE` clause

<Since v="v2.0.0" />

The `OVERWRITE` clause can be used to define a table and overwrite an existing one if it already exists. You should use the `OVERWRITE` clause when you want to modify an existing table definition. If the table already exists, the `DEFINE TABLE` statement will overwrite the existing table definition with the new one.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create an TABLE and overwrite if it already exists
DEFINE TABLE OVERWRITE example;
```

## Table with specialized `TYPE`-clause

<Since v="v1.4.0" />

When defining a table in SurrealDB, you can specify the type of data that can be stored in the table. This can be done using the `TYPE` clause, followed by either `ANY`, `NORMAL`, or `RELATION`.

With `TYPE ANY`, you can specify a table to store any type of data, whether it's a normal record or a relational record.

With `TYPE NORMAL`, you can specify a table to only store "normal" records, and not relations. When a table is defined as `TYPE NORMAL`, it will not be able to store relations this can be useful when you want to restrict the type of data that can be stored in a table in schemafull mode.

Finally, with `TYPE RELATION`, you can specify a table to only store relational type content. This can be useful when you want to restrict the type of data that can be stored in a table.

```surql
DEFINE TABLE person TYPE ANY;
DEFINE TABLE person;
```

With `TYPE NORMAL`, you can specify a table to only store "normal" records, and not relations.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Since it's default, we can also omit the TYPE clause
DEFINE TABLE person TYPE NORMAL;
```

With `TYPE RELATION`, you can specify a table to only store relational type content, and restrict what kind of relations can be stored.

```surql
-- Just a RELATION table, no constraints on the type of table
DEFINE TABLE likes TYPE RELATION;

-- Define a relation table, and constrain the type of relation which can be stored
DEFINE TABLE likes TYPE RELATION FROM user TO post;
-- OR use IN and OUT alternatively to FROM and TO
DEFINE TABLE likes TYPE RELATION IN user OUT post;
-- To allow a link to one of a possible set of record types, use the | operator
DEFINE TABLE likes TYPE RELATION FROM user TO post|video;
DEFINE TABLE likes TYPE RELATION IN user OUT post|video;
```

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Define a relation table, and constrain the type of relation which can be stored
DEFINE TABLE assigned_to SCHEMAFULL TYPE RELATION IN tag OUT sticky
    PERMISSIONS
        FOR create, select, update, delete
            WHERE in.owner == $auth.id AND out.author == $auth.id;
```

## Using ENFORCED to ensure that related records exist

<Since v="v2.0.0" />

As relations are represented by standalone tables, they can be constructed before any linked records exist.

```surql
/**[test]

[[test.results]]
value = "[{ distance: 12.4f, id: road_to:jd2f9pjzecb0ihmo2mbp, in: city:one, out: city:two, slope: 5.4f }]"
skip-record-id-key = true

*/

RELATE city:one->road_to->city:two SET
    distance = 12.4,
    slope = 5.4;
```

```surql title="Output"
[
	{
		distance: 12.4f,
		id: road_to:pacwucj25a056hhs2s5h,
		in: city:one,
		out: city:two,
		slope: 5.4f
	}
]
```

As such, a query on the relation will return nothing until the records it has been defined upon are created.

```surql
SELECT ->road_to->city FROM city;

CREATE city:one, city:two;
SELECT ->road_to->city FROM city;
```

```surql title="Output"
-------- Query --------

[]

-------- Query --------

[
	{
		"->road_to": {
			"->city": [
				city:two
			]
		}
	},
	{
		"->road_to": {
			"->city": []
		}
	}
]
```

If this behaviour is not desirable, the `ENFORCED` clause can be used on a table of `TYPE RELATION` to disallow a `RELATE` statement from working unless it points to existing data.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
error = ""The record 'city:one' does not exist""

*/

DEFINE TABLE road_to TYPE RELATION IN city OUT city ENFORCED;

RELATE city:one->road_to->city:three SET
    distance = 5.5,
    slope = 30.0;
```

```surql title="Output"
"The record 'city:one' does not exist"
```




================================================
FILE: src/content/doc-surrealql/statements/define/token.mdx
================================================
---
sidebar_position: 17
sidebar_label: DEFINE TOKEN
title: DEFINE TOKEN statement | SurrealQL
description: SurrealDB can work with third-party authentication providers such as OpenID Connect providers, OAuth providers and other trusted third parties.
---
import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'


> [!WARNING]
> This statement was deprecated in favour of [`DEFINE ACCESS ... TYPE JWT`](/docs/surrealql/statements/define/access/jwt) and [`DEFINE ACCESS ... TYPE RECORD ... WITH JWT`](/docs/surrealql/statements/define/access/record) in SurrealDB versions 2.x, and has been removed as of SurrealDB 3.0. Learn more in [define access documentation](/docs/surrealql/statements/define/access).

# `DEFINE TOKEN` statement

SurrealDB can work with third-party authentication providers such as OpenID Connect providers, OAuth providers and other trusted parties providing JWT (JSON Web Tokens, also referred to in this page as “tokens”). Let's say that your provider issues your client (e.g. a user or a service) a JWT once it has authenticated. By using the DEFINE TOKEN statement, you can set the public key or shared secret that will be used to verify the authenticity of the token.

This verification is performed automatically by SurrealDB when provided with a JWT through any of its interfaces (i.e. the [HTTP REST API](/docs/surrealdb/integration/http) through the “Authorization” header or [any of the SDKs](/docs/surrealdb/integration/sdks) through the “Authenticate” methods) before trusting the claims contained in the token and allowing SurrealQL queries to access the values of those claims.

<Tabs syncKey="define-token-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
DEFINE TOKEN [ OVERWRITE | IF NOT EXISTS ] @name ON [ NAMESPACE | DATABASE | SCOPE @scope ] TYPE @type VALUE @value [ COMMENT @string ]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const defineTokenAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "TOKEN" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OVERWRITE" }, { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] } ] } },
      { type: "NonTerminal", text: "@name" },
      { type: "Terminal", text: "ON" },
      { type: "Choice", index: 1, children: [ { type: "Terminal", text: "NAMESPACE" }, { type: "Terminal", text: "DATABASE" }, { type: "Sequence", children: [ { type: "Terminal", text: "SCOPE" }, { type: "NonTerminal", text: "@scope" } ] } ] },
      { type: "Terminal", text: "TYPE" },
      { type: "NonTerminal", text: "@type" },
      { type: "Terminal", text: "VALUE" },
      { type: "NonTerminal", text: "@value" },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "COMMENT" }, { type: "NonTerminal", text: "@string" } ] } }
    ]}
  ]
};

<RailroadDiagram ast={defineTokenAst} className="my-6" />

  </TabItem>
</Tabs>

## Verification Types

When defining a token, its type describes the cryptographic algorithm or specification that will be used to verify the token. This can be an HMAC algorithm, a public-key cryptography algorithm or a remote JWKS object containing all the required information to verify the token. When not specified, the type is defined as the `HS256` HMAC cryptographic algorithm.

### Hash-Based Message Authentication Code (HMAC)

With HMAC algorithms (`HS256`,`HS384`,`HS512`) the value of the defined token will be the secret used both to sign (by the issuer of the token) and verify (by SurrealDB) the token. Anyone with access to this secret will be able to issue tokens with arbitrary claims which will be trusted by SurrealDB.

The following example shows the definition of a token using an HMAC algorithm.

```surql
-- Specify the namespace and database for the token
USE NS abcum DB app_vitalsense;

-- Set the name of the token
DEFINE TOKEN token_name
  -- Use this token provider for database authorization
  ON DATABASE
  -- Specify the cryptographic signature algorithm used to verify the token
  TYPE HS512
  -- Specify the secret used to sign and verify the authenticity of the token
  VALUE "sNSYneezcr8kqphfOC6NwwraUHJCVAt0XjsRSNmssBaBRh3WyMa9TRfq8ST7fsU2H2kGiOpU4GbAF1bCiXmM1b3JGgleBzz7rsrz6VvYEM4q3CLkcO8CMBIlhwhzWmy8"
;
```

### Public-Key Cryptography

With public-key cryptography algorithms (`EDDSA`, `ES256`, `ES384`, `ES512`, `PS256`, `PS384`, `PS512`, `RS256`, `RS384`, `RS512`) the value of the defined token will be the public key used to verify the signature of the token. This value is not secret and should be provided by the issuer of the tokens. Tokens will be signed using the private key, known only to the issuer. The public key value should be provided to SurrealDB including its header and footer. Any whitespace will be trimmed.

The following example shows the definition of a token using a public-key cryptography algorithm.

```surql
-- Specify the namespace and database for the token
USE NS abcum DB app_vitalsense;

-- Set the name of the token
DEFINE TOKEN token_name
  -- Use this token provider for database authorization
  ON DATABASE
  -- Specify the cryptographic signature algorithm used to verify the token
  TYPE RS256
  -- Specify the public key used to verify the authenticity of the token
  VALUE "-----BEGIN PUBLIC KEY-----
MUO52Me9HEB4ZyU+7xmDpnixzA/CUE7kyUuE0b7t38oCh+sQouREqIjLwgHhFdhh3cQAwr6GH07D
ThioYrZL8xATJ3Youyj8C45QnZcGUif5PkpWXDi0HJSoMFekbW6Pr4xuqIqb2LGxGDVJcLZwJ2AS
Gtu2UAfPXbBD3ffiad393M22g1iHM80YaNi+xgswG7qtXE4lR/Lt4s0MeKKX7stdWI1VIsoB+y3i
r/OWUvJPjjDNbAsyy8tQmxydv+FUnLEP9TNT4AhN4DXcJ+XsDtW7OWt4EdSVDeKpGbIMvIrh1Pe+
Nilj8UHNyNDHa2AjK3seMo6CMvaIQJKj5o4xGFblFGwvvPD03SbuQLs1FdRjsZCeWLdYeQ3JDHE9
sFG7DCXlpMJcaYT1mf4XHJ0gPekNLQyewTY3Vxf7FgV3GCNjV20kcDFgJA2+iVW2wSrb+txD1ycE
kbi8jh0pedWwE40VQWaTh/8eAvX7IHWya/AEro25mq+m6vktNZLbvLphhp586kJK3Tdt3YjpkPre
M3nkFWOWurIyKbtIV9JemfwCgt89sNV45dTlnEDEZFFGnIgDnWgx3CUo4XmhICEQU8+tklw9jJYx
iCTjhbIDEBHySSSc/pQ4ftHQmhToTlQeOdEy4LYiaEIgl1X+hzRH1hBYvWlNKe4EY1nMCKcjgt0=
-----END PUBLIC KEY-----"
;
```

### JSON Web Key Set (JWKS)

<Since v="v1.2.0" />

With JWKS, a set of JWK (JSON Web Key) objects will be dynamically fetched from a remote location and used to verify tokens following the [RFC 7517](https://datatracker.ietf.org/doc/html/rfc7517) specification. When defining a JWKS token verification method, its value should contain a valid URL that is reachable by SurrealDB and allowed by the configured network [capabilities](/docs/surrealdb/security/capabilities). This URL should point to a valid JWKS object (as described in [Section 5 of RFC 7517](https://datatracker.ietf.org/doc/html/rfc7517#section-5)) in the form of a JSON document. This is the recommended method to integrate with authentication providers that support JWKS. Providers like [Google](https://developers.google.com/identity/openid-connect/openid-connect#discovery), [AWS Cognito](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-verifying-a-jwt.html#amazon-cognito-user-pools-using-tokens-manually-inspect), [Azure Active Directory](https://azure.github.io/azure-workload-identity/docs/installation/self-managed-clusters/oidc-issuer/jwks.html), [Auth0](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets), [Keycloak](https://documentation.cloud-iam.com/how-to-guides/configure-remote-jkws.html) or [OneLogin](https://developers.onelogin.com/authentication/tools/jwt) provide JWKS endpoints to verify tokens issued by their services.

The following example shows the definition of a token using a JWKS.

```surql
-- Specify the namespace and database for the token
USE NS abcum DB app_vitalsense;

-- Set the name of the token
DEFINE TOKEN token_name
  -- Use this token provider for database authorization
  ON DATABASE
  -- Specify the JWKS specification used to verify the token
  TYPE JWKS
  -- Specify the URL where the JWKS object can be found
  VALUE "https://example.com/.well-known/jwks.json"
;
```

Validating tokens generated by third-party authentication providers using JWKS ensures that keys can be revoked directly from the third-party service and will no longer be accepted by SurrealDB after the local cache for those keys expires. Likewise, it ensures that token verification will not break if keys are rotated, as any new keys will be automatically fetched from the authentication provider if a JWT is received containing a new key identifier in its `kid` header.

To avoid performing requests to the remote URL for each token that is verified, SurrealDB caches every JWKS object that it pulls for a period of 12 hours. The cache can be purged earlier (e.g. in the event a key is compromised) by restarting the SurrealDB server. If a JWT is received containing a reference to a new key identifier in its `kid` header, the JWKS object will be fetched again and updated in the cache if the key identifier is found in the remote JWKS object; this operation will only be performed once every 5 minutes to prevent malicious actors from abusing this process to perform denial of service.

## Requirements

- To `DEFINE TOKEN ... ON NAMESPACE ...` you must have root or namespace level access.
- To `DEFINE TOKEN ... ON DATABASE ...` you must have root, namespace, or database level access.
- To `DEFINE TOKEN ... ON SCOPE ...` you must have root, namespace, or database level access.
- [You must select your namespace and/or database](/docs/surrealql/statements/use) before you can use the `DEFINE TOKEN` statement for database or namespace tokens.

## Using `IF NOT EXISTS` clause

<Since v="v1.3.0" />

The `IF NOT EXISTS` clause can be used to define a token only if it does not already exist. If the token already exists, the `DEFINE TOKEN` statement will return an error.

```surql
-- Create a TOKEN if it does not already exist
DEFINE TOKEN IF NOT EXISTS example ON SCOPE example TYPE HS512 VALUE "example";
```

## Using Tokens

The `DEFINE TOKEN` statement lets you specify the amount of permission granting authority you want to give to a token issuer. You are able to specify if the provider can grant namespace, database, or scope level access to token holders. For this to work, the JWT issued to be used with SurrealDB must contain claims to specify which namespace, database or scope the token bearer is authorized to act on.

The following claims should be added to the JWT payload by the issuer of the token:

- `exp`: The token expiration Unix time. The token will not be valid after.
- `tk`: The name that you chose when defining the token.
- `ns`: The namespace that the token is issued for.
- `db`: The database that the token is issued for.
- `sc`: The scope that the token is issued for.

The names of these claims can be in all lowercase (i.e. `tk`) or all uppercase (i.e. `TK`), and can be optionally prefaced with the `https://surrealdb.com` namespace (e.g. `https://surrealdb.com/tk`) in order to separate claims directed to SurrealDB from claims directed to other services. When using a namespace, the claim name can also be used without abbreviation, such as in `https://surrealdb.com/token` or `https://surrealdb.com/scope`. Even when present in the token with a namespace prefix, [SurrealDB claims](https://github.com/surrealdb/surrealdb/blob/main/core/src/iam/token.rs) are directly accessible via the `$token` parameter (e.g. `$token.sc`), whereas custom claims will need to include the namespace prefix (e.g. `$token['https://surrealdb.com/pet_name']`) to be accessed in the same way.

The following optional claims are also processed by SurrealDB:

- `id`: The identifier of the resource (e.g. user) associated with the token.
- `nbf`: The token acceptance Unix time. The token will not be valid before.

The expected claims depend on the level at which the token was defined:

- For tokens defined `ON NAMESPACE`: `exp`, `tk`, `ns`.
- For tokens defined `ON DATABASE`: `exp`, `tk`,`ns`,`db`.
- For tokens defined `ON SCOPE`: `exp`, `tk`, `ns`,`db`, `sc`, optionally `id`.

For tokens defined `ON NAMESPACE` and `ON DATABASE`, the optional `rl` claim containing an array of capitalized [system user roles](/docs/surrealql/statements/define/user#roles) (e.g. `["Viewer", "Editor", "Owner"]`) can be provided. Doing so will apply the access policy for those roles to any action made using the token. By default, tokens without the `rl` claim will only have the `Viewer` role.

When calling any of the SurrealDB interfaces using a JWT, SurrealQL queries will gain access to the claims in the token through the `$token` variable. For example, if the token contains custom claims such as “name” or “email”, the values of those claims will be accessible through `$token.name` and `$token.email`.

Additionally, when the `id` claim is present in the token, the fields of the record matching the identifier specified will be accessible through the `$auth` variable. For example, if the value of the `id` claim is `user:73q1bl039y6k8z80v55d`, and user records have fields such as “name” or “email”, then `$auth.name` and `$auth.email` can be used to access those values for the `user:73q1bl039y6k8z80v55d` record specifically, without them being present in the JWT.

The signature of the token is verified with method defined when creating the token. If the signature of the token is invalid, calls to SurrealDB interfaces using that token will fail.

### Namespace

Namespace tokens can be used to select, create, update, and delete on all tables in all databases, as well as to define and remove databases and tables from the namespace.

```surql
-- Specify the namespace for the token
USE NS abcum;

-- Set the name of the token
DEFINE TOKEN token_name
  -- Use this OAuth provider for namespace authorization
  ON NAMESPACE
  -- Specify the cryptographic signature algorithm used to verify the token
  TYPE HS512
  -- Specify the public key so we can verify the authenticity of the token
  VALUE "sNSYneezcr8kqphfOC6NwwraUHJCVAt0XjsRSNmssBaBRh3WyMa9TRfq8ST7fsU2H2kGiOpU4GbAF1bCiXmM1b3JGgleBzz7rsrz6VvYEM4q3CLkcO8CMBIlhwhzWmy8"
;
```
The namespace token payload should at least include the following claims when used to authenticate with SurrealDB.

```json title="JWT Payload"
{
  "exp": 2147483647,
  "tk": "token_name",
  "ns": "abcum"
}
```

### Database

Database tokens can be used to select, create, update, and delete on all tables in a specific database, as well as to define and remove tables from the database.

```surql
-- Specify the namespace and database for the token
USE NS abcum DB app_vitalsense;

-- Set the name of the token
DEFINE TOKEN token_name
  -- Use this OAuth provider for database authorization
  ON DATABASE
  -- Specify the cryptographic signature algorithm used to verify the token
  TYPE HS512
  -- Specify the public key so we can verify the authenticity of the token
  VALUE "sNSYneezcr8kqphfOC6NwwraUHJCVAt0XjsRSNmssBaBRh3WyMa9TRfq8ST7fsU2H2kGiOpU4GbAF1bCiXmM1b3JGgleBzz7rsrz6VvYEM4q3CLkcO8CMBIlhwhzWmy8"
;
```

The database token payload should at least include the following claims when used to authenticate with SurrealDB.

```json title="JWT Payload"
{
  "exp": 2147483647,
  "tk": "token_name",
  "ns": "abcum",
  "db": "app_vitalsense"
}
```

### Scope

Since the origin of the claims in the JWT is verified, those claims can be used within SurrealQL in the context of a scope in order to provide table and field authorization through an external authenticator using OpenID Connect, OAuth or simply acting as a trusted issuer of a JWT.

This can be done by leveraging table permissions to allow or disallow access depending on the values of the claims in the verified token. For example, these claims can be compared with the records in a table to only return those matching certain criteria.

The scope for which the token was issued will be accessible to SurrealQL through the `$scope` variable, corresponding to the contents of the `sc` claim. External authorization providers may provide additional scopes that will not be accessible in this way, and instead should be accessed as any other claim through the `$token` variable.

Bear in mind that table and field permissions only apply to scope level tokens Access provided by namespace and database tokens is above table-level permissions. When application users will be the ones directly authenticating with JWT, scope tokens are most likely the right choice.

The following example shows how scope tokens can be used to grant authorization by verifying that the “email” claim in the token matches the email used as the index of a user table:


```surql
-- Specify the namespace and database for the token
USE NS abcum DB app_vitalsense;

-- Necessary in order to define a scope token
DEFINE SCOPE users;

DEFINE TOKEN token_name ON SCOPE users TYPE RS256 VALUE "-----BEGIN PUBLIC KEY-----
MUO52Me9HEB4ZyU+7xmDpnixzA/CUE7kyUuE0b7t38oCh+sQouREqIjLwgHhFdhh3cQAwr6GH07D
ThioYrZL8xATJ3Youyj8C45QnZcGUif5PkpWXDi0HJSoMFekbW6Pr4xuqIqb2LGxGDVJcLZwJ2AS
Gtu2UAfPXbBD3ffiad393M22g1iHM80YaNi+xgswG7qtXE4lR/Lt4s0MeKKX7stdWI1VIsoB+y3i
r/OWUvJPjjDNbAsyy8tQmxydv+FUnLEP9TNT4AhN4DXcJ+XsDtW7OWt4EdSVDeKpGbIMvIrh1Pe+
Nilj8UHNyNDHa2AjK3seMo6CMvaIQJKj5o4xGFblFGwvvPD03SbuQLs1FdRjsZCeWLdYeQ3JDHE9
sFG7DCXlpMJcaYT1mf4XHJ0gPekNLQyewTY3Vxf7FgV3GCNjV20kcDFgJA2+iVW2wSrb+txD1ycE
kbi8jh0pedWwE40VQWaTh/8eAvX7IHWya/AEro25mq+m6vktNZLbvLphhp586kJK3Tdt3YjpkPre
M3nkFWOWurIyKbtIV9JemfwCgt89sNV45dTlnEDEZFFGnIgDnWgx3CUo4XmhICEQU8+tklw9jJYx
iCTjhbIDEBHySSSc/pQ4ftHQmhToTlQeOdEy4LYiaEIgl1X+hzRH1hBYvWlNKe4EY1nMCKcjgt0=
-----END PUBLIC KEY-----";

DEFINE TABLE user SCHEMAFULL
  -- Authorized users can select, update, delete and create user records
  PERMISSIONS FOR select, update, delete, create
  -- The current scope must be "users"
  WHERE $scope = "users"
  -- The email of the user being queried must match the email claim in the token
  -- Only matching records will be changed or returned
  AND email = $token.email
;

DEFINE INDEX email ON user FIELDS email UNIQUE;
DEFINE FIELD email ON user TYPE string ASSERT string::is_email($value);
DEFINE FIELD name ON user TYPE string;
DEFINE FIELD nickname ON user TYPE string;
DEFINE FIELD picture ON user TYPE string;
```

You may also use permissions clauses to perform additional verification on other JWT claims (e.g. verifying that the iss claim matches a specific principal using $token.iss) that may be required or recommended by a the provider of the token.

The scope token payload should at least include the following claims when used to authenticate with SurrealDB.


```json title="JWT Payload"
{
  "exp": 2147483647,
  "tk": "token_name",
  "ns": "abcum",
  "db": "app_vitalsense",
  "sc": "users"
}
```



================================================
FILE: src/content/doc-surrealql/statements/define/user.mdx
================================================
---
sidebar_position: 18
sidebar_label: DEFINE USER
title: DEFINE USER statement | SurrealQL
description: Use the DEFINE USER statement to create system users on SurrealDB.
---

import Since from '@components/shared/Since.astro'
import RailroadDiagram from '@components/RailroadDiagram.astro'
import Tabs from '@components/Tabs/Tabs.astro'
import TabItem from '@components/Tabs/TabItem.astro'

# `DEFINE USER` statement

Use the `DEFINE USER` statement to create system users on SurrealDB


> [!NOTE]
> While existing logins still function, the DEFINE LOGIN statement has been replaced with DEFINE USER.

## Requirements

- You must be authenticated with a user that has enough permissions. Only the OWNER built-in role grants permissions to create users.
- You must be authenticated with a user that has permissions on the level where you are creating the user:
    - Root users with owner permissions can create Root, Namespace and Database users.
    - Namespace users with owner permissions can create Namespace and Database users
    - Database users with owner permissions can create Database users.
- To select the level where you want to create the user, [you may need to select a namespace and/or database](/docs/surrealql/statements/use) before you can use the `DEFINE USER` statement for database or namespace tokens.


> [!NOTE]
> You cannot use the DEFINE USER statement to create a record user.

## Statement syntax

<Tabs syncKey="define-user-statement">
  <TabItem label="SurrealQL Syntax">

```syntax title="SurrealQL Syntax"
DEFINE USER [ OVERWRITE | IF NOT EXISTS ] @name
	ON [ ROOT | NAMESPACE | DATABASE ]
	[ PASSWORD @pass | PASSHASH @hash ]
	[ ROLES @roles ]
	[ DURATION ( FOR TOKEN @duration [ , ] [ FOR SESSION @duration ] | FOR SESSION @duration [ , ] [ FOR TOKEN @duration ] ) ]
  [ COMMENT @string ]
```

  </TabItem>
  <TabItem label="Railroad Diagram">

export const defineUserAst = {
  type: "Diagram",
  padding: [10, 20, 10, 20],
  children: [
    { type: "Sequence", children: [
      { type: "Terminal", text: "DEFINE" },
      { type: "Terminal", text: "USER" },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Terminal", text: "OVERWRITE" }, { type: "Sequence", children: [ { type: "Terminal", text: "IF" }, { type: "Terminal", text: "NOT" }, { type: "Terminal", text: "EXISTS" } ] } ] } },
      { type: "NonTerminal", text: "@name" },
      { type: "Terminal", text: "ON" },
      { type: "Choice", index: 1, children: [ { type: "Terminal", text: "ROOT" }, { type: "Terminal", text: "NAMESPACE" }, { type: "Terminal", text: "DATABASE" } ] },
      { type: "Optional", child: { type: "Choice", index: 1, children: [ { type: "Sequence", children: [ { type: "Terminal", text: "PASSWORD" }, { type: "NonTerminal", text: "@pass" } ] }, { type: "Sequence", children: [ { type: "Terminal", text: "PASSHASH" }, { type: "NonTerminal", text: "@hash" } ] } ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "ROLES" }, { type: "NonTerminal", text: "@roles" } ] } },
      { type: "Optional", child: { type: "Sequence", children: [
        { type: "Terminal", text: "DURATION" },
        { type: "Choice", index: 1, children: [
          { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "TOKEN" }, { type: "NonTerminal", text: "@duration" }, { type: "Optional", child: { type: "Terminal", text: "," } }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "SESSION" }, { type: "NonTerminal", text: "@duration" } ] } } ] },
          { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "SESSION" }, { type: "NonTerminal", text: "@duration" }, { type: "Optional", child: { type: "Terminal", text: "," } }, { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "FOR" }, { type: "Terminal", text: "TOKEN" }, { type: "NonTerminal", text: "@duration" } ] } } ] }
        ] }
      ] } },
      { type: "Optional", child: { type: "Sequence", children: [ { type: "Terminal", text: "COMMENT" }, { type: "NonTerminal", text: "@string" } ] } }
    ]}
  ]
};

<RailroadDiagram ast={defineUserAst} className="my-6" />

  </TabItem>
</Tabs>

## Example usage
The following example shows how you can create a `ROOT` user using the `DEFINE USER` statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create the user with an owner role and some example durations
DEFINE USER username ON ROOT PASSWORD '123456' ROLES OWNER DURATION FOR SESSION 15m, FOR TOKEN 5s;

```
The following example shows how you can create a `NAMESPACE` user using the `DEFINE USER` statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Specify the namespace
USE NS abcum;
-- Create the user with an editor role and some example durations
DEFINE USER username ON NAMESPACE PASSWORD '123456' ROLES EDITOR DURATION FOR SESSION 12h, FOR TOKEN 1m;
```

The following example shows how you can create a `DATABASE` user using the `DEFINE USER` statement.
```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Specify the namespace and database for the user
USE NS abcum DB app_vitalsense;
-- Create the user with a viewer role and some example durations
DEFINE USER username ON DATABASE PASSWORD '123456' ROLES VIEWER DURATION FOR SESSION 5d, FOR TOKEN 2h;
```

## Using `IF NOT EXISTS` clause

<Since v="v1.3.0" />

The `IF NOT EXISTS` clause can be used to define a user only if it does not already exist. You should use the `IF NOT EXISTS` clause when defining a user in SurrealDB if you want to ensure that the user is only created if it does not already exist. If the user already exists, the `DEFINE USER` statement will return an error.

It's particularly useful when you want to safely attempt to define a user without manually checking its existence first.

On the other hand, you should not use the `IF NOT EXISTS` clause when you want to ensure that the user definition is updated regardless of whether it already exists. In such cases, you might prefer using the `OVERWRITE` clause, which allows you to define a user and overwrite an existing one if it already exists, ensuring that the latest version of the user definition is always in use

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a USER if it does not already exist
DEFINE USER IF NOT EXISTS example ON ROOT PASSWORD "example" ROLES OWNER;
```

## Using `OVERWRITE` clause

<Since v="v2.0.0" />

The `OVERWRITE` clause can be used to define a user and overwrite an existing one if it already exists. You should use the `OVERWRITE` clause when you want to modify an existing user definition. If the user already exists, the `DEFINE USER` statement will overwrite the existing user definition with the new one.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create an USER and overwrite if it already exists
DEFINE USER OVERWRITE example ON ROOT PASSWORD "example" ROLES OWNER;
```

## Roles
Currently, only the built-in roles OWNER, EDITOR and VIEWER are available.

<table>
<thead>
  <tr>
    <th>Role</th>
    <th>Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>OWNER</td>
    <td>Can view and edit any resource on the user's level or below, including user and token (IAM) resources.<br/>It also grants full permissions for child resources that support the `PERMISSIONS` clause (tables, fields, etc.)</td>
  </tr>
  <tr>
    <td>EDITOR</td>
    <td>Can view and edit any resource on the user's level or below, but not users or token (IAM) resources<br/>It also grants full permissions for child resources that support the `PERMISSIONS` clause (tables, fields, etc.)</td>
  </tr>
  <tr>
    <td>VIEWER</td>
    <td>Grants permissions to view any resource on the user's level or below, but not edit.<br/>It also grants view permissions for child resources that support the `PERMISSIONS` clause (tables, fields, etc.)</td>
  </tr>
</tbody>
</table>

## Duration
<Since v="v2.0.0" />

The duration clause specifies the duration of the token returned after successful authentication with a password or passhash as well as the duration of the session established both using a password or passhash and the aforementioned token. The difference between these concepts is explained in the [expiration](/docs/surrealdb/security/authentication#expiration) documentation.



================================================
FILE: src/content/doc-surrealql/statements/define/access/bearer.mdx
================================================
---
sidebar_position: 10
sidebar_label: BEARER 
title: DEFINE ACCESS ... TYPE BEARER statement | SurrealQL
description: A bearer access method allows accessing SurrealDB using a bearer key.
---

import Since from '@components/shared/Since.astro'

# `DEFINE ACCESS ... TYPE BEARER`

A bearer access method allows generating bearer grants with an associated key that can be used to access SurrealDB as a specific [system user](/docs/surrealdb/security/authentication#system-users) or [record user](/docs/surrealdb/security/authentication#record-users). Bearer grants allow other systems and software to authenticate with SurrealDB using a secure and unique credential that can be [audited](/docs/surrealql/statements/access#show) and [revoked](/docs/surrealql/statements/access#revoke) at any time.

Allowing access to SurrealDB using a bearer access method requires creating grants associated with that access method. This can be done using the [`GRANT`](/docs/surrealql/statements/access#grant) clause of the [`ACCESS`](/docs/surrealql/statements/access) statement.

After creating a grant for a subject (i.e. a [system user](/docs/surrealdb/security/authentication#system-users) or a [record user](/docs/surrealdb/security/authentication#record-users)) with a bearer access method, a bearer key will be returned. This bearer key can be used to sign in as the subject of the grant without using its password or any other credentials. As with other credentials in SurrealDB, signing in with a bearer key will return a JWT, which can be used to perform authenticated operations or establish a persistent [authenticated session](/docs/surrealdb/security/authentication). This makes bearer keys most suitable for automations and other service-to-service authentication use cases that require interacting with SurrealDB in an authenticated context by providing stronger security guarantees than passwords and removing the complexity of having to work with JWT directly.

## Requirements

- You must be authenticated as a [root, namespace or database user](/docs/surrealql/statements/define/user) before you can define a bearer access method.

## Statement syntax

```syntax title="SurrealQL Syntax"
DEFINE ACCESS [ OVERWRITE | IF NOT EXISTS ] @name
  ON [ NAMESPACE | DATABASE ]
  TYPE BEARER FOR [ USER | RECORD ]
  [ AUTHENTICATE @expression ]
  [ DURATION
    [ FOR GRANT @duration ]
    [ FOR TOKEN @duration ]
    [ FOR SESSION @duration ]
  ]
```

## `FOR USER`

Defining a bearer access method `FOR USER` will ensure that grants can only be created with a [system user](/docs/surrealdb/security/authentication#system-users) as its subject. This application is useful for integrations that require administering SurrealDB at the `ROOT`, `NAMESPACE` or `DATABASE` level with the roles with which the user has been defined with [`DEFINE USER`](/docs/surrealql/statements/define/user). 

### Example

```surql
DEFINE ACCESS api ON DATABASE TYPE USER DURATION FOR GRANT 30d, FOR TOKEN 15m, FOR SESSION 12h;
```

In this example, grants created with this bearer access method will be valid for 30 days. After signing in with any of those grants, SurrealDB will return a token that will be valid for 15 minutes. This token can be used to establish an authenticated SurrealDB session valid for 12 hours. Grants created with this access method will only allow a system user as its subject.

```surql
-- Define system user that access will be granted to
DEFINE USER automation ON DATABASE PASSWORD 'secret' ROLES VIEWER;
-- Define bearer access method to generate API keys for system users
DEFINE ACCESS api ON DATABASE TYPE BEARER FOR USER DURATION FOR GRANT 10d;
-- Generate bearer grant to be used by a specific automation
ACCESS api GRANT FOR USER automation;
```

```surql title="Response"
{
	ac: 'api',
	creation: d'2025-10-07T04:52:36.157Z',
	expiration: d'2025-10-17T04:52:36.157Z',
	grant: {
		id: 'W9gi9FVexSLP',
		key: 'surreal-bearer-W9gi9FVexSLP-WFmLPW6GyFyj1gJMdEY22YzA'
	},
	id: 'W9gi9FVexSLP',
	revocation: NONE,
	subject: {
		user: 'automation'
	},
	type: 'bearer'
}
```

The key value returned in the grant object is the bearer key, which can be used to sign in as the `automation` user without using its password.

Here are some examples on how to do that using the [JavaScript SDK](/docs/sdk/javascript) or a raw [HTTP request](/docs/surrealdb/integration/http).

#### JavaScript SDK

```js
const db = new Surreal();
db.connect('ws://localhost:8000/rpc', {
	namespace: 'test',
	database: 'test',
});

db.signin({
	namespace: 'test',
	database: 'test',

	// Provide the name of the access method
	access: 'api',

	// Provide the bearer key in the "key" variable
	variables: {
    		key: 'surreal-bearer-BNb2pS0GmaJz-5eTfQ5uEu8jbRb3oblqVMAt8',
	}
});
```

#### HTTP Request

```bash
curl -X POST \
	-H "Accept: application/json" \
	-d '{"NS":"test", "DB":"test", "AC":"api", "key":"surreal-bearer-BNb2pS0GmaJz-5eTfQ5uEu8jbRb3oblqVMAt8"}' \
	http://localhost:8000/signin
```

## `FOR RECORD`

Defining a bearer access method `FOR RECORD` will ensure that grants can only be created with a [record user](/docs/surrealdb/security/authentication#record-users) as its subject. This application is useful for integrations that require accessing only some data in a specific SurrealDB database and in accordance with existing `PERMISSIONS` clauses. Bearer access can only be defined `FOR RECORD` if a database is selected and using `ON DATABASE`.

```surql
-- Create record representing a user
CREATE user:1 CONTENT { name: "tobie" };
-- Define bearer access method to generate API keys for record users
DEFINE ACCESS api ON DATABASE TYPE BEARER FOR RECORD DURATION FOR GRANT 10d;
-- Generate bearer grant to be used by a specific automation belonging to the user
ACCESS api GRANT FOR RECORD user:1;
```

```surql title="Response"
-- Query 1
[
        {
                id: user:1,
                name: 'tobie'
        }
]
-- Query 2
NONE
-- Query 3
{
	ac: 'api',
	creation: d'2025-10-07T04:54:26.258986Z',
	expiration: d'2025-10-17T04:54:26.258987Z',
	grant: {
		id: 'jeGA4jfNmnoD',
		key: 'surreal-bearer-jeGA4jfNmnoD-X2xYQ1IILzB47DttrNpMBquN'
	},
	id: 'jeGA4jfNmnoD',
	revocation: NONE,
	subject: {
		record: user:1
	},
	type: 'bearer'
};
```

The key value returned in the grant object is the bearer key, which can be used to sign in as the `user:1` record in SurrealDB.

Here are some examples on how to do that using the JavaScript SDK or a raw HTTP request.

#### JavaScript SDK

```js
const db = new Surreal();
db.connect('ws://localhost:8000/rpc', {
	namespace: 'test',
	database: 'test',
});

db.signin({
	namespace: 'test',
	database: 'test',

	// Provide the name of the access method
	access: 'api',

	// Provide the bearer key in the "key" variable
	variables: {
    		key: 'surreal-bearer-NJ2I2d7OXxN9-Oa5LqF36IzfURpo6Bhxy9WMF',
	}
});
```

#### HTTP Request

```bash
curl -X POST \
	-H "Accept: application/json" \
	-d '{"NS":"test", "DB":"test", "AC":"api", "key":"surreal-bearer-NJ2I2d7OXxN9-Oa5LqF36IzfURpo6Bhxy9WMF"}' \
	http://localhost:8000/signin
```


## Using `IF NOT EXISTS` clause

The `IF NOT EXISTS` clause can be used to define an access method of type BEARER only if it does not already exist. You should use the `IF NOT EXISTS` clause when defining an access method in SurrealDB if you want to ensure that the access method is only created if it does not already exist. If the access method already exists, the `DEFINE ACCESS` statement will return an error.

It's particularly useful when you want to safely attempt to define an access method without manually checking its existence first.

```surql
-- Create a BEARER access method for the example database if it does not already exist
DEFINE ACCESS IF NOT EXISTS example ON DATABASE TYPE BEARER;
```

## Using `OVERWRITE` clause

The `OVERWRITE` clause can be used to define an access method of type BEARER and overwrite an existing one if it already exists. You should use the `OVERWRITE` clause when you want to modify an existing access method definition. If the access method already exists, the `DEFINE ACCESS` statement will overwrite the existing access method definition with the new one.

```surql
-- Create a BEARER access method for the example database and overwrite if it already exists
DEFINE ACCESS OVERWRITE example ON DATABASE TYPE BEARER;
```



================================================
FILE: src/content/doc-surrealql/statements/define/access/index.mdx
================================================
---
sidebar_position: 10
sidebar_label: DEFINE ACCESS
title: DEFINE ACCESS statement | SurrealQL
description: Defining an access method allows SurrealDB to grant access to resources using different kinds of credentials.
---

import Since from '@components/shared/Since.astro'

# `DEFINE ACCESS` statement

<Since v="v2.0.0" />

Defining an access method allows SurrealDB to grant access to resources using different kinds of credentials.

## Requirements

- You must be authenticated as a [system user](/docs/surrealdb/security/authentication#system-users) at the same level or higher than the level on which access is defined.

## Statement syntax

```syntax title="SurrealQL Syntax"
DEFINE ACCESS [ OVERWRITE | IF NOT EXISTS ] @name
  ON [ ROOT | NAMESPACE | DATABASE ]
  TYPE [
    JWT [ ALGORITHM @algorithm KEY @key | URL @url ]
    | RECORD
      [ SIGNUP @expression ]
      [ SIGNIN @expression ]
      [ WITH JWT
        [ ALGORITHM @algorithm KEY @key | URL @url ]
        [ WITH ISSUER KEY @key ]
      ]
      [ WITH REFRESH ]
    | BEARER FOR [ USER | RECORD ]
  [ AUTHENTICATE @expression ]
  [ DURATION
    [ FOR GRANT @duration ]
    [ FOR TOKEN @duration ]
    [ FOR SESSION @duration ]
  ]
  [ COMMENT @string ]
```

## JSON Web Token (JWT) Access

A JWT access method allows accessing SurrealDB with a token signed by a trusted issuer. The contents of the token will be trusted by SurrealDB as long as it has been signed with a trusted credential.

Learn more about [JWT access method in the documentation](/docs/surrealql/statements/define/access/jwt).

## Record Access

A record access method allows accessing SurrealDB as a [record user](/docs/surrealdb/security/authentication#record-users). Record users allow SurrealDB to operate as a web database by offering mechanisms to define custom signin and signup logic as well as custom table and field permissions.

Learn more about [record access method in the documentation](/docs/surrealql/statements/define/access/record).

## Bearer Access

A bearer access method allows generating bearer grants with an associated key that can be used to access SurrealDB as a specific [system user](/docs/surrealdb/security/authentication#system-users) or [record user](/docs/surrealdb/security/authentication#record-users). Bearer grants allow other systems and software to authenticate with SurrealDB using a secure and unique credential that can be audited and revoked at any time.

Learn more about [bearer access method in the documentation](/docs/surrealql/statements/define/access/bearer).

## Duration

The duration clause specifies the duration of the token returned after successful authentication with the access method as well as the duration of the session established both using the access method and the aforementioned token. The difference between these concepts is explained in the [expiration documentation](/docs/surrealdb/security/authentication#expiration).

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a RECORD access method for accounts
-- On successful authentication, a token expiring after 15 minutes will be returned
-- This token can be used to establish a session that will expire after 6 hours
-- The token will be automatically used to authenticate the session
DEFINE ACCESS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 15m, FOR SESSION 12h
;
```

## With `AUTHENTICATE` clause

The authenticate clause can be used to change the record identifier returned by the `SIGNIN` and `SIGNUP` clauses or replace the identifier provided in the token when authenticating `WITH JWT`, In the context of [`DEFINE ACCESS ... TYPE RECORD`](/docs/surrealql/statements/define/access/record), the `AUTHENTICATE` clause is always executed across signin, signup and token authentication.

When used in a [`DEFINE ACCESS ... TYPE JWT`](/docs/surrealql/statements/define/access/jwt), the `AUTHENTICATE` clause is used to validate the token claims and can be used to log or stop authentication attempts.

In both cases, the clause expects nothing to be returned and will otherwise fail with a generic error. The `THROW` statement can be called to return a custom error to the end user.

## Using `IF NOT EXISTS` clause
<Since v="v1.3.0" />

The `IF NOT EXISTS` clause can be used to define an access method only if it does not already exist. If the access method already exists, the `DEFINE ACCESS` statement will return an error.

```surql
-- Create an ACCESS if it does not already exist
DEFINE ACCESS IF NOT EXISTS example ON NAMESPACE ...;
```

## Using `OVERWRITE` clause

The `OVERWRITE` clause can be used to define an access method and overwrite an existing one if it already exists. You should use the `OVERWRITE` clause when you want to modify an existing access method definition. If the access method already exists, the `DEFINE ACCESS` statement will overwrite the existing access method definition with the new one.

```surql
-- Create an ACCESS and overwrite if it already exists
DEFINE ACCESS OVERWRITE example ON NAMESPACE ...;
```



================================================
FILE: src/content/doc-surrealql/statements/define/access/jwt.mdx
================================================
---
sidebar_position: 10
sidebar_label: JWT
title: DEFINE ACCESS ... TYPE JWT statement | SurrealQL
description: A JWT access method allows accessing SurrealDB with a token signed by a trusted issuer.
---

import Since from '@components/shared/Since.astro'


# `DEFINE ACCESS ... TYPE JWT`

<Since v="v2.0.0" />

A JWT access method allows accessing SurrealDB with a token signed by a trusted issuer. The contents of the token will be trusted by SurrealDB as long as it has been signed with a trusted credential.

SurrealDB can work with third-party authentication providers such as OpenID Connect providers, OAuth providers and other trusted parties providing JWT (JSON Web Tokens, also referred to in this page as “tokens”). Let's say that your provider issues your client (e.g. a user or a service) a JWT once it has authenticated. By using the `DEFINE ACCESS ... TYPE JWT` statement, you can set the public key or shared secret that will be used to verify the authenticity of the token.

This verification is performed automatically by SurrealDB when provided with a JWT through any of its interfaces (i.e. the [HTTP REST API](/docs/surrealdb/integration/http) through the “Authorization” header or [any of the SDKs](/docs/surrealdb/integration/sdks) through the “Authenticate” methods) before trusting the claims contained in the token and allowing SurrealQL queries to access the values of those claims.

Bear in mind that table and field permissions only apply to [record users](/docs/surrealdb/security/authentication#record-users), which must use tokens that are verified by a `RECORD` access method. Access provided by namespace and database tokens defined in a `JWT` access method is equivalent to access from [system users](/docs/surrealdb/security/authentication#system-users), which is above fine-grained permissions. When application users will be the ones directly authenticating with JWT, defining a `RECORD` access method `WITH JWT` is most likely the right choice.

## Requirements

- You must be authenticated as a [system user](/docs/surrealdb/security/authentication#system-users) at the same level or higher than the level to which you want to provide JWT access.
- [You must select a namespace or database](/docs/surrealql/statements/use) before you can define a JWT access method.

## Statement syntax

```syntax title="SurrealQL Syntax"
DEFINE ACCESS [ OVERWRITE | IF NOT EXISTS ] @name
  ON [ ROOT | NAMESPACE | DATABASE ]
  TYPE JWT [ ALGORITHM @algorithm KEY @key | URL @url ]
  [ AUTHENTICATE @expression ]
  [ DURATION FOR SESSION @duration ]
```

## Verification Types

When defining a token, its type describes the cryptographic algorithm or specification that will be used to verify the token. This can be an HMAC algorithm, a public-key cryptography algorithm or a remote JWKS object containing all the required information to verify the token. When not specified, the type is defined as the `HS256` HMAC cryptographic algorithm.

### Hash-Based Message Authentication Code (HMAC)

With HMAC algorithms (`HS256`,`HS384`,`HS512`) the value of the defined token will be the secret used both to sign (by the issuer of the token) and verify (by SurrealDB) the token. Anyone with access to this secret will be able to issue tokens with arbitrary claims which will be trusted by SurrealDB.

The following example shows the definition of a token using an HMAC algorithm.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Specify the namespace and database for the token
USE NS abcum DB app_vitalsense;

-- Set the name of the token
DEFINE ACCESS token_name
  -- Use this token provider for database authentication
  ON DATABASE
  -- Specify the type of access being defined
  TYPE JWT
  -- Specify the cryptographic signature algorithm used to verify the token
  ALGORITHM HS512
  -- Specify the symmetric key used to sign and verify the authenticity of the token
  KEY "sNSYneezcr8kqphfOC6NwwraUHJCVAt0XjsRSNmssBaBRh3WyMa9TRfq8ST7fsU2H2kGiOpU4GbAF1bCiXmM1b3JGgleBzz7rsrz6VvYEM4q3CLkcO8CMBIlhwhzWmy8"
;
```

### Public-Key Cryptography

With public-key cryptography algorithms (`EDDSA`, `ES256`, `ES384`, `ES512`, `PS256`, `PS384`, `PS512`, `RS256`, `RS384`, `RS512`) the value of the defined token will be the public key used to verify the signature of the token. This value is not secret and should be provided by the issuer of the tokens. Tokens will be signed using the private key, known only to the issuer. The public key value should be provided to SurrealDB including its header and footer. Any whitespace will be trimmed.

The following example shows the definition of a token using a public-key cryptography algorithm.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Specify the namespace and database for the token
USE NS abcum DB app_vitalsense;

-- Set the name of the token
DEFINE ACCESS token_name
  -- Use this token provider for database authentication
  ON DATABASE
  -- Specify the type of access being defined
  TYPE JWT
  -- Specify the cryptographic signature algorithm used to verify the token
  ALGORITHM RS256
  -- Specify the public key used to verify the authenticity of the token
  KEY "-----BEGIN PUBLIC KEY-----
MUO52Me9HEB4ZyU+7xmDpnixzA/CUE7kyUuE0b7t38oCh+sQouREqIjLwgHhFdhh3cQAwr6GH07D
ThioYrZL8xATJ3Youyj8C45QnZcGUif5PkpWXDi0HJSoMFekbW6Pr4xuqIqb2LGxGDVJcLZwJ2AS
Gtu2UAfPXbBD3ffiad393M22g1iHM80YaNi+xgswG7qtXE4lR/Lt4s0MeKKX7stdWI1VIsoB+y3i
r/OWUvJPjjDNbAsyy8tQmxydv+FUnLEP9TNT4AhN4DXcJ+XsDtW7OWt4EdSVDeKpGbIMvIrh1Pe+
Nilj8UHNyNDHa2AjK3seMo6CMvaIQJKj5o4xGFblFGwvvPD03SbuQLs1FdRjsZCeWLdYeQ3JDHE9
sFG7DCXlpMJcaYT1mf4XHJ0gPekNLQyewTY3Vxf7FgV3GCNjV20kcDFgJA2+iVW2wSrb+txD1ycE
kbi8jh0pedWwE40VQWaTh/8eAvX7IHWya/AEro25mq+m6vktNZLbvLphhp586kJK3Tdt3YjpkPre
M3nkFWOWurIyKbtIV9JemfwCgt89sNV45dTlnEDEZFFGnIgDnWgx3CUo4XmhICEQU8+tklw9jJYx
iCTjhbIDEBHySSSc/pQ4ftHQmhToTlQeOdEy4LYiaEIgl1X+hzRH1hBYvWlNKe4EY1nMCKcjgt0=
-----END PUBLIC KEY-----"
;
```

### JSON Web Key Set (JWKS)

With JWKS, a set of JWK (JSON Web Key) objects will be dynamically fetched from a remote location and used to verify tokens following the [RFC 7517](https://datatracker.ietf.org/doc/html/rfc7517) specification. When defining a JWKS token verification method, its value should contain a valid URL that is reachable by SurrealDB and allowed by the configured network [capabilities](/docs/surrealdb/security/capabilities). This URL should point to a valid JWKS object (as described in [Section 5 of RFC 7517](https://datatracker.ietf.org/doc/html/rfc7517#section-5)) in the form of a JSON document. This is the recommended method to integrate with authentication providers that support JWKS. Providers like [Google](https://developers.google.com/identity/openid-connect/openid-connect#discovery), [AWS Cognito](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-verifying-a-jwt.html#amazon-cognito-user-pools-using-tokens-manually-inspect), [Azure Active Directory](https://azure.github.io/azure-workload-identity/docs/installation/self-managed-clusters/oidc-issuer/jwks.html), [Auth0](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets), [Keycloak](https://documentation.cloud-iam.com/how-to-guides/configure-remote-jkws.html) or [OneLogin](https://developers.onelogin.com/authentication/tools/jwt) provide JWKS endpoints to verify tokens issued by their services.

> [!NOTE: Before you start]
> As the JWKS functionality requires establishing a network connection in order to download the JWKS object, you will require running the SurrealDB server with the network <a href="/docs/surrealdb/security/capabilities">capability</a>. For the strongest security, provide the specific hostname hosting the JWKS object when starting SurrealDB with <code>--allow-net</code>. For example: <code>--allow-net example.com</code>.


The following example shows the definition of a token using a JWKS.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Specify the namespace and database for the token
USE NS abcum DB app_vitalsense;

-- Set the name of the token
DEFINE ACCESS token_name
  -- Use this token provider for database authentication
  ON DATABASE
  -- Specify the type of access being defined
  TYPE JWT
  -- Specify the URL where the JWKS object can be found
  URL "https://example.com/.well-known/jwks.json"
;
```

Validating tokens generated by third-party authentication providers using JWKS ensures that keys can be revoked directly from the third-party service and will no longer be accepted by SurrealDB after the local cache for those keys expires. Likewise, it ensures that token verification will not break if keys are rotated, as any new keys will be automatically fetched from the authentication provider if a JWT is received containing a new key identifier in its `kid` header.

To avoid performing requests to the remote URL for each token that is verified, SurrealDB caches every JWKS object that it pulls for a period of 12 hours. The cache can be purged earlier (e.g. in the event a key is compromised) by restarting the SurrealDB server. If a JWT is received containing a reference to a new key identifier in its `kid` header, the JWKS object will be fetched again and updated in the cache if the key identifier is found in the remote JWKS object; this operation will only be performed once every 5 minutes to prevent malicious actors from abusing this process to perform denial of service.

## Using Tokens

The `DEFINE ACCESS ... TYPE JWT` statement lets you specify the amount of permission granting authority you want to give to a token issuer. You are able to specify if the provider can grant namespace or database access to token holders. For this to work, the JWT issued to be used with SurrealDB must contain claims to specify which namespace or database the token bearer is authorized to act on.

The following claims should be added to the JWT payload by the issuer of the token:

- `exp`: The token expiration Unix time. The token will not be valid after.
- `ac`: The name of the access method used to verify the token.
- `ns`: The namespace that the token is issued for.
- `db`: The database that the token is issued for.

The names of these claims can be in all lowercase (i.e. `ac`) or all uppercase (i.e. `AC`), and can be optionally prefaced with the `https://surrealdb.com` namespace (e.g. `https://surrealdb.com/ac`) in order to separate claims directed to SurrealDB from claims directed to other services. When using a namespace, the claim name can also be used without abbreviation, such as in `https://surrealdb.com/access`, `https://surrealdb.com/database`...

The following optional claims are also processed by SurrealDB:

- `id`: The identifier of the resource (e.g. user) associated with the token.
- `nbf`: The token acceptance Unix time. The token will not be valid before.

The expected claims depend on the level at which the token was defined:

- For tokens defined `ON ROOT`: `exp`, `ac`.
- For tokens defined `ON NAMESPACE`: `exp`, `ac`, `ns`.
- For tokens defined `ON DATABASE`: `exp`, `ac`,`ns`,`db`.

For tokens defined for [system users](/docs/surrealdb/security/authentication#system-users), the optional `rl` claim containing an array of capitalized [system user roles](/docs/surrealql/statements/define/user#roles) (e.g. `["Viewer", "Editor", "Owner"]`) can be provided. Doing so will apply the access policy for those roles to any action made using the token. By default, sessions established with tokens without the `rl` claim will only have the `Viewer` role.

When calling any of the SurrealDB interfaces using a JWT, SurrealQL queries will gain access to the claims in the token through the `$token` variable. For example, if the token contains custom claims such as “name” or “email”, the values of those claims will be accessible through `$token.name` and `$token.email`.

The signature of the token is verified with method defined when creating the token. If the signature of the token is invalid, calls to SurrealDB interfaces using that token will fail.

### Root

Root tokens can be used to select, create, update, and delete on all tables in all databases of all namespaces, as well as to define and remove namespaces and databases from the SurrealDB instance.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Set the name of the token
DEFINE ACCESS token_name
  -- Use this token provider for root authentication
  ON ROOT
  -- Specify the type of access being defined
  TYPE JWT
  -- Specify the cryptographic signature algorithm used to verify the token
  ALGORITHM HS512
  -- Specify the symmetric key used to sign and verify the authenticity of the token
  KEY "sNSYneezcr8kqphfOC6NwwraUHJCVAt0XjsRSNmssBaBRh3WyMa9TRfq8ST7fsU2H2kGiOpU4GbAF1bCiXmM1b3JGgleBzz7rsrz6VvYEM4q3CLkcO8CMBIlhwhzWmy8"
;
```
The root token payload should at least include the following claims when used to authenticate with SurrealDB.

```json title="JWT Payload"
{
  "exp": 2147483647,
  "ac": "token_name",
}
```

### Namespace

Namespace tokens can be used to select, create, update, and delete on all tables in all databases, as well as to define and remove databases and tables from the namespace.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Specify the namespace for the token
USE NS abcum;

-- Set the name of the token
DEFINE ACCESS token_name
  -- Use this token provider for namespace authentication
  ON NAMESPACE
  -- Specify the type of access being defined
  TYPE JWT
  -- Specify the cryptographic signature algorithm used to verify the token
  ALGORITHM HS512
  -- Specify the symmetric key used to sign and verify the authenticity of the token
  KEY "sNSYneezcr8kqphfOC6NwwraUHJCVAt0XjsRSNmssBaBRh3WyMa9TRfq8ST7fsU2H2kGiOpU4GbAF1bCiXmM1b3JGgleBzz7rsrz6VvYEM4q3CLkcO8CMBIlhwhzWmy8"
;
```
The namespace token payload should at least include the following claims when used to authenticate with SurrealDB.

```json title="JWT Payload"
{
  "exp": 2147483647,
  "ac": "token_name",
  "ns": "abcum"
}
```

### Database

Database tokens can be used to select, create, update, and delete on all tables in a specific database, as well as to define and remove tables from the database.

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Specify the namespace and database for the token
USE NS abcum DB app_vitalsense;

-- Set the name of the token
DEFINE ACCESS token_name
  -- Use this token provider for database authentication
  ON DATABASE
  -- Specify the type of access being defined
  TYPE JWT
  -- Specify the cryptographic signature algorithm used to verify the token
  ALGORITHM HS512
  -- Specify the symmetric key used to sign and verify the authenticity of the token
  KEY "sNSYneezcr8kqphfOC6NwwraUHJCVAt0XjsRSNmssBaBRh3WyMa9TRfq8ST7fsU2H2kGiOpU4GbAF1bCiXmM1b3JGgleBzz7rsrz6VvYEM4q3CLkcO8CMBIlhwhzWmy8"
;
```

The database token payload should at least include the following claims when used to authenticate with SurrealDB.

```json title="JWT Payload"
{
  "exp": 2147483647,
  "ac": "token_name",
  "ns": "abcum",
  "db": "app_vitalsense"
}
```

## With `AUTHENTICATE` clause

The `AUTHENTICATE` clause allows you to define a custom expression that will be executed when the token is verified. This expression will be executed in the context of the token, allowing you to perform additional checks on the token claims before the token is accepted. If the expression returns any value or throws any error, the token will be rejected.

#### Example: JWT User Authentication with Issuer and Audience Check

This example sets up additional token verification logic for a system user on a database using JSON Web Tokens (JWT) to authenticate. In this example, the HS512 algorithm is used to sign the token. The `AUTHENTICATE` block contains conditions to verify the token's validity: it checks that the issuer (`iss`) of the token is "surrealdb-test" and throws an error if it is not. Similarly, it checks that the audience of the token (defined in the `aud` claim, which can be provided either as an array of strings or a single string) includes "surrealdb-test" and throws an error if it does not. If both checks pass, the token is considered valid. The session duration is set to 2 hours.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE ACCESS user ON DATABASE TYPE JWT
ALGORITHM HS512 KEY "sNSYneezcr8kqphfOC6NwwraUHJCVAt0XjsRSNmssBaBRh3WyMa9TRfq8ST7fsU2H2kGiOpU4GbAF1bCiXmM1b3JGgleBzz7rsrz6VvYEM4q3CLkcO8CMBIlhwhzWmy8"
AUTHENTICATE {
  IF $token.iss != "surrealdb-test" { THROW "Invalid token issuer" };
  IF type::is_array($token.aud) {
    IF "surrealdb-test" NOT IN $token.aud { THROW "Invalid token audience" }
  } ELSE {
    IF $token.aud IS NOT "surrealdb-test" { THROW "Invalid token audience" }
  };
}
DURATION FOR SESSION 2h;
```


## Using `IF NOT EXISTS` clause

The `IF NOT EXISTS` clause can be used to define an access method of type JWT only if it does not already exist. You should use the `IF NOT EXISTS` clause when defining an access method in SurrealDB if you want to ensure that the access method is only created if it does not already exist. If the access method already exists, the `DEFINE ACCESS` statement will return an error.

It's particularly useful when you want to safely attempt to define an access method without manually checking its existence first.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a JWT access method for the example database if it does not already exist
DEFINE ACCESS IF NOT EXISTS example ON DATABASE TYPE JWT ALGORITHM HS512 KEY
"sNSYneezcr8kqphfOC6NwwraUHJCVAt0XjsRSNmssBaBRh3WyMa9TRfq8ST7fsU2H2kGiOpU4GbAF1bCiXmM1b3JGgleBzz7rsrz6VvYEM4q3CLkcO8CMBIlhwhzWmy8";
```

## Using `OVERWRITE` clause

The `OVERWRITE` clause can be used to define an access method of type JWT and overwrite an existing one if it already exists. You should use the `OVERWRITE` clause when you want to modify an existing access method definition. If the access method already exists, the `DEFINE ACCESS` statement will overwrite the existing access method definition with the new one.



```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a JWT access method for the example database and overwrite it if it already exists
DEFINE ACCESS OVERWRITE example ON DATABASE TYPE JWT ALGORITHM HS512 KEY 'secret';
```



================================================
FILE: src/content/doc-surrealql/statements/define/access/record.mdx
================================================
---
sidebar_position: 10
sidebar_label: RECORD
title: DEFINE ACCESS ... TYPE RECORD statement | SurrealQL
description: A record access method allows accessing SurrealDB as a record user.
---

import Since from '@components/shared/Since.astro'

# `DEFINE ACCESS ... TYPE RECORD`

<Since v="v2.0.0" />

A record access method allows accessing SurrealDB as a [record user](/docs/surrealdb/security/authentication#record-users).

Record users allow SurrealDB to operate as a web database by offering mechanisms to define custom signin and signup logic as well as custom table and field permissions.

## Requirements

- You must be authenticated as a [root, namespace or database user](/docs/surrealql/statements/define/user) before you can define a record access method.
- [You must select your namespace and database](/docs/surrealql/statements/use) before you can define a record access method.

## Statement syntax

```syntax title="SurrealQL Syntax"
DEFINE ACCESS [ OVERWRITE | IF NOT EXISTS ] @name
  ON DATABASE TYPE RECORD
    [ SIGNUP @expression ]
    [ SIGNIN @expression ]
    [ WITH JWT
      [ ALGORITHM @algorithm KEY @key | URL @url ]
      [ WITH ISSUER KEY @key ]
    ]
    [ WITH REFRESH ]
  [ AUTHENTICATE @expression ]
  [ DURATION
    [ FOR TOKEN @duration ]
    [ FOR SESSION @duration ]
  ]
```

## Example usage

Below shows how you can define record access using the `DEFINE ACCESS ... TYPE RECORD` statement.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE ACCESS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
	DURATION FOR TOKEN 15m, FOR SESSION 12h
;
```

### With JSON Web Token

Successful authentication with a record access method results in SurrealDB generating a JSON Web Token (JWT or, in the context of SurrealDB, just "token") that can be used until its expiration to authenticate as the record user without the need of providing any additional credentials. These tokens can also be issued by third parties and trusted by SurrealDB in order to allow for the authentication process to take place outside of SurrealDB, while the resulting access claims can be provided to SurrealDB inside of a token that it can trust. This feature is provided by the `WITH JWT` clause, which behaves similarly to [the JWT access method](/docs/surrealql/statements/define/access/jwt).

Since the origin of the claims in the JWT is verified, those claims can be used within SurrealQL in order to provide table and field authorization through an external authenticator using OpenID Connect, OAuth or simply acting as a trusted issuer of a JWT. This can be done by leveraging table permissions to allow or disallow access depending on the values of the claims in the verified token. For example, these claims can be compared with the records in a table to only return those matching certain criteria.

Bear in mind that table and field permissions only apply to [record users](/docs/surrealdb/security/authentication#record-users), which must use tokens that are verified by a `RECORD` access method. Access provided by namespace and database tokens defined in a `JWT` access method is equivalent to access from [system users](/docs/surrealdb/security/authentication#system-users), which is above fine-grained permissions. When application users will be the ones directly authenticating with JWT, defining a `RECORD` access method `WITH JWT` is most likely the right choice.

Reference [the JWT access method](/docs/surrealql/statements/define/access/jwt) documentation for additional information about how JWT tokens can be used in SurrealDB, including verification through [JWKS](/docs/surrealql/statements/define/access/jwt#json-web-key-set-jwks).

The following example shows how record access with a token can be used to grant authorization either by verifying that the `id` claim in the token (which is used to populate the [`$auth`](/docs/surrealql/parameters#auth) reserved parameter) matches the record that is being queried from the `user` table or if the `privileged` claim is set to `true` in the token:

```surql
/**[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

[[test.results]]
value = "NONE"

*/

-- Specify the namespace and database for the token
USE NS abcum DB app_vitalsense;

DEFINE ACCESS token_name ON DATABASE TYPE RECORD WITH JWT
ALGORITHM RS256 KEY "-----BEGIN PUBLIC KEY-----
MUO52Me9HEB4ZyU+7xmDpnixzA/CUE7kyUuE0b7t38oCh+sQouREqIjLwgHhFdhh3cQAwr6GH07D
ThioYrZL8xATJ3Youyj8C45QnZcGUif5PkpWXDi0HJSoMFekbW6Pr4xuqIqb2LGxGDVJcLZwJ2AS
Gtu2UAfPXbBD3ffiad393M22g1iHM80YaNi+xgswG7qtXE4lR/Lt4s0MeKKX7stdWI1VIsoB+y3i
r/OWUvJPjjDNbAsyy8tQmxydv+FUnLEP9TNT4AhN4DXcJ+XsDtW7OWt4EdSVDeKpGbIMvIrh1Pe+
Nilj8UHNyNDHa2AjK3seMo6CMvaIQJKj5o4xGFblFGwvvPD03SbuQLs1FdRjsZCeWLdYeQ3JDHE9
sFG7DCXlpMJcaYT1mf4XHJ0gPekNLQyewTY3Vxf7FgV3GCNjV20kcDFgJA2+iVW2wSrb+txD1ycE
kbi8jh0pedWwE40VQWaTh/8eAvX7IHWya/AEro25mq+m6vktNZLbvLphhp586kJK3Tdt3YjpkPre
M3nkFWOWurIyKbtIV9JemfwCgt89sNV45dTlnEDEZFFGnIgDnWgx3CUo4XmhICEQU8+tklw9jJYx
iCTjhbIDEBHySSSc/pQ4ftHQmhToTlQeOdEy4LYiaEIgl1X+hzRH1hBYvWlNKe4EY1nMCKcjgt0=
-----END PUBLIC KEY-----";

DEFINE TABLE user SCHEMAFULL
  -- Authorized users can select, update, delete and create user records
  PERMISSIONS FOR select, update, delete, create
  -- The access method must be "users"
  WHERE $access = "users"
  -- The record of the user being queried must match the one identified in the token
  -- Only matching records will be changed or returned
  AND id = $auth.id
  -- Allow privileged tokens to query any user
  OR $token.privileged = true
;
```

You may also use permissions clauses to perform additional verification on other JWT claims that may be required or recommended by the provider of the token, such as verifying that the `iss` claim matches a specific principal using `$token.iss`. However, this kind of logic may be better suited for the [`AUTHENTICATE`](#with-authenticate-clause) clause, which is only executed when the token is validated before an authenticated session is established instead of in every query and for each record.

The token payload should at least include the following claims when used to authenticate as a record user in SurrealDB.

```json title="JWT Payload"
{
  "exp": 2147483647,
  "ns": "abcum",
  "db": "app_vitalsense",
  "ac": "users",
  "id": "user:1"
}
```

When the `id` claim is present in the token, the fields of the record matching the identifier specified will be accessible through the `$auth` reserved parameter. For example, if the value of the `id` claim is `user:73q1bl039y6k8z80v55d`, and user records have fields such as “name” or “email”, then `$auth.name` and `$auth.email` can be used to access those values for the `user:73q1bl039y6k8z80v55d` record specifically, without them being present in the JWT.

#### With Issuer

When explicitly defining a way to verify tokens for record access, it is also possible to customize how these tokens are issued by SurrealDB. This allows specifying the algorithm and the signing key, which otherwise default to the HS512 algorithm with a randomly generated 128-character alphanumeric key. Configuring a record access method to sign tokens with specific signing credentials allows third party services to trust tokens issued by SurrealDB by trusting those signing credentials. In this way, an external service may rely on the signup and signin logic that has been implemented for record users in SurrealDB for its own authentication.

Currently, the algorithm for the issuer and the verifier are required to match. For this reason, the issuer algorithm can be omitted if it has already been defined in the `WITH JWT` clause. Likewise, an issuer does not need to be explicitly defined in the case where a key to verify JWT using a symmetric algorithm has already been defined in the `WITH JWT` clause, as the same key will also be used to sign the tokens.

The following is an example of defining a record access method that can issue tokens with an asymmetric key pair:

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE ACCESS token_name ON DATABASE TYPE RECORD WITH JWT
ALGORITHM RS256
  KEY "-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAu1SU1LfVLPHCozMxH2Mo
4lgOEePzNm0tRgeLezV6ffAt0gunVTLw7onLRnrq0/IzW7yWR7QkrmBL7jTKEn5u
+qKhbwKfBstIs+bMY2Zkp18gnTxKLxoS2tFczGkPLPgizskuemMghRniWaoLcyeh
kd3qqGElvW/VDL5AaWTg0nLVkjRo9z+40RQzuVaE8AkAFmxZzow3x+VJYKdjykkJ
0iT9wCS0DRTXu269V264Vf/3jvredZiKRkgwlL9xNAwxXFg0x/XFw005UWVRIkdg
cKWTjpBP2dPwVZ4WWC+9aGVd+Gyn1o0CLelf4rEjGoXbAAEgAqeGUxrcIlbjXfbc
mwIDAQAB
-----END PUBLIC KEY-----"
  WITH ISSUER KEY "-----BEGIN PRIVATE KEY-----
MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC7VJTUt9Us8cKj
MzEfYyjiWA4R4/M2bS1GB4t7NXp98C3SC6dVMvDuictGeurT8jNbvJZHtCSuYEvu
NMoSfm76oqFvAp8Gy0iz5sxjZmSnXyCdPEovGhLa0VzMaQ8s+CLOyS56YyCFGeJZ
qgtzJ6GR3eqoYSW9b9UMvkBpZODSctWSNGj3P7jRFDO5VoTwCQAWbFnOjDfH5Ulg
p2PKSQnSJP3AJLQNFNe7br1XbrhV//eO+t51mIpGSDCUv3E0DDFcWDTH9cXDTTlR
ZVEiR2BwpZOOkE/Z0/BVnhZYL71oZV34bKfWjQIt6V/isSMahdsAASACp4ZTGtwi
VuNd9tybAgMBAAECggEBAKTmjaS6tkK8BlPXClTQ2vpz/N6uxDeS35mXpqasqskV
laAidgg/sWqpjXDbXr93otIMLlWsM+X0CqMDgSXKejLS2jx4GDjI1ZTXg++0AMJ8
sJ74pWzVDOfmCEQ/7wXs3+cbnXhKriO8Z036q92Qc1+N87SI38nkGa0ABH9CN83H
mQqt4fB7UdHzuIRe/me2PGhIq5ZBzj6h3BpoPGzEP+x3l9YmK8t/1cN0pqI+dQwY
dgfGjackLu/2qH80MCF7IyQaseZUOJyKrCLtSD/Iixv/hzDEUPfOCjFDgTpzf3cw
ta8+oE4wHCo1iI1/4TlPkwmXx4qSXtmw4aQPz7IDQvECgYEA8KNThCO2gsC2I9PQ
DM/8Cw0O983WCDY+oi+7JPiNAJwv5DYBqEZB1QYdj06YD16XlC/HAZMsMku1na2T
N0driwenQQWzoev3g2S7gRDoS/FCJSI3jJ+kjgtaA7Qmzlgk1TxODN+G1H91HW7t
0l7VnL27IWyYo2qRRK3jzxqUiPUCgYEAx0oQs2reBQGMVZnApD1jeq7n4MvNLcPv
t8b/eU9iUv6Y4Mj0Suo/AU8lYZXm8ubbqAlwz2VSVunD2tOplHyMUrtCtObAfVDU
AhCndKaA9gApgfb3xw1IKbuQ1u4IF1FJl3VtumfQn//LiH1B3rXhcdyo3/vIttEk
48RakUKClU8CgYEAzV7W3COOlDDcQd935DdtKBFRAPRPAlspQUnzMi5eSHMD/ISL
DY5IiQHbIH83D4bvXq0X7qQoSBSNP7Dvv3HYuqMhf0DaegrlBuJllFVVq9qPVRnK
xt1Il2HgxOBvbhOT+9in1BzA+YJ99UzC85O0Qz06A+CmtHEy4aZ2kj5hHjECgYEA
mNS4+A8Fkss8Js1RieK2LniBxMgmYml3pfVLKGnzmng7H2+cwPLhPIzIuwytXywh
2bzbsYEfYx3EoEVgMEpPhoarQnYPukrJO4gwE2o5Te6T5mJSZGlQJQj9q4ZB2Dfz
et6INsK0oG8XVGXSpQvQh3RUYekCZQkBBFcpqWpbIEsCgYAnM3DQf3FJoSnXaMhr
VBIovic5l0xFkEHskAjFTevO86Fsz1C2aSeRKSqGFoOQ0tmJzBEs1R6KqnHInicD
TQrKhArgLXX4v3CddjfTRJkFWDbE/CkvKZNOrcf1nhaGCPspRJj2KUkj1Fhl9Cnc
dn/RsYEONbwQSjIfMPkvxF+8HQ==
-----END PRIVATE KEY-----"
;
```

The issuer is implicitly defined when using a symmetric algorithm in `WITH JWT`:

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE ACCESS token_name ON DATABASE TYPE RECORD WITH JWT
-- Symmetric algorithm with a symmetric key
-- The same key is used to sign and verify
ALGORITHM HS512 KEY "secret";
-- The following clause is implicit:
-- WITH ISSUER ALGORITHM HS512 KEY "secret"
```

### With refresh token

> [!CAUTION]
> Currently, the `WITH REFRESH` clause is an experimental feature intended to be used for validating its suitability and security. As such, it may be subject to breaking changes and may present unidentified security issues. Do not rely on this feature in production applications.

> [!NOTE]
> Due to changes required in the RPC API and the SDKs, refresh tokens are currently only available when signing up and in through the [HTTP REST API](/docs/surrealdb/integration/http).

Defining a record access method `WITH REFRESH` will result in an additional [bearer key](/docs/surrealql/statements/define/access/bearer) for the record user being returned after successful authentication with the access method. This bearer key is intended to be used as a "refresh token", which is a concept commonly found in standards such as [OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc6749#section-1.5).

Unlike authentication tokens (i.e. JWT), refresh tokens (i.e. bearer keys) feature randomly generated opaque strings that contain no authentication information by themselves, but rather a pointer to an access grant that is stored in the datastore. Also unlike authentication tokens, bearer keys such as refresh tokens can be [audited](/docs/surrealql/statements/access/#show) and [revoked](/docs/surrealql/statements/access/#revoke) using the [`ACCESS`](/docs/surrealql/statements/access) statement. Refresh tokens are automatically revoked and replaced by a new refresh token whenever used to obtain an authentication token, reducing the time window for exploiting a compromised refresh token. These additional security guarantees allow refresh tokens to be longer-lived than authentication tokens, which in turn encourages making the original authentication tokens as short-lived as technically possible.

By default, refresh tokens will expire after 30 days. However, their duration can be configured using the `DURATION FOR GRANT` clause, which will accept any duration. If set to `NONE`, refresh tokens will never expire. It is strongly recommended to set some expiration for refresh tokens to minimize the potential impact of credential stealing attacks.

Because refresh tokens can be used to indefinitely keep a user authenticated with SurrealDB as long as they are exchanged for a new fresh token before they expire, [special care](/docs/surrealdb/reference-guide/security-best-practices#token-storage) should be taken when storing and applications using them should be suitably protected from attacks.

Like other bearer keys, all refresh tokens are stored in the datastore even after they are expired or revoked. This means that using refresh tokens will have a space cost in addition to the performance cost of retrieving and verifying them against the datastore. Refresh tokens are intended to be used only to obtain a new authentication token after the existing one expires and applications should only use them when necessary, such as after receiving a [token expiration error](/docs/surrealdb/security/troubleshooting#token-expired-error). For certain high volume applications, you may want to regularly [purge](/docs/surrealql/statements/access/#purge) expired refresh tokens to minimize the space used by inactive refresh tokens.

For more information on how to manage existing refresh tokens, see the [`ACCESS`](/docs/surrealql/statements/access) statement.

#### Example: Signing in with a refresh token

Define a record access method `WITH REFRESH`:

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE ACCESS user ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
	WITH REFRESH
	DURATION FOR GRANT 15d, FOR TOKEN 1m, FOR SESSION 12h
;
```

Sign up with a new user or sign in with an existing user via the [HTTP REST API](/docs/surrealdb/integration/http):

```bash
curl -X POST \
	-H "Accept: application/json" \
	-d '{"NS":"test", "DB":"test", "AC":"user", "name":"John Doe", "email":"john.doe@example.com", "pass":"VerySecurePassword!"}' \
	http://localhost:8000/signup
```

```json title="Response"
{
	"code":200,
	"details":"Authentication succeeded",
	"token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MzQ1MTkyODIsIm5iZiI6MTczNDUxOTI4MiwiZXhwIjoxNzM0NTE5MzQyLCJpc3MiOiJTdXJyZWFsREIiLCJqdGkiOiJiYzQ3MzhkOS0zMTM3LTQ1ZjMtOGUzMy1jMmJmODI0MzZlZTciLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJBQyI6InVzZXIiLCJJRCI6InVzZXI6dHZ2NWVreXNscjBsb21sNHp4aTkifQ.liEvoYuxk9EgzqBE5MzyG2IaJTJxazz-aD9vqWPGc5AGL2u0H0gggjX3jpcaBAIyU356wxNaxFrvCoTqaA4Vrg",
	"refresh":"surreal-refresh-UgYUNmB3FR8t-zdTZlFNuvdoWOtKe0Aqb1laH"
}
```

Sign in with the refresh token to obtain a new token and refresh token:

```bash
curl -X POST \
	-H "Accept: application/json" \
	-d '{"NS":"test", "DB":"test", "AC":"user", "refresh":"surreal-refresh-UgYUNmB3FR8t-zdTZlFNuvdoWOtKe0Aqb1laH"}' \
	http://localhost:8000/signin
```

```json title="Response"
{
	"code":200,
	"details":"Authentication succeeded",
	"token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MzQ1MTkzNzcsIm5iZiI6MTczNDUxOTM3NywiZXhwIjoxNzM0NTE5NDM3LCJpc3MiOiJTdXJyZWFsREIiLCJqdGkiOiJjN2Q1YjgzYi0yMjJjLTQ2ODYtYjgzYi01ZWVlNDQ5Njk5YmUiLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJBQyI6InVzZXIiLCJJRCI6InVzZXI6dHZ2NWVreXNscjBsb21sNHp4aTkifQ.usM8aMtqAftJcwhUMdmqskr-k58ARF-KbmCYEQuDoGb5PlhVJDwYEwCb0oV8B85MJPvbKlC6HuFKW2wq6-AY9g",
	"refresh":"surreal-refresh-MPKzHBtznxMa-pFJj2Doj2IRHApIzGmeOAcYo"
}
```

### With `AUTHENTICATE` clause

In the context of [`DEFINE ACCESS ... TYPE RECORD`](/docs/surrealql/statements/define/access/record),the authenticate clause can be used to change the record identifier returned by the `SIGNIN` and `SIGNUP` clauses or replace the identifier provided in the token when authenticating `WITH JWT`.

This clause can also be used to log or stop authentication attempts from record users, as it is always executed across signin, signup and token authentication.

Unlike the [`PERMISSIONS`](/docs/surrealql/statements/define/table#defining-permissions) clause, the `AUTHENTICATE` clause is executed only at the time of authentication, resulting in increased performance for queries that only need to be validated at that point.

On the other hand, permissions queries are executed in every query and for each record, ensuring that any authorization conditions are verified at the time of the query. The `AUTHENTICATE` clause is a good fit for validating specific conditions that are not expected to change during the lifetime of the session such as the presence of any required token claims.

#### Example: External authentication providers

Replacing the record identifier that will be used to establish the session is especially useful in scenarios where the token used to authenticate the session does not contain one. This is common when using an external authentication provider, which may only have knowledge of generic user identifiers such as an email address or UUID.

In the below example, we check if the session may already be tied to an existing user by using the `$auth` reserved parameter, which contains the record identifier of the authenticated user. If we can select the `id` field from `$auth`, it means that the token already contained the `id` for a record that exists in the database. If that is not the case, we can check if the token contains a different claim that we can rely on to uniquely identifies users. In this case we check for an email address. If the `email` claim is present in the token, we try to retrieve the user from the `user` table by their email address. If none of the queries return a record, the `AUTHENTICATE` clause will fail with a generic error. You can also choose to `THROW` a custom error as shown in the next example.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE ACCESS user ON DATABASE TYPE RECORD
    WITH JWT ALGORITHM HS512 KEY 'secret'
    AUTHENTICATE {
        IF $auth.id {
            RETURN $auth.id;
        } ELSE IF $token.email {
            RETURN SELECT * FROM user WHERE email = $token.email;
        };
    }
;
```

#### Example: Failing authentication

Because the `AUTHENTICATE` clause is always executed across signin, signup and token authentication, it is in a unique position to centralize logic after user credentials are deemed valid, but before the user is completely authenticated.

Below, we show an example of validating if a user is enabled. If this is not the case, we can `THROW` an error stating why the user cannot authenticate, stopping the authentication attempt with a custom message. You can also choose to not return anything, which results in a generic authentication error. If the user is enabled, we can `RETURN` the record identifier, which confirms that authentication is successful and specifies that the record user which will be authenticated in the session is the same that was already authenticated.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE ACCESS user ON DATABASE TYPE RECORD
    SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass), enabled = true )
    SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
    AUTHENTICATE {
        IF !$auth.enabled {
            THROW "This user is not enabled";
        };

        RETURN $auth;
    }
;
```

#### Example: Auditing and revoking tokens

In addition to what is shown in the previous example, the `AUTHENTICATE` clause can also be used to create records and access the claims found in the token itself using the `$token` reserved parameter. These features can be combined to log authentication attempts and stop authentication from completing if some conditions are met.

Below, we show a proof of concept example that leverages the fact that tokens issued by SurrealDB have the standard `jti` claim, which contains a randomly generated unique identifier for the token. This value can be used to uniquely identify each token that is issued by SurrealDB for the purposes of auditing and revocation.

In this example, we create a new record in the `token` table for each token that SurrealDB issues after a successful `SIGNIN` and `SIGNUP`. This record is identified by the value in the `jti`(JWT ID) claim. Every time that a token is used to authenticate, we check if the record in the `token` table with identifier matching the `jti`(JWT ID) claim has been revoked and, if so, we fail authentication with a custom message. Otherwise, we log the time that the token was used to successfully authenticate in the `audit` table and continue authentication without changes.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

DEFINE ACCESS user ON DATABASE TYPE RECORD
    SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
    SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
    AUTHENTICATE {
        IF type::record("token", $token.jti).revoked = true {
            THROW "This token has been revoked";
        };
        INSERT INTO token { id: $token.jti, exp: $token.exp, revoked: false };
        CREATE audit CONTENT { token: $token.jti, time: time::now() };
        RETURN $auth;
    }
    DURATION FOR TOKEN 30d, FOR SESSION 1h
;
```

## Using `IF NOT EXISTS` clause

The `IF NOT EXISTS` clause can be used to define an access method of type RECORD only if it does not already exist. You should use the `IF NOT EXISTS` clause when defining an access method in SurrealDB if you want to ensure that the access method is only created if it does not already exist. If the access method already exists, the `DEFINE ACCESS` statement will return an error.

It's particularly useful when you want to safely attempt to define an access method without manually checking its existence first.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a RECORD access method for the example database if it does not already exist
DEFINE ACCESS IF NOT EXISTS example ON DATABASE TYPE RECORD;
```

## Using `OVERWRITE` clause

The `OVERWRITE` clause can be used to define an access method of type RECORD and overwrite an existing one if it already exists. You should use the `OVERWRITE` clause when you want to modify an existing access method definition. If the access method already exists, the `DEFINE ACCESS` statement will overwrite the existing access method definition with the new one.

```surql
/**[test]

[[test.results]]
value = "NONE"

*/

-- Create a RECORD access method for the example database and overwrite if it already exists
DEFINE ACCESS OVERWRITE example ON DATABASE TYPE RECORD;
```



================================================
FILE: src/content/doc-tutorials/build-a-realtime-presence-web-application-using-surrealdb-live-queries.mdx
================================================
---
sidebar_position: 7
sidebar_label: Build a realtime presence web application
title: Build a realtime presence web application | Tutorials
description: In this guide, you'll learn how to implement realtime presence tracking that can be integrated in any application including chat applications, multiplayer games, and more.
---

# Build a realtime presence web application using SurrealDB Live Queries

SurrealDB offers various features including a realtime notification mechanism called Live Queries. This feature allows you to subscribe to changes in your database and receive notifications in real-time. In this guide, you’ll learn how to implement realtime presence tracking that can be integrated in any application including chat applications, multiplayer games, and more. The demo project is available on [GitHub](https://github.com/Odonno/surrealdb-presence-demo) using the following tech stack:

- [SurrealDB](/) our database
- [React](https://react.dev/) for the frontend with [Vite](https://vite.dev/) as a bundler
- [TanStack Query](https://tanstack.com/query) to fetch and store data retrieved from the database
- [Tailwind](https://tailwindcss.com/) for styling our application

## Hello, are you there?

![room-users.png](https://github.com/Odonno/surrealdb-presence-demo/raw/main/img/room-users.png)

The demo application looks like a simple chat application with basic features allowing users to join a room and send messages. The application also displays the number of users in the room and their presence status. The presence status is updated in real-time using SurrealDB Live Queries. The mechanism used to detect the presence of a user is a periodic ping sent by the client to the server.

The following configuration is used to setup the project:

- Signal user presence in room periodically every **10 seconds**
- Display status badge based on idle time
        - 🟩 < **2 minutes** of inactivity
        - 🟨 < **10 minutes** of inactivity
        - ⬜ beyond **10 minutes** of inactivity

Note: Those values are completely arbitrary and can be changed to fit your needs.

## Architecture

This project is using the following folder structure:

- `/schemas` - list of SurrealDB tables
- `/events` - list of SurrealDB events
- `/migrations` - list of db migrations that will be automatically applied
- `/src`
        - `/api` - TanStack query hooks
        - `/components`
        - `/constants`
        - `/contexts` - Theme and SurrealDB providers
        - `/hooks` - custom React hooks
        - `/lib` - functions and app models
        - `/mutations` - surql query files to create or update data, using SurrealDB events
        - `/pages`
        - `/queries` - surql query files to query the database, using SurrealDB tables

## Prerequisites

Before you begin this tutorial you’ll need the following:

a. [SurrealDB](/docs/surrealdb/installation) installed on your machine (Make sure you upgrade to the latest version if you already have SurrealDB installed on your machine)

b. The [Bun](https://bun.sh/docs/installation) runtime

c. Optional: [surrealdb-migrations](https://github.com/Odonno/surrealdb-migrations) to manage and automate the deployment of your SurrealDB schema

d. A basic understanding of React and TanStack Query

## Step 0: Setup the project

Once everything is installed, clone the project and navigate to it. Then:

1. Start a new SurrealDB instance locally

```bash
surreal start --log debug --user root --pass root memory --allow-guests
```

2. Apply migrations to the database

Either apply schema & migrations automatically by running the following command:

```bash
surrealdb-migrations apply
```

Or manually apply each file stored in the following folders:

- `schemas`
- `events`
- `migrations`

3. Install dependencies and run the web app

```bash
bun install
bun start
```

4. Launch your web browser on the generated url (eg. http://localhost:5173/) and play with the app: create new accounts, join rooms, leave rooms, etc..

## Step 1: Authentication

For users to join rooms and interact with the app, we need users. And thankfully, SurrealDB also offers authentication mechanism. We will need some basic authentication such as a registration form, a login form, and a way to sign out.

The `user` table will look like this:

```surql
DEFINE TABLE user SCHEMALESS;

DEFINE FIELD username ON user TYPE string;
DEFINE FIELD email ON user TYPE string PERMISSIONS FOR select NONE;
DEFINE FIELD passcode ON user TYPE string PERMISSIONS FOR select NONE;
DEFINE FIELD registered_at ON user TYPE datetime DEFAULT time::now();
DEFINE FIELD avatar ON user TYPE option<string>;

DEFINE INDEX unique_username ON user COLUMNS username UNIQUE;
DEFINE INDEX unique_email ON user COLUMNS email UNIQUE;

DEFINE ACCESS user_access
    ON DATABASE TYPE RECORD
    SIGNUP (
        CREATE user
        SET
            username = $username,
            email = $email,
            avatar = "https://www.gravatar.com/avatar/" + crypto::md5($email) + "?d=identicon",
            passcode = fn::create_passcode($email)
    )
    SIGNIN (
        SELECT *
        FROM user
        WHERE email = $email AND passcode = $passcode
    );
```

We can then create a [login form](https://github.com/Odonno/surrealdb-presence-demo/blob/main/src/components/SignInPopover.tsx) and a [sign up dialog](https://github.com/Odonno/surrealdb-presence-demo/blob/main/src/components/SignUpDialog.tsx).

> [!NOTE]
>We use a passcode to ensure a minimum security authentication. This passcode is generated by the signup function and is stored in the user record. The signin function checks if the passcode is correct. This is for a demonstration purpose only. In a real-world application, you should use a more secure authentication mechanism.

## Step 2: Display room information

We first start by writing the query that will be used to display room information.

```surql
SELECT
    id,
    name,
    created_at,
    (
        RETURN $auth.id IN $parent.users
    ) AS is_in_room,
    array::len(
        SELECT count()
        FROM $parent.users
        WHERE time::now() - ((
            SELECT VALUE at
            FROM last_presence
            WHERE user == $parent.id
        )[0] ?? time::from_secs(0)) < 5m
    ) AS number_of_active_users,
    owner.id != $auth.id AS can_leave
FROM room
ORDER BY created_at DESC;
```

Each `*.surql` query file can then be linked to a TanStack Query query, like this one:

```ts
import roomsQuery from "@/queries/rooms.surql?raw"; // importing raw text file query written in SurrealQL

export const useRooms = () => {
	const dbClient = useSurrealDbClient();

	const getRoomsAsync = async () => {
		const response = await dbClient.query<[Room[]]>(roomsQuery);
		return response[0];
	};

	return useQuery({
		...queryKeys.rooms.list,
		queryFn: getRoomsAsync,
	});
};
```

Here, we will expose a new hook that encapsulates a `useQuery` hook underneath. The same can be done with TanStack query mutations.

## Step 3: Signal user presence

Signaling a presence from the client is almost too easy.

We use the `usePageVisibility` hook to ensure the user is still looking at our app, meaning he did not put the app in the background. Note: this hook is using the [Page Visibility API](https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API) underneath.

And if the page is visible, we use the `useInterval` hook to trigger the signal event every 10 seconds via a TanStack Query mutation .

```ts
const SIGNAL_PRESENCE_INTERVAL = 10 * SECOND;

const SignalPresence = () => {
	const isPageVisible = usePageVisibility();
	const canSignalPresence = isPageVisible;

	const dbClient = useSurrealDbClient();

	const signalPresence = useMutation({
		mutationKey: ["signalPresence"],
		mutationFn: async () => {
			await dbClient.query(signalPresenceQuery);
		},
	});

	useInterval(
		() => {
			signalPresence.mutate();
		},
		canSignalPresence ? SIGNAL_PRESENCE_INTERVAL : null,
	);

	useEffect(() => {
		if (canSignalPresence) {
			signalPresence.mutate();
		}
	}, [isPageVisible]);

	return null;
};
```

The mutation will trigger the following SurrealDB event:

```surql
DEFINE EVENT signal_presence ON TABLE signal_presence WHEN $event == "CREATE" THEN (
    CREATE presence SET user = $auth.id
);
```

The `presence` table will store every presence detection event triggered by our application.

## Step 4: Display realtime presence status

Storing all the presence detection triggered is interesting but it's not very useful. We want to display the presence status of each user in realtime efficiently. To do so, we will create a new table called `last_presence` to retrieve the last presence detection event for each user. We will then be able to use this table to display the presence status of each user in realtime..

```surql
DEFINE TABLE last_presence AS
	SELECT
        user,
        time::max(updated_at) AS at
    FROM presence
	GROUP BY user;
```

Displaying the presence status badge of a user is quite simple. We just need to retrieve the last presence detection event for the user and display the presence status badge based on the time difference between the last presence detection event and the current time.

```ts
const GREEN_STATUS_THRESHOLD = 2 * MINUTE;
const ORANGE_STATUS_THRESHOLD = 10 * MINUTE;

const getPresenceBackgroundClass = (
	lastPresenceDate: Date | undefined,
	now: Date,
) => {
	if (!lastPresenceDate) {
		return "bg-gray-500";
	}

	const diffTimeInSeconds = now.getTime() - lastPresenceDate.getTime();

	if (diffTimeInSeconds < GREEN_STATUS_THRESHOLD) {
		return "bg-green-500";
	}

	if (diffTimeInSeconds < ORANGE_STATUS_THRESHOLD) {
		return "bg-yellow-500";
	}

	return "bg-gray-500";
};

export type PresenceProps = {
	lastPresenceDate?: Date;
	className?: string;
};

const Presence = (props: PresenceProps) => {
	const { lastPresenceDate, className } = props;

	const [now, setNow] = useState(new Date());

	useInterval(() => {
		setNow(new Date());
	}, SECOND);

	const bgClass = getPresenceBackgroundClass(lastPresenceDate, now);

	return (
		<span className={cn(className, "w-2.5 h-2.5 rounded-full", bgClass)} />
	);
};
```

> [!NOTE]
> We trigger a re-render every second to update the presence status. This may not be the most efficient way to do it, but it's enough for this demo. We could use a more specific interval, or use a more efficient way to notify the client when the presence status changes, but it's not the point of this demo.

Now, this component can be easily integrated into another components, like this one:

```ts
const CurrentUserPresence = () => {
	const lastPresenceDate = useRealtimeCurrentUserPresence();

	return (
		<Presence lastPresenceDate={lastPresenceDate} className="-ml-1 mt-1" />
	);
};
```

For reference, we query the last presence of the current user with this query:

```surql
SELECT VALUE at
FROM last_presence
WHERE user == $auth.id;
```

The `useRealtimeCurrentUserPresence` hook retrieves the last presence of the current user and is composed of multiple hooks:

- `useCurrentUserPresence` - the base hook to retrieve the current user presence (without realtime capability)
- `useCurrentUserPresenceLive` - the base hook that is notified by each changes in the database (pure realtime capability)
- `useRealtimeCurrentUserPresence` - the hook itself that combines both previous hooks (current value + upcoming changes)

```ts
const useCurrentUserPresence = () => {
	const dbClient = useSurrealDbClient();

	const getCurrentUserPresenceAsync = async () => {
		const response = await dbClient.query<[string]>(currentUserPresenceQuery);

		if (!response?.[0]) {
			throw new Error();
		}

		return new Date(response[0]);
	};

	return useQuery({
		...queryKeys.users.current._ctx.presence,
		queryFn: getCurrentUserPresenceAsync,
	});
};

const useCurrentUserPresenceLive = (enabled: boolean) => {
	const dbClient = useSurrealDbClient();

	const getCurrentUserPresenceLiveAsync = async () => {
		const query = `LIVE ${currentUserPresenceQuery}`;
		const response = await dbClient.query<[Uuid]>(query);
		return response?.[0];
	};

	return useQuery({
		...queryKeys.users.current._ctx.presence._ctx.live,
		queryFn: getCurrentUserPresenceLiveAsync,
		enabled,
	});
};

export const useRealtimeCurrentUserPresence = () => {
	const queryClient = useQueryClient();

	const { data: lastPresenceDate, isSuccess } = useCurrentUserPresence();
	const { data: liveQueryUuid } = useCurrentUserPresenceLive(isSuccess);

	useLiveQuery({
		queryUuid: liveQueryUuid,
		callback: (action, result) => {
			if (action === "CREATE" || action === "UPDATE") {
				queryClient.setQueryData(
					queryKeys.users.current._ctx.presence.queryKey,
					new Date(result as unknown as string),
				);
			}
		},
		enabled: Boolean(liveQueryUuid),
	});

	useMount(() => {
		return () => {
			queryClient.invalidateQueries({
				queryKey: queryKeys.users.current._ctx.presence.queryKey,
			});
		};
	});

	return lastPresenceDate;
};
```

## Step 5: Refactoring with the `useLiveQuery` hook

One can notice the presence of the `useLiveQuery` hook. This hook is a custom hook that we created to simplify then lifecycle of a Live Query. It automatically subscribe to the Live Query when enabled and it will kill the Live Query on cleanup (when the component is unmounted). Correctly cleaning Live Queries would prevent from any memory leak.

```typescript
export type UseLiveQueryProps<
	T extends Record<string, unknown> = Record<string, unknown>,
> = {
	queryUuid: Uuid | undefined;
	callback: LiveHandler<T>;
	enabled?: boolean;
};

export const useLiveQuery = ({
	queryUuid,
	callback,
	enabled = true,
}: UseLiveQueryProps) => {
	const dbClient = useSurrealDbClient();

	useEffect(() => {
		if (enabled && !!queryUuid) {
			const runLiveQuery = async () => {
				await dbClient.subscribeLive(queryUuid, callback);
			};

			const clearLiveQuery = async () => {
				await dbClient.kill(queryUuid);
			};

			const handleBeforeUnload = () => {
				clearLiveQuery();
			};

			window.addEventListener("beforeunload", handleBeforeUnload);
			runLiveQuery();

			return () => {
				clearLiveQuery();
				window.removeEventListener("beforeunload", handleBeforeUnload);
			};
		}
	}, [queryUuid, enabled]);
};
```

## Bonus: the simulator

Being alone is not really that fun, isn't it? We can't really test the realtime presence feature without having multiple users connected to the same room. That's why we can use the simulator script built to generate some fake users that will interact with the app while active. You can run the following command to start the simulator:

```bash
bun run .\simulator.ts
```

And then let's enjoy the nature of randomness make the app alive!

## Resources

- [Live demo](https://surrealdb-presence-demo.vercel.app/) - The live demo of the application
- [GitHub repository](https://github.com/Odonno/surrealdb-presence-demo) - The GitHub repository of the application
- [SurrealDB Live Queries](/docs/surrealql/statements/live) - The SurrealDB Live Queries documentation
- [SurrealQL Documentation](/docs/surrealql) - The SurrealQL documentation
- [Javascript SDK Documentation](/docs/sdk/javascript) - The Javascript SDK documentation


================================================
FILE: src/content/doc-tutorials/connect-to-surrealdb-via-ngrok-tunnel.mdx
================================================
---
sidebar_position: 4
sidebar_label: Connect to SurrealDB via Ngrok tunnel
title: Tutorials
description: In this section, you will find step-by-step guides and tutorials on how to perform various tasks and achieve specific goals using SurrealDB.
---

# Connect to SurrealDB via Ngrok tunnel

This guide will walk you through connecting a local SurrealDB instance to the internet using Ngrok, making it accessible remotely. 
[Ngrok](https://ngrok.com/) is a cross-platform application that allows developers to expose their local web servers to the internet. It hosts a local web server on its own sub-domain and makes your local development box available on the internet through Tunneling.

This setup is beneficial for remote development and quick testing of applications built locally on SurrealDB. 

## Prerequisites

This guide assumes the following:

- You have [SurrealDB installed](/docs/surrealdb/installation) and a [fresh instance of SurrealDB running.](/docs/surrealdb/introduction/start)
- Downloaded [Ngrok](https://ngrok.com/download) to be used as a tunnel.


> [!IMPORTANT]
> Tunneling refers to the process of using a network protocol to encapsulate a different payload protocol, enabling data to pass securely through a network or the internet

## Steps

There are two ways to connect to a SurrealDB instance via Ngrok tunnel.

### Start SurrealDB Instance

Open your command line or terminal and run the following command to [start SurrealDB](/docs/surrealdb/introduction/start).
    
```bash
surreal start memory -A --user root --pass secret
```
    
We use the default username and password `root`. You can replace it with your own credentials if you have set them up.
   
### Set Up Ngrok Tunnel
    
Open another command line or terminal window (do not close the SurrealDB one) and run the following command to expose SurrealDB’s default port (8000) to the internet:
    
```bash
ngrok http 8000
```
    
Note the forwarding address provided by Ngrok. For example, **`25f6-2402-e280-2189-38e-9c15-d08-2f83-779e.ngrok-free.app`**.

> [!IMPORTANT]
> Keep this address handy as we will use it in the next step.
    
### Connect to SurrealDB via the Ngrok Address
    
Now, let's [connect to your SurrealDB instance](/docs/surrealdb/cli/sql) using the forwarding address provided by Ngrok.
    
Run the following command in a new terminal window/tab, replacing **`[ngrok-address]`** with the actual Ngrok forwarding address you noted earlier:
    
```bash
surreal sql --conn wss://[ngrok-address] --user root --pass secret --ns test --db test --pretty
```
    
### Verify the Connection
    
Finally, let’s ensure the connection is properly set up by running a test query.
With the help of the `CREATE` statement, [create a new record](/docs/surrealql/statements/create). 
    
```surql
CREATE registration SET 
full_name = 'John Doe',
email = 'johndoe@gmail.com',
address_line1 = 'Room number 1, Hogwarts',
address_line2 = 'Near Diagon Alley',
city = 'Hogwarts',
country = 'England';
```
And let's [query the data](/docs/surrealql/statements/select) from the record now. 
```surql
SELECT * FROM registration
 ```

## Conclusion

In this guide, we have looked at how we can connect to a local instance of SurrealDB using tunnels like Ngrok which can help with testing applications. Ngrok provides a random or custom subdomain for your tunnel URL every time you start the tunnel, which is difficult to predict. The data transmitted over the Ngrok tunnel is encrypted, ensuring the information remains secure while it travels over the internet.



================================================
FILE: src/content/doc-tutorials/define-a-schema.mdx
================================================
---
sidebar_position: 6
sidebar_label: Define a Schema in SurrealDB
title: Define a Schema in SurrealDB | Tutorials
description: In this tutorial, you will learn how to define a schema in SurrealDB, what using either schema type means for data retrieval, and how to use what you need as your product grows.
---

# Define a Schema in SurrealDB


When starting a new database project, there are a couple of early decisions to be made, such as creating tables and defining the fields that will be in these tables and also the datatypes of the records, and how the tables you describe relate to each other which includes data sharing or manipulation.

While this might look like many decisions, you are Defining a Schema.

A Schema defines the structure and organisation of data. It dictates how data is stored, organised, and manipulated. Schemas can specify tables, fields (columns), data types, constraints, and relationships between tables.

In summary, a schema is the primary way to ensure your data acts as expected.

There are two main types of schemas:

1. **Schemafull (Structured)**
2. **Schemaless (Unstructured)**

When starting a new project in SurrealDB, you can define your Schema using either method depending on your application's requirements. Since SurrealDB is a multi-model database, you can have both in the same project, depending on your needs.

In this tutorial, you will learn how to define a schema in SurrealDB, what using either schema type means for data retrieval, and how to use what you need as your product grows.

## Prerequisites

Before you start, this guide assumes the following:

- Basic knowledge of databases and data modelling.
- SurrealDB is installed on your machine. You can download and install SurrealDB from the [installation page](/docs/surrealdb/installation).
- [A Command line interface (CLI)](/docs/surrealdb/cli/sql) for interacting with SurrealDB or a [Surrealist sandbox](/docs/surrealist/getting-started#using-the-sandbox).

## Schemafull (Structured) Databases

A schemafull database requires the upfront definition of the structure of your data, including collections (tables) and fields (columns). This approach enforces consistency and integrity, making it suitable for applications with well-defined data models.

In SurrealDB, the Schemafull approach is realised through [Define statements](/docs/surrealql/statements/define), that provide instructions on parts of your database, such as authentication access and behaviour, global parameters, table configurations, table events, analyzers, and indexes. You can set a schemafull table in the following steps:

### Creating a schemafull table

1. Define a Table: To start a schemafull table, specifically use the Define Table statement.

```surql
-- Create a schemafull user table.
DEFINE TABLE user SCHEMAFULL;
```

2. Define Fields: Now that the table is schemafull, no fields can be set unless first defined through a `DEFINE FIELD` statement.

```surql
-- Define some fields.
DEFINE FIELD firstName ON TABLE user TYPE string;
DEFINE FIELD lastName ON TABLE user TYPE string;
DEFINE FIELD email ON TABLE user TYPE string
  ASSERT string::is_email($value);
```

In the code above you may notice the `ASSERT` clause. This can be used to validate any restrictions you want on a field. In the example above the [`string::is_email`](/docs/surrealql/functions/database/string#stringis_email) function is used to check whether the [value](/docs/surrealql/parameters#reserved-variable-names) is an email.

### Adding data to a Schemafull table

Now that you have defined all the fields needed, you can start populating them. To do this, you can use the [CREATE statement](/docs/surrealql/statements/create). For example, add a new user:

```surql
-- 1: Add a user with all required fields.
CREATE user CONTENT {
    firstName: 'John',
    lastName: 'Doe',
    email: 'JohnDoe@someemail.com',
};
```

This will return the data in an object. In the case where the email wasn’t a real email for example:

```surql
-- Using the CREATE statement to populate the table
CREATE user CONTENT {
    firstName: 'John',
    lastName: 'Doe',
    email: 'JohnDoe.com',
};
```

The above will return an error because the field must conform to `string::is_email($value)`

### Inserting fields that don’t exist in the schema

In a schemafull table, since the fields need to be defined before you can populate them, if you add a field that doesn’t exist, your data will be ignored. For example, in the user table, you have only defined the `firstname`, `lastname` and `email` fields. If you introduce a `photoURI` field without defining the field in the `user` table, it will return an error.

```surql
-- 2: Add a user with all required fields and an undefined one, 'photoURI'.
CREATE user CONTENT {
    firstName: 'John',
    lastName: 'Doe',
    email: 'JohnDoe@someemail.com',
    photoURI: 'photo/yxCFi22Jw2.webp'
};
```

## Schemaless (Unstructured) Databases

A schemaless database does not require predefined structures, allowing for more flexible and dynamic data storage. This approach is ideal for applications with evolving data models or when dealing with diverse and unpredictable data formats.

In SurrealDB there are two ways you can define a schemaless table. You can either use any of the data definition statements such as [`CREATE`](/docs/surrealql/statements/create) or [`UPDATE`](/docs/surrealql/statements/update)  and that will make a table based on the [record ID](/docs/surrealql/datamodel/ids#object-based-record-ids) specified. For example:

```surql
-- Using the CREATE statement
CREATE IC_directory:['John', 'Doe'] CONTENT {
	username: 'johndoe',
	full_name: 'John Doe',
	email: 'johndoe@example.com',
	date_of_birth: "1990-01-01",
	join_date: "2024-05-30",
	department: 'Engineering',
	role: 'Software Engineer',
	skills: ['Python', 'JavaScript', 'surql'],
	manager: manager_directory:janesmith,
	tags: ['full-time', 'remote']
};

-- Using the UPDATE statement
UPDATE manager_directory:janesmith CONTENT {
	username: 'janesmith',
	full_name: 'Jane Smith',
	email: 'janesmith@example.com',
	date_of_birth: "1985-01-01",
	join_date: "2019-05-30",
	department: 'Engineering',
    role: 'Software Engineer Manager',
	skills: ['Python', 'JavaScript', 'surql'],
	report: IC_directory:['John', 'Doe'],
	tags: ['full-time', 'remote']
};
```

In the example above, you used the `CREATE` statement to make an `IC_directory` table and created an Object ID for this table. Record IDs can be specified by you [in a large number of formats](/docs/surrealql/datamodel/ids), defaulting to a random UUID if you don't specify your own format for the ID. . You have also used the UPDATE statement to make a `manager_directory`, which has `janesmith` as the ID. Learn more about [Record IDs in the documentation](/docs/surrealql/datamodel/ids#object-based-record-ids).

Notice how we have linked these two tables with the manager and report fields in the `IC_directory` and `manager_directory` tables, respectively.

You can also start defining a Schemaless table using the `DEFINE TABLE` statement.

```surql
-- Create schemaless user table.
DEFINE TABLE user SCHEMALESS;

-- Define some fields.
DEFINE FIELD firstName ON TABLE user TYPE string;
DEFINE FIELD lastName ON TABLE user TYPE string;
DEFINE FIELD email ON TABLE user TYPE string;
```

In the example above you have created a schemaless table using the `SCHEMALESS` clause.

### Inserting fields that don’t exist in the schema

Since a schemaless table doesn’t have any restrictions on the structure if you introduce a new field to an existing table the column will be added to the table even if other records don’t have the value. For example, take the schemafull example of introducing  a `photoURI` field without defining the field in the `user` table:

```surql
CREATE user CONTENT {
    firstName: 'John',
    lastName: 'Doe',
    email: 'JohnDoe@someemail.com',
    photoURI: 'photo/yxCFi22Jw2.webp'
};
```

Since the `user` table is schemaless the `photoURI` field will be added for `John` without an error.

## Combining Schemafull and Schemaless

Now that you have seen how you can make a table in SurrealDB deciding what to go with depends on the restrictions you want to have on your Schema.

Since SurrealDB is multi-model, if some tables require less restrictions you can make them schemaless and if you want to ensure that the structure remains the same for each entry then go with the schemafull option.

### Adding flexible fields in a Schemafull table

In SurrealDB, you can add [flexible fields](/docs/surrealql/statements/define/field#flexible-data-types) to a schemafull table using the `DEFINE FIELD` statement using the `FLEXIBLE` clause. This allows you to have `schemaless` functionality in a `schemafull` table. For example

```surql
-- Define a flexible field in a schemafull table.
DEFINE FIELD interactions ON TABLE user FLEXIBLE;
```

In the example above, you have added a flexible field `interactions` to the `user` table. This field can store any type of data, making it schemaless within a schemafull table. For example, you can store chat logs, emails, phone call records, or any other unstructured data in this field as a JSON object.

```surql
-- Add an interaction to the user table.
UPDATE user:wd99oovq358zfdmajnt7 CONTENT {
    firstName: 'John',
    lastName: 'Doe',
    email: 'JohnDoe@someemail.com',
    interactions: {
        type: 'email',
        subject: 'Welcome to our platform',
        body: 'Thank you for joining our platform. We hope you enjoy your experience.',
        date: '2024-05-30',
    },
};
```

In the example above, you have added an interaction to the `user` table using the `UPDATE` statement. The `interactions` field stores an email interaction with the user, including the type, subject, body, and date.

### Use Case: Customer Relationship Management (CRM) System

A Customer Relationship Management (CRM) system is a prime example of an application that can benefit from both schemafull and schemaless tables.

In this system, schemafull tables are essential for storing structured and consistent data such as customer details, orders, and products.

For instance, a table for customers would include fields like customer ID, first name, last name, email, phone number, and the date they joined, ensuring data integrity and facilitating reliable reporting and analysis.

Similarly, tables for orders and products would maintain strict schemas to track orders accurately and manage product inventories effectively.

On the other hand, schemaless tables offer flexibility for handling unstructured or semi-structured data, which can vary widely. This is particularly useful for storing customer interactions such as emails, chat logs, phone call records, and social media messages, as well as customer feedback and reviews.

These types of data do not fit neatly into a rigid schema due to their diverse formats and content.

By utilising both schemafull and schemaless tables, a CRM system can achieve a balance between maintaining reliable, structured data for critical operations and providing the flexibility to capture and analyse a wide range of customer-related information, enhancing the system's overall adaptability and functionality.

## Conclusion

A schema is the structure of tables in your database. The most important consideration when deciding whether to use a schemafull, schemaless, or both approaches is how flexible you want the content to be. Choose schemafull tables for structured data with strict validation requirements. Use schemaless tables for flexible, dynamic data that might evolve.

Combine both approaches to leverage the strengths of each based on your application's needs.

With respect to Performance Optimisation, you can use the `DEFINE INDEX` statement to create indexes on either form of table. This can also optimise storage and retrieval.

Learn more about setting up a schema in the [`DEFINE` statement documentation](/docs/surrealql/statements/define).



================================================
FILE: src/content/doc-tutorials/index.mdx
================================================
---
sidebar_position: 1
sidebar_label: Tutorials
title: Tutorials | SurrealDB Tutorials | How to guides | SurrealDB guides | Database tutorials
description: In this section, you will find step-by-step guides and tutorials on how to perform various tasks and achieve specific goals using SurrealDB.
---

import Image from "@components/Image.astro";

import LightLogo from "@img/icon/light/tutorials-light.png";
import DarkLogo from "@img/icon/dark/tutorials.png";

<div class="flag-title">
	<Image
		alt="Tutorials"
		width={42}
		height={42}
		src={{
			light: LightLogo,
			dark: DarkLogo,
		}}
	/>
	# Tutorials
</div>

Welcome to the tutorial section. Here you will find comprehensive, step-by-step guides that will walk you through various features and functionalities of SurrealDB.

## Introduction

The purpose of this section is to provide you with practical instructions and examples to help you understand and use SurrealDB effectively. Each tutorial is designed to be concise, easy to follow, and accompanied by code snippets and examples to illustrate the concepts.

If you are new to SurrealDB, we recommend that you start with the [Getting Started](/docs/surrealdb/introduction/start) section of the documentation or the [SurrealQL](/docs/surrealql). This section will provide you with a solid foundation of the core concepts and features of SurrealDB.

## Tutorials

Within this section, you will find a collection of tutorials that cover a wide range of topics related to SurrealDB. These tutorials will walk you through the necessary steps to understand and use specific features, such as setting up database connections, implementing data models, and more.

To get started, select a tutorial from the sidebar or use the search functionality to find a specific topic of interest. Each tutorial provides clear instructions, code examples, and explanations to help you understand and use the feature effectively.

- [Working with SurrealDB over HTTP via Postman](/docs/tutorials/working-with-surrealdb-over-http-via-postman)
- [Integrate Auth0 as an Authentication provider](/docs/tutorials/integrate-auth0-as-authentication-provider)
- [Integrate AWS Cognito as an Authentication Provider](/docs/tutorials/integrate-aws-cognito-as-authentication-provider)
- [Connect to SurrealDB via Ngrok tunnel](/docs/tutorials/connect-to-surrealdb-via-ngrok-tunnel)
- [Define a Schema in SurrealDB](/docs/tutorials/define-a-schema)
- [Using Github Actions in SurrealDB](/docs/tutorials/using-github-actions)



================================================
FILE: src/content/doc-tutorials/integrate-auth0-as-authentication-provider.mdx
================================================
---
sidebar_position: 2
sidebar_label: Integrate Auth0 as an Authentication Provider
title: Integrate Auth0 as an Authentication Provider | Tutorials
description: In this section, you will find step-by-step guides and tutorials on how to perform various tasks and achieve specific goals using SurrealDB.
---
import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Integrate Auth0 as an Authentication Provider

This guide will cover using [Auth0](https://auth0.com/) as the authentication provider for single-page web applications using SurrealDB as the only backend.

Depending on the version of SurrealDB that you are on: `v1.x` or `v2.x`, you may have different options available with respect to using [Scope](/docs/surrealql/statements/define/scope) and [Token](/docs/surrealql/statements/define/token) or [DEFINE ACCESS](/docs/surrealql/statements/define/access) methods to you for integrating Auth0 as an authentication provider.

In this guide you will learn how to:

- Configure Auth0 to issue tokens that can be used with SurrealDB.
- Configure SurrealDB to accept tokens issued by Auth0.
- Define user-level authorization using SurrealDB [record users](/docs/surrealdb/security/authentication#record-users) or [scopes](/docs/surrealql/statements/define/scope) if you are on `v1.x`.
- Authenticate users with Auth0 in a single-page application.
- Retrieve and update information from SurrealDB using the authenticated user.

This guide will cover the most general case, in which SurrealDB is the only backend for your application. You can still follow this guide even if you have additional backends, but in that case you may have other options available to request and validate tokens issued by Auth0. Likewise, even if your application is not strictly a  Single-Page Application (SPA), you may still follow and benefit from this guide.

## Prerequities

This guide assumes the following:

- You have a [fresh instance of SurrealDB running.](/docs/surrealdb/introduction/start)

- You can [use a local Docker container](/docs/surrealdb/installation/running/docker) without volumes for the purposes of this guide.

```bash
docker run --rm --pull always -p 8000:8000 surrealdb/surrealdb:latest \
  start --user root --pass secret
```

To run the SurrealQL statements mentioned in this guide, you will also need an interactive shell.

```bash
surreal sql -u root -p root --pretty
```

You will also need to [create an Auth0 account](https://auth0.com/signup), which can be on the free plan.

## Configuring Auth0

### Creating a simple SPA, an Auth0 application and an Auth0 API

First of all, you will need to complete the regular setup for creating a Single-Page Application and an API resource within Auth0. You can do this by following the official Auth0 [documentation](https://auth0.com/docs/quickstart/spa) for your SPA.

If you are using plain JavaScript, follow [the vanilla guide](https://auth0.com/docs/quickstart/spa/vanillajs/01-login) to create an application in Auth0 and [the API guide](https://auth0.com/docs/quickstart/spa/vanillajs/02-calling-an-api) to create an API in Auth0.

> [!NOTE]
> You will not need to create an actual backend API (e.g. using backend languages like NodeJS or Go) as the documentation suggests when using SurrealDB. A simple file server (e.g. <code>python3 -m http.server 8080</code>, for local testing or any static web server for production) that can serve the static content of your website will suffice. However, creating an API resource in Auth0 is necessary, as it will generate an “audience” string which will be required for Auth0 to add claims to its access tokens.

At the end of those tutorials, you should have both an application and an API created in your Auth0 account and a simple client-side web application that authenticates with Auth0 using those two resources. This website will capture the access token issued by Auth0, which is the token that we are using with SurrealDB. If you were not able to create a working website, you can also use this [minimal example created by SurrealDB](https://github.com/surrealdb/examples/tree/main/auth0).

When completing the actions above, make sure to keep the following information handy:

- Auth0 Client ID, generated when creating the application.
- Auth0 Domain, generated when creating the application.
- Auth0 Audience, generated when creating the API.

### Creating a custom Auth0 action to add claims for SurrealDB

Now, Auth0 is ready to perform authentication and issue tokens for your application. However, SurrealDB expects these tokens to contain some specific claims. Auth0 allows adding custom claims through its “actions” and “flows” features. Since Auth0 [requires claims for an API audience to be namespaced](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/custom-claims-migration#restricted-token-audience), these claims will need to have the `https://surrealdb.com/` prefix.

To add custom claims, you must [create an Auth0 action](https://auth0.com/docs/customize/actions/write-your-first-action#create-an-action) with the “Login / Post Login” trigger.

For this example, you can use the following code:

<Tabs groupId="version">
  <TabItem value="V2" label="Using DEFINE ACCESS" default>
```js
exports.onExecutePostLogin = async (event, api) => {
  if (event.authorization) {
    // The claims in this block are expected by SurrealDB.
    // These values should match your SurrealDB installation.
    api.accessToken.setCustomClaim(`https://surrealdb.com/ns`, "test");
    api.accessToken.setCustomClaim(`https://surrealdb.com/db`, "test");
    // This value corresponds to the name of the JWT access method
    // which will be created in SurrealDB during the next section.
    api.accessToken.setCustomClaim(`https://surrealdb.com/ac`, "auth0");

    // In this block, we will add additional claims which are not required by SurrealDB.
    // These claims can be used from SurrealQL to implement application logic.
    // In this example, we will add the data that we will store for each user.
    // We will also use some of this data to perform authorization.
    api.accessToken.setCustomClaim(`https://surrealdb.com/email`, event.user.email);
    api.accessToken.setCustomClaim(`https://surrealdb.com/email_verified`, event.user.email_verified);
    api.accessToken.setCustomClaim(`https://surrealdb.com/name`, event.user.name);
    api.accessToken.setCustomClaim(`https://surrealdb.com/nickname`, event.user.nickname);
    api.accessToken.setCustomClaim(`https://surrealdb.com/picture`, event.user.picture);
  }
};
```
</TabItem>
<TabItem value="V1" label="Using Scope and Token">
```js
exports.onExecutePostLogin = async (event, api) => {
  if (event.authorization) {
    // The claims in this block are expected by SurrealDB.
    // These values should match your SurrealDB installation.
    api.accessToken.setCustomClaim(`https://surrealdb.com/ns`, "test");
    api.accessToken.setCustomClaim(`https://surrealdb.com/db`, "test");
    // These values correspond to the names of the SCOPE and TOKEN resources
    // which will be created in SurrealDB during the next section.
    api.accessToken.setCustomClaim(`https://surrealdb.com/sc`, "user");
    api.accessToken.setCustomClaim(`https://surrealdb.com/tk`, "auth0");

    // In this block, we will add additional claims which are not required by SurrealDB.
    // These claims can be used from SurrealQL to implement application logic.
    // In this example, we will add the data that we will store for each user.
    // We will also use some of this data to perform authorization.
    api.accessToken.setCustomClaim(`https://surrealdb.com/email`, event.user.email);
    api.accessToken.setCustomClaim(`https://surrealdb.com/email_verified`, event.user.email_verified);
    api.accessToken.setCustomClaim(`https://surrealdb.com/name`, event.user.name);
    api.accessToken.setCustomClaim(`https://surrealdb.com/nickname`, event.user.nickname);
    api.accessToken.setCustomClaim(`https://surrealdb.com/picture`, event.user.picture);
  }
};
```
</TabItem>
</Tabs>

This action should be saved and added to the “Login” flow in the “Actions > Flows” section.

## Configuring SurrealDB

<Tabs groupId="version">
<TabItem value="V2" label="Using DEFINE ACCESS" default>
  #### Defining permissions and fields in SurrealDB

For this simple example, we will create a single table named “user”, where any user that authenticates through Auth0 using your application will be granted complete permissions over their data. For this to work as intended, we will need to ensure that the email address is unique between users and that users are granted permissions to access their own record as long as they authenticated with the access method that we will define.

```surql
DEFINE TABLE user SCHEMAFULL
  -- Authorized users can select, update, delete and create user records.
  -- Records that do not match the permissions will not be modified nor returned.
  PERMISSIONS FOR select, update, delete, create
  WHERE
    -- The access method must match the method that we will define.
    $access = "auth0"
    -- The record identifier must match that of the authenticated user.
    AND id = $auth
;

-- In this example, we will use the email as the primary identifier for a user.
DEFINE INDEX email ON user FIELDS email UNIQUE;
DEFINE FIELD email ON user TYPE string ASSERT string::is_email($value);
-- We define some other information present in the token that we want to store.
DEFINE FIELD name ON user TYPE string;
DEFINE FIELD nickname ON user TYPE string;
DEFINE FIELD picture ON user TYPE string;
```

#### Defining a token verification method in SurrealDB

Next, we should configure SurrealDB so that it can verify tokens sent to it through the [HTTP REST API](/docs/surrealdb/integration/http) via the “Authorization” header or through any of the [SDKs](/docs/surrealdb/integration/sdks) via the “Authenticate” methods.

To do that, we will leverage the JWKS support in SurrealDB in order to define a token verification mechanism pointing to a JWKS object served by Auth0. This JWKS object can be found in a [dedicated endpoint for your Auth0 domain](https://auth0.com/docs/secure/tokens/json-web-tokens/locate-json-web-key-sets). Pointing to a JWKS file ensures that token verification will work seamlessly even after [rotating the signing keys](https://auth0.com/docs/get-started/tenant-settings/signing-keys/rotate-signing-keys) and that tokens signed with revoked keys will no longer be accepted by SurrealDB. To understand how revocation is handled by SurrealDB, read the [JSON Web Key Set documentation](/docs/surrealql/statements/define/access/jwt#json-web-key-set-jwks) under `DEFINE ACCESS ... TYPE JWT`.

We will also use the [`AUTHENTICATE`](/docs/surrealql/statements/define/access/record#with-authenticate-clause) clause in order to check that any necessary token claims have the expected values before returning the user matching the email address provided by Auth0. This is required because Auth0 has no knowledge of the record identifiers that are used in SurrealDB, so we need to use an identifier that can actually be provided by Auth0 in order to retrieve the corresponding record user.

The following queries will create the required resources to authenticate a token for a record user:

```surql
-- Specify the namespace and database that will be used.
-- These values should match the custom claims that we configured before.
USE NS test DB test;

-- Define the public key to verify tokens issued by Auth0 for our application.
-- The name of the token should match the custom claim that we configured before.
DEFINE ACCESS auth0 ON DATABASE TYPE RECORD
    -- We verify the token using the public keys hosted by Auth0.
    WITH JWT URL "https://<YOUR_AUTH0_DOMAIN>/.well-known/jwks.json"
    -- We check the token claims and map the email address to a record user.
    AUTHENTICATE {
        IF (
            -- The JWT specification allows the audience claim to be an array or a string.
            -- In this example, we ensure that it is provided as an array by Auth0.
            $token.aud.is_array()
            -- The audience claim must contain the audience of you application.
            -- This is the value that you defined when creating the API in Auth0.
            AND $token.aud CONTAINS "<YOUR_AUTH0_AUDIENCE_VALUE>"
            -- The audience claim must contain your Auth0 user information endpoint.
            -- It contains the domain generated when when creating the application in Auth0.
            AND $token.aud CONTAINS "https://<YOUR_AUTH0_DOMAIN>/userinfo"
            -- The email address in the token must be verified as belonging to the user.
            AND $token['https://surrealdb.com/email_verified'] = true
        ) {
            -- We return the only user that matches the email address claim found in the token.
            RETURN SELECT * FROM user WHERE email = $token['https://surrealdb.com/email']
        }
    }
;
```

In the example above, replace the placeholder with the domain value defined for your Auth0 application.

It is important to not that [validating the audience of the token is a requirement of Auth0](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens), other providers may require validating additional claims (e.g. `iss`, `sub`) to ensure that the token is being used as intended. With Auth0, you can also make use of [OpenID Connect scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes), which can be accessed through the `scopes` claim via `$token.scopes` and contain the OIDC scopes requested by the application and granted by the user, which we will not do for this example.

> [!IMPORTANT]
> In order to allow SurrealDB to establish a connection with Auth0 to download the JWKS object, you will require running it with the network <a href="/docs/surrealdb/security/capabilities">capability</a>. For the strongest security, provide your specific Auth0 domain when starting SurrealDB with <code>--allow-net</code>. For example: <code>--allow-net example.eu.auth0.com</code>.

  </TabItem>
  <TabItem value="V1" label="Using Scope and Token" >
  #### Defining a token verification method in SurrealDB

Next, we should configure SurrealDB so that it can verify tokens sent to it through the [HTTP REST API](/docs/surrealdb/integration/http) via the “Authorization” header or through any of the [SDKs](/docs/surrealdb/integration/sdks) via the “Authenticate” methods.

To do that, we will leverage the JWKS support in SurrealDB in order to define a token verification mechanism pointing to a JWKS object served by Auth0. This JWKS object can be found in a [dedicated endpoint for your Auth0 domain](https://auth0.com/docs/secure/tokens/json-web-tokens/locate-json-web-key-sets).

Pointing to a JWKS file ensures that token verification will work seamlessly even after [rotating the signing keys](https://auth0.com/docs/get-started/tenant-settings/signing-keys/rotate-signing-keys) and that tokens signed with revoked keys will no longer be accepted by SurrealDB.

To understand how revocation is handled by SurrealDB, read the [JSON Web Key Set documentation](/docs/surrealql/statements/define/token#json-web-key-set-jwks) under `DEFINE TOKEN`.

The following queries will create the required resources to authenticate a token for a scope:

```surql
-- Specify the namespace and database that will be used.
-- These values should match the custom claims that we configured before.
USE NS test DB test;

-- Define the scope where the token will be used.
-- The name of the scope should match the custom claim that we configured before.
DEFINE SCOPE user;

-- Define the public key to verify tokens issued by Auth0 for our application.
-- The name of the token should match the custom claim that we configured before.
DEFINE TOKEN auth0 ON SCOPE user TYPE JWKS VALUE "https://<YOUR_AUTH0_DOMAIN>/.well-known/jwks.json";
```

In the example above, replace the placeholder with the domain value defined for your Auth0 application.


> [!IMPORTANT]
> In order to allow SurrealDB to establish a connection with Auth0 to download the JWKS object, you will require running it with the network <a href="/docs/surrealdb/security/capabilities">capability</a>. For the strongest security, provide your specific Auth0 domain when starting SurrealDB with <code>--allow-net</code>. For example: <code>--allow-net example.eu.auth0.com</code>.

#### Defining authorization criteria in SurrealDB
For this simple example, we will create a single table named “user”, where any user that authenticates through Auth0 using your application with a verified email address will be able to register, view and update their data. For this to work as intended, we will need to verify some information in the token claims.

```surql
DEFINE TABLE user SCHEMAFULL
  -- Authorized users can select, update, delete and create user records.
  -- Records that do not match the permissions will not be modified nor returned.
  PERMISSIONS FOR select, update, delete, create
  WHERE
    -- The token scope must match the scope that we defined.
    -- The name of the scope should match the scope that we defined before.
    $scope = "user"
    -- The audience claim must contain the audience of you application.
    -- This is the value that you defined when creating the API in Auth0.
    AND $token.aud CONTAINS "<YOUR_AUTH0_AUDIENCE_VALUE>"
    -- The audience claim must contain your Auth0 user information endpoint.
    -- It contains the domain generated when when creating the application in Auth0.
    AND $token.aud CONTAINS "https://<YOUR_AUTH0_DOMAIN>/userinfo"
    -- The email claim must match the email of the user being queried.
    AND email = $token['https://surrealdb.com/email']
    -- The email must be verified as belonging to the user.
    AND $token['https://surrealdb.com/email_verified'] = true
;

-- In this example, we will use the email as the primary identifier for a user.
DEFINE INDEX email ON user FIELDS email UNIQUE;
DEFINE FIELD email ON user TYPE string ASSERT string::is_email($value);
-- We define some other information present in the token that we want to store.
DEFINE FIELD name ON user TYPE string;
DEFINE FIELD nickname ON user TYPE string;
DEFINE FIELD picture ON user TYPE string;
```
It is important to know that [validating the audience of the token is a requirement of Auth0](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens), other providers may require validating additional claims (e.g. iss, sub) to ensure that the token is being used as intended. With Auth0, you can also make use of [OpenID Connect scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes), which can be accessed through the `scopes` claim via `$token.scopes` and contain the OIDC scopes requested by the application and granted by the user, which we will not do for this example.

It is also important to note that the `$auth` variable accessible from SurrealQL will not contain any values in this case, as it requires the `id` claim to be added to the JWT, containing the value of the identifier of a SurrealDB record. For the current example, the `$auth` variable will not be necessary.


  </TabItem>
</Tabs>



## Configuring the Application

Now that we have everything ready for Auth0 to generate tokens and for SurrealDB to receive and verify them, we will modify our simple web application to use the token issued by Auth0 to register a new user or to update its information if the user already exists.

Because of the diversity of SDKs that both SurrealDB and Auth0 support, it is difficult to provide examples that will work for everyone. In this guide, we will provide code examples for the most unspecific use case of using the [SurrealDB HTTP REST API](/docs/surrealdb/integration/http) and [Auth0 SPA JS](https://github.com/auth0/auth0-spa-js).

This code will run entirely on the client and can be added to the static website that you created while following the Auth0 quick start documentation linked at the beginning of this guide.

With the aforementioned interfaces, we can use the following functions to authenticate users:

```js
// Returns users in that the token is authorized to select.
// Should return only the user matching the email in the token.
const getUser = async () => {
	// We fetch an access token from Auth0 with the ID token.
	const auth0Token = await auth0Client.getTokenSilently();

	const response = await fetch(surrealDbConfig.endpoint + "/key/user", {
		method: "GET",
		headers: {
			"Accept": "application/json",
			"Authorization": "Bearer " + auth0Token
		}
	});

	return response.json();
};

// Creates a user matching the information in the token.
// If the user already exists, updates the existing user with the new data.
const createUpdateUser = async () => {
	// We collect the user data from the Auth0 ID token.
	const auth0User = await auth0Client.getUser();
	// We fetch an access token from Auth0 with the ID token.
	const auth0Token = await auth0Client.getTokenSilently();

	// We define the general query to create or update a user.
	// We leave the method to be defined later.
	let query = {
		body: JSON.stringify({
			email: auth0User.email,
			name: auth0User.name,
			nickname: auth0User.nickname,
			picture: auth0User.picture
		}),
		headers: {
			"Accept": "application/json",
			"Authorization": "Bearer " + auth0Token
		}
	};
	// We get the user that the token is authorized to access.
	const surrealDbUser = await getUser();
	if (surrealDbUser[0].result.length == 0) {
		// If a user for the token does not exist, we create the record.
		console.log("Token user does not exist in database. Creating record.");
		query.method = "POST";
	} else {
		// If a user for the token already exists, we update the record.
		console.log("Token user already exists in database. Updating record.");
		query.method = "PUT";
	}

	// We perform the query and return the created/updated record.
	let response = await fetch(surrealDbConfig.endpoint + "/key/user", query);
	return response.json();
};
```

If you want to see how this code would fit inside the web application that you built, you can view this [minimal example created by SurrealDB](https://github.com/surrealdb/examples/tree/main/auth0).

To learn about other potential uses for the SurrealDB token functionality, you can read the [`DEFINE ACCESS ... TYPE JWT`] documentation page](/docs/surrealql/statements/define/access/jwt).

## Annex

In this section, we will provide a few examples of how to configure the application to work with Auth0.

## Example Single Page Application

You can view and download a minimal example of an SPA using Auth0 and SurrealDB [in this repository](https://github.com/surrealdb/examples/tree/main/auth0).

## Alternative: Using HMAC

Using public key cryptography algorithms for signing tokens prevents you from having to store any secrets at all in SurrealDB. However, some SurrealDB administrators may prefer to use HMAC algorithms, which use the same secret to both sign and verify the signature of the JWT. This secret will be stored in SurrealDB when provided as value for the `DEFINE ACCESS` statement and its access should be restricted, as it can be used to issue arbitrary tokens which will be trusted by SurrealDB. However, **we do not recommend this method** over using public cryptography, as the later significantly reduces the burden of creating strong secrets, keeping them secret and managing their lifecycle.

According to the OAuth 2.0 specification (part of OpenID Connect), only confidential (as opposed to public) applications should be allowed to use HMAC algorithms, as it requires being able to keep the secret secure. For this reason, Auth0 will not allow using HMAC algorithms with applications of the SPA (Single-Page Application) type, as they generally would have to store the secret in the client, which is publicly accessible. However, because of the particular case of SurrealDB, the secret will not need to be exposed to the client and will instead be stored in SurrealDB.

Auth0 can support scenarios like these through the option to [disable OIDC-conformant authentication](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication). Once disabled, Auth0 will allow selecting HMAC algorithms for SPA. Keep in mind that other options may become available in Auth0 after this change which, if modified without proper care, may compromise the security of your application.

If the choice of using HMAC is made, the rest of the guide can be followed as is, with the exception of specifying the proper HMAC algorithm and placing the secret as the value when defining a token. In Auth0, the secret used to sign using HMAC algorithm corresponds to the [Auth0 Client Secret](https://auth0.com/docs/secure/application-credentials#client-secret-authentication) string. The example below shows how a token using the HS256 algorithm can be defined:

<Tabs groupId="version">
  <TabItem value="V2" label="Using DEFINE ACCESS" default>
  ```surql
-- Define the secret to verify tokens issued by Auth0 for our application.
-- The name of the access method should match the custom claim that we configured before.
DEFINE ACCESS auth0 ON DATABASE TYPE RECORD
  WITH JWT ALGORITHM HS256 KEY "<YOUR_AUTH0_CLIENT_SECRET_VALUE>"
;
```
  </TabItem>
  <TabItem value="V1" label="Using Scope and Token">
  ```surql
-- Define the secret to verify tokens issued by Auth0 for our application.
-- The name of the token should match the custom claim that we configured before.
DEFINE TOKEN auth0 ON SCOPE user TYPE HS256 VALUE "<YOUR_AUTH0_CLIENT_SECRET_VALUE>";
```
  </TabItem>

</Tabs>



================================================
FILE: src/content/doc-tutorials/integrate-aws-cognito-as-authentication-provider.mdx
================================================
---
sidebar_position: 3
sidebar_label: Integrate AWS Cognito as an Authentication Provider
title: Integrate AWS Cognito as an Authentication Provider | Tutorials
description: In this section, you will find step-by-step guides and tutorials on how to perform various tasks and achieve specific goals using SurrealDB.
---

import Tabs from "@components/Tabs/Tabs.astro";
import TabItem from "@components/Tabs/TabItem.astro";

# Integrate AWS Cognito as an Authentication Provider

This guide will cover using [AWS Cognito](https://aws.amazon.com/cognito/) as the authentication provider for client-side web applications using SurrealDB as the only backend.

Depending on the version of SurrealDB that you are on: `v1.x` or `v2.x`, you may have different options available with respect to using [Scope](/docs/surrealql/statements/define/scope) and [Token](/docs/surrealql/statements/define/token) or [DEFINE ACCESS](/docs/surrealql/statements/define/access) methods to you for integrating Auth0 as an authentication provider.

In this guide you will learn how to:

- Configure AWS Cognito to issue tokens that can be used with SurrealDB.
- Configure SurrealDB to accept tokens issued by AWS Cognito.
- Define user-level authorization using SurrealDB [record users](/docs/surrealdb/security/authentication#record-users).
- Authenticate users with AWS Cognito in a client-side web application.
- Retrieve and update information from SurrealDB using the authenticated user.

This guide will cover the most general case, in which SurrealDB is the only backend for your application. You can still follow this guide even if you have additional backends, but in that case you may have other options available to request and validate tokens issued by AWS Cognito.

## Prerequities

This guide assumes the following:

- You have a [fresh instance of SurrealDB running](/docs/surrealdb/introduction/start) with version `1.2.0` or later.

- You can [use a local Docker container](/docs/surrealdb/installation/running/docker) without volumes for the purposes of this guide.

```bash
docker run --rm --pull always -p 8000:8000 surrealdb/surrealdb:latest \
  start --user root --pass secret
```

To run the SurrealQL statements mentioned in this guide, you will also need an interactive shell.

```bash
surreal sql -u root -p root --pretty
```

You will also need to [have an Amazon Web Services account](https://aws.amazon.com/resources/create-account/). By following this guide you will be subject to **at least** the [AWS Cognito](https://aws.amazon.com/cognito/pricing/) and [AWS Lambda](https://aws.amazon.com/lambda/pricing/) pricing plans. Although the resources used in this guide should be well within the free tier for both, we cannot guarantee that this will be the case in your particular situation.

## Configuring AWS Cognito

In this section, we will create a user pool and a client that will be used to authenticate users with AWS Cognito.

### Creating a User Pool and a Client

Cognito offers [user pools](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html) as a user directory for mobile and web applications. This directory can hold users defined directly within Cognito, but can also integrate with third-party identity providers like Google and Facebook. Additionally, it provides the ability to handle user registrations directly in the [Cognito Hosted UI](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-app-integration.html), which can also take care of requiring specific information, verifying user email addresses and phone numbers or even enforcing multi-factor authentication. Within a user pool, [creating a client](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-client-apps.html#cognito-user-pools-app-idp-settings-console-create) establishes a method (in our case a client-side web application) to authenticate with the user pool.

You will need to [create a user pool](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pool-as-user-directory.html) that meets your requirements. In order to be able to follow along with this guide, the following configuration options are strongly recommended:

- In the "Configure sign-in experience" step:
  - Select at least "Email" in "Cognito user pool sign-in options".
- In the "Configure sign-up experience" step:
  - Select at least "email" in "Required attributes".
  - Select "Allow Cognito to automatically send messages to verify and confirm".
- In the "Configure message delivery" step:
  - Select "Send email with Cognito" in "Email".
- In the "Integrate your app" step:
  - Select "Use the Cognito Hosted UI" in "Hosted authentication pages".
  - Select "Use a Cognito domain" in "Domain" and set a name for it.
  - Select "Public client" in "Initial app client".
  - Select "Don't generate a client secret" in "Initial app client".
  - Under "Allowed callback URLs" in "Initial app client", set the URL of your web application.
  - Under "Advanced app client settings" in "Initial app client", ensure "Authorization code grant" is selected.
  - Under "Attribute read and write permissions" in "Initial app client", ensure "email" is selected for "Read".
  - Under "Attribute read and write permissions" in "Initial app client", ensure "email_verified" is selected for "Read".


> [!IMPORTANT]
> These suggested configuration options may not provide the strongest security or match your specific requirements, but will ensure that you are able to follow with this guide to understand the simplest example of an integration between SurrealDB and AWS Cognito, which you should later update to meet your requirements. Changes in these options may require changes in the other steps outlined in this guide. Other configuration options can be left with their default values or may be changed to fit your requirements.


Once you user pool has been created, open it in the AWS Console and take note of the following values:

- "User pool ID" from the "User pool overview" section in the main user pool view.
- "Cognito domain" from the "Configuration for all app clients" section under the "App integration" tab.
- "Client ID" from the only client in the "App client list" under the "App integration" tab.

### Creating a Pre-Token Generation Lambda

Cognito is now ready to perform authentication and issue tokens for your application. However, SurrealDB expects these tokens to contain some specific claims. Cognito allows modifying token claims through [pre-token generation lambda](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-token-generation.html#cognito-user-pools-lambda-trigger-syntax-pre-token-generation) triggers. Specifically, we will be [adding custom claims](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-token-generation.html#aws-lambda-triggers-pre-token-generation-example-2) to the token.

To create the trigger, just [create an AWS Lambda function](https://docs.aws.amazon.com/lambda/latest/dg/getting-started.html#getting-started-create-function) with the following code:

<Tabs groupId="version">
  <TabItem value="v2.x" label="Using DEFINE ACCESS" default>
  ```js
const handler = async (event) => {
  event.response = {
    claimsOverrideDetails: {
      claimsToAddOrOverride: {
        ac: "cognito", // The access method that has been defined using DEFINE ACCESS.
        ns: "test", // The namespace selected when calling DEFINE ACCESS.
        db: "test", // The database selected when calling DEFINE ACCESS.
      },
    },
  };

  return event;
};

export { handler };
```
  </TabItem>
  <TabItem value="v1.x" label="Using Scope and Token">
  ```js
  const handler = async (event) => {
  event.response = {
    claimsOverrideDetails: {
      claimsToAddOrOverride: {
        tk: "cognito", // The name of the token given when defining it with DEFINE TOKEN.
        sc: "user", // The scope that the token has been defined for with DEFINE TOKEN.
        ns: "test", // The namespace selected when calling DEFINE TOKEN.
        db: "test", // The database selected when calling DEFINE TOKEN.
      },
    },
  };

  return event;
};

export { handler };
```
  </TabItem>
</Tabs>



Note that, in order to use the suggested code, the function must be configured as "Node.js 20.x" or equivalent.

After the Lambda trigger has been created, we will need to [associate it with our client integration](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html). Visit your user pool in Cognito and, under the "User pool properties" tab, in the "Lambda triggers" section, click on "Add Lambda trigger". For this guide, the trigger type will be "Authentication", specifically a "Pre token generation trigger". Select the function that you created.

### Creating a Test User

Depending on how you configured your user pool, users will be able to register by different means. To ensure this guide can be followed easily, we will create a test user that to authenticate in our web application. Open your user pool and click on the "Create user" button under the "Users" section in the main user pool view. Provide an email address for that user and check "Mark email address as verified" to avoid having to do so manaually. Set a password that matches the requirements that you configured.

## Configuring SurrealDB

<Tabs groupId="version">
<TabItem value="v2.x" label="Using DEFINE ACCESS" default>
#### Defining permissions and fields in SurrealDB

For this simple example, we will create a single table named “user”, where any user that authenticates through AWS Cognito using your application will be granted complete permissions over their data. For this to work as intended, we will need to ensure that the email address is unique between users and that users are granted permissions to access their own record as long as they authenticated with the access method that we will define.

```surql
DEFINE TABLE user SCHEMAFULL
  -- Authorized users can select, update, delete and create user records.
  -- Records that do not match the permissions will not be modified nor returned.
  PERMISSIONS FOR select, update, delete, create
  WHERE
    -- The access method must match the method that we will define.
    $access = "cognito"
    -- The record identifier must match that of the authenticated user.
    AND id = $auth
;

-- In this example, we will use the email as the primary identifier for a user.
DEFINE INDEX email ON user FIELDS email UNIQUE;
DEFINE FIELD email ON user TYPE string ASSERT string::is_email($value);
-- We define some other information present in the token that we want to store.
DEFINE FIELD cognito_username ON user TYPE string;
```

#### Defining a token verification method in SurrealDB

Next, we should configure SurrealDB so that it can verify tokens sent to it through the [HTTP REST API](/docs/surrealdb/integration/http) via the “Authorization” header or through any of the [SDKs](/docs/surrealdb/integration/sdks) via the “Authenticate” methods.

To do that, we will leverage the [JWKS support in SurrealDB](/docs/surrealql/statements/define/token#json-web-key-set-jwks) in order to define a token verification mechanism pointing to a JWKS object served by AWS for your Cognito user pool. This JWKS object can be found in an endpoint [build from your AWS region and user pool](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-verifying-a-jwt.html) in the format `https://cognito-idp.<Region>.amazonaws.com/<userPoolId>/.well-known/jwks.json`. Pointing to a remote JWKS object ensures that token verification will work seamlessly even in the case that AWS rotates their encryption keys and that tokens signed with revoked keys will no longer be accepted by SurrealDB. To understand how revocation is handled by SurrealDB, read the [JSON Web Key Set documentation](/docs/surrealql/statements/define/token#json-web-key-set-jwks) under `DEFINE ACCESS ... TYPE JWT`.

We will also use the [`AUTHENTICATE`](/docs/surrealql/statements/define/access/record#with-authenticate-clause) clause in order to check that any necessary token claims have the expected values before returning the user matching the email address provided by AWS Cognito. This is required because AWS Cognito has no knowledge of the record identifiers that are used in SurrealDB, so we need to use an identifier that can actually be provided by AWS Cognito in order to retrieve the corresponding record user.

The following queries will create the required resources to authenticate a token for a record using JWKS:

```surql
-- Specify the namespace and database that will be used.
-- These values should match the custom claims that we configured before.
USE NS test DB test;

-- Define the public key to verify tokens issued by your AWS Cognito user pool.
-- The name of the access method should match the custom claim that we configured before.
DEFINE ACCESS cognito ON DATABASE TYPE RECORD
-- We verify the token using the public keys hosted by AWS.
    WITH JWT URL "https://cognito-idp.<YOUR_AWS_REGION>.amazonaws.com/<YOUR_COGNITO_USER_POOL_ID>/.well-known/jwks.json"
    -- We check the token claims and map the email address to a record user.
    AUTHENTICATE {
        IF (
            -- The issuer claim must match the URL of your AWS Cognito user pool.
            $token.iss = "https://cognito-idp.<YOUR_AWS_REGION>.amazonaws.com/<YOUR_COGNITO_USER_POOL_ID>"
            -- The audience claim must match you AWS Cognito Client ID.
            AND $token.aud = "<YOUR_COGNITO_CLIENT_ID>"
            -- The email address in the token must be verified as belonging to the user.
            AND $token.email_verified = true
        ) {
            -- We return the only user that matches the email address claim found in the token.
            RETURN SELECT * FROM user WHERE email = $token.email
        }
  }
;
```

In the example above, replace the placeholders with values applicable to your Cognito user pool.

It is important to know that [validating the issuer and audience of the token is a requirement of AWS Cognito](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-verifying-a-jwt.html), other providers may require validating additional claims to ensure that the token is being used as intended.

In order to allow SurrealDB to establish a connection with AWS Cognito to download the JWKS object, you will require running it with the network <a href="/docs/surrealdb/security/capabilities">capability</a>.

For the strongest security, provide your specific Cognito user pool domain when starting SurrealDB with `--allow-net`. For example: `--allow-net cognito-idp.eu-west-1.amazonaws.com`.
  </TabItem>
  <TabItem value="v1.x" label="Using Scope and Token">
  #### Defining a token verification method in SurrealDB

Next, we should configure SurrealDB so that it can verify tokens sent to it through the [HTTP REST API](/docs/surrealdb/integration/http) via the “Authorization” header or through any of the [SDKs](/docs/surrealdb/integration/sdks) via the “Authenticate” methods.

To do that, we will leverage the [JWKS support in SurrealDB](/docs/surrealql/statements/define/token#json-web-key-set-jwks) in order to define a token verification mechanism pointing to a JWKS object served by AWS for your Cognito user pool. This JWKS object can be found in an endpoint [build from your AWS region and user pool](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-verifying-a-jwt.html) in the format `https://cognito-idp.<Region>.amazonaws.com/<userPoolId>/.well-known/jwks.json`.

Pointing to a remote JWKS object ensures that token verification will work seamlessly even in the case that AWS rotates their encryption keys and that tokens signed with revoked keys will no longer be accepted by SurrealDB.

To understand how revocation is handled by SurrealDB, read the [JSON Web Key Set documentation](/docs/surrealql/statements/define/token#json-web-key-set-jwks) under `DEFINE TOKEN`.

The following queries will create the required resources to authenticate a token for a scope using JWKS:

```surql
-- Specify the namespace and database that will be used.
-- These values should match the custom claims that we configured before.
USE NS test DB test;

-- Define the scope where the token will be used.
-- The name of the scope should match the custom claim that we configured before.
DEFINE SCOPE user;

-- Define the public key to verify tokens issued by your AWS Cognito user pool.
-- The name of the token should match the custom claim that we configured before.
DEFINE TOKEN cognito ON SCOPE user TYPE JWKS
  VALUE "https://cognito-idp.<YOUR_AWS_REGION>.amazonaws.com/<YOUR_COGNITO_USER_POOL_ID>/.well-known/jwks.json";
;
```

In the example above, replace the placeholders with values applicable to your Cognito user pool.

In order to allow SurrealDB to establish a connection with AWS Cognito to download the JWKS object, you will require running it with the network <a href="/docs/surrealdb/security/capabilities">capability</a>.

For the strongest security, provide your specific Cognito user pool domain when starting SurrealDB with `--allow-net`. For example: `--allow-net cognito-idp.eu-west-1.amazonaws.com`.

#### Defining authorization criteria in SurrealDB

For this example, we will create a single table named `user`, where any user that authenticates through AWS Cognito using your application with a verified email address will be able to register, view and update their data. For this to work as intended, we will need to verify some information in the token claims.

```surql
DEFINE TABLE user SCHEMAFULL
  -- Authorized users can select, update, delete and create user records.
  -- Records that do not match the permissions will not be modified nor returned.
  PERMISSIONS FOR select, update, delete, create
  WHERE
    -- The token scope must match the scope that we defined.
    -- The name of the scope should match the scope that we defined before.
    $scope = "user"
    -- The issuer claim must match the URL of your AWS Cognito user pool.
    AND $token.iss = "https://cognito-idp.<YOUR_AWS_REGION>.amazonaws.com/<YOUR_COGNITO_USER_POOL_ID>"
    -- The audience claim must match you AWS Cognito Client ID.
    AND $token.aud = "<YOUR_COGNITO_CLIENT_ID>"
    -- The email claim must match the email of the user being queried.
    AND email = $token.email
    -- The email must be verified as belonging to the user.
    AND $token.email_verified = true
;

-- In this example, we will use the email as the primary identifier for a user.
DEFINE INDEX email ON user FIELDS email UNIQUE;
DEFINE FIELD email ON user TYPE string ASSERT string::is_email($value);
-- We define some other information present in the token that we want to store.
DEFINE FIELD cognito_username ON user TYPE string;
```

It is important to know that [validating the issuer and audience of the token is a requirement of AWS Cognito](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-verifying-a-jwt.html), other providers may require validating additional claims to ensure that the token is being used as intended.

It is also important to note that the `$auth` variable accessible from SurrealQL will not contain any values in this case, as it requires the `id` claim to be added to the JWT, containing the value of the identifier of a SurrealDB record. For the current example, the `$auth` variable will not be necessary.

  </TabItem>

</Tabs>

## Creating a Simple Web Application

For this guide, we will create a simple client-side web application that will direct the user to log in using the Cognito Hosted UI, redirect the user back your our application with a query parameter containing an authorization code and exchange that code to Cognito for the user identity token which we will use to authenticate with SurrealDB. The application will create or update a SurrealDB user using data from the token claims. This user will later be able visit our web application and retrieve their information from SurrealDB.


> [!NOTE]
> As most other authentication providers using OpenID Connect (OIDC), AWS Cognito issues both identity and access tokens. In this example, we will be using the identity token as it can include custom claims (which are required by SurrealDB) by default. It is important to note that identity tokens should only be used to assert identity claims as opposed to access claims. In this case, we trust the identity token to provide information about the indentity of the user. If we wanted the token to contain authorization claims (e.g. OAuth scopes) we should instead rely on the access token. Customizing access token claims has been <a href="https://aws.amazon.com/about-aws/whats-new/2023/12/amazon-cognito-user-pools-customize-access-tokens/">recently supported by AWS</a> and requires enabling <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pool-settings-advanced-security.html#cognito-user-pool-settings-advanced-security.title">advanced security features</a>. This guide makes the deliberate decision of using the identity token to simplify the process.

We have developed an [example application](https://github.com/surrealdb/examples/tree/main/aws-cognito) that uses plain JavaScript to authenticate with Cognito using basic HTTP requests against the [login endpoint](https://docs.aws.amazon.com/cognito/latest/developerguide/login-endpoint.html) of the Cognito Hosted UI and the Cognito [token endpoint](https://docs.aws.amazon.com/cognito/latest/developerguide/token-endpoint.html). For the purposes of following this guide, we recommend using our example code. However, keep in mind that this code aims to be as simple as possible and is not suitable for production applications. Alternatively, you can develop this application yourself using the [Cognito SDK](https://docs.aws.amazon.com/cognito/latest/developerguide/service_code_examples_cognito-identity-provider.html) or the new [Amplify SDK](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-integrate-apps.html#cognito-integrate-apps-amplify).

When using our example code, you will only need to update the `config.json` file with the values that you saved after creating your user pool and run the web application using the `start.sh` script or any equivalent web server. Once in the web application, clicking the "Log in" button should take you to the Cognito Hosted UI to log in with your test user, after which you should be redirected back to your web application. For this to work, the URL of your web application (without a trailing slash) should be present in the "Allowed callback URLs" list that you defined when configuring the user pool client. After redirection, the web application will show some information about the authenticated user and attempt to create it in SurrealDB via the configured endpoint. After the user is created, subsequent logins will retrieve its information from SurrealDB and display it in the web application. If that is not the case, use the developer console of your browser together with the SurrealDB logs (running with `--log trace` during the debugging for maximum verbosity) to understand why.

Once the example web application is working, you can inspect the simple code under `app.js` to understand how.

## Annex

In this section, we will provide a few examples of how to configure the application to work with AWS Cognito.

## Example Single Page Application

You can view and download a minimal example of an web application using AWS Cognito and SurrealDB [in the AWS cognito example project](https://github.com/surrealdb/examples/tree/main/aws-cognito).



================================================
FILE: src/content/doc-tutorials/using-github-actions.mdx
================================================
---
sidebar_position: 3
sidebar_label: Use SurrealDB in GitHub Actions
title: Use SurrealDB in GitHub Actions | Tutorials
description: This guide will show you how to set up and use the official GitHub Action for SurrealDB in your CI/CD pipeline.
---

# Use SurrealDB in GitHub Actions

This guide will show you how to set up and use the official GitHub Action for SurrealDB in your CI/CD pipeline.

## Step 1: Create a New GitHub Workflow File

Create a new YAML file in your repository's `.github/workflows` directory. You can name the file `surrealdb-ci.yml`.

```yaml
name: SurrealDB CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Git checkout
      uses: actions/checkout@v4
    - name: Start SurrealDB
      uses: surrealdb/setup-surreal@v2
      with:
        surrealdb_version: latest
        surrealdb_port: 8000
        surrealdb_username: root
        surrealdb_password: root
        surrealdb_auth: false
        surrealdb_strict: false
        surrealdb_log: info
        surrealdb_additional_args: --allow-all
        surrealdb_retry_count: 30
```

## Step 2: Customize Workflow Arguments

The official SurrealDB GitHub Action accepts several arguments to configure the SurrealDB setup. Here's a breakdown of the available arguments and their defaults:

<table>
    <thead>
        <tr>
            <th scope="col">Argument</th>
            <th scope="col">Description</th>
            <th scope="col">Default</th>
            <th scope="col">Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Argument">
                surrealdb_version
            </td>
            <td scope="row" data-label="Description">
                SurrealDB version to use
            </td>
            <td scope="row" data-label="Default">
                latest
            </td>
            <td scope="row" data-label="Value">
                latest, v2.x.x
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Argument">
                surrealdb_port
            </td>
            <td scope="row" data-label="Description">
                Port to run SurrealDB on
            </td>
            <td scope="row" data-label="Default">
                8000
            </td>
            <td scope="row" data-label="Value">
                Valid number from 0 to 65535
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Argument">
                surrealdb_username
            </td>
            <td scope="row" data-label="Description">
                Username to use for SurrealDB
            </td>
            <td scope="row" data-label="Default">
                
            </td>
            <td scope="row" data-label="Value">
                Customisable by the user
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Argument">
                surrealdb_password
            </td>
            <td scope="row" data-label="Description">
                Password to use for SurrealDB         
            </td>
            <td scope="row" data-label="Default">
                
            </td>
            <td scope="row" data-label="Value">
                Customisable by the user
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Argument">
                surrealdb_auth
            </td>
            <td scope="row" data-label="Description">
                Enable authentication        
            </td>
            <td scope="row" data-label="Default">
                
            </td>
            <td scope="row" data-label="Value">
                true, false
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Argument">
                surrealdb_strict
            </td>
            <td scope="row" data-label="Description">
                Enable strict mode       
            </td>
            <td scope="row" data-label="Default">
                
            </td>
            <td scope="row" data-label="Value">
                true, false
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Argument">
                surrealdb_log
            </td>
            <td scope="row" data-label="Description">
                Enable logs       
            </td>
            <td scope="row" data-label="Default">
                
            </td>
            <td scope="row" data-label="Value">
                none, full, warn, info, debug, trace
            </td>
        </tr>
        <tr>
            <td scope="row" data-label="Argument">
                surrealdb_additional_args
            </td>
            <td scope="row" data-label="Description">
                Additional arguments for SurrealDB       
            </td>
            <td scope="row" data-label="Default">
                
            </td>
            <td scope="row" data-label="Value">
                <a href="/docs/surrealdb/cli/start" target="_blank" title="Any valid SurrealDB CLI arguments">Any valid SurrealDB CLI arguments</a>            
            </td>
        </tr>
    </tbody>
</table>


### Example Configuration

Here is an example configuration that sets specific values for each argument:

```yaml
name: SurrealDB CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Git checkout
      uses: actions/checkout@v4
    - name: Start SurrealDB
      uses: surrealdb/setup-surreal@v2
      with:
        surrealdb_version: latest
        surrealdb_port: 8000
        surrealdb_username: root
        surrealdb_password: root
        surrealdb_auth: false
        surrealdb_strict: false
        surrealdb_log: info
        surrealdb_additional_args: --allow-all
        surrealdb_retry_count: 30
```

### Tips for Customization

1. **Version Control**: Use specific versions to avoid unexpected changes. Example: surrealdb_version: v2.0.0.
2. **Security**: Always use strong passwords for surrealdb_password and avoid using default credentials in production.
3. **Logs**: Set an appropriate log level based on your needs. For debugging, use debug or trace.
4. **Additional Arguments**: Utilise surrealdb_additional_args to pass any additional CLI arguments required by your setup.

## Step 3: Commit and Push

After creating and customising your workflow file, commit and push it to your repository:
```sh
git add .github/workflows/surrealdb-ci.yml
git commit -m "Add SurrealDB CI workflow"
git push origin main
```

## Step 4: Verify Workflow Execution

Go to your repository on GitHub and navigate to the "Actions" tab. You should see your workflow running when you push changes or create a pull request. Check the logs to verify that SurrealDB is starting up correctly and that all steps are executed successfully.

## Conclusion

Using the official GitHub Action for SurrealDB simplifies the process of setting up and running SurrealDB in your CI/CD pipeline. Customise the workflow as per your project requirements, and ensure you follow best practices for security and version control. Happy coding!



================================================
FILE: src/content/doc-tutorials/working-with-surrealdb-over-http-via-postman.mdx
================================================
---
sidebar_position: 5
sidebar_label: Working with SurrealDB over HTTP via Postman
title: Working with SurrealDB over HTTP via Postman | Tutorials
description: In this tutorial, you will learn how to query the SurrealDB RESTful HTTP API endpoints using Postman.
---

# Working with SurrealDB over HTTP via Postman

SurrealDB provides a RESTful HTTP API for interacting with the database. 

In this tutorial, you will learn how to query SurrealDB endpoints via the [Postman collection](https://postman.com/surrealdb/workspace/surrealdb/collection/19100500-3da237f3-588b-4252-8882-6d487c11116a). SurrealDB supports requests via HTTP & Rest with which you can handle different queries from creating simple tables to having Graph relationships between complex tables.

Check out the [HTTP & Rest integration documentation](/docs/surrealdb/integration/http) for a detailed list of all the endpoints supported.

## Prerequisites

This tutorial assumes that you have the following: 

- A Postman account to fork the [SurrealDB collection](https://postman.com/surrealdb/workspace/surrealdb/collection/19100500-3da237f3-588b-4252-8882-6d487c11116a)
- SurrealDB installed - If you do not, see the [installation guide](/docs/surrealdb/installation) specific to your machine.

## Getting Started.

Before forking the Collection from Postman, ensure that you have your SurrealDB instance running locally because by default the collection endpoint is set to [`localhost:8000`](http://localhost:8000) or [`http://127.0.0.1:8000`](http://127.0.0.1:8000/)

To do so run the [Start command](/docs/surrealdb/cli/start) in your terminal: 

```surql
surreal start --user root --pass secret
```

The above command starts SurrealDB with [authentication](/docs/surrealdb/cli/start#authentication) and specifies that the user and password are `root`. Note that this is just for demonstration purposes. You can replace `root` in both instances with any other value.

After running locally, head over to Postman and create a fork for your workspace. You should see all the endpoints listed. You can also [check the endpoints in the documentation](/docs/surrealdb/integration/http). 

## Using the `INFO` Statement

You can get information about your workspace by using the INFO statement. However, you need the right permissions in order to see the output. See the documentation for the [INFO statement](/docs/surrealql/statements/info).

It is also important to note that the `namespace` and `database` values for the Postman collection are set to `test` by default. 

You can see the JSON output using the [INFO statement](/docs/surrealql/statements/info) in the body of the request.

```surql
INFO FOR ROOT / DB / NS
```

Below is the output of querying for the info of the current namespace.

```surql
INFO FOR NS
```

```json
[
    {
        "result": {
            "accesses": {},
            "databases": {
                "test": "DEFINE DATABASE test"
            },
            "users": {}
        },
        "status": "OK",
        "time": "190.166µs"
    }
]
```

## Defining a Record User

To define a [record user](/docs/surrealdb/security/authentication#record-users), first navigate to the `POST /sql`  endpoint and in the header of the request add the following fields:

```json
Accept:application/json
NS:{{namespace}}
DB:{{database}}
```
You can also [define](/docs/surrealql/statements/define/user) a [system user](/docs/surrealdb/security/authentication#system-users) with other credentials such as Root or Database user. For this tutorial, we will be using only [record users](/docs/surrealdb/security/authentication#record-users).


> [!NOTE]
> The Namespace and Database fields are set to the value `test` by default. You can change this in the collection settings.

In the request body, [define the record access method](/docs/surrealql/statements/define/access/record) `human` with a session of 24 hours: 

```surql
DEFINE ACCESS human ON DATABASE TYPE RECORD
    SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
    SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
    DURATION FOR SESSION 24h
;
```

The code above allows a user to sign up as a record user with their email and password. Then hash the password with the [`crypto::argon2::generate`](/docs/surrealql/functions/database/crypto#cryptoargon2generate) function 

The sign in logic gets all the users where the emails match and uses the [`crypto::argon2::compare`](/docs/surrealql/functions/database/crypto#cryptoargon2compare) function to check the hash value to the unhashed. 

Now when you get the info of the Database using `INFO for DB` you can see the access method `human` in the following output:

```json
[
    {
        "result": null,
        "status": "OK",
        "time": "102.458µs"
    },
    {
        "result": {
            "accesses": {
                "human": "DEFINE ACCESS human ON DATABASE TYPE RECORD SIGNUP (CREATE user SET email = $email, pass = crypto::argon2::generate($pass)) SIGNIN (SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass)) DURATION FOR TOKEN 1h, FOR SESSION 1d"
            },
            "analyzers": {},
            "functions": {},
            "models": {},
            "params": {},
            "tables": {},
            "users": {}
        },
        "status": "OK",
        "time": "78.084µs"
    }
]
```

## Signing Up a New Scope user

After defining the `signup` and `signin` logic head over to the `POST /signup` endpoint to signup and in the header of the request add the following fields: 

```json
Accept:application/json
namespace:test
database:test
access:human  
```

In the body of the request add the following information:

```json
{
    "ns": "test",
    "db": "test",
    "ac": "human",
    "email": "test@surreal.com",
    "pass":"1234567886"
}
```

The result will be a  JSON object: 

```json
{
    "code": 200,
    "details": "Authentication succeeded",
    "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MDcxNDY2NTgsIm5iZiI6MTcwNzE0NjY1OCwiZXhwIjoxNzA3MjMzMDU4LCJpc3MiOiJTdXJyZWFsREIiLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJBQyI6Imh1bWFuIiwiSUQiOiJ1c2VyOnc2ZzBsNmh5eHpjZzlubTY2dGVjIn0.8Gud51cocThB8DMKD1zovtGiVgf5L1dAS6-pjWb6Lm6a7-4Spp7xXjD7JrHHdtJVNX1O0d8GdjZwRGTsP_NM9A"
}
```

## Signing in a record user

Now that we have defined a User we can now log in. To do so, head to the `POST /signin` and using the same credentials. In the body of the request, add the same information you used to sign up:

```json
{
    "ns": "test",
    "db": "test",
    "ac": "human",
    "email": "test3@surreal.com",
    "pass":"1234567886"
} 
```

This should return a similar JSON object indicating successful authentication and providing a new token.

```json
{
    "code": 200,
    "details": "Authentication succeeded",
    "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MDcxNDY2NTgsIm5iZiI6MTcwNzE0NjY1OCwiZXhwIjoxNzA3MjMzMDU4LCJpc3MiOiJTdXJyZWFsREIiLCJOUyI6InRlc3QiLCJEQiI6InRlc3QiLCJBQyI6Imh1bWFuIiwiSUQiOiJ1c2VyOnc2ZzBsNmh5eHpjZzlubTY2dGVjIn0.8Gud51cocThB8DMKD1zovtGiVgf5L1dAS6-pjWb6Lm6a7-4Spp7xXjD7JrHHdtJVNX1O0d8GdjZwRGTsP_NM9A"
}
```

## Using Table Endpoints

The Postman collection has a couple of endpoints for `POST` `GET` `PUT` `PATCH` `DEL` operations. For example, If you want to add a new entry to the table `Person` (Which is the default table in the collection) go to the [`POST /key/:table`](/docs/surrealdb/integration/http#post-table) endpoint then in a body of the request and add the table content in the body of the request. E.g:

```json
{
    age: 32,
    name: 'John'
}
```

You should get a response as seen below, notice that there is a [record ID](/docs/surrealql/datamodel/ids), with this record ID you can now use any of the [`/key/:table/:id`](/docs/surrealdb/integration/http#get-record) endpoints for  `POST` `GET` `PUT` `PATCH` `DEL` operations. 

```json
[
    {
        "result": [
            {
                "age": 32,
                "id": "person:p1cdf6cx89gnfboq5wye",
                "name": "John"
            }
        ],
        "status": "OK",
        "time": "105.667µs"
    }
]
```

## Conclusion

In this tutorial, we've walked through how to set up and use SurrealDB over HTTP using Postman. We've covered how to define a new record access method, sign up a new user, and sign in with a user. These steps are crucial for managing user authentication in your applications using SurrealDB.

The Postman collection is still in active development for more information on using  surrealDB via the HTTP endpoints. [Check out our documentation on HTTP and rest endpoints](/docs/surrealdb/integration/http)


================================================
FILE: src/content/labs-items/aeons-surreal-renaissance-official-book-for-in-depth-learning-through-storytelling.md
================================================
---
title: "Aeon's Surreal Renaissance - Official book for in-depth learning through storytelling."
url: /learn/book
category: Tutorials
author: surrealdb
topics:
  - Examples
  - Beginner
---




================================================
FILE: src/content/labs-items/allographer.md
================================================
---
title: "allographer"
url: https://github.com/itsumura-h/nim-allographer
category: Libraries
author:
  name: Itsumura H.
  role: Software Engineer
  avatar: itsumura-h
topics: []
---




================================================
FILE: src/content/labs-items/aspire-community-package.md
================================================
---
title: "Aspire Integration"
url: https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.SurrealDb
category: Libraries
topics: []
author:
  name: David Bottiau
  role: Software Engineer
  avatar: david-bottiau
---



================================================
FILE: src/content/labs-items/aspnet-healthchecks-package.md
================================================
---
title: "AspNetCore.HealthChecks.SurrealDb"
url: https://www.nuget.org/packages/AspNetCore.HealthChecks.SurrealDb
category: Libraries
topics: []
author:
  name: David Bottiau
  role: Software Engineer
  avatar: david-bottiau
---





================================================
FILE: src/content/labs-items/awaited-surrealdb.md
================================================
---
title: "awaited-surrealdb"
url: https://github.com/theopensource-company/awaited-surrealdb
category: Libraries
author:
  name: Micha de Vries
  role: Software Engineer
  avatar: micha-de-vries
topics: []
---




================================================
FILE: src/content/labs-items/beyond-surreal-a-closer-look-at-newsql-relational-data-beyond-fireship.md
================================================
---
title: "Beyond Surreal? A closer look at NewSQL Relational Data - Beyond Fireship."
url: https://www.youtube.com/watch?v=LCAIkx1p1k0
category: Videos
author:
  name: Fireship
  role: Content Creator - Software Engineer
  avatar: fireship
topics:
  - Beginner
  - Examples
---




================================================
FILE: src/content/labs-items/blink-instant-editing.md
================================================
---
title: "Blink - Build a Notion clone with SurrealDB and WebAssembly engine"
url: https://github.com/kearfy/blink 
category: Demos
author:
  name: Micha de Vries
  role: Software Engineer
  avatar: micha-de-vries
topics:
  - Beginner
  - Examples
---


================================================
FILE: src/content/labs-items/build-a-realtime-presence-web-application-using-surrealdb-live-queries.md
================================================
---
title: "Build a realtime presence web application using SurrealDB Live Queries"
url: /docs/tutorials/build-a-realtime-presence-web-application-using-surrealdb-live-queries
category: Tutorials
topics:
  - Beginner
author:
  name: David Bottiau
  role: Software Engineer
  avatar: david-bottiau
---


================================================
FILE: src/content/labs-items/build-an-ai-rag-agent.md
================================================
---
title: "Build an AI RAG Agent"
url: https://github.com/colinmcnamara/austin_langchain/blob/main/labs/LangChain_104/104-langgraph-rag-agent.ipynb
category: Tutorials
author:
  name: Karim Lalani
  role: Software Engineer
  avatar: karim-lalani
topics:
  - AI
  - Examples
languages:
  - Python
---




================================================
FILE: src/content/labs-items/cli-phone-book-in-python-using-surrealdb-as-database.md
================================================
---
title: "CLI phone book in Python using SurrealDB as database."
url: https://python.code-maven.com/surrealdb-python-cli-phonebook
category: Tutorials
author:
  name: Gabor Szabo
  role: Software Engineer
  avatar: gabor-szabo
topics:
  - Data Management
  - Examples
---




================================================
FILE: src/content/labs-items/connect-to-surrealdb-via-ngrok-tunnel.md
================================================
---
title: "Connect to SurrealDB via Ngrok tunnel"
url: /docs/tutorials/connect-to-surrealdb-via-ngrok-tunnel
category: Tutorials
topics:
  - Examples
author: surrealdb
---





================================================
FILE: src/content/labs-items/define-a-schema-in-surrealdb.md
================================================
---
title: "Define a Schema in SurrealDB"
url: /docs/tutorials/define-a-schema
category: Tutorials
topics:
  - Beginner
author: surrealdb
---





================================================
FILE: src/content/labs-items/dokku-surrealdb.md
================================================
---
title: "Dokku Surrealdb"
url: https://github.com/IgnisDa/dokku-surrealdb
category: Deployment Tools
author:
  name: Diptesh Choudhuri
  role: Software Engineer
  avatar: diptesh-choudhuri
topics: []
---




================================================
FILE: src/content/labs-items/getting-started-with-surrealdb-future-of-cloud-databases-maybe.md
================================================
---
title: "Getting started with SurrealDB! Future of cloud databases (maybe)?"
url: https://www.youtube.com/watch?v=D41jb4DDIdA
category: Videos
author:
  name: Chris Hay
  role: Content Creator
  avatar: chris-hay
topics:
  - Beginner
---




================================================
FILE: src/content/labs-items/getting-started-with-surrealdb-using-python-and-docker.md
================================================
---
title: "Getting started with SurrealDB using Python and Docker."
url: https://python.code-maven.com/surrealdb-getting-started
category: Tutorials
author:
  name: Gabor Szabo
  role: Software Engineer
  avatar: gabor-szabo
topics:
  - Beginner
languages:
  - Python
---




================================================
FILE: src/content/labs-items/getting-started-with-surrealdb.md
================================================
---
title: "Getting started with SurrealDB."
url: /docs/surrealdb/introduction/start
category: Tutorials
author: surrealdb
topics:
  - Beginner
---




================================================
FILE: src/content/labs-items/gke-using-terraform.md
================================================
---
title: "GKE using Terraform"
url: https://github.com/dvanmali/terraform-google-surrealdb
category: Deployment Tools
author:
  name: Dylan Vanmali
  role: Software Engineer
  avatar: dylan-vanmali
topics:
  - Data Management
---




================================================
FILE: src/content/labs-items/hosting-surreal-db-in-rust-in-less-than-3-minutes.md
================================================
---
title: "Hosting Surreal DB in Rust in Less Than 3 Minutes."
url: https://www.youtube.com/watch?v=VoRoeL1tal4
category: Tutorials
author:
  name: Gui Bibeau
  role: Software Engineer
  avatar: gui-bibeau
topics: 
  - Beginner
---




================================================
FILE: src/content/labs-items/how-to-use-surrealdb-with-the-fresh-framework-and-deno.md
================================================
---
title: "How to Use SurrealDb with the Fresh Framework and Deno."
url: https://www.freecodecamp.org/news/how-to-use-surrealdb-with-fresh-framework/
category: Tutorials
author:
  name: Rajdeep Singh
  role: Software Engineer
  avatar: rajdeep-singh
topics:
  - Examples
---




================================================
FILE: src/content/labs-items/improve-database-management-with-surrealdb.md
================================================
---
title: "Improve database management with SurrealDB."
url: https://blog.logrocket.com/improve-database-management-surrealdb/
category: Tutorials
author:
  name: Alexander Nnakwue
  role: Software Engineer
  avatar: alexander-nnakwue
topics:
  - Data Management
---




================================================
FILE: src/content/labs-items/integrate-auth0-as-an-authentication-provider.md
================================================
---
title: "Integrate Auth0 as an Authentication Provider"
url: /docs/tutorials/integrate-auth0-as-authentication-provider
category: Tutorials
topics:
  - Security
  - Examples
author: surrealdb
---





================================================
FILE: src/content/labs-items/integrate-aws-cognito-as-an-authentication-provider.md
================================================
---
title: "Integrate AWS Cognito as an Authentication Provider"
url: /docs/tutorials/integrate-aws-cognito-as-authentication-provider
category: Tutorials
topics:
  - Security
  - Examples
author: surrealdb
---





================================================
FILE: src/content/labs-items/iot-telemetry-example.md
================================================
---
title: "IoT telemetry example"
url: https://github.com/surrealdb/example-iot-telemetry
category: Demos
topics:
  - Examples
languages:
  - Rust
author:
  name: Martin Schaer
  role: Solutions Engineer
  avatar: martin-schaer
---





================================================
FILE: src/content/labs-items/kards-social-foss-social-media-app.md
================================================
---
title: "Kards Social - FOSS social media app."
url: https://github.com/theopensource-company/kards-social
category: Demos
author:
  name: Micha de Vries
  role: Software Engineer
  avatar: micha-de-vries
topics:
  - Examples
---




================================================
FILE: src/content/labs-items/kysely-surrealdb.md
================================================
---
title: "kysely-surrealdb"
url: https://github.com/igalklebanov/kysely-surrealdb
category: Libraries
author:
  name: Igal Klebanov
  role: Software Engineer
  avatar: igal-klebanov
topics: []
---




================================================
FILE: src/content/labs-items/langchain-integration.md
================================================
---
title: "LangChain integration"
url: /docs/integrations/frameworks/langchain
category: Integrations
topics:
  - AI
  - Examples
languages:
  - Python
author: surrealdb
---



================================================
FILE: src/content/labs-items/livestream-series-documenting-learning-surrealdb.md
================================================
---
title: "Livestream series documenting learning SurrealDB."
url: https://www.youtube.com/playlist?list=PL5AVzKSngnt_xPGNuYdrbB7NZtJbQ046a
category: Videos
author:
  name: Xkonti
  role: Content Creator
  avatar: xkonti
topics: []
---




================================================
FILE: src/content/labs-items/make-a-genai-chatbot-using-graphrag-with-surrealdb-langchain.md
================================================
---
title: "Make a GenAI chatbot using GraphRAG with SurrealDB + LangChain"
url: /blog/make-a-genai-chatbot-using-graphrag-with-surrealdb-langchain
category: Demos
topics:
  - AI
  - Examples
author: surrealdb
---



================================================
FILE: src/content/labs-items/medical-graphrag-chatbot-rust-langchain.md
================================================
---
title: "Make a medical chatbot in Rust using GraphRAG with SurrealDB + LangChain"
url: /blog/make-a-medical-chatbot-using-graphrag-with-surrealdb-langchain
category: Demos
topics:
  - AI
  - Examples
author: surrealdb
---



================================================
FILE: src/content/labs-items/minimal-langchain-chatbot-example-with-vector-and-graph.md
================================================
---
title: "Minimal LangChain chatbot example with vector and graph"
url: /blog/minimal-langchain-chatbot-example-with-vector-and-graph
category: Demos
topics:
  - AI
  - Examples
author: surrealdb
---



================================================
FILE: src/content/labs-items/nextjs-surrealdb-demo-basic-blog-that-serves-as-a-demo-template-for-your-nextjs-surrealdb-project.md
================================================
---
title: "Nextjs + surrealdb demo - Basic blog that serves as a demo / template for your nextjs + surrealdb project."
url: https://github.com/kearfy/demo-nextjs-surrealdb
category: Demos
author:
  name: Micha de Vries
  role: Software Engineer
  avatar: micha-de-vries
topics:
  - Examples
  - Beginner
---




================================================
FILE: src/content/labs-items/playrbase-event-player-management-system.md
================================================
---
title: "Playrbase - Event & player management system."
url: https://github.com/theopensource-company/playrbase
category: Demos
author:
  name: Micha de Vries
  role: Software Engineer
  avatar: micha-de-vries
topics:
  - Examples
---




================================================
FILE: src/content/labs-items/pterodactyl-egg.md
================================================
---
title: "Pterodactyl Egg"
url: https://github.com/Stefanuk12/Pterodactyl/blob/master/eggs/misc/egg-surrealdb.json
category: Deployment Tools
author:
  name: Stefan
  role: Freelance Developer
  avatar: stefan
topics: []
---




================================================
FILE: src/content/labs-items/pysurrealdb.md
================================================
---
title: "PySurrealDB"
url: https://github.com/aurelion314/pysurrealdb
category: Libraries
author:
  name: Mike Aurelion
  role: Software Engineer
  avatar: mike-aurelion
topics: []
languages:
  - Python
---




================================================
FILE: src/content/labs-items/ra-surrealdb.md
================================================
---
title: "ra-surrealdb"
url: https://github.com/djedi23/ra-surrealdb
category: Libraries
author:
  name: Moïse Valvassori
  role: Software Engineer
  avatar: mose-valvassori
topics: []
---




================================================
FILE: src/content/labs-items/rust-powered-database-surrealdb-its-pretty-ambitious-code-to-the-moon.md
================================================
---
title: "Rust Powered Database SurrealDB (It's Pretty Ambitious) - Code to the Moon."
url: https://www.youtube.com/watch?v=DPQbuW9dQ7w
category: Videos
author:
  name: Code to the Moon
  role: Content Creator
  avatar: code-to-the-moon
topics: []
---




================================================
FILE: src/content/labs-items/semantic-search-rust-using-mistralai.md
================================================
---
title: "Semantic search in Rust with SurrealDB and Mistral AI"
url: /blog/semantic-search-in-rust-with-surrealdb-and-mistral-ai
category: Demos
topics:
  - AI
  - Examples
languages:
  - Rust
author: surrealdb
---


================================================
FILE: src/content/labs-items/semantic-search-rust-using-openai.md
================================================
---
title: "Semantic search in Rust with SurrealDB and OpenAI"

url: /blog/semantic-search-with-surrealdb-and-openai
category: Demos
topics:
  - AI
  - Examples
languages:
  - Rust
author: surrealdb
---


================================================
FILE: src/content/labs-items/simple-api-with-gingonic-and-surrealdb-go.md
================================================
---
title: "Simple API with Gin/Gonic and SurrealDB (GO)."
url: https://atoo.hashnode.dev/simple-api-with-gingonic-and-surrealdb
category: Tutorials
author:
  name: Atharva Deshpande
  role: Software Engineer
  avatar: atharva-deshpande
topics: []
---




================================================
FILE: src/content/labs-items/sirqle.md
================================================
---
title: "Sirqle"
url: https://github.com/PythiaSocialTech/sirqle
category: Libraries
author:
  name: Tudor Andrei Dumitrascu
  role: Lead AI Developer
  avatar: tudor-andrei-dumitrascu
topics: []
---




================================================
FILE: src/content/labs-items/smig.md
================================================
---
title: "smig schema migration tool"
url: https://github.com/kathysledge/smig
category: Development Tools
topics:
  - Data Management
  - Examples
author:
  name: Chris Harris
  role: Maker
  avatar: chris-harris
---



================================================
FILE: src/content/labs-items/starter-kit-for-surrealdb-tauri-next-js.md
================================================
---
title: "Starter Kit for SurrealDB + Tauri + Next.js."
url: https://github.com/reymom/surrealdb-starter-taurikit
category: Templates
author:
  name: Reymon
  role: Software Engineer
  avatar: reymon
topics:
  - Examples
  - Beginner
---




================================================
FILE: src/content/labs-items/surreal-4o-fine-tuned-model-datasets-for-surrealql-queries-project-to-create-structured-datasets-for-openai.md
================================================
---
title: "Surreal-4o Fine-tuned Model Datasets for SurrealQL Queries - Project to create structured datasets for OpenAI."
url: https://github.com/sFritsch09/surreal-4o
category: Development Tools
author:
  name: Sebastian Fritsch
  role: Fullstack Developer
  avatar: sebastian-fritsch
topics:
  - AI
---




================================================
FILE: src/content/labs-items/surreal-codegen.md
================================================
---
title: "surreal-codegen"
url: https://github.com/siteforge-io/surreal-codegen
category: Development Tools
author:
  name: Albert Marashi
  role: Software Engineer
  avatar: albert-marashi
topics: []
---




================================================
FILE: src/content/labs-items/surreal-id.md
================================================
---
title: "surreal-id"
url: https://github.com/liamwh/surreal-id
category: Libraries
author:
  name: Liam Woodleigh-Hardinge
  role: Lead Engineer
  avatar: liam-woodleigh-hardinge
topics: []
---




================================================
FILE: src/content/labs-items/surreal-transfer.md
================================================
---
title: "Surreal Transfer"
url: https://github.com/LucyEgan/surreal-transfer
category: Development Tools
topics:
  - Data Management
author:
  name: Lucy Egan
  role: Software Engineer
  avatar: lucy-egan
---





================================================
FILE: src/content/labs-items/surreal-ts.md
================================================
---
title: "surreal-ts"
url: https://github.com/horvbalint/surreal-ts
category: Libraries
topics: []
author:
  name: horvbalint
  role: Software Engineer
  avatar: horvbalint
---





================================================
FILE: src/content/labs-items/surrealdb-1.md
================================================
---
title: "surrealdb"
url: https://github.com/surrealdb/surrealdb/tree/main/crates/sdk
category: SDKs
author: surrealdb
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-admin.md
================================================
---
title: "SurrealDB Admin"
url: https://github.com/sachinbhutani/surrealdb-admin
category: Development Tools
author:
  name: Sachin Bhutani
  role: Software Engineer
  avatar: sachin-bhutani
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-ai-assistant.md
================================================
---
title: "SurrealDB AI Assistant"
url: https://surrealdb-ai.jimpex.dev/
category: Development Tools
topics:
  - AI
  - Beginner
author:
  name: Jimpex
  role: Software Engineer
  avatar: jimpex
---





================================================
FILE: src/content/labs-items/surrealdb-ai-docs-retrieval-project-to-showcase-how-to-build-a-gpt-based-question-answering-system-on-top-of-surrealdb-docs.md
================================================
---
title: "SurrealDB AI Docs Retrieval - Project to showcase: How to build a GPT-Based question-answering system on top of SurrealDB Docs."
url: https://github.com/truskovskiyk/surrealdb-docs-retrieval
category: Demos
author:
  name: Kyryl Truskovskyi
  role: Machine Learning Engineer
  avatar: kyryl-truskovskyi
topics:
  - Examples
  - AI
languages:
  - Python
---




================================================
FILE: src/content/labs-items/surrealdb-as-a-vector-store-for-langchain-a-jupyter-notebook-demonstrating-how-to-use-surrealdb-as-a-vector-store.md
================================================
---
title: "SurrealDB as a Vector Store for LangChain - A Jupyter notebook demonstrating how to use SurrealDB as a Vector Store."
url: https://github.com/lalanikarim/notebooks/blob/main/SurrealDB-Langchain.ipynb
category: Demos
author:
  name: Karim Lalani
  role: Software Engineer
  avatar: karim-lalani
topics:
  - Embedding
  - Examples
languages:
  - Python
---




================================================
FILE: src/content/labs-items/surrealdb-c.md
================================================
---
title: "surrealdb.c"
url: https://github.com/surrealdb/surrealdb.c
category: SDKs
author: surrealdb
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-client-generator.md
================================================
---
title: "surrealdb-client-generator"
url: https://github.com/sebastianwessel/surrealdb-client-generator
category: Development Tools
author:
  name: Sebastian Wessel
  role: Software Engineer
  avatar: sebastian-wessel
topics: []
languages:
  - TypeScript
---




================================================
FILE: src/content/labs-items/surrealdb-cloudflare.md
================================================
---
title: "surrealdb-cloudflare"
url: https://github.com/theopensource-company/surrealdb-cloudflare
category: SDKs
author:
  name: Micha de Vries
  role: Software Engineer
  avatar: micha-de-vries
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-cr.md
================================================
---
title: "surrealdb.cr"
url: https://github.com/yorci/surrealdb.cr
category: SDKs
author:
  name: Muhammed Yaşar
  role: Backend Crafter
  avatar: muhammed-yaar
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-erlang.md
================================================
---
title: "surrealdb-erlang"
url: https://github.com/meppu/surreal
category: SDKs
author:
  name: Meppu
  role: Software Engineer
  avatar: meppu
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-explorer.md
================================================
---
title: "SurrealDB Explorer"
url: https://github.com/iDevelopThings/SurrealDB-Explorer
category: Development Tools
author:
  name: Sam Parton
  role: Software Engineer
  avatar: sam-parton
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-extras.md
================================================
---
title: "surrealdb-extras"
url: https://docs.rs/surrealdb-extras/latest/surrealdb_extras/
category: Libraries
author:
  name: Frederik Uni
  role: Software Engineer
  avatar: frederik-uni
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-fastapi-nextjs-starter.md
================================================
---
title: "SurrealDB + FastAPI-NextJS Starter."
url: https://github.com/richie-omondi/fastapi-nextjs-surrealdb-starterkit
category: Templates
author:
  name: Mardav Chirag and Richard Orido
  role: Software Engineers
  avatar: mardav-chirag-and-richard-orido
topics:
  - Examples
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealdb-flask-starter.md
================================================
---
title: "SurrealDB + Flask Starter."
url: https://github.com/syedzubeen/surrealdb_flask_starter_app
category: Templates
author:
  name: Syed Zubeen
  role: Software Engineer
  avatar: syed-zubeen
topics:
  - Examples
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealdb-flutter.md
================================================
---
title: "surrealdb-flutter"
url: https://github.com/duhanbalci/surrealdb_flutter
category: SDKs
author:
  name: Duhan Balci
  role: Software Engineer
  avatar: duhan-balci
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-fundamentals-course-official-course-to-efficiently-learn-surrealdb-in-3-hours.md
================================================
---
title: "SurrealDB Fundamentals Course - Official course to efficiently learn SurrealDB in 3 hours."
url: /learn/fundamentals
category: Tutorials
author: surrealdb
topics:
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealdb-github-action.md
================================================
---
title: "SurrealDB GitHub Action"
url: https://github.com/marketplace/actions/surrealdb-in-github-action
category: CI/CD
author: surrealdb
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-go-driver-starter.md
================================================
---
title: "SurrealDB + Go Driver Starter."
url: https://github.com/sbshah97/surrealdb-go-starter-project
category: Templates
author:
  name: Salman Shah
  role: Software Engineer
  avatar: salman-shah
topics:
  - Examples
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealdb-go.md
================================================
---
title: "surrealdb.go"
url: https://github.com/surrealdb/surrealdb.go
category: SDKs
author: surrealdb
topics: []
languages:
  - Go
---




================================================
FILE: src/content/labs-items/surrealdb-grafana-datasource.md
================================================
---
title: "SurrealDB Grafana datasource"
url: https://github.com/grafana/surrealdb-datasource
category: Integrations
topics:
  - Data Management
author:
  name: Grafana Labs
  role: Observability
  avatar: grafana
---





================================================
FILE: src/content/labs-items/surrealdb-in-100-seconds.md
================================================
---
title: "SurrealDB in 100 seconds."
url: https://www.youtube.com/watch?v=C7WFwgDRStM
category: Videos
author:
  name: Fireship
  role: Content Creator
  avatar: fireship
topics:
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealdb-java.md
================================================
---
title: "surrealdb.java"
url: https://github.com/surrealdb/surrealdb.java
category: SDKs
author: surrealdb
topics: []
languages:
  - Java
---




================================================
FILE: src/content/labs-items/surrealdb-js.md
================================================
---
title: "surrealdb.js"
url: https://github.com/surrealdb/surrealdb.js
category: SDKs
author: surrealdb
topics: []
languages:
  - TypeScript
---




================================================
FILE: src/content/labs-items/surrealdb-koa-starter-rest-api.md
================================================
---
title: "SurrealDB + Koa starter rest api."
url: https://github.com/jerempy/surrealdb-starter-koa
category: Templates
author:
  name: Jerempy
  role: Software Engineer
  avatar: jerempy
topics:
  - Examples
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealdb-mcp-server.md
================================================
---
title: "SurrealDB MCP Server"
url: https://github.com/nsxdavid/surrealdb-mcp-server
category: Integrations
topics:
  - AI
author:
  name: David Whatley
  role: Software Engineer
  avatar: david-whatley
---





================================================
FILE: src/content/labs-items/surrealdb-migrations-action.md
================================================
---
title: "surrealdb-migrations Action"
url: https://github.com/marketplace/actions/surrealdb-migrations
category: CI/CD
author:
  name: David Bottiau
  role: Software Engineer
  avatar: david-bottiau
topics:
  - Data Management
---


================================================
FILE: src/content/labs-items/surrealdb-migrations.md
================================================
---
title: "surrealdb-migrations"
url: https://github.com/Odonno/surrealdb-migrations
category: Libraries
author:
  name: David Bottiau
  role: Software Engineer
  avatar: david-bottiau
topics:
  - Data Management
---




================================================
FILE: src/content/labs-items/surrealdb-net.md
================================================
---
title: "surrealdb.net"
url: https://github.com/surrealdb/surrealdb.net
category: SDKs
author: surrealdb
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-node.md
================================================
---
title: "surrealdb.node"
url: https://github.com/surrealdb/surrealdb.node
category: SDKs
author: surrealdb
topics: []
languages:
  - TypeScript
---




================================================
FILE: src/content/labs-items/surrealdb-nuxt-3-starter.md
================================================
---
title: "SurrealDB + Nuxt 3 Starter."
url: https://github.com/dvanmali/surrealdb-nuxt-starter
category: Templates
author:
  name: Dylan Vanmali
  role: Software Engineer
  avatar: dylan-vanmali
topics:
  - Examples
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealdb-odatav4-connector.md
================================================
---
title: "SurrealDB ODataV4 Connector"
url: https://github.com/knackstedt/odatav4
category: Integrations
topics:
  - Security
  - Optimisation
author:
  name: Andrew G. Knackstedt
  role: Sr Backend Engineer
  avatar: andrew-g-knackstedt
---





================================================
FILE: src/content/labs-items/surrealdb-php.md
================================================
---
title: "surrealdb.php"
url: https://github.com/surrealdb/surrealdb.php
category: SDKs
author: surrealdb
topics: []
languages:
  - PHP
---




================================================
FILE: src/content/labs-items/surrealdb-presence-demo-demo-project-on-how-to-create-a-realtime-presence-web-application-using-surrealdb-live-queries.md
================================================
---
title: "SurrealDB Presence Demo - Demo project on how to create a realtime presence web application using SurrealDB Live Queries."
url: https://github.com/Odonno/surrealdb-presence-demo
category: Demos
author:
  name: David Bottiau
  role: Software Engineer
  avatar: david-bottiau
topics:
  - Examples
---




================================================
FILE: src/content/labs-items/surrealdb-py.md
================================================
---
title: "surrealdb.py"
url: https://github.com/surrealdb/surrealdb.py
category: SDKs
author: surrealdb
topics: []
languages:
  - Python
---




================================================
FILE: src/content/labs-items/surrealdb-react-nodejs-starter.md
================================================
---
title: "SurrealDB + React-Nodejs starter."
url: https://github.com/MSaiKiran9/react.nodejs_starter
category: Templates
author:
  name: Sai Kiran
  role: Software Engineer
  avatar: sai-kiran
topics:
  - Examples
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealdb-rocket.md
================================================
---
title: "SurrealDB + Rocket."
url: https://github.com/davidzr/surrealdb-rocket-starter
category: Templates
author:
  name: David Zabala
  role: Software Engineer
  avatar: david-zabala
topics:
  - Examples
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealdb-rust-embedded-database-quick-tutorial.md
================================================
---
title: "SurrealDB - Rust Embedded Database - Quick Tutorial."
url: https://www.youtube.com/watch?v=iOyvum0D3LM
category: Tutorials
author:
  name: Jeremy Chone
  role: Software Engineer
  avatar: jeremy-chone
topics:
  - Data Management
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealdb-sandbox-an-offline-browser-based-playground-for-experimenting-with-surrealdb.md
================================================
---
title: "SurrealDB Sandbox - An offline browser-based playground for experimenting with SurrealDB."
url: https://github.com/plasmatech8/surrealdb-sandbox
category: Development Tools
author:
  name: Mark Connelly
  role: Software Engineer
  avatar: mark-connelly
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-solidstart-starter.md
================================================
---
title: "SurrealDB + SolidStart Starter."
url: https://github.com/metruzanca/surreal-solid-template
category: Templates
author:
  name: Sam Zanca
  role: Software Engineer
  avatar: sam-zanca
topics:
  - Examples
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealdb-spring-client.md
================================================
---
title: "surrealdb-spring-client"
url: https://github.com/Mukund2900/surrealdb-spring-client
category: SDKs
author:
  name: Mukund Mundhra
  role: Software Engineer
  avatar: mukund-mundhra
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-springboot.md
================================================
---
title: "SurrealDB + SpringBoot."
url: https://github.com/PDROJACK/surrealdb-springboot-starter
category: Templates
author:
  name: Priyadarshan Singh
  role: Software Engineer
  avatar: priyadarshan-singh
topics:
  - Examples
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealdb-streamlit-starter.md
================================================
---
title: "SurrealDB + Streamlit Starter."
url: https://github.com/LuciAkirami/surrealdb-streamlit-starter-kit
category: Templates
author:
  name: Lucifer Akirami
  role: Software Engineer
  avatar: lucifer-akirami
topics:
  - Examples
langugages:
  - Python
---




================================================
FILE: src/content/labs-items/surrealdb-surrealdb.md
================================================
---
title: "surrealdb/surrealdb"
url: https://hub.docker.com/r/surrealdb/surrealdb
category: Docker Images
author: surrealdb
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-sveltekit-auth-example.md
================================================
---
title: "SurrealDB + SvelteKit Auth Example."
url: https://github.com/AlbertMarashi/surrealdb-svelte-auth-template
category: Templates
author:
  name: Albert Marashi
  role: Software Engineer
  avatar: albert-marashi
topics:
  - Examples
  - Security
---




================================================
FILE: src/content/labs-items/surrealdb-sveltekit-starter.md
================================================
---
title: "SurrealDB + SvelteKit Starter."
url: https://github.com/spinspire/surrealdb-sveltekit-starter
category: Templates
author:
  name: Jitesh Doshi
  role: Software Engineer
  avatar: jitesh-doshi
topics:
  - Examples
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealdb-sveltekit.md
================================================
---
title: "SurrealDB + SvelteKit."
url: https://github.com/oskar-gmerek/surreal-sveltekit
category: Templates
author:
  name: Oskar Gmerek
  role: Software Engineer
  avatar: oskar-gmerek
topics:
  - Examples
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealdb-the-kitchen-sink-document-store-that-might-dethrone-firebase.md
================================================
---
title: "SurrealDB. The Kitchen Sink Document Store that might dethrone Firebase."
url: https://www.youtube.com/watch?v=tWpj8Bc_jBQ
category: Videos
author:
  name: Ray Villalobos
  role: Content Creator
  avatar: ray-villalobos
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-valibot.md
================================================
---
title: "surrealdb-valibot"
url: https://github.com/ShadowWolf308/surrealdb-valibot
category: Libraries
author:
  name: Levy van der Valk
  role: Web Developer
  avatar: levy-van-der-valk
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-vector-store-for-langchain.md
================================================
---
title: "SurrealDB Vector Store for LangChain"
url: https://python.langchain.com/docs/integrations/vectorstores/surrealdb
category: Integrations
author:
  name: LangChain
  role: Open Source Project
  avatar: langchain
topics:
  - Embedding
---




================================================
FILE: src/content/labs-items/surrealdb-vue-blog-starter.md
================================================
---
title: "SurrealDB + Vue Blog Starter."
url: https://github.com/SrWither/surrealdb-vuejs
category: Templates
author:
  name: Fadel SrWither
  role: Software Engineer
  avatar: fadel-srwither
topics:
  - Examples
---




================================================
FILE: src/content/labs-items/surrealdb-vue-starter.md
================================================
---
title: "SurrealDB + Vue Starter."
url: https://github.com/inkollusireeshaadharani/vue-starter-kit
category: Templates
author:
  name: Dharani Inkollu
  role: Software Engineer
  avatar: dharani-inkollu
topics:
  - Examples
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealdb-wasm.md
================================================
---
title: "surrealdb.wasm"
url: https://github.com/surrealdb/surrealdb.wasm
category: SDKs
author: surrealdb
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb-x-openai-example-of-rag-using-surrealdb-and-openai.md
================================================
---
title: "SurrealDB x OpenAI - Example of RAG using SurrealDB and OpenAI."
url: https://github.com/Ce11an/surrealdb-openai
category: Demos
author:
  name: Cellan Hall
  role: MLOps Engineer
  avatar: cellan-hall
topics:
  - AI
  - Examples
---




================================================
FILE: src/content/labs-items/surrealdb-zod.md
================================================
---
title: "surrealdb-zod"
url: https://github.com/ShadowWolf308/surrealdb-zod
category: Libraries
author:
  name: Levy van der Valk
  role: Web Developer
  avatar: levy-van-der-valk
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb.md
================================================
---
title: "SurrealDB"
url: https://github.com/surrealdb/surrealdb
category: Development Tools
author: surrealdb
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb_dsl.md
================================================
---
title: "SurrealDB_DSL"
url: https://github.com/mnbjhu/SurrealDB_DSL
category: SDKs
author:
  name: Mnbjhu
  role: Software Engineer
  avatar: mnbjhu
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb_extra.md
================================================
---
title: "surrealdb_extra"
url: https://github.com/jakin010/surrealdb_extra
category: Libraries
author:
  name: Jakin010
  role: Software Engineer
  avatar: jakin010
topics: []
---




================================================
FILE: src/content/labs-items/surrealdb_migration_engine.md
================================================
---
title: "surrealdb_migration_engine"
url: https://github.com/mcmah309/surrealdb_migration_engine
category: Libraries
author:
  name: Henry
  role: Software Engineer
  avatar: henry
topics:
  - Data Management
---




================================================
FILE: src/content/labs-items/surrealdb_query_builder.md
================================================
---
title: "surrealdb_query_builder"
url: https://github.com/AyushChothe/surrealdb_query_builder
category: Libraries
author:
  name: Ayush Chothe
  role: Software Engineer
  avatar: ayush-chothe
topics: []
---




================================================
FILE: src/content/labs-items/surrealised.md
================================================
---
title: "Surrealised"
url: https://github.com/ozone-team/surrealised
category: Libraries
author:
  name: Harry Carpenter
  role: Software Engineer
  avatar: harry-carpenter
topics: []
---




================================================
FILE: src/content/labs-items/surrealist-1.md
================================================
---
title: "surrealist"
url: https://github.com/kotolex/surrealist
category: Libraries
author:
  name: Kotolex
  role: Software Engineer
  avatar: kotolex
topics: []
---




================================================
FILE: src/content/labs-items/surrealist.md
================================================
---
title: "Surrealist"
url: https://app.surrealdb.com
category: Development Tools
author: surrealdb
topics:
  - Beginner
---




================================================
FILE: src/content/labs-items/surrealml-vs-pytorch-vs-onnx-benchmarking-the-performance-of-surrealml-against-pytorch-and-onnx-vladimir-rotariu.md
================================================
---
title: "SurrealML vs PyTorch vs ONNX - Benchmarking the performance of SurrealML against PyTorch and ONNX - Vladimir Rotariu."
url: https://github.com/vladimirrotariu/surrealml-vs-onnx-vs-pytorch/tree/main
category: Development Tools
author:
  name: Vladimir Rotariu
  role: AI & Backend engineer
  avatar: vladimir-rotariu
topics:
  - AI
---




================================================
FILE: src/content/labs-items/surrealreact.md
================================================
---
title: "SurrealReact"
url: https://github.com/rvdende/surrealreact
category: Development Tools
author:
  name: Rouan van der Ende
  role: Software Engineer
  avatar: rouan-van-der-ende
topics: []
---




================================================
FILE: src/content/labs-items/sveltekit-surreal-database-authentication.md
================================================
---
title: "SvelteKit Surreal Database Authentication"
url: https://github.com/jdgamble555/sveltekit-surreal-js
category: Tutorials
topics:
  - Examples
  - Beginner
author:
  name: Jonathan Gamble
  role: Software Engineer
  avatar: jonathan-gamble
---





================================================
FILE: src/content/labs-items/tour-of-surrealdb-course-to-learn-basics-in-30-minutes.md
================================================
---
title: "A Tour of SurrealDB - A course to learn the ins and outs of SurrealDB in 30 minutes."
url: /learn/tour
category: Tutorials
author: surrealdb
topics:
  - Beginner
---




================================================
FILE: src/content/labs-items/type-surrealdb.md
================================================
---
title: "type-surrealdb"
url: https://github.com/ibilux/type-surrealdb
category: Libraries
author:
  name: Bilux
  role: Software Engineer
  avatar: bilux
topics: []
---




================================================
FILE: src/content/labs-items/unlocking-surrealdb-building-a-real-world-multi-tenant-rbac-system-made-easy-4-part-series.md
================================================
---
title: "Unlocking SurrealDB: Building a Real-World Multi-Tenant RBAC System Made Easy (4 Part Series)."
url: https://dev.to/sebastian_wessel/series/24535
category: Tutorials
author:
  name: Sebastian Wessel
  role: Software Engineer
  avatar: sebastian-wessel
topics:
  - Security
---




================================================
FILE: src/content/labs-items/unreal-orm.md
================================================
---
title: "UnrealORM: TypeScript ORM built for SurrealDB"
url: https://unreal-orm.jimpex.dev
category: Libraries
topics:
  - Data Management
author:
  name: Jimpex
  role: Software Engineer
  avatar: jimpex
---


================================================
FILE: src/content/labs-items/use-surrealdb-in-github-actions.md
================================================
---
title: "Use SurrealDB in GitHub Actions"
url: /docs/tutorials/using-github-actions
category: Tutorials
topics:
  - Examples
author: surrealdb
---





================================================
FILE: src/content/labs-items/use-surrealdb-with-langchain.md
================================================
---
title: "Use SurrealDB with LangChain"
url: https://github.com/surrealdb/langchain-surrealdb
category: Integrations
author: surrealdb
topics:
  - AI
  - Embedding
---




================================================
FILE: src/content/labs-items/using-surrealdb-to-prove-football-statistics.md
================================================
---
title: "Using SurrealDB to prove football statistics."
url: https://www.youtube.com/watch?v=6J1SPMXzOh4&t=5s
category: Videos
author:
  name: Joseph McCarthy
  role: Content Creator
  avatar: joseph-mccarthy
topics: []
---




================================================
FILE: src/content/labs-items/working-with-surrealdb-over-http-via-postman.md
================================================
---
title: "Working with SurrealDB over HTTP via Postman"
url: /docs/tutorials/working-with-surrealdb-over-http-via-postman
category: Tutorials
topics: []
author: surrealdb
---




